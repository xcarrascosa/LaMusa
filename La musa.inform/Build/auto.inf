!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=500000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Other Configuration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant Grammar__Version 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Identification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6M62";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://CC598049-E316-43E4-B7AC-39698419D4FF//";

Global Story = BC_0;
Constant Headline BC_1;
Constant Story_Author BC_2;
Release 3;
Serial "220426";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "Spanish Language version 1/210825 by Sebastian Arg (basada en InformATE! de Zak, con la contribución de toda la comunidad)^";
    print "Quip-Based Conversation Sp version 5 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)^";
    print "Reactable Quips SP version 10 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)^";
];
[ ShowFullExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Spanish Language version 1/210825 by Sebastian Arg (basada en InformATE! de Zak, con la contribución de toda la comunidad)^";
    print "Glulx Text Effects version 5/150123 by Emily Short^";
    print "Basic Screen Effects Sp version 7 by Emily Short (SPANISH MESSAGES by Sarganar)^";
    print "Basic Help Menu SP by Emily Short (Rev 16.08.06 - Traducción de Johan Paz)^";
    print "Quip-Based Conversation Sp version 5 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)^";
    print "Flexible Windows version 15/220305 by Jon Ingold^";
    print "Basic Screen Effects version 7/140425 by Emily Short^";
    print "Menus SP version 3 by Emily Short^";
    print "Reactable Quips SP version 10 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)^";
    print "Alternative Startup Rules version 1/140516 by Dannii Willis^";
    print "Glulx Entry Points version 10/200602 by Emily Short^";
    print "Menus version 3 by Emily Short^";
    print "Glulx Definitions version 1/160919 by Dannii Willis^";
    print "Glk Object Recovery version 1/171025 by Dannii Willis^";
    print "Glk Events version 2/200807 by Dannii Willis^";
];
[ ShowOneExtension 
    id ! Implied call parameter
    ;
    if (id == 1) print "Standard Rules version 3/120430 by Graham Nelson";
    if (id == 2) print "English Language version 1 by Graham Nelson";
    if (id == 3) print "Spanish Language version 1/210825 by Sebastian Arg (basada en InformATE! de Zak, con la contribución de toda la comunidad)";
    if (id == 4) print "Glulx Text Effects version 5/150123 by Emily Short";
    if (id == 5) print "Basic Screen Effects Sp version 7 by Emily Short (SPANISH MESSAGES by Sarganar)";
    if (id == 6) print "Basic Help Menu SP by Emily Short (Rev 16.08.06 - Traducción de Johan Paz)";
    if (id == 7) print "Quip-Based Conversation Sp version 5 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)";
    if (id == 8) print "Flexible Windows version 15/220305 by Jon Ingold";
    if (id == 9) print "Basic Screen Effects version 7/140425 by Emily Short";
    if (id == 10) print "Menus SP version 3 by Emily Short";
    if (id == 11) print "Reactable Quips SP version 10 by Michael Martin (SPANISH Work by Sarganar - STAND ALONE VERSION)";
    if (id == 12) print "Alternative Startup Rules version 1/140516 by Dannii Willis";
    if (id == 13) print "Glulx Entry Points version 10/200602 by Emily Short";
    if (id == 14) print "Menus version 3 by Emily Short";
    if (id == 15) print "Glulx Definitions version 1/160919 by Dannii Willis";
    if (id == 16) print "Glk Object Recovery version 1/171025 by Dannii Willis";
    if (id == 17) print "Glk Events version 2/200807 by Dannii Willis";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Use options
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant TEXT_TY_BufferSize = 1024+3; 
! Use option:
 Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 #IFNDEF USE_SCORING; Constant USE_SCORING = 1; #ENDIF; 
! Use option:
 Constant PREVENT_UNDO; 
! Use option:
 Constant CAPTURE_BUFFER_LEN = 256; 
! Use option:
 Constant USE_NO_STATUS_LINE 1; 


#Ifndef USE_SCORING;
Constant USE_SCORING = 0;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: VM Target Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Wordsize-Dependent Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Z-Machine Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Glulx Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Powers of Two
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Text Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Colour Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Window Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Paragraphing Flags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Descriptors in the Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Run-Time Problem Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6; ! Now out of use
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;
Constant RTP_WRONGASSIGNEDKIND       = 60;
Constant RTP_CANTBEOFFSTAGE          = 61;
Constant RTP_RELKINDVIOLATION        = 62;
Constant RTP_CANTMAKEPART       	 = 63;
Constant RTP_TEXTTOKENTOOHARD        = 64;
Constant RTP_TABLE_NOTABLE2          = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL              = 67;
Constant RTP_LISTSIZENEGATIVE        = 68;
Constant RTP_REGIONSNOTADJACENT      = 69;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant PRINTING_INVENTORY_DETAILS_ACT  = 4;
Constant LISTING_CONTENTS_ACT            = 5;
Constant GROUPING_TOGETHER_ACT           = 6;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 7;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 8;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 10;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 11;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 12;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 13;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 14;
Constant PRINTING_BANNER_TEXT_ACT        = 15;

Constant READING_A_COMMAND_ACT           = 16;
Constant DECIDING_SCOPE_ACT              = 17;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 18;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 19;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 20;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 21;
Constant PRINTING_A_PARSER_ERROR_ACT     = 22;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 23;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 24;
Constant IMPLICITLY_TAKING_ACT           = 25;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 26;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 27;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 28;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 29;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 30;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 31;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 32;

Constant PRINTING_RESPONSE_ACT           = 33;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STARTUP_RB                      = 0;
Constant TURN_SEQUENCE_RB                = 1;
Constant SHUTDOWN_RB                     = 2;

Constant WHEN_PLAY_BEGINS_RB             = 4;
Constant WHEN_PLAY_ENDS_RB               = 5;
Constant WHEN_SCENE_BEGINS_RB            = 6;
Constant WHEN_SCENE_ENDS_RB              = 7;

Constant ACTION_PROCESSING_RB            = 9;
Constant SETTING_ACTION_VARIABLES_RB     = 10;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 11;

Constant ACCESSIBILITY_RB                = 13;
Constant REACHING_INSIDE_RB              = 14;
Constant REACHING_OUTSIDE_RB             = 15;
Constant VISIBLE_RB                      = 16;

Constant PERSUADE_RB                     = 17;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 18;

Constant AFTER_RB                        = 23;
Constant REPORT_RB                       = 24;

Constant MULTIPLE_ACTION_PROCESSING_RB   = 26;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Kind IDs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNKNOWN_TY = -2147483602;
Constant VALUE_TY = 2;
Constant POINTER_VALUE_TY = 3;
Constant WORD_VALUE_TY = 4;
Constant ARITHMETIC_VALUE_TY = 5;
Constant REAL_ARITHMETIC_VALUE_TY = 6;
Constant ENUMERATED_VALUE_TY = 7;
Constant SAYABLE_VALUE_TY = 8;
Constant COMBINED_VALUE_TY = 9;
Constant OBJECT_TY = 10;
Constant NUMBER_TY = 11;
Constant REAL_NUMBER_TY = 12;
Constant TRUTH_STATE_TY = 13;
Constant TEXT_TY = 14;
Constant UNICODE_CHARACTER_TY = 15;
Constant USE_OPTION_TY = 16;
Constant RESPONSE_TY = 17;
Constant VERB_TY = 18;
Constant SNIPPET_TY = 19;
Constant TABLE_TY = 20;
Constant EQUATION_TY = 21;
Constant RULEBOOK_OUTCOME_TY = 22;
Constant UNDERSTANDING_TY = 23;
Constant INTERMEDIATE_TY = 24;
Constant NIL_TY = 25;
Constant KIND_VARIABLE_TY = 26;
Constant PHRASE_TY = 27;
Constant TUPLE_ENTRY_TY = 28;
Constant VARIABLE_TY = 29;
Constant RELATION_TY = 30;
Constant RULE_TY = 31;
Constant RULEBOOK_TY = 32;
Constant ACTIVITY_TY = 33;
Constant LIST_OF_TY = 34;
Constant DESCRIPTION_OF_TY = 35;
Constant PROPERTY_TY = 36;
Constant TABLE_COLUMN_TY = 37;
Constant COMBINATION_TY = 38;
Constant DESCRIPTION_OF_ACTION_TY = 39;
Constant STORED_ACTION_TY = 40;
Constant ACTION_NAME_TY = 41;
Constant TIME_TY = 42;
Constant SCENE_TY = 43;
Constant FIGURE_NAME_TY = 44;
Constant SOUND_NAME_TY = 45;
Constant EXTERNAL_FILE_TY = 46;
Constant BASE_KIND_HWM = 62; ! Base kind high-water-mark



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Parser Error Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STUCK_PE         = 1;
Constant UPTO_PE          = 2;
Constant NUMBER_PE        = 3;
Constant ANIMA_PE         = 4;
Constant CANTSEE_PE       = 5;
Constant TOOLIT_PE        = 6;
Constant NOTHELD_PE       = 7;
Constant MULTI_PE         = 8;
Constant MMULTI_PE        = 9;
Constant VAGUE_PE         = 10;
Constant EXCEPT_PE        = 11;
Constant VERB_PE          = 12;
Constant SCENERY_PE       = 13;
Constant ITGONE_PE        = 14;
Constant JUNKAFTER_PE     = 15;
Constant TOOFEW_PE        = 16;
Constant NOTHING_PE       = 17;
Constant ASKSCOPE_PE      = 18;
Constant NOTINCONTEXT_PE  = 19;
Constant BLANKLINE_PE     = 20; ! Not formally a parser error, but used by I7 as if
Constant ANIMAAGAIN_PE    = 21;
Constant COMMABEGIN_PE    = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE   = 24;
Constant TOTALK_PE        = 25;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Scope Searching Reasons
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Token Types
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: GPR Return Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: List Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Lengths Of Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant EMPTY_TEXT_PACKED "";
Array EMPTY_TEXT_VALUE --> CONSTANT_PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TheEmptyTable --> 0 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Prop_Falsity reason obj; return 0; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Score and Rankings Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MAX_SCORE = 7;

#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Attributes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute pluralname; ! = I7 "plural-named"
Attribute ambigpluralname; ! = I7 "ambiguously plural"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Properties
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property KD_Count; ! Instance count of the kind of the current object
Property IK1_Count; ! These are instance counts within kinds K1, K2, ...
Property IK2_Count; ! and it is efficient to declare the common ones with Property
Property IK4_Count; ! since this results in a slightly smaller story file
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Loss of Life
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant life = NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Action Count
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ActionCount = 94;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Fake Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Formal Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global formal_rv;
Global formal_par0;
Global formal_par1;
Global formal_par2;
Global formal_par3;
Global formal_par4;
Global formal_par5;
Global formal_par6;
Global formal_par7;
Global unicode_temp;

	Constant RUCKSACK_CLASS = K15_player_s_holdall;


! =====================================================================
! INFSP (Spanish Inform Library)
! =====================================================================
!        Author: INFSP Task Team
!       Version: 0.97
!      Revision: 08 - Mayo - 2014
! Serial Number: 14005.08

Message "^Compilando con Spanish: Mensajes y rutinas de idioma [INFSP 0.97 MAYO 2014]";
Message "   Asegurate de estar corriendo I7 Build 6M62^";

! ---------------------------------------------------------------------------
!   Parte I.   Asuntos preliminares
! ---------------------------------------------------------------------------

Constant LanguageVersion = "  - Librería I6 Española 1010.29, basada en InformATE!";

! Definición de caractéres "baratos". Esto permite que estas letras
! ocupen menos bits en la máquina Z. No funciona si se intenta la
! compilación por módulos (viejo método)

#ifdef TARGET_ZCODE;
  Zcharacter 'á';                    ! a con acento
  Zcharacter 'é';                    ! e con acento
  Zcharacter 'í';                    ! i con acento
  Zcharacter 'ó';                    ! o con acento
  Zcharacter 'ú';                    ! u con acento
  Zcharacter 'ñ';                    ! n con virguilla
  Zcharacter 'Ñ';                    ! N con virguilla
  Zcharacter 'ü';                    ! u con dieresis
  Zcharacter '¿';                    ! abrir interrogación
  Zcharacter '¡';                    ! abrir exclamación
#endif;

!----------------------------------------------
! CONSTANTES Y CLASES ESPECIFICAS DE INFORMATE
!---------------------------------------------- 

Class VerboIrregular;

!------------------------------------
! Globales específicas de InformatE!
!------------------------------------

global PreguntaCualExactamente = 0;
	! Esta variable se pone a 1 cuando se le pregunta al jugador ¿Cuál
	! exactamente...? esto indica que puede ser necesario re-traducir la
	! respuesta que el jugador dé, ya que puede que simplemente el jugador
	! cambie de idea y en lugar de responder a nuestra pregunta introduzca
	! un comando completamente nuevo.

global PreguntaSiNo = 0;
	! Esta variable debe ponerse a 1 manualmente si queremos que el verbo
	! 'no' sea accesible como respuesta (y no como punto cardinal). La
	! variable sólo afecta a la siguiente respuesta del jugador y vuelve a
	! hacerse cero automáticamente.

Global quitacentos = 1;

Array  texto_impreso --> 52;

#ifndef NI_BUILD_COUNT;
Global dialecto_sudamericano = 0;
#ifnot;
    #ifndef DIALECTO_SPANISH; ! seteado desde el I7 environment
       Global dialecto_sudamericano = 0;
    #endif;
#endif;

!---------------------------------------------------------------------------
! Atributos y propiedades específicas de InformatE!, tambien usados en INFSP
!---------------------------------------------------------------------------

Property imperativo alias name;
Property irrelevante alias name;


Replace PrintCommand;

Replace IndefArt;
	Global capture_active = 0;	

Array captured_text --> CAPTURE_BUFFER_LEN + 1;

Global text_capture_old_stream = 0;
Global text_capture_new_stream = 0;

[ StartCapture i;   
	if (capture_active ==1)
		return;
	capture_active = 1;
	text_capture_old_stream = glk_stream_get_current();
	text_capture_new_stream = glk_stream_open_memory_uni(captured_text + WORDSIZE, CAPTURE_BUFFER_LEN, 1, 0);
	glk_stream_set_current(text_capture_new_stream);
];

[ EndCapture len;
	if ( capture_active == 0 )
		return;
	capture_active = 0;
	glk_stream_set_current(text_capture_old_stream);
	@copy $ffffffff sp;
	@copy text_capture_new_stream sp;
	@glk $0044 2 0; ! stream_close
	@copy sp len;
	@copy sp 0;
	captured_text-->0 = len;
	if (len > CAPTURE_BUFFER_LEN)
	{
		captured_text-->0 = CAPTURE_BUFFER_LEN;
	}
];

[ PrintCapture len i;
	len = captured_text-->0;
	for ( i = 0 : i < len : i++ )
	{
		glk_put_char_uni(captured_text-->(i + 1));
	}
];




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Global Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__pc_save = 0;
Global say__n; Global say__comp;
Global los_rv = false;
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Global parameter_value; ! not typesafe in I7
Array deferred_calling_list --> 27;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur

#ifdef TARGET_ZCODE;
Constant BLOCKV_STACK_SIZE = 224;
#ifnot;
Constant BLOCKV_STACK_SIZE = DynamicMemoryAllocation/4;
#endif;

Array blockv_stack --> BLOCKV_STACK_SIZE;
Global I7SFRAME;

Global TEXT_TY_RE_Err = 0;

Array LocalParking --> 64;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 1;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;

! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = T_SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = T_SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value = EMPTY_TEXT_VALUE; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses
Global prior_named_noun; ! for adaptive text generation
Global prior_named_list; ! ditto: length of list of items
Global prior_named_list_gender; ! ditto: common gender of list of items, or -1
Global story_tense = 1; ! ditto: present tense
Global story_viewpoint = 2; ! ditto: second person singular

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: VM-Specific Code
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;

Replace GGRecoverObjects;

Global GE_Event_Struct_type;
Global GE_Event_Struct_win;
Global GE_Event_Struct_val1;
Global GE_Event_Struct_val2;

Replace glk_select;
 Array evGlobal --> 4; 
Replace glk_window_open;
Replace glk_window_close;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant GLK_NULL 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Infglk
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! infglk.h -- auto-generated by parse_dispatch.py.
! Generated for Glk API version 0.7.4

Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = 4294967289;
Constant keycode_Down = 4294967291;
Constant keycode_End = 4294967283;
Constant keycode_Escape = 4294967288;
Constant keycode_Func1 = 4294967279;
Constant keycode_Func10 = 4294967270;
Constant keycode_Func11 = 4294967269;
Constant keycode_Func12 = 4294967268;
Constant keycode_Func2 = 4294967278;
Constant keycode_Func3 = 4294967277;
Constant keycode_Func4 = 4294967276;
Constant keycode_Func5 = 4294967275;
Constant keycode_Func6 = 4294967274;
Constant keycode_Func7 = 4294967273;
Constant keycode_Func8 = 4294967272;
Constant keycode_Func9 = 4294967271;
Constant keycode_Home = 4294967284;
Constant keycode_Left = 4294967294;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = 4294967285;
Constant keycode_PageUp = 4294967286;
Constant keycode_Return = 4294967290;
Constant keycode_Right = 4294967293;
Constant keycode_Tab = 4294967287;
Constant keycode_Unknown = 4294967295;
Constant keycode_Up = 4294967292;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;

[ glk_exit _vararg_count;
  ! glk_exit()
  @glk 1 _vararg_count 0;
  return 0;
];

[ glk_tick _vararg_count;
  ! glk_tick()
  @glk 3 _vararg_count 0;
  return 0;
];

[ glk_gestalt _vararg_count ret;
  ! glk_gestalt(uint, uint) => uint
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
  ! glk_gestalt_ext(uint, uint, uintarray, arraylen) => uint
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
  ! glk_window_iterate(window, &uint) => window
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
  ! glk_window_get_rock(window) => uint
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
  ! glk_window_get_root() => window
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
  ! glk_window_open(window, uint, uint, uint, uint) => window
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count;
  ! glk_window_close(window, &{uint, uint})
  @glk 36 _vararg_count 0;
  return 0;
];

[ glk_window_get_size _vararg_count;
  ! glk_window_get_size(window, &uint, &uint)
  @glk 37 _vararg_count 0;
  return 0;
];

[ glk_window_set_arrangement _vararg_count;
  ! glk_window_set_arrangement(window, uint, uint, window)
  @glk 38 _vararg_count 0;
  return 0;
];

[ glk_window_get_arrangement _vararg_count;
  ! glk_window_get_arrangement(window, &uint, &uint, &window)
  @glk 39 _vararg_count 0;
  return 0;
];

[ glk_window_get_type _vararg_count ret;
  ! glk_window_get_type(window) => uint
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
  ! glk_window_get_parent(window) => window
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count;
  ! glk_window_clear(window)
  @glk 42 _vararg_count 0;
  return 0;
];

[ glk_window_move_cursor _vararg_count;
  ! glk_window_move_cursor(window, uint, uint)
  @glk 43 _vararg_count 0;
  return 0;
];

[ glk_window_get_stream _vararg_count ret;
  ! glk_window_get_stream(window) => stream
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count;
  ! glk_window_set_echo_stream(window, stream)
  @glk 45 _vararg_count 0;
  return 0;
];

[ glk_window_get_echo_stream _vararg_count ret;
  ! glk_window_get_echo_stream(window) => stream
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count;
  ! glk_set_window(window)
  @glk 47 _vararg_count 0;
  return 0;
];

[ glk_window_get_sibling _vararg_count ret;
  ! glk_window_get_sibling(window) => window
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
  ! glk_stream_iterate(stream, &uint) => stream
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
  ! glk_stream_get_rock(stream) => uint
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
  ! glk_stream_open_file(fileref, uint, uint) => stream
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
  ! glk_stream_open_memory(nativechararray, arraylen, uint, uint) => stream
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count;
  ! glk_stream_close(stream, &{uint, uint})
  @glk 68 _vararg_count 0;
  return 0;
];

[ glk_stream_set_position _vararg_count;
  ! glk_stream_set_position(stream, int, uint)
  @glk 69 _vararg_count 0;
  return 0;
];

[ glk_stream_get_position _vararg_count ret;
  ! glk_stream_get_position(stream) => uint
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count;
  ! glk_stream_set_current(stream)
  @glk 71 _vararg_count 0;
  return 0;
];

[ glk_stream_get_current _vararg_count ret;
  ! glk_stream_get_current() => stream
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource _vararg_count ret;
  ! glk_stream_open_resource(uint, uint) => stream
  @glk 73 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
  ! glk_fileref_create_temp(uint, uint) => fileref
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
  ! glk_fileref_create_by_name(uint, string, uint) => fileref
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
  ! glk_fileref_create_by_prompt(uint, uint, uint) => fileref
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count;
  ! glk_fileref_destroy(fileref)
  @glk 99 _vararg_count 0;
  return 0;
];

[ glk_fileref_iterate _vararg_count ret;
  ! glk_fileref_iterate(fileref, &uint) => fileref
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
  ! glk_fileref_get_rock(fileref) => uint
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count;
  ! glk_fileref_delete_file(fileref)
  @glk 102 _vararg_count 0;
  return 0;
];

[ glk_fileref_does_file_exist _vararg_count ret;
  ! glk_fileref_does_file_exist(fileref) => uint
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
  ! glk_fileref_create_from_fileref(uint, fileref, uint) => fileref
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count;
  ! glk_put_char(uchar)
  @glk 128 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream _vararg_count;
  ! glk_put_char_stream(stream, uchar)
  @glk 129 _vararg_count 0;
  return 0;
];

[ glk_put_string _vararg_count;
  ! glk_put_string(string)
  @glk 130 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream _vararg_count;
  ! glk_put_string_stream(stream, string)
  @glk 131 _vararg_count 0;
  return 0;
];

[ glk_put_buffer _vararg_count;
  ! glk_put_buffer(nativechararray, arraylen)
  @glk 132 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream _vararg_count;
  ! glk_put_buffer_stream(stream, nativechararray, arraylen)
  @glk 133 _vararg_count 0;
  return 0;
];

[ glk_set_style _vararg_count;
  ! glk_set_style(uint)
  @glk 134 _vararg_count 0;
  return 0;
];

[ glk_set_style_stream _vararg_count;
  ! glk_set_style_stream(stream, uint)
  @glk 135 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream _vararg_count ret;
  ! glk_get_char_stream(stream) => int
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
  ! glk_get_line_stream(stream, nativechararray, arraylen) => uint
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
  ! glk_get_buffer_stream(stream, nativechararray, arraylen) => uint
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
  ! glk_char_to_lower(uchar) => uchar
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
  ! glk_char_to_upper(uchar) => uchar
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count;
  ! glk_stylehint_set(uint, uint, uint, int)
  @glk 176 _vararg_count 0;
  return 0;
];

[ glk_stylehint_clear _vararg_count;
  ! glk_stylehint_clear(uint, uint, uint)
  @glk 177 _vararg_count 0;
  return 0;
];

[ glk_style_distinguish _vararg_count ret;
  ! glk_style_distinguish(window, uint, uint) => uint
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
  ! glk_style_measure(window, uint, uint, &uint) => uint
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count;
  ! glk_select(&{uint, window, uint, uint})
  @glk 192 _vararg_count 0;
  return 0;
];

[ glk_select_poll _vararg_count;
  ! glk_select_poll(&{uint, window, uint, uint})
  @glk 193 _vararg_count 0;
  return 0;
];

[ glk_request_line_event _vararg_count;
  ! glk_request_line_event(window, nativechararray, arraylen, uint)
  @glk 208 _vararg_count 0;
  return 0;
];

[ glk_cancel_line_event _vararg_count;
  ! glk_cancel_line_event(window, &{uint, window, uint, uint})
  @glk 209 _vararg_count 0;
  return 0;
];

[ glk_request_char_event _vararg_count;
  ! glk_request_char_event(window)
  @glk 210 _vararg_count 0;
  return 0;
];

[ glk_cancel_char_event _vararg_count;
  ! glk_cancel_char_event(window)
  @glk 211 _vararg_count 0;
  return 0;
];

[ glk_request_mouse_event _vararg_count;
  ! glk_request_mouse_event(window)
  @glk 212 _vararg_count 0;
  return 0;
];

[ glk_cancel_mouse_event _vararg_count;
  ! glk_cancel_mouse_event(window)
  @glk 213 _vararg_count 0;
  return 0;
];

[ glk_request_timer_events _vararg_count;
  ! glk_request_timer_events(uint)
  @glk 214 _vararg_count 0;
  return 0;
];

[ glk_image_get_info _vararg_count ret;
  ! glk_image_get_info(uint, &uint, &uint) => uint
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
  ! glk_image_draw(window, uint, int, int) => uint
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
  ! glk_image_draw_scaled(window, uint, int, int, uint, uint) => uint
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count;
  ! glk_window_flow_break(window)
  @glk 232 _vararg_count 0;
  return 0;
];

[ glk_window_erase_rect _vararg_count;
  ! glk_window_erase_rect(window, int, int, uint, uint)
  @glk 233 _vararg_count 0;
  return 0;
];

[ glk_window_fill_rect _vararg_count;
  ! glk_window_fill_rect(window, uint, int, int, uint, uint)
  @glk 234 _vararg_count 0;
  return 0;
];

[ glk_window_set_background_color _vararg_count;
  ! glk_window_set_background_color(window, uint)
  @glk 235 _vararg_count 0;
  return 0;
];

[ glk_schannel_iterate _vararg_count ret;
  ! glk_schannel_iterate(schannel, &uint) => schannel
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
  ! glk_schannel_get_rock(schannel) => uint
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
  ! glk_schannel_create(uint) => schannel
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count;
  ! glk_schannel_destroy(schannel)
  @glk 243 _vararg_count 0;
  return 0;
];

[ glk_schannel_create_ext _vararg_count ret;
  ! glk_schannel_create_ext(uint, uint) => schannel
  @glk 244 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_multi _vararg_count ret;
  ! glk_schannel_play_multi(schannelarray, arraylen, uintarray, arraylen, uint) => uint
  @glk 247 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
  ! glk_schannel_play(schannel, uint) => uint
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
  ! glk_schannel_play_ext(schannel, uint, uint, uint) => uint
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count;
  ! glk_schannel_stop(schannel)
  @glk 250 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume _vararg_count;
  ! glk_schannel_set_volume(schannel, uint)
  @glk 251 _vararg_count 0;
  return 0;
];

[ glk_sound_load_hint _vararg_count;
  ! glk_sound_load_hint(uint, uint)
  @glk 252 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume_ext _vararg_count;
  ! glk_schannel_set_volume_ext(schannel, uint, uint, uint)
  @glk 253 _vararg_count 0;
  return 0;
];

[ glk_schannel_pause _vararg_count;
  ! glk_schannel_pause(schannel)
  @glk 254 _vararg_count 0;
  return 0;
];

[ glk_schannel_unpause _vararg_count;
  ! glk_schannel_unpause(schannel)
  @glk 255 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink _vararg_count;
  ! glk_set_hyperlink(uint)
  @glk 256 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink_stream _vararg_count;
  ! glk_set_hyperlink_stream(stream, uint)
  @glk 257 _vararg_count 0;
  return 0;
];

[ glk_request_hyperlink_event _vararg_count;
  ! glk_request_hyperlink_event(window)
  @glk 258 _vararg_count 0;
  return 0;
];

[ glk_cancel_hyperlink_event _vararg_count;
  ! glk_cancel_hyperlink_event(window)
  @glk 259 _vararg_count 0;
  return 0;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
  ! glk_buffer_to_lower_case_uni(uintarray, arraylen, uint) => uint
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
  ! glk_buffer_to_upper_case_uni(uintarray, arraylen, uint) => uint
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
  ! glk_buffer_to_title_case_uni(uintarray, arraylen, uint, uint) => uint
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_decompose_uni _vararg_count ret;
  ! glk_buffer_canon_decompose_uni(uintarray, arraylen, uint) => uint
  @glk 291 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_normalize_uni _vararg_count ret;
  ! glk_buffer_canon_normalize_uni(uintarray, arraylen, uint) => uint
  @glk 292 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count;
  ! glk_put_char_uni(uint)
  @glk 296 _vararg_count 0;
  return 0;
];

[ glk_put_string_uni _vararg_count;
  ! glk_put_string_uni(unicode)
  @glk 297 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_uni _vararg_count;
  ! glk_put_buffer_uni(uintarray, arraylen)
  @glk 298 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream_uni _vararg_count;
  ! glk_put_char_stream_uni(stream, uint)
  @glk 299 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream_uni _vararg_count;
  ! glk_put_string_stream_uni(stream, unicode)
  @glk 300 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream_uni _vararg_count;
  ! glk_put_buffer_stream_uni(stream, uintarray, arraylen)
  @glk 301 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream_uni _vararg_count ret;
  ! glk_get_char_stream_uni(stream) => int
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
  ! glk_get_buffer_stream_uni(stream, uintarray, arraylen) => uint
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
  ! glk_get_line_stream_uni(stream, uintarray, arraylen) => uint
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
  ! glk_stream_open_file_uni(fileref, uint, uint) => stream
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
  ! glk_stream_open_memory_uni(uintarray, arraylen, uint, uint) => stream
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource_uni _vararg_count ret;
  ! glk_stream_open_resource_uni(uint, uint) => stream
  @glk 314 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count;
  ! glk_request_char_event_uni(window)
  @glk 320 _vararg_count 0;
  return 0;
];

[ glk_request_line_event_uni _vararg_count;
  ! glk_request_line_event_uni(window, uintarray, arraylen, uint)
  @glk 321 _vararg_count 0;
  return 0;
];

[ glk_set_echo_line_event _vararg_count;
  ! glk_set_echo_line_event(window, uint)
  @glk 336 _vararg_count 0;
  return 0;
];

[ glk_set_terminators_line_event _vararg_count;
  ! glk_set_terminators_line_event(window, uintarray, arraylen)
  @glk 337 _vararg_count 0;
  return 0;
];

[ glk_current_time _vararg_count;
  ! glk_current_time(&{int, uint, int})
  @glk 352 _vararg_count 0;
  return 0;
];

[ glk_current_simple_time _vararg_count ret;
  ! glk_current_simple_time(uint) => int
  @glk 353 _vararg_count ret;
  return ret;
];

[ glk_time_to_date_utc _vararg_count;
  ! glk_time_to_date_utc(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 360 _vararg_count 0;
  return 0;
];

[ glk_time_to_date_local _vararg_count;
  ! glk_time_to_date_local(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 361 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_utc _vararg_count;
  ! glk_simple_time_to_date_utc(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 362 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_local _vararg_count;
  ! glk_simple_time_to_date_local(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 363 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_utc _vararg_count;
  ! glk_date_to_time_utc(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 364 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_local _vararg_count;
  ! glk_date_to_time_local(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 365 _vararg_count 0;
  return 0;
];

[ glk_date_to_simple_time_utc _vararg_count ret;
  ! glk_date_to_simple_time_utc(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 366 _vararg_count ret;
  return ret;
];

[ glk_date_to_simple_time_local _vararg_count ret;
  ! glk_date_to_simple_time_local(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 367 _vararg_count ret;
  return ret;
];


! Replacement function from Glk Events by Dannii Willis
[ glk_select event_struct;
	! Call the real glk_select
	@push event_struct;
	@glk 192 1 0;
	
	! Copy values to our variables
	GE_Event_Struct_type = event_struct-->0;
	GE_Event_Struct_win = event_struct-->1;
	GE_Event_Struct_val1 = event_struct-->2;
	GE_Event_Struct_val2 = event_struct-->3;
	
	! Run the glulx input handling rules (but disable rules debugging because it crashes if keyboard input events are pending)
	@push debug_rules; @push say__p; @push say__pc;
	debug_rules = false; ClearParagraphing(1);
	FollowRulebook( 405, GE_Event_Struct_type, true );
	@pull say__pc; @pull say__p; @pull debug_rules;

	! Copy back to the original event structure
	event_struct-->0 = GE_Event_Struct_type;
	event_struct-->1 = GE_Event_Struct_win;
	event_struct-->2 = GE_Event_Struct_val1;
	event_struct-->3 = GE_Event_Struct_val2;
	return 0;
];

! Replacement functions from Flexible Windows by Jon Ingold
[ glk_window_open parent method size type rock result;
	result = ( Closure_21-->1 )( parent, method, size, type, rock );
	if ( result == 0 )
	{
		return FW_glk_window_open( parent, method, size, type, rock );
	}
	return result;
];

[ glk_window_close ref;
	( Closure_22-->1 )( ref );
	return 0;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Rocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
    
    ! Empty the parse buffer (see bug 0001451)
    buffer3-->0 = 0;
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
				default: IdentifyGlkObject(1, 3, id, gg_arguments-->0);
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];


! Replacement GGRecoverObjects from Glk Object Recovery by Dannii Willis
[ GGRecoverObjects ref;
	! Reset all Glk references as if none existed
	FollowRulebook( 399 );
	
	! Iterate through each of the windows, streams, file refs and sound channels
	while ( ref = glk_window_iterate( ref, gg_arguments ) )
	{
		(Global_Vars-->27) = gg_arguments-->0;
		(Global_Vars-->28) = ref;
		FollowRulebook( 400 );
	}
	ref = 0;
	while ( ref = glk_stream_iterate( ref, gg_arguments ) )
	{
		(Global_Vars-->27) = gg_arguments-->0;
		(Global_Vars-->28) = ref;
		FollowRulebook( 401 );
	}
	ref = 0;
	while ( ref = glk_fileref_iterate( ref, gg_arguments ) )
	{
		(Global_Vars-->27) = gg_arguments-->0;
		(Global_Vars-->28) = ref;
		FollowRulebook( 402 );
	}
	if ( glk_gestalt( gestalt_Sound, 0 ) )
	{
		ref = 0;
		while ( ref = glk_schannel_iterate( ref, gg_arguments ) )
		{
			(Global_Vars-->27) = gg_arguments-->0;
			(Global_Vars-->28) = ref;
			FollowRulebook( 403 );
		}
	}

	! Tell the game to tie up any loose ends
	FollowRulebook( 404 );
	rfalse;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Random Number Generator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	@setrandom n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Glulx-Only Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: GlkList Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	if ((actor == player) && (untouchable_silence == false))
		QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	RESTORE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We first have to recover
		! all the Glk objects; the values in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		RESTORE_THE_GAME_RM('B'); new_line;
		rtrue;
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) { SAVE_THE_GAME_RM('B'); new_line; rtrue; }
	.SFailed;
	SAVE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) { VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue; }
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line;
	VersionSub();
	return;
	.S1Failed;
	SWITCH_TRANSCRIPT_ON_RM('C'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Unsigned__Compare x y;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
];

[ RT__ChLDW x y;
	@aload x y sp;
	@return sp;
];

[ RT__ChLDB x y;
	@aloadb x y sp;
	@return sp;
];

#Endif;

#Ifdef TARGET_ZCODE;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: RNG
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c;
   switch (c) {
		'A' to 'Z': c = c + 32;
		202, 204, 212, 214, 221: c--;
		217, 218: c = c - 2;
		158 to 160, 167 to 168, 208 to 210: c = c - 3;
		186 to 190, 196 to 200: c = c - 5 ;
		175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
		'a' to 'z': c = c - 32;
		201, 203, 211, 213, 220: c++;
		215, 216: c = c + 2;
		155 to 157, 164 to 165, 205 to 207: c = c + 3;
		181 to 185, 191 to 195: c = c + 5 ;
		169 to 174: c = c + 6;
   }
   return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing(8);
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		TEXT_TY_Say(left_hand_status_line);
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		TEXT_TY_Say(right_hand_status_line);
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; TEXT_TY_Say(right_hand_status_line);
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing(8);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	RESTORE_THE_GAME_RM('A'); new_line;
	rtrue;
	.RMaybe; RESTORE_THE_GAME_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: SAVE_THE_GAME_RM('A'); new_line;
		1: SAVE_THE_GAME_RM('B'); new_line;
		2: RESTORE_THE_GAME_RM('B'); new_line;
	}
	#IFNOT;
	save Smaybe;
	SAVE_THE_GAME_RM('A'); new_line; rtrue;
	.SMaybe; SAVE_THE_GAME_RM('B'); new_line;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue;
	.Vwrong;
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	@output_stream 2;
	if (((0-->8) & 1) == 0) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line; VersionSub();
	transcript_mode = true;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	@output_stream -2;
	if ((0-->8) & 1) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	transcript_mode = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OC__Cl obj cla j a n objflag;

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Compass
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object Compass "compass" has concealed;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Definicion de bufferaux y parseraux, usados en DictionaryLookup [001115]
#ifdef TARGET_ZCODE;
  Array bufferaux -> 123;
  Array parseaux  buffer 63;
#ifnot; ! TARGET_GLULX
  Array  bufferaux    buffer INPUT_BUFFER_LEN;
  Array parseaux  --> PARSE_BUFFER_LEN;
#endif; ! TARGET_



! Tremendo bug corregido. Antes usaba el buffer buf2, el cual usa
! tambien el parser para leer commandos incompletos del estilo de "¿a
! cual te refieres exactamente?"
! Este bug estaba en la libreria original, pero nunca aparecia porque
! apenas se usa DictionaryLookup. En cambio InformATE lo usa para
! comprobar si quitando la R a un verbo se obtiene una palabra válida.
!
! [Gracias a Presi por detectarlo] 
[ DictionaryLookup texto longitud
    i;

	! copiar texto a bufferaux (copiado especial)
	for (i=0:i<longitud:i++) bufferaux->(WORDSIZE+i) = texto->i;
	! completar correctamente cabeceras de los buffers
	!	para la rutina Tokenise.
#ifdef TARGET_ZCODE;
	bufferaux->1 = longitud;
	bufferaux->0 = 120;
	parseaux-> 0 = 1;
#ifnot; ! TARGET_GLULX
	bufferaux-->0 = longitud;
#endif; ! TARGET_
#ifdef DEBUG;
    if (parser_trace>=9) { ! infsp debug
		print "    DictionaryLookup: texto a procesar: |";
        ImprimeTodoElBuffer(bufferaux);
        print "|^";
    }
#endif;
	VM_Tokenise(bufferaux,parseaux); ! procesar texto de bufferaux, el resultado está en parseaux-->1
	return parseaux-->1; ! retornar address del token encontrado (-1 si falla)
];


Constant AGAIN1__WD = 'repetir';
Constant AGAIN2__WD = 're';
Constant AGAIN3__WD = 'g//';
Constant OOPS1__WD    = 'oops';
Constant OOPS2__WD    = 'epa';
Constant OOPS3__WD    = 'eepa';
Constant UNDO1__WD  = 'undo';
Constant UNDO2__WD  = 'deshacer';
Constant UNDO3__WD  = 'anular';

Constant ALL1__WD    = 'todos';
Constant ALL2__WD    = 'todas';
Constant ALL3__WD    = 'todo';
Constant ALL4__WD    = 'ambos';
Constant ALL5__WD    = 'ambas';
Constant AND1__WD    = 'y//';
Constant AND2__WD    = 'y//';
Constant AND3__WD    = 'e//';
Constant BUT1__WD   = 'excepto';
Constant BUT2__WD   = 'menos';
Constant BUT3__WD   = 'salvo';
Constant ME1__WD      = '-me';
Constant ME2__WD      = '-te';
Constant ME3__WD      = '-se';
Constant OF1__WD      = '.de';       ! no usados nunca, pues provocan
Constant OF2__WD      = '.de';       ! interferencia con la preposición "de"
Constant OF3__WD      = '.de';       ! usada por algunos verbos, como en
Constant OF4__WD      = '.de';       ! "saca objeto de la caja"
Constant OTHER1__WD    = 'otro';
Constant OTHER2__WD    = 'otra';
Constant OTHER3__WD    = 'otro';
Constant THEN1__WD = 'ydespues';
Constant DESPUES11_WD = 'despues';
Constant THEN2__WD = 'yluego';
Constant DESPUES21_WD = 'luego';
Constant THEN3__WD = 'yentonces';
Constant DESPUES31_WD = 'entonces';

Constant NO1__WD      = 'n//';
Constant NO2__WD      = 'no';
Constant NO3__WD      = 'no';
Constant YES1__WD      = 's//';
Constant YES2__WD      = 'si';
Constant YES3__WD      = 'sí';

Constant AMUSING__WD = 'curiosidades';
Constant FULLSCORE1__WD  = 'puntuacion';
Constant FULLSCORE2__WD  = 'punt';
Constant QUIT1__WD    = 'q//';
Constant QUIT2__WD    = 'terminar';
Constant RESTART__WD    = 'reiniciar';
Constant RESTORE__WD    = 'recuperar';

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Vocabulary (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array LanguagePronouns table

!   palabra  GNAs que pueden                conectado
!            seguirle:                      a:
!              a     i
!              s  p  s  p
!              mfnmfnmfnmfn

    '-lo'	$$101000100001                    NULL
    '-los'	$$000101000101                    NULL
    '-la'	$$010000010000                    NULL
    '-las'	$$000010000010                    NULL
    '-le'	$$110000110000                    NULL
    '-les'	$$000110000110                    NULL
    'él'		$$100000100000                    NULL
    'ella'	$$010000010000                    NULL
    'ellos'	$$000100000100                    NULL
    'ellas'	$$000010000010                    NULL;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Pronouns (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array LanguageDescriptors table

    !palabra  GNAs que pueden     tipo de   conectado
    !              seguirles:	  descriptor:       con:
    !          a     i
    !          s  p  s  p
    !          mfnmfnmfnmfn                 
    
    'mi'	$$110110110110    POSSESS_PK      0
!    'este'	$$100000100000    POSSESS_PK      0 ! Mel Hython: para evitar problemas con direccion 'este'
    'estos'	$$000100000100    POSSESS_PK      0
    'esta'	$$010000010000    POSSESS_PK      0
    'estas'	$$000010000010    POSSESS_PK      0
    'ese'	$$100000100000    POSSESS_PK      1
    'esa'	$$010000010000    POSSESS_PK      1
    'esos'	$$000100000100    POSSESS_PK      1
    'esas'	$$000010000010    POSSESS_PK      1
    'su'	$$110000110000    POSSESS_PK      '-le'
    'sus'	$$000110000110    POSSESS_PK      '-le'
    'el'	$$100000100000    DEFART_PK       NULL
    'la'	$$010000010000    DEFART_PK       NULL
    'los'	$$000100000100    DEFART_PK       NULL
    'las'	$$000010000010    DEFART_PK       NULL
    'un'	$$100000100000    INDEFART_PK     NULL
    'una'	$$010000010000    INDEFART_PK     NULL
    'unos'	$$000100000100    INDEFART_PK     NULL
    'unas'	$$000010000010    INDEFART_PK     NULL
    'algún'	$$100000100000    INDEFART_PK     NULL
   'algunos' $$000100000100    INDEFART_PK     NULL
   'algunas' $$000010000010    INDEFART_PK     NULL
 'encendido' $$100000100000    light             NULL
 'encendida' $$010000010000    light             NULL
'encendidos' $$000100000100    light             NULL
'encendidas' $$000010000010    light             NULL
   'apagado' $$100000100000    (-light)          NULL
   'apagada' $$010000010000    (-light)          NULL
  'apagados' $$000100000100    (-light)          NULL
  'apagadas' $$000010000010    (-light)          NULL;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Descriptors (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array LanguageNumbers table
    'un' 1 'uno' 1 'una' 1 'dos' 2 'tres' 3 'cuatro' 4 'cinco' 5
    'seis' 6 'siete' 7 'ocho' 8 'nueve' 9 'diez' 10
    'once' 11 'doce' 12 'trece' 13 'catorce' 14 'quince' 15
    'dieciséis' 16 'diecisiete' 17 'dieciocho' 18 'diecinueve' 19
    'veinte' 20;

[ LanguageNumber n venti m f;
    if (n==0) { print "cero"; rfalse; }
    if (n<0) { print "menos "; n=-n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        !if (f == 1) print ", ";
    	!print (LanguageNumber) n/1000000000, " billón"; n = n%1000000000; f = 1;
		if (n<2000000000) print "mil";
        else { LanguageNumber(n/1000000000,1); print " mil";} 
        n=n%1000000000; f = 1;
        if (n~=0) print " ";
    }
    if (n >= 1000000) {
    	print (LanguageNumber) n/1000000;
		if ((n<2000000) && (f==0)) print " millón";
        else { print " millones";} 
        n = n%1000000;
        if (n~=0) print " ";
    }
#Endif;
    if (n>=1000) { 
		if (n<2000) print "mil";
        else { LanguageNumber(n/1000,1); print " mil";} 
        n=n%1000; 
        if (n~=0) print " ";
    }
    if (n>=100)  { 
		CientosEspanol(n/100); 
        if (n%100~=0) print " ";
		n=n%100; 
    }
    if (n==0) rfalse;

    if (n<10) {
		DigitoEspanol(n); rfalse;
    }
    if (n>=20)
	{	m=n/10;
        if (n%10~=0) {
				if (m==2) print "veinti";
            } else {
				if (m==2) print "veinte";
            }
            if (m==3) print "treinta";
			if (m==4) print "cuarenta";
            if (m==5) print "cincuenta";
            if (m==6) print "sesenta";
            if (m==7) print "setenta";
            if (m==8) print "ochenta";
            if (m==9) print "noventa";
            if (n%10==0) rfalse;
            if (m>2) print " y "; 
            DigitoEspanol(n%10, (m==2)&&(venti==0)); rfalse;
        }
    if (n==10) { print "diez"; rfalse; }
    if (n==11) { print "once"; rfalse; }
    if (n==12) { print "doce"; rfalse; }
    if (n==13) { print "trece"; rfalse; }
    if (n==14) { print "catorce"; rfalse; }
    if (n==15) { print "quince"; rfalse; }
    if (n==16) { print "dieciséis"; rfalse; }
    if (n==17) { print "diecisiete"; rfalse; }
    if (n==18) { print "dieciocho"; rfalse; }
    print "diecinueve";
];

[ DigitoEspanol n venti;
    if (n==1) { print "un"; rfalse; }
    if (n==2) { 
         if (venti) {print "dós";} else {print "dos"; };
         rfalse; }
    if (n==3) { 
         if (venti) {print "trés";} else {print "tres"; };
         rfalse; }
    if (n==4) { print "cuatro"; rfalse; }
    if (n==5) { print "cinco"; rfalse; }
    if (n==6) { 
         if (venti) {print "séis";} else {print "seis"; };
         rfalse; }
    if (n==7) { print "siete"; rfalse; }
    if (n==8) { print "ocho"; rfalse; }
    if (n==9) { print "nueve"; rfalse; }
];

[ CientosEspanol n;
	if (n==1) { print "ciento"; rfalse; }
	if (n==2) { print "dos";}
	if (n==3) { print "tres";}
	if (n==4) { print "cuatro";}
	if (n==5) { print "quinientos"; rfalse;}
	if (n==6) { print "seis";}
	if (n==7) { print "sete";}
	if (n==8) { print "ocho";}
	if (n==9) { print "nove";}
	print "cientos"; rfalse;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Numbers (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Directions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageDirection d;
	print (name) d;
];


! ---------------------------------------------------------------------------
!   Parte III.   Traducción
! ---------------------------------------------------------------------------

!------------------------------------
! Funciones de ayuda a la depuración
!------------------------------------

#ifdef DEBUG;
[ ImprimeBuffer b desde l i;
    for (i=desde:i<desde+l:i++)
    print (char) b->i;
];

[ ImprimeTodoElBuffer b;
#ifdef TARGET_ZCODE;
   ImprimeBuffer(b, 2, b->1);
#ifnot; !TARGET_GLULX
   ImprimeBuffer(b, WORDSIZE, b-->0);
#endif;
];

#endif; !DEBUG

#ifdef TARGET_GLULX; ! TARGET_GLULX
[ PasarAMinuscula buffer   ! [INFSP] Necesario en EspanolAInformes (en modo Glulx), para q el buffer
        i;                 !         sea reconocido (al usar infinitivo en mayuscula (EXAMINAR) o verbos pronominales (EXAMINALA)
    for (i=WORDSIZE:i<(WORDSIZE+(buffer-->0)):i++)
        buffer->i = VM_UpperToLowerCase (buffer->i);
    return buffer;
];
#endif; !TARGET_

!----------------------------------------------------------------
! [010515] Rutina nueva, que recibe una palabra de diccionario y un
! lugar donde buscar, y retorna "true" si alguno de los objetos de ese
! lugar tiene esa palabra en su campo nombre, name_f...
!
! Es usada por la rutina ArreglarLosY, pues se mira si la palabra que
! viene detrás de la Y es un nombre, y si lo es, si es aplicable a algún
! objeto cercano. Observar que fallará en los objetos que proporcionen
! su propio parse_name. 
!----------------------------------------------------------------
[ EncajeSimplon w donde i;
  objectloop(i in donde) {
    if (WordInProperty(w, i, name)) rtrue;

    if (children(i) && EncajeSimplon(w, i)) rtrue;
  }
  rfalse;
];


!----------------------------------------------------------------
! QuitarAcentos
!
! La siguiente función prueba a quitar los acentos de las palabras que
! no hayan podido ser interpretadas. De este modo, el jugador puede usar
! o no los acentos. Para ello el juego debe definir las palabras sin acentos
! por ejemplo:
! object sillon "sillón confortable"
! with name 'sillon' 'confortable'
!
! Si el jugador pone: "mira sillon", la palabra encaja directamente y es
! comprendida. Si pone "mira sillón", no es comprendida, de modo que se
! le quita el acento y se reintenta el parsing.
!
! Este caso no es especialmente importante, pues el programador
! siempre puede definir 'sillon' y 'sillón', ambos como nombres para
! el objeto. Pero el asunto es más importante para el caso de los
! verbos, ya que si el jugador teclea "cógelo" este es separado en
! "cóge" y "-lo" y el verbo "cóge" (con acento) no sería
! comprendido.
!
! La llamada a esta función puede desactivarse con el comando de
! debugging "acentos sí" de modo que los acentos que teclee el jugador
! no serán eliminados (con propósitos de depuración)

[ QuitarAcentos buf pars x i word at len;

#ifdef DEBUG;
    if (parser_trace >= 7) ! imprimir el buffer recibido
    {
          print "^[ QuitarAcentos:  ";
          print "Buffer recibido: |";
             ImprimeTodoElBuffer(buf);
          print "|^";
    } 
#endif;
    VM_Tokenise(buf, pars); 
    for (x=1:x<=tokenCount(pars):x++) ! para cada token
    {
	word = tokenDict (pars,x); !dictionary value of token 1,2,3...
	at = tokenPos (pars,x); ! position in buffer of token 1,2,3... 
	len = WordLength (x);! length in chars of token 1,2,3...

	if (word==0) ! no comprendida
       {
#ifdef DEBUG;
		if (parser_trace>=7)
		{
		    print "    QuitarAcentos:NO COMPRENDIDO: |";
			ImprimeBuffer(buf, at, len);
		    print "|^";
		}
#endif;
		for (i=at:i<at+len:i++)
		   switch(buf->i)
		  {
			'á': buf->i='a';
			'é': buf->i='e';
			'ë': buf->i='e';
			'í': buf->i='i';
			'ó': buf->i='o';
			'ú': buf->i='u';
			'ü': buf->i='u';
			'ñ': buf->i='n'; 
		!             '?': buf->i=' ';
		!             '¿': buf->i=' ';
		!             '!': buf->i=' ';
		!         '¡': buf->i=' ' ;    
		   }
        VM_Tokenise(buf, pars); 
        }
    }

#ifdef DEBUG;
    if (parser_trace>=7){
        print "    Buffer sin acentos: |";
        ImprimeTodoElBuffer(buf);
        print "|^";
    }
#endif;
];

! funciones de soporte para gestionar parse y buffer
!  From InformFAQ - Roger Firth

[ tokenDict pars w; ! dictionary value of token 1,2,3...
#Ifdef TARGET_ZCODE;
	return pars-->(2*w - 1);
#Ifnot; ! TARGET_GLULX
	return pars-->(3*w - 2);
#Endif; ! TARGET_
];
[ tokenLen pars w; ! length in chars of token 1,2,3...
#Ifdef TARGET_ZCODE;
	return pars->(4*w);
#Ifnot; ! TARGET_GLULX
	return pars-->(3*w - 1);
#Endif; ! TARGET_
];
[ tokenPos pars w; ! position in buffer of token 1,2,3...
#Ifdef TARGET_ZCODE;
	return pars->(4*w + 1);
#Ifnot; ! TARGET_GLULX
	return pars-->(3*w);
#Endif; ! TARGET_
]; 

[ tokenCount pars;
#Ifdef TARGET_ZCODE;
	return pars->1;
#Ifnot; ! TARGET_GLULX
	return pars-->0;
#Endif; ! TARGET_
];

!-----------------------------------------------------
! LanguageToInformese
!
! Esta parte es interesante. Debe separar los sufijos pronominales
! como en "cogela" "mirale", claro que no basta con ver si las dos
! últimas letras del verbo son "la" "le", etc, pues el verbo podría
! terminar de forma "natural" en esas letras (como en "habla"). Así
! que hay que separar el sufijo sólo si el verbo no ha sido hallado en
! el diccionario.
!
[ LanguageToInformese ;
    EspanolAInformes(buffer, parse);
];

! La función que verdaderamente hace la traducción es la siguiente. Ha
! sido separada de LanguageToInformese porque es llamada también desde
! LanguageIsVerb, pero recibe un buffer diferente para procesar. 

[ EspanolAInformes buf pars x i word at len romper_en siguiente retokenise at2; !    print "   EspanolAInformes called^"; ! infsp debug

   #ifdef TARGET_GLULX; ! TARGET_GLULX
    buf = PasarAMinuscula (buf); ![INFSP] Necesario para q no cazque al procesar infinitivos
   #endif;

    VM_Tokenise( buf, pars);     retokenise=0;
#ifdef DEBUG;
    if (parser_trace>=7) !imprimir el buf recibido
    {
          print "^[ EspanolAInformes:  ";
          print "Buffer recibido: |";
		ImprimeTodoElBuffer(buf);
          print "|^  ";
    } 
#endif;
    if (quitacentos) QuitarAcentos(buf, pars);

     for (x=1:x<=tokenCount(pars):x++) ! para cada token
    {
	word = tokenDict (pars,x); !dictionary value of token 1,2,3...
	at = tokenPos (pars,x); ! position in buffer of token 1,2,3... 
	len = tokenLen (pars,x);! length in chars of token 1,2,3...

#ifdef DEBUG;
	if (parser_trace>=7){
          print "Palabra ",x," : ";
          if (word==0)
            print "<no comprendida>";
          else 
            print (address) word," ^";
          print " ^";
        }        
#endif;

	if (dialecto_sudamericano && (word == 'coge'))
	{
	  ! Un poco bestia, pero funciona. En caso de dialecto sudamericano,
	  ! cambiar un par de letras convierte "coge" en "jode"
	  buf->(at)     = 'j';
	  buf->(at + 2) = 'd';
	  retokenise    = 1;
	  if (dialecto_sudamericano == 1)  ! [071030_git]
	  {
	    print "[Este juego utiliza por defecto el dialecto sudamericano,
		    por lo que aquí COGER es entendido como una palabra
		    malsonante. Por favor, utiliza TOMAR en su lugar, o bien
		    elige el dialecto castellano con DIALECTO CASTELLANO.]^";
	    dialecto_sudamericano = 2;
	  }
	}
    
    if (word=='del' or 'al')
    {
        buf->(at+len-1)=' ';    ! convertir "del" "al" en "de"
                                       ! "a" respectivamente
        retokenise=1;
    }
    

    ! Si el jugador ha escrito "no", y previamente el programador
    ! había puesto a 1 el flag "PreguntaSiNo" (que indica que
    ! acaba de hacerse una pregunta que podría admitir NO como
    ! respuesta), en ese caso cambiamos "no" por "xo". La
    ! gramática define el verbo "xo" para generar la acción NO
    ! (negar), y así lo distinguimos de la acción "Ir noroeste"
    if ((word=='no')&&(PreguntaSiNo==1))
    {
        buf->(at+len-1)='x';
        PreguntaSiNo=0;
        retokenise=1;
    }
        
        ! "pegar" las expresiones "y luego" "y despues" "y entonces"
        ! para que queden "yluego" "ydespues" "yentonces"
        ! que es como las reconoce el parser
     if (word=='y//')
    {
       siguiente= tokenDict (pars,x+1); ! palabra siguiente

	if (siguiente==DESPUES11_WD or DESPUES21_WD or DESPUES31_WD)
       {
	   at2 = tokenPos (pars,x+1); ! position in buffer of token 1,2,3... 
           for (i=0:i<tokenLen(pars,x+1):i++){
                   buf->(at2+i) = ' '; ! borrar palabra 'entonces' (pisándola con espacios)
	   }
           buf->(at+len)='l'; ! agregar 'luego' inmediatamente despues de 'y', formando 'yluego'
           buf->(at+len+1)='u';
           buf->(at+len+2)='e';
           buf->(at+len+3)='g';
           buf->(at+len+4)='o';
           retokenise=1;
#ifdef DEBUG;
           if (parser_trace>=7) !imprimir el buf recibido
	   {
		print "^[   YLUEGO:  ";
		print "Buffer recibido: |";
		ImprimeTodoElBuffer(buf);
		print "|^  ";
	    } 
#endif;
       }
    }     

    if (word==0) ! no comprendida
    {
#ifdef DEBUG;
        if (parser_trace>=7)
        {
            print "NO COMPRENDIDO: |";
            ImprimeBuffer(buf, at, len);
            print "|^";
        }
#endif;        
        if (len > 2) !sólo si tiene más de tres letras
        {
           romper_en=0;
           if ((buf->(at+len-1)=='s') &&
            (buf->(at+len-2)=='a' or 'o' or 'e') &&
            (buf->(at+len-3)=='l'))
            romper_en=3;
           if ((buf->(at+len-1)=='a' or 'o' or 'e') &&
            (buf->(at+len-2)=='l'))
            romper_en=2;
           if ((buf->(at+len-1)=='e') &&
            (buf->(at+len-2)=='m' or 't' or 's'))
            romper_en=2;  ! [001108] Antes ponía == ¡seré burro!
           if (romper_en) 
           {
            ! [990524]
            ! Antes de modificar el buffer, comprobemos si
            ! servirá para algo, es decir, si la palabra que
            ! queda una vez separado el sufijo existe en el
            ! diccionario y es un verbo
            i=DictionaryLookup(buf+at, len-romper_en);
            
              if (i) if ((i->#dict_par1)&1)
              {
                LTI_Insert(at+len-romper_en, '-', buf);
                LTI_Insert(at+len-romper_en, ' ', buf);
                VM_Tokenise(buf,pars);
               }
              if (QuitandoRFinal(buf+at, len-romper_en)||
                  BuscarEntreVerbosIrregulares(buf+at, len-romper_en))
              {
                LTI_Insert(at+len-romper_en, '-', buf);
                LTI_Insert(at+len-romper_en, ' ', buf);
                VM_Tokenise(buf,pars);
               }
             } ! if (romper_en
        } ! if (len > 2
    } ! if (word==0
    } ! for (x=0:

    if (retokenise==1) ! [INFSP] Agregado if, como en la seccion Glulx
       VM_Tokenise(buf, pars);

    ArreglarLosY(buf, pars);
    
    ! Como paso final, quitamos las palabras que aparezcan dos veces
    ! seguidas. Esto puede ocurrir si el jugador teclea un comando
    ! incompleto, como "MIRA HACIA", y el parser le pregunta "¿Hacia
    ! donde quieres mirar?" y el jugador responde "HACIA EL NORTE". En
    ! este caso se construiría la orden concatenada: "MIRA HACIA HACIA
    ! EL NORTE".
    if (PreguntaCualExactamente==1){
        !print "PreguntaCualExactamente:",PreguntaCualExactamente;!debug
        PreguntaCualExactamente=0;
        EliminarDuplicados(buf, pars);
    }
    
#ifdef DEBUG;
    if (parser_trace>=7){
       print "Buffer traducido a informese: ^|";
        ImprimeTodoElBuffer(buf);
       print "| (", pars->1," palabras) ^";
    }
#endif;
];


[ ArreglarLosY buf pars
    word at len x i retoke;

    for (x=1:x<=tokenCount(pars):x++) ! para cada token
    {
 	word = tokenDict (pars,x); !dictionary value of token 1,2,3...
        if (word=='y//')
	{
		i = tokenDict (pars,x+1); ! palabra siguiente
        ! [010515] arreglado bug. at y len no apuntaban a la
        ! palabra siguiente, sino a la propia 'y', por lo que no
        ! eran reconocidos los verbos en infinitivo
		at = tokenPos (pars,x+1); ! position in buffer of token siguiente 
		len = tokenLen (pars,x+1);! length in chars of token siguiente

        ! [010515] Añadido. Si la palabra es noun, se retorna
        ! (aunque pueda ser también un verbo) de este modo, en
        ! COGE VINO Y CAVA, si el juego tiene un objeto llamado
        ! "cava", la frase será parseada como tratando de coger
        ! dos objetos, llamados "vino" y "cava". Si el juego no
        ! define el sustantivo "cava", la frase será parseada como
        ! dos acciones en secuencia <<Coger vino>> y <<Excavar>>
		if (i && (i->#dict_par1)&128) {
			if (EncajeSimplon(i, location)) continue;
		}
		if (i && ((i->#dict_par1)&1)||QuitandoRFinal(buf+at,len)||
			BuscarEntreVerbosIrregulares(buf+at, len))
		{
			at = tokenPos (pars,x); ! position in buffer of token siguiente 
			buf->(at)='.';
			retoke=true;
		}
	}
    }
    if (retoke) VM_Tokenise(buf, pars);
];

[ EliminarDuplicados buf pars
    word at len x i siguiente retokenise;

!    VM_Tokenise(buf, pars);
#ifdef DEBUG;
    if (parser_trace>=8) !imprimir el buffer recibido
    {
          print "^[ EliminarDuplicados:  ";
          print "Buffer recibido: |";
              ImprimeTodoElBuffer(buf);
          print "| (", pars->1, " palabras)^";
    } 
#endif;
    for (x=1:x<=tokenCount(pars):x++) ! para cada token
    {
	word = tokenDict (pars,x); !dictionary value of token 1,2,3...
	siguiente = tokenDict (pars,x+1); !dictionary value of token 1,2,3...
	at = tokenPos (pars,x); ! position in buffer of token 1,2,3... 
	len = tokenLen (pars,x);! length in chars of token 1,2,3...
    if ((word==siguiente) && (word~=0))
    {
#ifdef DEBUG;
        if (parser_trace>=8) print "Encontrados duplicados!:",
		(address) word, "=", (address) siguiente, ".^";
#endif;
        for (i=at:i<at+len:i++) buf->i=' ';
        retokenise=1;
    }
    }
    if (retokenise) 
    VM_Tokenise(buf, pars);

#ifdef DEBUG;
    if (parser_trace>=8) !imprimir el buffer recibido
    {
          print "Buffer resultante: |";
        ImprimeTodoElBuffer(buf);
          print "| (", pars->1, " palabras)^";
    } 
#endif;
];


! La siguiente función debe devolver si el verbo recibido es
! reconocido o no. Se recibe el buffer completo y "pos" indica qué
! palabra dentro del buffer "pars" es el supuesto verbo.
! Hay que devolver la dirección de diccionario del verbo en cuestión.
!
! Lo usamos para admitir infinitivos. El método es:
!   Si la palabra corresponde a una palabra de diccionario, no hacemos
!   nada (retornamos esa palabra, sin molestarnos en comprobar que sea
!   un verbo. Ya lo hará el parser).
!
!   Si la palabra no está en el diccionario, miramos si termina en
!   'r', y de ser así se la quitamos y re-tokenizamos. Si de este modo
!   se obtiene una palabra en el diccionario, retornamos su valor (sin
!   comprobar que sea un verbo, ya lo hará el parser).
!
!   Si tampoco de este modo se reconoce, comparamos la palabra dada
!   con todos los verbos irregulares conocidos. Si en uno de ellos
!   encontramos coincidencia, retornamos el primer elemento de la
!   propiedad "imperativo" del verbo en cuestión.
!
!   En el caso de la desambiguacion, puede darse que el jugador responda
!   con un verbo nuevo, pero con sufijo pronominal la/le/lo/me/te/se (ej. examinala)
!   Por ello se hace una llamada a EspanolAInformes

[ LanguageIsVerb buf pars pos
    i word at len;
    
#ifdef DEBUG;
    if (parser_trace>=7) !imprimir el buffer recibido
    {
	print "^[ LanguageIsVerb:  ";
	print "Buffer recibido: |";
		ImprimeTodoElBuffer(buf);
	print "|, pos=", pos, "^  ";
    } 
#endif;
    if (PreguntaCualExactamente) ! caso de desambiguación
	EspanolAInformes(buf, pars); ! revisar la existencia de sufijos pronominales la/le/lo/me/te/se
    word = tokenDict (pars,pos); !dictionary value of token 1,2,3...
    at = tokenPos (pars,pos); ! position in buffer of token 1,2,3... 
    len = tokenLen (pars,pos);! length in chars of token 1,2,3...

    ! Si la palabra se reconoce, devolverla sin más
     if (word~=0 && word->#dict_par1 & 1 ~= 0)
    {
#ifdef DEBUG;
	if (parser_trace>=7) print " la palabra ~", (address)
		word, "~ está en el diccionario.^";
#endif;
	return    (word);
    }

   
    ! Si no, probar a ver si se reconoce sin la 'r' final
    i=QuitandoRFinal(buf + at,len);

    ! Si no la ha reconocido, intentamos ver si es un verbo irregular
    if (i~=0)
    {
	if (parser_trace>=7) print "^ Verbo reconocido
		al quitarle la 'r' final.^";
    }
    else 
    {
	if (parser_trace>=7) print "^ Verbo no reconocido sin la
		'r'. ^Probando irregulares...";
 	i=BuscarEntreVerbosIrregulares(buf + at,len);
#ifdef DEBUG;
	if (parser_trace>=7) 
	{
		if (i==0) print "No reconocido como irregular.^";
		else print "      Reconocido como el verbo ", (address) i, "^";
	}
#endif;
    }     
       if (parser_trace>=7) 
        print " ^                   -- end LanguageIsVerb ]^";
    return i;    
];

[ QuitandoRFinal texto longitud
    i;

#ifdef DEBUG;
    if (parser_trace>=9) {
	print "^[ QuitandoRFinal: buffer recibido |";
		ImprimeBuffer(texto, 0, longitud);
	print "|^";
    }
#endif;	
	if (texto->(longitud-1)~='r')
    {
	if (parser_trace>=9) print "No termina en 'r'^";
	return 0;
    }
    
    i=DictionaryLookup(texto, longitud-1);     
    if (dialecto_sudamericano && (i == 'coge'))
    {
      if (dialecto_sudamericano == 1)  ! [071030] git
      {
        print "[Este juego utiliza por defecto el dialecto sudamericano,
                por lo que aquí COGER es entendido como una palabra
                malsonante. Por favor, utiliza TOMAR en su lugar, o bien
                elige el dialecto castellano con DIALECTO CASTELLANO.]^";
        dialecto_sudamericano = 2;
      }
      return 'jode';
    }     
     if ((i->#dict_par1)&1) return i;
    else 
    {
    if (parser_trace>=9) print "Está en el diccionario, pero no es verbo.^";
    return 0;
    }
];


[ BuscarEntreVerbosIrregulares texto longitud
    verbo i k;

    objectloop (verbo ofclass VerboIrregular)
    {
#ifdef DEBUG;
	if (parser_trace>=8) print "^[Bucando irregulares. Probando
		con ~", (name) verbo, "~.-->"; 	
#endif;
		k = VM_PrintToBuffer (texto_impreso,46,verbo);

    
        !Si sus longitudes no coinciden no es necesario seguir comparando
        if (k~=longitud) jump NoCoincide;
    
        !Si sus longitudes coinciden, miramos letra a letra
        for (i=0:i<k:i++)
            if ((texto->i)~=(texto_impreso->(i+WORDSIZE)))
        
	jump NoCoincide; ! si una sola letra no coincide,
	! Si ha pasado los test anteriores, hemos hallado una
	! coincidencia
	#ifdef DEBUG;if (parser_trace>=8) print "¡coincide!^";#endif;
	return (verbo.&imperativo-->0);

	.NoCoincide;
	#ifdef DEBUG;if (parser_trace>=8) print "no coincide^";#endif;
    }
    return 0;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Translation (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = male;

Constant LanguageContractionForms = 1;     ! Para el español
! No se produce contracción del artículo. Sólo de las preposiciones
! como en "del" y "al", pero eso no está contemplado por el manual
! del traductor, por lo que es necesario otro tipo de truco

[ LanguageContraction ;
    return 0;
];

Array LanguageArticles -->
    ! Forma de contracción 0:
    ! Cdef   Def  Indef  
    "El " "el " "un "    
    "La " "la " "una "   
    "Los " "los " "unos "  
    "Las " "las " "unas ";

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n                 
Array LanguageGNAsToArticles --> 0 1 0 2 3 2 0 1 0 2 3 2;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Articles (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Definimos una función para imprimir el verbo coger. Esto hace más fácil
! la adaptación de los juegos a los dialectos sudamericanos, en los
! que debe usarse "tomar" en lugar de "coger"
! 
! La variable global que elige el dialecto se fija en tiempo de
! ejecución con el meta-verbo "dialecto". También puede fijarse en
! Initialize para que su valor por defecto sea 1.
!
[ coge sufijo;
    if (dialecto_sudamericano)
      print "toma";
    else print "coge";
    if (sufijo ~= 0)
       print (string) sufijo;
!    #ifndef NI_BUILD_COUNT; print (string) sufijo;#endif; !desde I7 no puede usarse 'sufijo'
];

! La siguiente es la versión con la primera letra mayúscula

[ MCoge sufijo;
    if (dialecto_sudamericano)
    print "Toma";
    else print "Coge";
    if (sufijo ~= 0)
       print (string) sufijo;
!    #ifndef NI_BUILD_COUNT; print (string) sufijo;#endif; !desde I7 no puede usarse 'sufijo'
];

! Y finalmente una versión con todo mayúsculas

[ MMCoge sufijo;
    if (dialecto_sudamericano)
    print "TOMA";
    else print "COGE";
    if (sufijo ~= 0)
       print (string) sufijo;
!    #ifndef NI_BUILD_COUNT; print (string) sufijo;#endif; !desde I7 no puede usarse 'sufijo'
];

! Funciones para manejar concordancias de género y número en los
! mensajes de respuesta genéricos.
!
! o -> escribe la terminación -o -a -os -as según el género y número
! del objeto recibido, para hacer concordar los adjetivos.
!
! n -> escribe la terminación -"" -n según el número del objeto, para
! hacer concordar el verbo en plural.
!
! esta -> escribe "está" o "están" según el número del objeto.
!
! del -> escribe "del" "de la" "de los" "de las" según el género y
! número del objeto. En realidad, determina qué artículo habría de ir
! y si éste es "el" realiza la contracción "del".
!
! al -> como del, pero con "al" "a la" "a los" "a las".
!
! lo -> Escribe "lo" "la" "le" "los" "las" "les" (proname) según el
! género y número del objeto y según sea animate o no.
!

Constant PARTICULA_TE       = "te";
Constant THOSET__TX      = "esas cosas";
Constant THAT__TX        = "eso";

[ o obj gna;

    gna=GetGNAOfObject(obj);
    switch(gna)
    {
     0,6: print "o";
     1,7: print "a";
     3,9: print "os";
     4,10: print "as";
    }
];    

[ e obj gna;

    gna=GetGNAOfObject(obj);
    switch(gna)
    {
     0,6: print "e";
     1,7: print "a";
     3,9: print "es";
     4,10: print "as";
    }
];


[ n obj;
    if (obj == player) print "s";
    else if (obj has pluralname) print "n";
];

[ s obj;
    if (obj has pluralname) print "s";
];

[ esta obj;
    print "está", (n) obj;
];

[ es obj;
    if (obj has pluralname) print "son";
    else print "es";
];

[ _Es obj;
    if (obj has pluralname) print "Son";
    else print "Es";
];

[ _s obj;
    if (obj has pluralname) print "es";
];

[ el_ obj;
    if (obj hasnt proper) PrefaceByArticle(obj,1,-1);
];

[ un_ obj;
    if (obj hasnt proper) PrefaceByArticle(obj,2,-1);
];


[ el obj;
    print (the) obj;
];

[ _El obj;
    print (The) obj;
];

![ un obj;
!    if (un_(obj)) print " ";
!    print (name) obj;
!];

[ un obj;
!  if (obj has proper) print "a "; ![infsp] ya se incluyó esta linea en el hackeo de Indefart.
  print (a) obj;
];

[ _Un obj; ! indefinido con la primera letra en mayuscula. -Eliuk Blau
  print (A) obj;
];


[ _nombre_ obj;
    print (name) obj;
];

[ numero obj;
    print (number) obj;
];


! "al" y "del" plantean un bonito problema. La contracción debe
! producirse si el artículo es "el", pero esto no se sabe consultando
! el GNA, pues hay palabras como "aguila" que son femeninas y no
! obstante usan "el" como artículo.
! El truquillo consiste en llamar a (the) para averiguar qué artículo
! se imprimiría (pero capturando la salida de ese print y guardándola
! en una variable). Si el artículo en cuestión empieza por 'e', se
! produce la contracción.
!
! Para capturar la salida a una variable, es necesario descender al
! lenguaje ensamblador de la Z machine. Este truco lo aprendí del
! Designers manual (respuesta al ejercicio 96, página 249)
!
[ del_ obj;
    if (obj has proper) {        ! 030305
            print "de ";
            rtrue;
    }
!print " (del) "; ! infsp debug
                
#ifdef TARGET_ZCODE;
    texto_impreso-->0 = 50;
    @output_stream 3 texto_impreso;
    print (the)obj;
    @output_stream -3;
    if (texto_impreso->2 == 'e') print "d";
    else print "de ";
#ifnot; !TARGET_GLULX
    Glulx_PrintAnyToArray(texto_impreso, 50, PrefaceByArticle, obj, 1, -1);
    if (texto_impreso->0 == 'e') print "d";
    else print "de ";
#endif;    
    if (obj hasnt proper) PrefaceByArticle(obj, 1, -1);
];

! Con "al" el truco es más complejo, ya que si el artículo impreso por
! el_ empieza por "e", hay que cambiar esta "e" por una "a". Y si no
! empieza por "e" hay que poner una "a" delante.
! Además debemos capturar el caso de que no se imprima artículo alguno
! (si el objeto proporciona una propiedad "articulos" con cadenas
! vacías).
!------------------------------------------------------------------------------
! ELIUK BLAU: He re-implementado la rutina para permitir que la primera letra
! se imprima en mayuscula si se activa el argumento 'flag' durante la llamada.
[ al_ obj flag; ! ELIUK: 'flag' es usado solo por rutina de impresion (_Al)
    #ifdef TARGET_ZCODE;
      texto_impreso-->0 = 50;
      @output_stream 3 texto_impreso;
      print (the) obj;
      @output_stream -3;
      ! print "^  ";for (i=2:i<50:i++) print (char)texto_impreso->i;print "   "; ! infsp debug
    #ifnot; !TARGET_GLULX
      ! PrintAnyToArray(texto_impreso, 50, PrefaceByArticle, obj, 1, -1);
      Glulx_PrintAnyToArray(texto_impreso, 50, Defart, obj);! 070809 infsp fix: corrige mal funcionamiento con Propios - gracias Eliuk
      ! print "^  ";for (i=0:i<2:i++) print (char)texto_impreso->i;print "   "; ! infsp debug
    #endif; !TARGET_
    
    ! ELIUK: aqui se decide si se pone mayuscula o no
    if (flag) { print "A"; } ! 'flag' activado
    else { print "a"; }      ! 'flag' desactivado

    ! ELIUK: completamos el resto del texto que se imprimira finalmente
    #ifdef TARGET_ZCODE;
      if (texto_impreso->2 == 'e') { print "l "; }
      else {
        print " ";
        if (obj hasnt proper) { PrefaceByArticle(obj, 1, -1); }
      }
    #ifnot; !TARGET_GLULX
      if (texto_impreso->0 == 'e') { print "l "; }
      else {
        print " ";
        if (obj hasnt proper) { PrefaceByArticle(obj, 1, -1); }
      }
    #endif; !TARGET_
];

[ del obj;
    print (del_) obj;
    print (name) obj;
];

[ al obj;
    print (al_) obj;
    print (name) obj;
];

! ELIUK BLAU: Rutina de impresion "A", "Al", "A la", "A los", "A las" con la primera
! letra en mayuscula. Se usa como base el funcionamiento de la rutina al_() de INFSP.
[ _Al obj;
    al_(obj,1); ! con 1 se activa 'flag' para imprimir primera letra en mayuscula
    print (name) obj;
    ! NOTA: SI POSTERIORMENTE SE INTENTA MEJORAR ESTA RUTINA, JUNTO CON al_(),
    ! LA SOLUCION JAMAS DEBE SER IMPRIMIR A UN BUFFER PORQUE LOS RESULTADOS
    ! PUEDEN SER INESPERADOS. LA PROPIA al_() YA IMPRIME A UN BUFFER, ASI QUE
    ! OTRO TRABAJO DEL MISMO TIPO IMPLICARIA TENER QUE CREAR UN NUEVO ARRAY
    ! CON EL QUE TRABAJAR O USAR EL ARRAY COMUN StorageForShortName DE LA
    ! PROPIA LIBRERIA INFORM. EN ESTE ULTIMO CASO ES CUANDO SE PRODUCEN LOS
    ! PROBLEMAS... POR OTRO LADO: CREAR UN NUEVO ARRAY SOLO PARA QUE LO USE
    ! ESTA RUTINA NO TIENE SENTIDO. POR ESO LA NECESIDAD DEL 'flag' EN al_()
];

[ lo obj gna;
    gna=GetGNAOfObject(obj);
    switch(gna)
    {
     0,6: print "lo";
     1,7: print "la";
     3,9: print "los";
     4,10: print "las";
    }
];

! deprecated
![ IsOrAre obj;  !I7 stuffs, in Verbs.i6/GenericVerbSub
!    if (obj == player)             { print "Eres"; return; }
!    if (obj has pluralname)        { print "Son"; return; }
!    print "Es";
!];


!LanguageVerb: imprime el verbo, usado en pregunta para esclarecer comando
[ LanguageVerb i aux;

    if (ImprimirIrregular(i)==0){
        !print "^   LanguageVerb: Verbo no es irregular.^"; ! infsp debug
      
      ! Tatar de matchear con la brújula - 807.7 infsp
      objectloop (aux in Compass){
        if (WordInProperty(i, aux, name)) {
          print "ir hacia algún lado";
          rtrue; ! no avanzar más en la rutina
        }    
       }
       
       ! Un ultimo intento, con una rutina stub a proveer por el autor
       if (PrintVerb(i)==0){
         print (address) i; print "r";
        }
    }

    if (i=='mete') rtrue;
    
#ifdef TARGET_ZCODE;
    ! Comprobemos si era un verbo reflexivo (-te)
    texto_impreso-->0 = 50;
    @output_stream 3 texto_impreso;
    print (address) i;
    @output_stream -3;
    aux=2;
!    print "^   LanguageVerb: i : ",(address) i,"^"; ! infsp debug
    if (texto_impreso->(texto_impreso->1+1)=='e')
     if (texto_impreso->(texto_impreso->1) == 't' or 's' or 'm')
     {
!     print "^   LanguageVerb:Verbo reflexivo."; ! infsp debug
       if (actor ~= player) print "se";
        else print (string) PARTICULA_TE; ! "te"
     }
#endif;
#ifdef TARGET_GLULX;
    aux=Glulx_PrintAnyToArray(texto_impreso, 50, i);
    if ((texto_impreso->(aux-1)=='e')&&
        (texto_impreso->(aux-2) == 't' or 's' or 'm')) 
    {
       if (actor ~= player) print "se";
        else print (string) PARTICULA_TE;
    }
#endif;
    rtrue;

];

[ ImprimirIrregular v i;
  ! Imprime los verbos irregulares (es decir, aquellos en los que no basta
  ! añadir una "r" al imperativo). Por ejemplo, si el jugador teclea "friega"
  ! la respuesta por defecto sería "¿Qué quieres friegar?"
  ! Para evitar esto, el programador debe definir un objeto de la clase
  ! VerboIrregular, con nombre "fregar" y propiedad name = "friega"
  ! Esta rutina busca entre los verbos así definidos, en el campo name
  ! y si encuentra una coincidencia imprime el nombre del objeto para
  ! el cual se halló.

  ! Para mayor flexibilidad aún, se permite que el programador incluya
  ! una rutina en la propiedad nombre_corto del verbo, por si el nombre
  ! del verbo a imprimir es variable según el momento en que se llame.
  ! Si existe nombre_corto para el verbo en cuestión, se ejecuta dicha rutina
  ! de lo contrario se imprime el nombre de ese verbo sin más.

  ! Ver SpanishG.h para ejemplos de declaración de verbos irregulares.

  objectloop (i ofclass VerboIrregular)
   if (WordInProperty(v, i, imperativo)) {
     if (i.&short_name~=0) return(PrintOrRun(i, short_name, 1));
     else { print (name) i; rtrue;}}
  rfalse;
];

!  LanguageVerbLikesAdverb is called by PrintCommand when printing an UPTO_PE
!  error or an inference message.  Words which are intransitive verbs, i.e.,
!  which require a direction name as an adverb ('walk west'), not a noun
!  ('I only understood you as far as wanting to touch /the/ ground'), should
!  cause the routine to return true.

[ LanguageVerbLikesAdverb w;
    if (w == 'vete' or 've' or 'camina' or
        'anda' or 'corre' or 'vuelve' or 'ir')
        rtrue;
    rfalse;
]; 

!  LanguageVerbMayBeName is called by NounDomain when dealing with the 
!  player's reply to a "Which do you mean, the short stick or the long
!  stick?" prompt from the parser. If the reply is another verb (for example,
!  LOOK) then then previous ambiguous command is discarded /unless/
!  it is one of these words which could be both a verb /and/ an
!  adjective in a 'name' property.

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal'
                    or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Commands (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Default LanguageCases 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The Old Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Darkness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object thedark "(darkness object)";


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Light Measurement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Invariant
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global lightflag = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Adjust Light Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) {
			ADJUST_LIGHT_RM('A'); new_line;
		}
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Silent Light Consideration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Translucency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Visibility Parent
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Find Visibility Levels
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Touchability Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TouchabilityCeiling original o p;
	o = original;
	while (o) {
	    p = CoreOfParentOfCoreOf(o);
	    if (p ofclass K1_room) return p;
	    if (p == nothing) return o;
	    if ((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))
	    	return p;
	    o = p;
	}
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Scope Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Object Is Untouchable
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
	if (LocationOf(p) ~= real_location) {
		for (x = CoreOf(item): x: x = CoreOfParentOfCoreOf(x)) {
			if (x ofclass K4_door or K7_backdrop) {
				moving = true;
				MoveFloatingObjects(LocationOf(p));
				break;
			}
		}
	}
	untouchable_object = item; untouchable_silence = silent_flag;
	touch_persona = p; if (p == actor) touch_persona = 0;
	save_sp = say__p; say__p = 0;
	@push actor; actor = p;
	if (FollowRulebook(ACCESSIBILITY_RB, 0, true)) {
		if (RulebookSucceeded()) decision = false;
		else decision = true;
	} else decision = false;
	@pull actor;
	if (say__p == false) say__p = save_sp;
	if (moving) MoveFloatingObjects();
	untouchable_silence = 0;
	return decision;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Access Through Barriers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				ACCESS_THROUGH_BARRIERS_RM('A', untouchable_object);
				new_line;
			}
		}
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (FollowRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		while (i~=ancestor && i) {
			if ((external == false) &&
				(FollowRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Outside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_OUTSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Rooms Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_value && parameter_value ofclass K1_room) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_ROOMS_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Specification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Memory
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant REQUISITION_STACK_SIZE = 3*84;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListOfMarkedObjects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length g gc;

	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) gc = g;
		else if (gc ~= g) gc = -1;
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) {
    	if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
    	else if (style & CFIRSTART_BIT ~= 0) LIST_WRITER_INTERNAL_RM('X');
		else LIST_WRITER_INTERNAL_RM('Y');
	} else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	return;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Number and Gender
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RegardingMarkedObjects
	obj length g gc;
	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) {
			gc = g;
			prior_named_noun = obj;
		} else if (gc ~= g) gc = -1;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	if (length == 0) { prior_named_noun = nothing; prior_named_list_gender = -1; }
	return;	
];

[ RegardingSingleObject obj;
	prior_named_list = 1;
	prior_named_list_gender = -1;
	prior_named_noun = obj;
];

[ RegardingNumber n;
	prior_named_list = n;
	prior_named_list_gender = -1;
	prior_named_noun = nothing;
];

[ PNToVP gna;
	if (prior_named_noun == player) return story_viewpoint;
	if (prior_named_noun) gna = GetGNAOfObject(prior_named_noun);
	if (((gna%6)/3 == 1) || (prior_named_list >= 2)) return 6;
	return 3;
];

[ PrintVerbAsValue vb;
	if (vb == 0) print "(no verb)";
	else { print "verb "; vb(1); }
];

[ VerbIsMeaningful vb;
	if ((vb) && (BlkValueCompare(vb(CV_MEANING), Rel_Record_0) ~= 0)) rtrue;
	rfalse;
];

[ VerbIsModal vb;
	if ((vb) && (vb(CV_MODAL))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Writer Regard Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LWI_Storage --> 1 (-1) nothing;
[ SetLWI a b c;
	LWI_Storage-->0 = a;
	LWI_Storage-->1 = b;
	LWI_Storage-->2 = c;
];
[ RegardingLWI;
	prior_named_list = LWI_Storage-->0;
	prior_named_list_gender = LWI_Storage-->1;
	prior_named_noun = LWI_Storage-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Response Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ResponseViaActivity R;
	@push prior_named_noun; @push prior_named_list; @push prior_named_list_gender;
	RegardingSingleObject(nothing);
	CarryOutActivity(PRINTING_RESPONSE_ACT, R);
	@pull prior_named_list_gender; @pull prior_named_list; @pull prior_named_noun;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: About Iterator Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Marked List Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
	switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
							(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) && (ConcealedFromLists(obj))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Concealment
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ConcealedFromLists obj c;
	if ((obj has concealed) || (obj has scenery)) rtrue;
	c = parent(obj);
	if ((c) && (c ofclass K5_container or K6_supporter) && (TestConcealment(c, obj))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Marked List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength) &&
				(LT_Compare((MarkedObjectArray-->i).list_together, lt) == 0): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if (LT_Compare((MarkedObjectArray-->l).list_together, lt) == 0) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Object Tree Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) obj = child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
!if (function == ADVANCE_ITF) print "Considering ", (the) obj, ": ", (TEXT_TY_Say) obj.list_together, ": ", (TEXT_TY_Say) required_lt, ": ", ": ", (TEXT_TY_Say) lt_value, ": ", LT_Compare(obj.list_together, required_lt), "^";
		if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
			(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) && (ConcealedFromLists(obj))) continue;
		return obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb):
				(memb) && (LT_Compare(memb.list_together, lt) == 0): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (LT_Compare(later.list_together, lt) == 0) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListFrom
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
		if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
        else LIST_WRITER_INTERNAL_RM('Y');
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together)
				BlkValueCopy(ol.list_together, EMPTY_TEXT_VALUE);
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Standard Contents Listing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_value), c_style, c_depth, true);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partitioning
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partition List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Equivalence Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Grouping
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	current_lt = EMPTY_TEXT_VALUE;
	lt = EMPTY_TEXT_VALUE;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
        	if ((LT_Compare(lt, lt_value) ~= 0) &&
            	(LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) &&
            	(LT_Compare(lt, current_lt) == 0)) {
            	no_groups--;
            }
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ LT_Compare lt1 lt2;
	if (lt1 == lt2) return 0;
	if (lt1 == 0) lt1 = EMPTY_TEXT_VALUE;
	if (lt2 == 0) lt2 = EMPTY_TEXT_VALUE;
	if (TEXT_TY_IsSubstituted(lt1) == false) {
		if (TEXT_TY_IsSubstituted(lt2) == false) return (lt1-->1)-(lt2-->1);
		return -1;
	}
	if (TEXT_TY_IsSubstituted(lt2) == false) {
		return -1;
	}
	return BlkValueCompare(lt1, lt2);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write List Recursively
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
    	SetLWI(index, -1, o);
    	LIST_WRITER_INTERNAL_RM('V', o);
    	if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=EMPTY_TEXT_VALUE: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; return; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((LT_Compare(memb.list_together, lt_value) == 0) ||
        	(LT_Compare(memb.list_together, EMPTY_TEXT_VALUE) == 0)) current_lt = EMPTY_TEXT_VALUE;
		else {
            if (LT_Compare(memb.list_together, current_lt) == 0) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes &&
				(LT_Compare(q.list_together, memb.list_together) == 0)) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (LT_Compare(q.list_together, memb.list_together) == 0)
					listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = EMPTY_TEXT_VALUE;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
            	#ifdef SERIAL_COMMA; if (cl > 1) print ","; #endif;
               LIST_WRITER_INTERNAL_RM('C');
            }
            if (groups_to_do > 1) print ", ";
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Multiple Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if ((pv-->1)() == 1) jump Omit__Sublist2;
		} else if (pv) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (TEXT_TY_Say) pv;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			(pv-->1)();
		} else if (LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Single Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write After Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == false) {
			combo = 0;
			if (o has light && location hasnt light) combo=combo+1;
			if (o has container && o hasnt open)     combo=combo+2;
			if ((o has container && (o has open || o has transparent))
				&& (child(o)==0))                    combo=combo+4;
			if (combo) LIST_WRITER_INTERNAL_RM('A'); ! space and open bracket
			switch (combo) {
				1: LIST_WRITER_INTERNAL_RM('D', o);
				2: LIST_WRITER_INTERNAL_RM('E', o);
				3: LIST_WRITER_INTERNAL_RM('H', o);
				4: LIST_WRITER_INTERNAL_RM('F', o);
				5: LIST_WRITER_INTERNAL_RM('I', o);
				6: LIST_WRITER_INTERNAL_RM('G', o);
				7: LIST_WRITER_INTERNAL_RM('J', o);
			}
			if (combo) LIST_WRITER_INTERNAL_RM('B'); ! close bracket
		}
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if (ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == false) {
			if (o has light && o has worn) { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('K', o);  parenth_flag = true; }
			else {
				if (o has light)           { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('D', o);  parenth_flag = true; }
				if (o has worn)            { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('L', o); parenth_flag = true; }
			}
	
			if (o has container)
				if (o has openable) {
					if (parenth_flag) {
						#Ifdef SERIAL_COMMA; print ","; #Endif;
						LIST_WRITER_INTERNAL_RM('C');
					} else            LIST_WRITER_INTERNAL_RM('A', o);
					if (o has open)
						if (child(o)) LIST_WRITER_INTERNAL_RM('M', o);
						else          LIST_WRITER_INTERNAL_RM('N', o);
					else
						if (o has lockable && o has locked) LIST_WRITER_INTERNAL_RM('P', o);
						else                                LIST_WRITER_INTERNAL_RM('O', o);
					parenth_flag = true;
				}
				else
					if (child(o)==0 && o has transparent)
						if (parenth_flag) { LIST_WRITER_INTERNAL_RM('C'); LIST_WRITER_INTERNAL_RM('F'); }
						else              { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('F'); LIST_WRITER_INTERNAL_RM('B'); }
	
			if (parenth_flag) LIST_WRITER_INTERNAL_RM('B');
		}
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (ConcealedFromLists(p) == false))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) { print " "; LIST_WRITER_INTERNAL_RM('Q', o); print " "; }
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('R', o);
                } else LIST_WRITER_INTERNAL_RM('S', o);
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('T', o);
                } else LIST_WRITER_INTERNAL_RM('U', o);
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT)) {
    	SetLWI(child_count, -1, eldest_child);
    	LIST_WRITER_INTERNAL_RM('V', o); print " ";
	}

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = EMPTY_TEXT_VALUE; listing_together = 0; listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) LIST_WRITER_INTERNAL_RM('B');
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_WRITER_INTERNAL_R;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Saying Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Kinds
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: DigitToValue
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GenerateRandomNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GroupChildren
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GroupChildren par value;
    while (child(par) ~= 0) {
        if (LT_Compare(child(par).list_together, value) ~= 0)
        	move child(par) to out_obj;
        else
        	move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: PrintSpaces
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: RunRoutines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SwapWorkflags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: TestUseOption
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_USE_OPTIONS = 33;
[ TestUseOption 
    UO ! Implied call parameter
    ;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 4) rtrue;
    if (UO == 11) rtrue;
    if (UO == 17) rtrue;
    if (UO == 30) rtrue;
    if (UO == 32) rtrue;
    rfalse;
];
[ PrintUseOption 
    UO ! Implied call parameter
    ;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum text length option [1024]";
        3: print "index figure thumbnails option [50]";
        4: print "maximum things understood at once option [100]";
        5: print "American dialect option";
        6: print "serial comma option";
        7: print "full-length room descriptions option";
        8: print "abbreviated room descriptions option";
        9: print "memory economy option";
        10: print "authorial modesty option";
        11: print "scoring option";
        12: print "no scoring option";
        13: print "engineering notation option";
        14: print "unabbreviated object names option";
        15: print "command line echoing option";
        16: print "manual pronouns option";
        17: print "undo prevention option";
        18: print "predictable randomisation option";
        19: print "fast route-finding option";
        20: print "slow route-finding option";
        21: print "numbered rules option";
        22: print "telemetry recordings option";
        23: print "no deprecated features option";
        24: print "gn testing version option";
        25: print "VERBOSE room descriptions option";
        26: print "BRIEF room descriptions option";
        27: print "SUPERBRIEF room descriptions option";
        28: print "Dialecto Castellano option";
        29: print "Dialecto Sudamericano option";
        30: print "maximum capture buffer length option [256]";
        31: print "direct event handling option";
        32: print "no status line option";
    }
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerDivide
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerRemainder
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: UnsignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnsignedCompare x y u v;
	#Ifdef TARGET_GLULX;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
	#Ifnot;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
    #Endif;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SignedCompare x y;
	if (x > y) return 1;
	if (x == y) return 0;
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: ZRegion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Memcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Memcpy to_addr from_addr size  n;
#Ifdef TARGET_ZCODE;
	for (n = size/WORDSIZE: (n--) > 0: ) to_addr-->n = from_addr-->n;
	for (n = size: ((n--) % WORDSIZE ~= 0): ) to_addr->n = from_addr->n;
#Ifnot; ! TARGET_GLULX
    @mcopy size from_addr to_addr;
#Endif; ! TARGET_
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Arrcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries  n val;
	if (to_entry_size == from_entry_size)
		Memcpy(to_array, from_array, to_entry_size*no_entries);
	else if ((to_entry_size == 2) && (from_entry_size == 4)) {
		for (n = 0: n<no_entries: n++) {
			val = from_array-->n;
			to_array->0 = (val/256)%256; to_array->1 = val%256;
			to_array = to_array + 2;
		}
	} else "*** Arrcpy doesn't support this ***";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object InformParser "(Inform Parser)" has proper;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Line Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Token Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
#Endif;

[ WordFrom w p i j wc;
	#Ifdef TARGET_ZCODE; wc = p->1; i = w*2-1;
	#Ifnot; wc = p-->0; i = w*3-2; #Endif;
    if ((w < 1) || (w > wc)) return 0;
    j = p-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Snippets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	TEXT_TY_Say(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Unpacking Grammar Lines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Extracting Verb Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Keyboard Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (0 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Reading the Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) {
				PARSER_ERROR_INTERNAL_RM('X', noun); new_line;
			}
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { PARSER_COMMAND_INTERNAL_RM('A'); new_line; continue; }
			if (nw == 1) { PARSER_COMMAND_INTERNAL_RM('B'); new_line; continue; }
			if (nw > 2) { PARSER_COMMAND_INTERNAL_RM('C'); new_line; continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			IMMEDIATELY_UNDO_RM('E'); new_line;
			continue;
		}
		return nw;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Parser__parse
	syntax line num_lines line_address i j k token l m inferred_go;
	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    if (held_back_mode) {
        held_back_mode = false; wn = hb_wn;
        if (verb_wordnum > 0) i = WordAddress(verb_wordnum); else i = WordAddress(1);
        j = WordAddress(wn);
        if (i<=j) for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }

        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;

	cobj_flag = 0;
	actors_location = ScopeCeiling(player);
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

    parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount(); players_command = 100 + num_words;
    wn = 1; inferred_go = false;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese

    num_words = WordCount(); players_command = 100 + num_words;

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE; jump GiveError;
    }
	if (verb_word == comma_word) {
		best_etype = COMMABEGIN_PE; jump GiveError;
	}

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across

    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            best_etype = ANIMAAGAIN_PE;
			jump GiveError;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    	jump ReParse;
    }

    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->ACTION_PRES = action;
            parser_results-->NO_INPS_PRES = 0;
            parser_results-->INP1_PRES = noun;
            parser_results-->INP2_PRES = second;
            if (noun) parser_results-->NO_INPS_PRES = 1;
            if (second) parser_results-->NO_INPS_PRES = 2;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            inferred_go = true;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = MISSINGPERSON_PE; jump GiveError;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
 		best_etype = ANIMALISTEN_PE; noun = l; jump GiveError;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = TOTALK_PE; jump GiveError;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			best_etype = ANIMAAGAIN_PE;
			jump GiveError;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		verb_word = UnknownVerb(verb_word);
		if (verb_word ~= 0) jump VerbAccepted;
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.

                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump EmptyLine;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            if (wn <= num_words) l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        .EmptyLine;
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects
                        	k = parser_results-->INP1_PRES; @push k; @push parameters;
                        	parameters = 1; parser_results-->INP1_PRES = 0;
                            l = NounDomain(actors_location, actor, NOUN_TOKEN, true);
                            @pull parameters; @pull k; parser_results-->INP1_PRES = k;
                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                else {
                                	if (l == 1) print "but multiple found]^";
                                	if (l == 0) print "error ", etype, "]^";
                                	if (l >= 2) print (the) l, "]^";
                                }
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter G
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

		m = true;
        for (pcount=1 : : pcount++)
            if (line_token-->(pcount-1) == ENDIT_TOKEN) {
            	if (pcount >= 2) {
            		while ((((line_token-->(pcount-2))->0) & $10) ~= 0) pcount--;
            		AnalyseToken(line_token-->(pcount-2));
            		if (found_ttype == PREPOSITION_TT) {
            			l = -1;
            			while (true) {
            				m = NextWordStopped();
            				if (m == -1) break;
            				l = m;
            			}
            			if (PrepositionChain(l, pcount-2) == -1) {
            				m = false;
							#Ifdef DEBUG;
							if (parser_trace >= 2)
								print "[line rejected for not ending with correct preposition]^";
							#Endif; ! DEBUG
						} else m = true;
	           		}
            	}
            	break;
            }
		wn = verb_wordnum+1;

		if (m) for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = true; hb_wn = wn-1;
                    } else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1) {
                	if (parser_results-->INP1_PRES == 0) {
                	    l = ReviseMulti(parser_results-->INP2_PRES);
                	    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                	}
                }
                if (parameters >= 2) {
                	if (parser_results-->INP2_PRES == 0) {
            	        l = ReviseMulti(parser_results-->INP1_PRES);
                	    if (l ~= 0) { etype = l; break; }
                	} else {
                		k = parser_results-->INP1_PRES; l = parser_results-->INP2_PRES;
                		if (k && l) {
	                 		if ((multi_context==MULTIEXCEPT_TOKEN && k == l) ||
	                			((multi_context==MULTIINSIDE_TOKEN && k notin l && l notin k))) {
                				best_etype = NOTHING_PE;
                				parser_results-->ACTION_PRES = action_to_be; jump GiveError;
                			}
                		}
                	}
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing(20);
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter H
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable "player's command"
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    PARSER_ERROR_INTERNAL_RM('A'); new_line; oops_from = 1; }
    if (etype == UPTO_PE) {
    	if (inferred_go) PARSER_ERROR_INTERNAL_RM('C');
    	else PARSER_ERROR_INTERNAL_RM('B');
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0);
        print ".^";
    }
    if (etype == NUMBER_PE) {   PARSER_ERROR_INTERNAL_RM('D'); new_line; }
    if (etype == CANTSEE_PE) {  PARSER_ERROR_INTERNAL_RM('E'); new_line; oops_from=saved_oops; }
    if (etype == TOOLIT_PE) {   PARSER_ERROR_INTERNAL_RM('F'); new_line; }
    if (etype == NOTHELD_PE) {  PARSER_ERROR_INTERNAL_RM('G'); new_line; oops_from=saved_oops; }
    if (etype == MULTI_PE) {    PARSER_ERROR_INTERNAL_RM('H'); new_line; }
    if (etype == MMULTI_PE) {   PARSER_ERROR_INTERNAL_RM('I'); new_line; }
    if (etype == VAGUE_PE) {    PARSER_ERROR_INTERNAL_RM('J'); new_line; }
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL) { PARSER_ERROR_INTERNAL_RM('J'); new_line; }
        else { PARSER_ERROR_INTERNAL_RM('K', noun); new_line; }
    }
    if (etype == EXCEPT_PE) {   PARSER_ERROR_INTERNAL_RM('L'); new_line; }
    if (etype == ANIMA_PE) {    PARSER_ERROR_INTERNAL_RM('M'); new_line; }
    if (etype == VERB_PE) {     PARSER_ERROR_INTERNAL_RM('N'); new_line; }
    if (etype == SCENERY_PE) {  PARSER_ERROR_INTERNAL_RM('O'); new_line; }
    if (etype == JUNKAFTER_PE) {  PARSER_ERROR_INTERNAL_RM('P'); new_line; }
    if (etype == TOOFEW_PE) {  PARSER_ERROR_INTERNAL_RM('Q', multi_had); new_line; }
    if (etype == NOTHING_PE) {
    	if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
        	noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) { PARSER_N_ERROR_INTERNAL_RM('C', noun); new_line; }
            else if (noun hasnt container or supporter) { PARSER_N_ERROR_INTERNAL_RM('D', noun); new_line; }
            else if (noun has container && noun hasnt open)  { PARSER_N_ERROR_INTERNAL_RM('E', noun); new_line; }
            else if (children(noun)==0) { PARSER_N_ERROR_INTERNAL_RM('F', noun); new_line; }
            else parser_results-->ACTION_PRES = 0;
        }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100) { PARSER_N_ERROR_INTERNAL_RM('A'); new_line; }
            else                  {  PARSER_N_ERROR_INTERNAL_RM('B'); new_line; }
        }
    }
    if (etype == NOTINCONTEXT_PE) { PARSER_ERROR_INTERNAL_RM('R'); new_line; }
    if (etype == ANIMAAGAIN_PE) { PARSER_ERROR_INTERNAL_RM('S'); new_line; }
    if (etype == COMMABEGIN_PE) { PARSER_ERROR_INTERNAL_RM('T'); new_line; }
    if (etype == MISSINGPERSON_PE) { PARSER_ERROR_INTERNAL_RM('U'); new_line; }
    if (etype == ANIMALISTEN_PE) { PARSER_ERROR_INTERNAL_RM('V', noun); new_line; }
    if (etype == TOTALK_PE) { PARSER_ERROR_INTERNAL_RM('W'); new_line; }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter J
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter K
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        hb_wn = wn;
        held_back_mode = true;
       return;
    }
    best_etype = UPTO_PE;
    jump GiveError;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: End of Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

]; ! end of Parser__parse


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PARSER_ERROR_INTERNAL_R; ];
[ PARSER_N_ERROR_INTERNAL_R; ];
[ PARSER_COMMAND_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=number_matched-1: i>=0: i--) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN)) {
               	RunTimeProblem(RTP_TEXTTOKENTOOHARD);
               	return GPR_PREPOSITION;
        	}
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...
	
!	if (match_from ~= oops_from) print match_from, " vs ", oops_from, "^";

!    wn = oops_from + match_length;
    wn = match_from + match_length;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Happy or unhappy endings:

  .PassToken;
    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
		  	if (token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) multi_context = token;
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Descriptors  o x flag cto type n;
    ResetDescriptors();
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                flag = true;
                type = LanguageDescriptors-->(x+2);
                if (type ~= DEFART_PK) indef_mode = true;
                indef_possambig = true;
                indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

                if (type == POSSESS_PK) {
                    cto = LanguageDescriptors-->(x+3);
                    switch (cto) {
                      0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default:
                        indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                    }
                }

                if (type == light)  indef_type = indef_type | LIT_BIT;
                if (type == -light) indef_type = indef_type | UNLIT_BIT;
            }

        if (o == OTHER1__WD or OTHER2__WD or OTHER3__WD) {
            indef_mode = 1; flag = 1;
            indef_type = indef_type | OTHER_BIT;
        }
        if (o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
            indef_mode = 1; flag = 1; indef_wanted = INDEF_ALL_WANTED;
            if (take_all_rule == 1) take_all_rule = 2;
            indef_type = indef_type | PLURAL_BIT;
        }
        if (allow_plurals) {
        	if (NextWordStopped() ~= -1 or THEN1__WD) { wn--; n = TryNumber(wn-1); } else { n=0; wn--; }
            if (n == 1) { indef_mode = 1; flag = 1; }
            if (n > 1) {
                indef_guess_p = 1;
                indef_mode = 1; flag = 1; indef_wanted = n;
                indef_nspec_at = wn-1;
                indef_type = indef_type | PLURAL_BIT;
            }
        }
        if (flag == 1 && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
            wn--;  ! Skip 'of' after these
    }
    wn--;
    return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Preposition Chain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Creature
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noun Domain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounDomain domain1 domain2 context dont_ask
	first_word i j k l answer_words marker;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [NounDomain called at word ", wn, "^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "seeking definite object^";
    }
    #Endif; ! DEBUG

    match_length = 0; number_matched = 0; match_from = wn;

    SearchScope(domain1, domain2, context);

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   [ND made ", number_matched, " matches]^";
    #Endif; ! DEBUG

    wn = match_from+match_length;

    ! If nothing worked at all, leave with the word marker skipped past the
    ! first unmatched word...

    if (number_matched == 0) { wn++; rfalse; }

    ! Suppose that there really were some words being parsed (i.e., we did
    ! not just infer).  If so, and if there was only one match, it must be
    ! right and we return it...

    if (match_from <= num_words) {
        if (number_matched == 1) {
            i=match_list-->0;
            return i;
        }

        ! ...now suppose that there was more typing to come, i.e. suppose that
        ! the user entered something beyond this noun.  If nothing ought to follow,
        ! then there must be a mistake, (unless what does follow is just a full
        ! stop, and or comma)

        if (wn <= num_words) {
            i = NextWord(); wn--;
            if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                   or THEN1__WD or THEN2__WD or THEN3__WD
                   or BUT1__WD or BUT2__WD or BUT3__WD) {
                if (lookahead == ENDIT_TOKEN) rfalse;
            }
        }
    }

    ! Now look for a good choice, if there's more than one choice...

    number_of_classes = 0;

    if (number_matched == 1) {
    	i = match_list-->0;
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
			if (context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or
				NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN) {
				BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
				if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) &&
					(RulebookFailed())) rfalse;
				EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
			}
		}
    }
    if (number_matched > 1) {
		i = true;
	    if (number_matched > 1)
	    	for (j=0 : j<number_matched-1 : j++)
				if (Identical(match_list-->j, match_list-->(j+1)) == false)
					i = false;
		if (i) dont_infer = true;
        i = Adjudicate(context);
        if (i == -1) rfalse;
        if (i == 1) rtrue;       !  Adjudicate has made a multiple
                             !  object, and we pass it on
    }

    ! If i is non-zero here, one of two things is happening: either
    ! (a) an inference has been successfully made that object i is
    !     the intended one from the user's specification, or
    ! (b) the user finished typing some time ago, but we've decided
    !     on i because it's the only possible choice.
    ! In either case we have to keep the pattern up to date,
    ! note that an inference has been made and return.
    ! (Except, we don't note which of a pile of identical objects.)

    if (i ~= 0) {
    	if (dont_infer) return i;
        if (inferfrom == 0) inferfrom=pcount;
        pattern-->pcount = i;
        return i;
    }

	if (dont_ask) return match_list-->0;

    ! If we get here, there was no obvious choice of object to make.  If in
    ! fact we've already gone past the end of the player's typing (which
    ! means the match list must contain every object in scope, regardless
    ! of its name), then it's foolish to give an enormous list to choose
    ! from - instead we go and ask a more suitable question...

    if (match_from > num_words) jump Incomplete;

    ! Now we print up the question, using the equivalence classes as worked
    ! out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestion;
	j = 1; marker = 0;
	for (i=1 : i<=number_of_classes : i++) {
		while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
			marker++;
		if (match_list-->marker hasnt animate) j = 0;
	}
	if (j) PARSER_CLARIF_INTERNAL_RM('A');
	else PARSER_CLARIF_INTERNAL_RM('B');

    j = number_of_classes; marker = 0;
    for (i=1 : i<=number_of_classes : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i)) marker++;
        k = match_list-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < j-1)  print ", ";
        if (i == j-1) {
			#Ifdef SERIAL_COMMA;
			if (j ~= 2) print ",";
        	#Endif; ! SERIAL_COMMA
        	PARSER_CLARIF_INTERNAL_RM('H');
        }
    }
    print "?^";

	.SkipWhichQuestion; EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:

  .WhichOne;
    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i = ' ';
    #Endif; ! TARGET_ZCODE
    answer_words=Keyboard(buffer2, parse2);

    ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.
    first_word = (parse2-->1);

    ! Take care of "all", because that does something too clever here to do
    ! later on:

    if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
        if (context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
            l = multiple_object-->0;
            for (i=0 : i<number_matched && l+i<MATCH_LIST_WORDS : i++) {
                k = match_list-->i;
                multiple_object-->(i+1+l) = k;
            }
            multiple_object-->0 = i+l;
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM('C');
        jump WhichOne;
    }

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;		
		}

    ! If the first word of the reply can be interpreted as a verb, then
    ! assume that the player has ignored the question and given a new
    ! command altogether.
    ! (This is one time when it's convenient that the directions are
    ! not themselves verbs - thus, "north" as a reply to "Which, the north
    ! or south door" is not treated as a fresh command but as an answer.)

    #Ifdef LanguageIsVerb;
    if (first_word == 0) {
        j = wn; first_word = LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! Now we insert the answer into the original typed command, as
    ! words additionally describing the same object
    ! (eg, > take red button
    !      Which one, ...
    !      > music
    ! becomes "take music red button".  The parser will thus have three
    ! words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j--) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j--) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_

    ! Having reconstructed the input, we warn the parser accordingly
    ! and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount(); players_command = 100 + num_words;
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount(); players_command = 100 + num_words;
    actors_location = ScopeCeiling(player);
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT);

    return REPARSE_CODE;

    ! Now we come to the question asked when the input has run out
    ! and can't easily be guessed (eg, the player typed "take" and there
    ! were plenty of things which might have been meant).

  .Incomplete;

    if (context == CREATURE_TOKEN) PARSER_CLARIF_INTERNAL_RM('D', actor);
    else                           PARSER_CLARIF_INTERNAL_RM('E', actor);
    new_line;

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
			VM_CopyBuffer(buffer, buffer2);
			jump RECONSTRUCT_INPUT;
		}

    first_word=(parse2-->1);
    #Ifdef LanguageIsVerb;
    if (first_word==0) {
        j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb

    ! Once again, if the reply looks like a command, give it to the
    ! parser to get on with and forget about the question...

    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! ...but if we have a genuine answer, then:
    !
    ! (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE) {
                PronounNotice(pattern-->j);
                for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
                    if (pattern-->j == LanguagePronouns-->(k+2)) {
                        parse2-->1 = LanguagePronouns-->k;
                        #Ifdef DEBUG;
                        if (parser_trace >= 5)
                        	print "[Using pronoun '", (address) parse2-->1, "']^";
                        #Endif; ! DEBUG
                        break;
                    }
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

    ! (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE

    jump RECONSTRUCT_INPUT;

]; ! end of NounDomain

[ PARSER_CLARIF_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Adjudicate
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Adjudicate context i j k good_ones last n ultimate flag offset;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }
        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed && n hasnt scenery) 
        {   good_ones++; last=n; }
        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }
    if (good_ones == 1) {
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0 &&
			context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
	        BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) &&
            	(RulebookFailed())) good_ones = 0;
	        EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
			if (good_ones == 1) return last;
		} else {
			return last;
		}
    }

    ! If there is ambiguity about what was typed, but it definitely wasn't
    ! animate as required, then return anything; higher up in the parser
    ! a suitable error will be given.  (This prevents a question being asked.)

    if (context == CREATURE_TOKEN && good_ones == 0) return match_list-->0;

    if (indef_mode == 0) indef_type=0;

    ScoreMatchL(context);
    if (number_matched == 0) return -1;

    if (indef_mode == 0) {
        !  Is there now a single highest-scoring object?
        i = SingleBestGuess();
        if (i >= 0) {

            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Single best-scoring object returned.]^";
            #Endif; ! DEBUG
            return i;
        }
    }

    if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
        if (context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
                     or MULTIINSIDE_TOKEN) {
            etype = MULTI_PE;
            return -1;
        }
        i = 0; offset = multiple_object-->0;
        for (j=BestGuess(): j~=-1 && i<indef_wanted && i+offset<MATCH_LIST_WORDS-1:
        	j=BestGuess()) {
            flag = 0;
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {
                if (j hasnt concealed && j hasnt worn) flag = 1;
                if (context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN && parent(j) ~= actor)
                    flag = 0;

                if (action_to_be == ##Take or ##Remove && parent(j) == actor)
                    flag = 0;

                k = ChooseObjects(j, flag);

                if (k == 1)
                    flag = 1;
                else {
                    if (k == 2) flag = 0;
                }
            } else {
                flag = 0; if (RulebookSucceeded()) flag = 1;
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if (flag == 1) {
                i++; multiple_object-->(i+offset) = j;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Accepting it^";
                #Endif; ! DEBUG
            }
            else {
                i = i;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Rejecting it^";
                #Endif; ! DEBUG
            }
        }
        if (i < indef_wanted && indef_wanted < INDEF_ALL_WANTED) {
            etype = TOOFEW_PE; multi_wanted = indef_wanted;
			 if (parser_trace >= 4) print "Too few found^";
            multi_had=i;
            return -1;
        }
        multiple_object-->0 = i+offset;
        multi_context = context;
        #Ifdef DEBUG;
        if (parser_trace >= 4)
            print "   Made multiple object of size ", i, "]^";
        #Endif; ! DEBUG
        return 1;
    }

    for (i=0 : i<number_matched : i++) match_classes-->i = 0;

    n = 1;
    for (i=0 : i<number_matched : i++)
        if (match_classes-->i == 0) {
            match_classes-->i = n++; flag = 0;
            for (j=i+1 : j<number_matched : j++)
                if (match_classes-->j == 0 && Identical(match_list-->i, match_list-->j) == 1) {
                    flag=1;
                    match_classes-->j = match_classes-->i;
                }
            if (flag == 1) match_classes-->i = 1-n;
        }
     n--; number_of_classes = n;

    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   Grouped into ", n, " possibilities by name:^";
        for (i=0 : i<number_matched : i++)
            if (match_classes-->i > 0)
                print "   ", (The) match_list-->i, " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
    }
    #Endif; ! DEBUG

    if (indef_mode == 0) {
        if (n > 1) {
            k = -1;
            for (i=0 : i<number_matched : i++) {
                if (match_scores-->i > k) {
                    k = match_scores-->i;
                    j = match_classes-->i; j = j*j;
                    flag = 0;
                }
                else
                    if (match_scores-->i == k) {
                        if ((match_classes-->i) * (match_classes-->i) ~= j)
                            flag = 1;
                    }
            }

        if (flag) {
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Unable to choose best group, so ask player.]^";
            #Endif; ! DEBUG
            return 0;
        }
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Best choices are all from the same group.^";
        #Endif; ! DEBUG
        }
    }

    !  When the player is really vague, or there's a single collection of
    !  indistinguishable objects to choose from, choose the one the player
    !  most recently acquired, or if the player has none of them, then
    !  the one most recently put where it is.

    if (n == 1) dont_infer = true;
    return BestGuess();

]; ! Adjudicate


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ReviseMulti
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj sn rv;
    if (token_filter ofclass Routine) {
    	sn = noun;
	    noun = obj;
    	rv = indirect(token_filter);
    	noun = sn;
    	return rv;
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScoreMatchL
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD

    for (i=0 : i<number_matched : i++) {
        obj = match_list-->i; its_owner = parent(obj); its_score=0; met=0;

        !      if (indef_type & OTHER_BIT ~= 0
        !          &&  obj ~= itobj or himobj or herobj) met++;
        if (indef_type & MY_BIT ~= 0 && its_owner == actor) met++;
        if (indef_type & THAT_BIT ~= 0 && its_owner == actors_location) met++;
        if (indef_type & LIT_BIT ~= 0 && obj has light) met++;
        if (indef_type & UNLIT_BIT ~= 0 && obj hasnt light) met++;
        if (indef_owner ~= 0 && its_owner == indef_owner) met++;

        if (met < threshold) {
            #Ifdef DEBUG;
            if (parser_trace >= 4)
            	print "   ", (The) match_list-->i, " (", match_list-->i, ") in ",
            	    (the) its_owner, " is rejected (doesn't match descriptors)^";
            #Endif; ! DEBUG
            match_list-->i = -1;
        }
        else {
            its_score = 0;
            if (obj hasnt concealed) its_score = SCORE__UNCONCEALED;

            if (its_owner == actor) its_score = its_score + a_s;
            else
                if (its_owner == actors_location) its_score = its_score + l_s;
                else
                    if (its_owner ~= compass) its_score = its_score + SCORE__NOTCOMPASS;

            its_score = its_score + SCORE__CHOOSEOBJ * ChooseObjects(obj, 2);

            if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
            if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

            !   A small bonus for having the correct GNA,
            !   for sorting out ambiguous articles and the like.

            if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
                its_score = its_score + SCORE__GNA;

            match_scores-->i = match_scores-->i + its_score;
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "     ", (The) match_list-->i, " (", match_list-->i,
              ") in ", (the) its_owner, " : ", match_scores-->i, " points^";
            #Endif; ! DEBUG
        }
     }

    for (i=0 : i<number_matched : i++) {
        while (match_list-->i == -1) {
            if (i == number_matched-1) { number_matched--; break; }
            for (j=i : j<number_matched-1 : j++) {
                match_list-->j = match_list-->(j+1);
                match_scores-->j = match_scores-->(j+1);
            }
            number_matched--;
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: BestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SingleBestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Identical
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Print Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { PARSER_CLARIF_INTERNAL_RM('F'); jump TokenPrinted; }
        if (i == 1) { PARSER_CLARIF_INTERNAL_RM('G'); jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: CantSee
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
		w = NextWordStopped(); wn--;
		if ((w == -1) || (line_token-->(pcount) ~= ENDIT_TOKEN)) {
			if (pcount > 0) AnalyseToken(line_token-->(pcount-1));
			if ((pcount > 0) && (found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT))
				e = NOTINCONTEXT_PE;
			else {
				pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
				e = ITGONE_PE;
			}
		}
    }
    
    if (etype > e) return etype;
    return e;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaceInScope O opts ws; ! If opts is set, do not place contents in scope
	ws = wn; wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	wn = ws; return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope Level 0
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SearchScope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScopeWithin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeActionAndRecurse
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeAction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Object Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MatchTextAgainstObject item i;
    if (token_filter ~= 0 && ConsultNounFilterToken(item) == 0) return;

	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryGivenObject
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Refers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: NounWord
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to THIRTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Gender
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetGender person;
    if (person hasnt female) rtrue;
    rfalse;
];

[ GetGNAOfObject obj case gender;
    if (obj hasnt animate) case = 6;
    if (obj has male) gender = male;
    if (obj has female) gender = female;
    if (obj has neuter) gender = neuter;
    if (gender == 0) {
        if (case == 0) gender = LanguageAnimateGender;
        else gender = LanguageInanimateGender;
    }
    if (gender == female)   case = case + 1;
    if (gender == neuter)   case = case + 2;
    if (obj has pluralname) case = case + 3;
    return case;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noticing Plurals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Pronoun Handling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(14);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ PronounNotice obj x bm g;
    if (obj == player) return;

	g = (GetGNAOfObject(obj));

    bm = PowersOfTwo_TB-->g;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (bm & (LanguagePronouns-->(x+1)) ~= 0)
            LanguagePronouns-->(x+2) = obj;

	if (((g % 6) < 3) && (obj has ambigpluralname)) {
		g = g + 3;
		bm = PowersOfTwo_TB-->g;
		for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
			if (bm & (LanguagePronouns-->(x+1)) ~= 0)
				LanguagePronouns-->(x+2) = obj;
	}
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Yes/No Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer2 parse2;
        else read buffer2 parse2 DrawStatusLine;
        j = parse2->1;
        #Ifnot; ! TARGET_GLULX;
        if (location ~= nothing && parent(player) ~= nothing) DrawStatusLine();
        KeyboardPrimitive(buffer2, parse2);
        j = parse2-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse2-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        YES_OR_NO_QUESTION_INTERNAL_RM('A'); print "> ";
    }
];

[ YES_OR_NO_QUESTION_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Number Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Choose Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant COBJ_DEBUG;

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(parser_results-->INP1_PRES, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple); parameters = ", parameters,
			" aw = ", advance_warning, "]^";
		#endif;
		@push action_to_be;
		if (parameters==0) {
			if (advance_warning > 0)
				l = ScoreDabCombo(obj, advance_warning);
			else
				l = ScoreDabCombo(obj, 0);
		} else {
			l = ScoreDabCombo(parser_results-->INP1_PRES, obj);
		}
		@pull action_to_be;
		return l;
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	spcount = pcount;
	while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
	if (line_ttype-->pcount == ELEMENTARY_TT) {
		if (line_tdata-->pcount == TOPIC_TOKEN) {
			pcount = spcount;
			jump CodeTwo;
		}
		while (wn <= num_words) {
			l = NextWordStopped(); wn--;
			if (l == THEN1__WD) break;
			if ( (l ~= -1 or 0) && (l->#dict_par1) &8 ) { wn++; continue; }	! if preposition
			if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) { wn++; continue; }
			SafeSkipDescriptors();
			! save the current match state
			@push match_length; @push token_filter; @push match_from;
			alt_match_list-->0 = number_matched;
			COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;
			token_filter = 0;
			SearchScope(actor, actors_location, line_tdata-->pcount);
			#ifdef COBJ_DEBUG;
			print number_matched, " possible second nouns]^";
			#endif;
			wn = swn;
			cobj_flag = 1;
			! restore match variables
			COBJ__SwapMatches();
			@pull match_from; @pull token_filter; @pull match_length;
			pcount = spcount;
			jump CodeOne;
		}
	}
	pcount = spcount;
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ ScoreDabCombo a b  result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = CheckDPMR();
	@pull second; @pull noun; @pull act_requester; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Default Topic
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Order of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Main
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global EarlyInTurnSequence;
Global IterationsOfTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ClearRTP();
	FollowRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
			IterationsOfTurnSequence++;
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Virtual Machine Startup Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VIRTUAL_MACHINE_STARTUP_R;
	CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
	VM_Initialise();
	print "^^^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initial Situation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> selfobj nothing I218_en_la_oscuridad 540 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initialise Memory Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	StackFramingInitialise(); ! Create an empty stack
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];

 
[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG
	if (0) VM_Seed_RNG(0);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Seed Random Number Generator Rule (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Position Player In Model World Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }
	else { real_location = location; SilentlyConsiderLight(); }

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Parse Command Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Treat Parser Results
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GENERATE_ACTION_R i;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) noun = nothing; else noun = inp1;
	if (inp2 == 1) second = nothing; else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) {
			if (actor == player) { GENERATE_ACTION_RM('B'); new_line; }
			return;
		}
		if (toomany_flag) {
			toomany_flag = false;
			if (actor == player) { GENERATE_ACTION_RM('A'); }
		}
		i = multiple_object-->0;
		FollowRulebook(MULTIPLE_ACTION_PROCESSING_RB);
		if ((multiple_object-->0 == 1) && (i > 1)) {
			multiflag = false;
			if (inp1 == 0) noun = multiple_object-->1;
			if ((inp2 == 0) && (parser_results-->NO_INPS_PRES >= 2))
				second = multiple_object-->1;
		}
		if (multiple_object-->0 == 0) rfalse;
	}
	
	if (multiflag) {
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Multiple Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) {
			if (player == actor) { ACTION_PROCESSING_INTERNAL_RM('J'); new_line; }
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Timed Events Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIMED_EVENTS_R i d event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				d = (the_time - event_timer + TWENTY_FOUR_HOURS) % TWENTY_FOUR_HOURS;
				if ((d >= 0) && (d < 30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				FollowRulebook(rule);
			}
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Time Of Day
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Advance Time Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Note Object Acquisitions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved;
    objectloop (obj has concealed)
    	if (IndirectlyContains(player, obj)) give obj ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Resurrect Player If Asked Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Ask The Final Question Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
		if (resurrect_please) rtrue;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Read The Final Answer Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restart VM Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTART_VM_R; @restart; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restore Saved Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Quit Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_QUIT_R; @quit; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Undo Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_UNDO_R; Perform_Undo(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Obituary Headline Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) PRINT_OBITUARY_HEADLINE_RM('A');
    if (deadflag == 2) PRINT_OBITUARY_HEADLINE_RM('B');
    if (deadflag == 3) PRINT_OBITUARY_HEADLINE_RM('C');
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORING; print "^"; #Endif;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Final Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_FINAL_SCORE_R;
	#Iftrue USE_SCORING ~= 0; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Display Final Status Line Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Properties
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant p3_list_grouping_key = list_together;
Constant p4_printed_name = short_name;
Constant p5_printed_plural_name = plural;
Constant p6_indefinite_article = article;
Constant p7_description = description;
Constant p8_map_region = map_region;
Constant p9_initial_appearance = initial;
Constant p11_other_side = door_to;
Constant p12_carrying_capacity = capacity;
Constant p13_matching_key = with_key;
Constant p28_plural_named = pluralname;
Constant p30_proper_named = proper;
Constant p32_ambiguously_plural = ambigpluralname;
Constant p33_privately_named = privately_named;
Constant p35_lighted = light;
Constant p37_visited = visited;
Constant p39_lit = light;
Constant p41_edible = edible;
Constant p43_fixed_in_place = static;
Constant p45_scenery = scenery;
Constant p46_wearable = clothing;
Constant p47_pushable_between_rooms = pushable;
Constant p48_handled = moved;
Constant p50_undescribed = concealed;
Constant p51_marked_for_listing = workflag;
Constant p53_mentioned = mentioned;
Constant p55_enterable = enterable;
Constant p57_transparent = transparent;
Constant p58_open = open;
Constant p60_openable = openable;
Constant p62_lockable = lockable;
Constant p63_locked = locked;
Constant p65_female = female;
Constant p67_neuter = neuter;
Constant p68_switched_on = on;
Constant p83 = vector;
Constant p84 = room_index;
Constant p85 = door_dir;
Constant p86 = door_to;
Constant p87 = absent;
Constant p88 = found_in;
Constant p89 = cap_short_name;
Constant p90 = mark_as_room;
Constant p91 = mark_as_thing;
Constant p92 = component_parent;
Constant p93 = component_child;
Constant p94 = component_sibling;
Constant p95 = regional_found_in;
Constant p96 = IK1_Count;
Constant p97 = IK1_Link;
Constant p98 = IK2_Count;
Constant p99 = IK2_Link;
Constant p100 = IK3_Count;
Constant p101 = IK3_Link;
Constant p102 = IK4_Count;
Constant p103 = IK4_Link;
Constant p104 = IK5_Count;
Constant p105 = IK5_Link;
Constant p106 = IK6_Count;
Constant p107 = IK6_Link;
Constant p108 = IK7_Count;
Constant p109 = IK7_Link;
Constant p110 = IK8_Count;
Constant p111 = IK8_Link;
Constant p112 = IK9_Count;
Constant p113 = IK9_Link;
Constant p114 = IK10_Count;
Constant p115 = IK10_Link;
Constant p116 = IK11_Count;
Constant p117 = IK11_Link;
Constant p118 = IK12_Count;
Constant p119 = IK12_Link;
Constant p120 = IK13_Count;
Constant p121 = IK13_Link;
Constant p122 = IK14_Count;
Constant p123 = IK14_Link;
Constant p124 = IK15_Count;
Constant p125 = IK15_Link;
Constant p126 = IK16_Count;
Constant p127 = IK16_Link;
Constant p128 = IK17_Count;
Constant p129 = IK17_Link;
Constant p130 = IK18_Count;
Constant p131 = IK18_Link;
Constant p132 = IK19_Count;
Constant p133 = IK19_Link;
Constant p134 = KD_Count;
Constant p135 = name;
Constant p136 = parse_name;
Constant p137 = action_bitmap;

Attribute p74_g_required;
Attribute p76_g_present;
Attribute p78_currently_being_processe;
Attribute p79_complacida;
Attribute p81_vivo;
Constant FBNA_PROP_NUMBER = p70_recurring;
Object property_numberspace_forcer
    with p70_recurring false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region NULL
    ! offset 10: property list_together
    "list grouping key" K1_room K2_thing K3_direction K9_region NULL
    ! offset 16: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 22: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 28: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region NULL
    ! offset 34: property description
    "description" K1_room K2_thing NULL
    ! offset 38: property map_region
    "map region" K1_room NULL
    ! offset 41: property initial
    "initial appearance" K2_thing NULL
    ! offset 44: property p10_opposite
    "opposite" K3_direction NULL
    ! offset 47: property door_to
    "other side" K4_door NULL
    ! offset 50: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 55: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 60: property p14_adaptive_text_viewpoint
    "adaptive text viewpoint" NULL
    ! offset 62: property p15_default_ask_quip
    "default ask quip" K8_person NULL
    ! offset 65: property p16_default_tell_quip
    "default tell quip" K8_person NULL
    ! offset 68: property p17_greeting
    "greeting" K8_person NULL
    ! offset 71: property p18_litany
    "litany" K8_person NULL
    ! offset 74: property p19_type
    "type" K16_g_window NULL
    ! offset 77: property p20_position
    "position" K16_g_window NULL
    ! offset 80: property p21_scale_method
    "scale method" K16_g_window NULL
    ! offset 83: property p22_measurement
    "measurement" K16_g_window NULL
    ! offset 86: property p23_minimum_size
    "minimum size" K16_g_window NULL
    ! offset 89: property p24_rock_number
    "rock number" K16_g_window NULL
    ! offset 92: property p25_ref_number
    "ref number" K16_g_window NULL
    ! offset 95: property p26_border_hint
    "border hint" K16_g_window NULL
    ! offset 98: property p27_background_color
    "background color" K16_g_window NULL
    ! offset 101: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 107: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 113: property ambigpluralname
    "ambiguously plural" K1_room K2_thing K3_direction K9_region NULL
    ! offset 119: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 125: property light
    "lighted" K1_room K2_thing NULL
    ! offset 129: property visited
    "visited" K1_room NULL
    ! offset 132: property light
    "lit" K1_room K2_thing NULL
    ! offset 136: property edible
    "edible" K2_thing NULL
    ! offset 139: property static
    "fixed in place" K2_thing NULL
    ! offset 142: property scenery
    "scenery" K2_thing NULL
    ! offset 145: property clothing
    "wearable" K2_thing NULL
    ! offset 148: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 151: property moved
    "handled" K2_thing NULL
    ! offset 154: property concealed
    "undescribed" K2_thing NULL
    ! offset 157: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 161: property mentioned
    "mentioned" K2_thing NULL
    ! offset 164: property enterable
    "enterable" K5_container K6_supporter NULL
    ! offset 168: property transparent
    "transparent" K5_container NULL
    ! offset 171: property open
    "open" K4_door K5_container NULL
    ! offset 175: property openable
    "openable" K4_door K5_container NULL
    ! offset 179: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 183: property locked
    "locked" K4_door K5_container NULL
    ! offset 187: property female
    "female" K1_room K2_thing K8_person I51_north I52_northeast I53_northwest I54_south I55_southeast I56_southwest I57_east I58_west I59_up I60_down in_obj out_obj NULL
    ! offset 204: property neuter
    "neuter" K8_person I200_main_window I201_status_window I202_quote_window I223_abismo I231_presencia NULL
    ! offset 212: property on
    "switched on" K13_device NULL
    ! offset 215: property p70_recurring
    "recurring" NULL
    ! offset 217: property p72_grammatical_gender
    "grammatical gender" K1_room K2_thing K3_direction K9_region NULL
    ! offset 223: property p73_quiptext
    "quiptext" NULL
    ! offset 225: property p74_g_required
    "g-required" K16_g_window NULL
    ! offset 228: property p76_g_present
    "g-present" K16_g_window NULL
    ! offset 231: property p78_currently_being_processe
    "currently being processed" K16_g_window NULL
    ! offset 234: property p79_complacida
    "complacida" I220_musa NULL
    ! offset 237: property p81_vivo
    "vivo" I270_mercader NULL
    ! offset 240: property vector
    "<nameless>" NULL
    ! offset 242: property room_index
    "<nameless>" NULL
    ! offset 244: property door_dir
    "<nameless>" NULL
    ! offset 246: property door_to
    "<nameless>" K4_door NULL
    ! offset 249: property absent
    "<nameless>" NULL
    ! offset 251: property found_in
    "<nameless>" NULL
    ! offset 253: property cap_short_name
    "<nameless>" NULL
    ! offset 255: property mark_as_room
    "<nameless>" NULL
    ! offset 257: property mark_as_thing
    "<nameless>" NULL
    ! offset 259: property component_parent
    "<nameless>" NULL
    ! offset 261: property component_child
    "<nameless>" NULL
    ! offset 263: property component_sibling
    "<nameless>" NULL
    ! offset 265: property regional_found_in
    "<nameless>" NULL
    ! offset 267: property IK1_Count
    "<nameless>" NULL
    ! offset 269: property IK1_Link
    "<nameless>" NULL
    ! offset 271: property IK2_Count
    "<nameless>" NULL
    ! offset 273: property IK2_Link
    "<nameless>" NULL
    ! offset 275: property IK3_Count
    "<nameless>" NULL
    ! offset 277: property IK3_Link
    "<nameless>" NULL
    ! offset 279: property IK4_Count
    "<nameless>" NULL
    ! offset 281: property IK4_Link
    "<nameless>" NULL
    ! offset 283: property IK5_Count
    "<nameless>" NULL
    ! offset 285: property IK5_Link
    "<nameless>" NULL
    ! offset 287: property IK6_Count
    "<nameless>" NULL
    ! offset 289: property IK6_Link
    "<nameless>" NULL
    ! offset 291: property IK7_Count
    "<nameless>" NULL
    ! offset 293: property IK7_Link
    "<nameless>" NULL
    ! offset 295: property IK8_Count
    "<nameless>" NULL
    ! offset 297: property IK8_Link
    "<nameless>" NULL
    ! offset 299: property IK9_Count
    "<nameless>" NULL
    ! offset 301: property IK9_Link
    "<nameless>" NULL
    ! offset 303: property IK10_Count
    "<nameless>" NULL
    ! offset 305: property IK10_Link
    "<nameless>" NULL
    ! offset 307: property IK11_Count
    "<nameless>" NULL
    ! offset 309: property IK11_Link
    "<nameless>" NULL
    ! offset 311: property IK12_Count
    "<nameless>" NULL
    ! offset 313: property IK12_Link
    "<nameless>" NULL
    ! offset 315: property IK13_Count
    "<nameless>" NULL
    ! offset 317: property IK13_Link
    "<nameless>" NULL
    ! offset 319: property IK14_Count
    "<nameless>" NULL
    ! offset 321: property IK14_Link
    "<nameless>" NULL
    ! offset 323: property IK15_Count
    "<nameless>" NULL
    ! offset 325: property IK15_Link
    "<nameless>" NULL
    ! offset 327: property IK16_Count
    "<nameless>" NULL
    ! offset 329: property IK16_Link
    "<nameless>" NULL
    ! offset 331: property IK17_Count
    "<nameless>" NULL
    ! offset 333: property IK17_Link
    "<nameless>" NULL
    ! offset 335: property IK18_Count
    "<nameless>" NULL
    ! offset 337: property IK18_Link
    "<nameless>" NULL
    ! offset 339: property IK19_Count
    "<nameless>" NULL
    ! offset 341: property IK19_Link
    "<nameless>" NULL
    ! offset 343: property KD_Count
    "<nameless>" NULL
    ! offset 345: property name
    "<nameless>" NULL
    ! offset 347: property parse_name
    "<nameless>" NULL
    ! offset 349: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 48;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 138 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets 
    i ! loop counter
    ;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->list_together = 10;
    valued_property_offsets-->short_name = 16;
    valued_property_offsets-->plural = 22;
    valued_property_offsets-->article = 28;
    valued_property_offsets-->description = 34;
    valued_property_offsets-->map_region = 38;
    valued_property_offsets-->initial = 41;
    valued_property_offsets-->p10_opposite = 44;
    valued_property_offsets-->door_to = 47;
    valued_property_offsets-->capacity = 50;
    valued_property_offsets-->with_key = 55;
    valued_property_offsets-->p14_adaptive_text_viewpoint = 60;
    valued_property_offsets-->p15_default_ask_quip = 62;
    valued_property_offsets-->p16_default_tell_quip = 65;
    valued_property_offsets-->p17_greeting = 68;
    valued_property_offsets-->p18_litany = 71;
    valued_property_offsets-->p19_type = 74;
    valued_property_offsets-->p20_position = 77;
    valued_property_offsets-->p21_scale_method = 80;
    valued_property_offsets-->p22_measurement = 83;
    valued_property_offsets-->p23_minimum_size = 86;
    valued_property_offsets-->p24_rock_number = 89;
    valued_property_offsets-->p25_ref_number = 92;
    valued_property_offsets-->p26_border_hint = 95;
    valued_property_offsets-->p27_background_color = 98;
    attributed_property_offsets-->pluralname = 101;
    attributed_property_offsets-->proper = 107;
    attributed_property_offsets-->ambigpluralname = 113;
    attributed_property_offsets-->privately_named = 119;
    attributed_property_offsets-->light = 125;
    attributed_property_offsets-->visited = 129;
    attributed_property_offsets-->light = 132;
    attributed_property_offsets-->edible = 136;
    attributed_property_offsets-->static = 139;
    attributed_property_offsets-->scenery = 142;
    attributed_property_offsets-->clothing = 145;
    attributed_property_offsets-->pushable = 148;
    attributed_property_offsets-->moved = 151;
    attributed_property_offsets-->concealed = 154;
    attributed_property_offsets-->workflag = 157;
    attributed_property_offsets-->mentioned = 161;
    attributed_property_offsets-->enterable = 164;
    attributed_property_offsets-->transparent = 168;
    attributed_property_offsets-->open = 171;
    attributed_property_offsets-->openable = 175;
    attributed_property_offsets-->lockable = 179;
    attributed_property_offsets-->locked = 183;
    attributed_property_offsets-->female = 187;
    attributed_property_offsets-->neuter = 204;
    attributed_property_offsets-->on = 212;
    valued_property_offsets-->p70_recurring = 215;
    valued_property_offsets-->p72_grammatical_gender = 217;
    valued_property_offsets-->p73_quiptext = 223;
    attributed_property_offsets-->p74_g_required = 225;
    attributed_property_offsets-->p76_g_present = 228;
    attributed_property_offsets-->p78_currently_being_processe = 231;
    attributed_property_offsets-->p79_complacida = 234;
    attributed_property_offsets-->p81_vivo = 237;
    valued_property_offsets-->vector = 240;
    valued_property_offsets-->room_index = 242;
    valued_property_offsets-->door_dir = 244;
    valued_property_offsets-->door_to = 246;
    attributed_property_offsets-->absent = 249;
    valued_property_offsets-->found_in = 251;
    valued_property_offsets-->cap_short_name = 253;
    attributed_property_offsets-->mark_as_room = 255;
    attributed_property_offsets-->mark_as_thing = 257;
    valued_property_offsets-->component_parent = 259;
    valued_property_offsets-->component_child = 261;
    valued_property_offsets-->component_sibling = 263;
    valued_property_offsets-->regional_found_in = 265;
    valued_property_offsets-->IK1_Count = 267;
    valued_property_offsets-->IK1_Link = 269;
    valued_property_offsets-->IK2_Count = 271;
    valued_property_offsets-->IK2_Link = 273;
    valued_property_offsets-->IK3_Count = 275;
    valued_property_offsets-->IK3_Link = 277;
    valued_property_offsets-->IK4_Count = 279;
    valued_property_offsets-->IK4_Link = 281;
    valued_property_offsets-->IK5_Count = 283;
    valued_property_offsets-->IK5_Link = 285;
    valued_property_offsets-->IK6_Count = 287;
    valued_property_offsets-->IK6_Link = 289;
    valued_property_offsets-->IK7_Count = 291;
    valued_property_offsets-->IK7_Link = 293;
    valued_property_offsets-->IK8_Count = 295;
    valued_property_offsets-->IK8_Link = 297;
    valued_property_offsets-->IK9_Count = 299;
    valued_property_offsets-->IK9_Link = 301;
    valued_property_offsets-->IK10_Count = 303;
    valued_property_offsets-->IK10_Link = 305;
    valued_property_offsets-->IK11_Count = 307;
    valued_property_offsets-->IK11_Link = 309;
    valued_property_offsets-->IK12_Count = 311;
    valued_property_offsets-->IK12_Link = 313;
    valued_property_offsets-->IK13_Count = 315;
    valued_property_offsets-->IK13_Link = 317;
    valued_property_offsets-->IK14_Count = 319;
    valued_property_offsets-->IK14_Link = 321;
    valued_property_offsets-->IK15_Count = 323;
    valued_property_offsets-->IK15_Link = 325;
    valued_property_offsets-->IK16_Count = 327;
    valued_property_offsets-->IK16_Link = 329;
    valued_property_offsets-->IK17_Count = 331;
    valued_property_offsets-->IK17_Link = 333;
    valued_property_offsets-->IK18_Count = 335;
    valued_property_offsets-->IK18_Link = 337;
    valued_property_offsets-->IK19_Count = 339;
    valued_property_offsets-->IK19_Link = 341;
    valued_property_offsets-->KD_Count = 343;
    valued_property_offsets-->name = 345;
    valued_property_offsets-->parse_name = 347;
    valued_property_offsets-->action_bitmap = 349;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUMBER_RULEBOOKS_CREATED = 451;
Constant V0_printing_the_name = 0;
Constant V1_printing_the_plural_name = 1;
Constant V2_printing_a_number = 2;
Constant V3_printing_room_description = 3;
Constant V4_printing_inventory_detail = 4;
Constant V5_listing_contents = 5;
Constant V6_grouping_together = 6;
Constant V7_writing_a_paragraph_about = 7;
Constant V8_listing_nondescript_items = 8;
Constant V9_printing_the_name_of_a_da = 9;
Constant V10_printing_the_description = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_the_announcemen = 12;
Constant V13_printing_a_refusal_to_ac = 13;
Constant V14_constructing_the_status_ = 14;
Constant V15_printing_the_banner_text = 15;
Constant V16_reading_a_command = 16;
Constant V17_deciding_the_scope = 17;
Constant V18_deciding_the_concealed_p = 18;
Constant V19_deciding_whether_all_inc = 19;
Constant V20_clarifying_the_parser_s_ = 20;
Constant V21_asking_which_do_you_mean = 21;
Constant V22_printing_a_parser_error = 22;
Constant V23_supplying_a_missing_noun = 23;
Constant V24_supplying_a_missing_seco = 24;
Constant V25_implicitly_taking = 25;
Constant V26_starting_the_virtual_mac = 26;
Constant V27_amusing_a_victorious_pla = 27;
Constant V28_printing_the_player_s_ob = 28;
Constant V29_handling_the_final_quest = 29;
Constant V30_printing_the_locale_desc = 30;
Constant V31_choosing_notable_locale_ = 31;
Constant V32_printing_a_locale_paragr = 32;
Constant V33_issuing_the_response_tex = 33;
Constant V34_pausing_the_game = 34;
Constant V35_displaying = 35;
Constant V36_quipping = 36;
Constant V37_constructing = 37;
Constant V38_deconstructing = 38;
Constant V39_refreshing = 39;

Array Activity_before_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 125 128 371 374 380 418 421 424 NULL;

Array Activity_for_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 126 129 372 375 381 419 422 425 NULL;

Array Activity_after_rulebooks --> 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 127 130 373 376 382 420 423 426 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ff;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSceneName 
    value ! Implied call parameter
    ;
    switch(value) {
        I78_entire_game: print "Entire Game";
        default: print "<illegal scene>";
    }
];
[ A_PrintSceneName 
    value ! Implied call parameter
    ;
    return (value % 1)+1;
];
[ B_PrintSceneName 
    value ! Implied call parameter
    ;
    return ((value+-1) % 1)+1;
];
[ R_PrintSceneName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(1));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName 
    value ! Implied call parameter
    ;
    switch(value) {
        I77_figure_of_cover: print "Figure of cover";
        I203_figure_portada: print "Figure portada";
        I204_figure_musa: print "Figure Musa";
        I205_figure_musa_esperando: print "Figure Musa esperando";
        I206_figure_musa_riendo: print "Figure Musa riendo";
        I207_figure_musa_vigilante: print "Figure Musa vigilante";
        I208_figure_musa_llorando: print "Figure Musa llorando";
        I209_figure_pastor: print "Figure Pastor";
        I210_figure_soldado: print "Figure Soldado";
        I211_figure_reo: print "Figure Reo";
        I212_figure_doncella: print "Figure Doncella";
        I213_figure_mercader: print "Figure Mercader";
        I214_figure_cultista: print "Figure Cultista";
        default: print "<illegal figure name>";
    }
];
[ A_PrintFigureName 
    value ! Implied call parameter
    ;
    return (value % 13)+1;
];
[ B_PrintFigureName 
    value ! Implied call parameter
    ;
    return ((value+11) % 13)+1;
];
[ R_PrintFigureName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(13));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName 
    value ! Implied call parameter
    ;
    switch(value) {
        I215_sound_of_ending: print "Sound of ending";
        I216_sound_of_atmosphere: print "Sound of atmosphere";
        I217_sound_of_start: print "Sound of start";
        default: print "<illegal sound name>";
    }
];
[ A_PrintSoundName 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_PrintSoundName 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_PrintSoundName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName 
    value ! Implied call parameter
    ;
    switch(value) {
        default: print "<illegal external file>";
    }
];
[ A_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return (value % 0)+1;
];
[ B_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E61 
    value ! Implied call parameter
    ;
    switch(value) {
        I71_english_language: print "English language";
        I72_french_language: print "French language";
        I73_german_language: print "German language";
        I74_italian_language: print "Italian language";
        I75_spanish_language: print "Spanish language";
        I76_swedish_language: print "Swedish language";
        default: print "<illegal natural language>";
    }
];
[ A_E61 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_E61 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_E61 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E62 
    value ! Implied call parameter
    ;
    switch(value) {
        I80_didn_t_understand_error: print "didn't understand error";
        I81_only_understood_as_far_a: print "only understood as far as error";
        I82_didn_t_understand_that_n: print "didn't understand that number error";
        I83_can_only_do_that_to_some: print "can only do that to something animate error";
        I84_can_t_see_any_such_thing: print "can't see any such thing error";
        I85_said_too_little_error: print "said too little error";
        I86_aren_t_holding_that_erro: print "aren't holding that error";
        I87_can_t_use_multiple_objec: print "can't use multiple objects error";
        I88_can_only_use_multiple_ob: print "can only use multiple objects error";
        I89_not_sure_what_it_refers_: print "not sure what it refers to error";
        I90_excepted_something_not_i: print "excepted something not included error";
        I91_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        I92_not_something_you_need_t: print "not something you need to refer to error";
        I93_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        I94_didn_t_understand_the_wa: print "didn't understand the way that finished error";
        I95_not_enough_of_those_avai: print "not enough of those available error";
        I96_nothing_to_do_error: print "nothing to do error";
        I97_noun_did_not_make_sense_: print "noun did not make sense in that context error";
        I98_referred_to_a_determinat: print "referred to a determination of scope error";
        I99_i_beg_your_pardon_error: print "I beg your pardon error";
        I100_can_t_again_the_address: print "can't again the addressee error";
        I101_comma_can_t_begin_error: print "comma can't begin error";
        I102_can_t_see_whom_to_talk_: print "can't see whom to talk to error";
        I103_can_t_talk_to_inanimate: print "can't talk to inanimate things error";
        I104_didn_t_understand_addre: print "didn't understand addressee's last name error";
        default: print "<illegal command parser error>";
    }
];
[ A_E62 
    value ! Implied call parameter
    ;
    return (value % 25)+1;
];
[ B_E62 
    value ! Implied call parameter
    ;
    return ((value+23) % 25)+1;
];
[ R_E62 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(25));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E63 
    value ! Implied call parameter
    ;
    switch(value) {
        I106_present_tense: print "present tense";
        I107_past_tense: print "past tense";
        I108_perfect_tense: print "perfect tense";
        I109_past_perfect_tense: print "past perfect tense";
        I110_future_tense: print "future tense";
        default: print "<illegal grammatical tense>";
    }
];
[ A_E63 
    value ! Implied call parameter
    ;
    return (value % 5)+1;
];
[ B_E63 
    value ! Implied call parameter
    ;
    return ((value+3) % 5)+1;
];
[ R_E63 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E64 
    value ! Implied call parameter
    ;
    switch(value) {
        I112_first_person_singular: print "first person singular";
        I113_second_person_singular: print "second person singular";
        I114_third_person_singular: print "third person singular";
        I115_first_person_plural: print "first person plural";
        I116_second_person_plural: print "second person plural";
        I117_third_person_plural: print "third person plural";
        default: print "<illegal narrative viewpoint>";
    }
];
[ A_E64 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_E64 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_E64 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E65 
    value ! Implied call parameter
    ;
    switch(value) {
        I119_nominative: print "nominative";
        I120_accusative: print "accusative";
        default: print "<illegal grammatical case>";
    }
];
[ A_E65 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E65 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E65 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E66 
    value ! Implied call parameter
    ;
    switch(value) {
        I122_neuter_gender: print "neuter gender";
        I123_masculine_gender: print "masculine gender";
        I124_feminine_gender: print "feminine gender";
        default: print "<illegal grammatical gender>";
    }
];
[ A_E66 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E66 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E66 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E67 
    value ! Implied call parameter
    ;
    switch(value) {
        I126_all_styles: print "all-styles";
        I127_normal_style: print "normal-style";
        I128_italic_style: print "italic-style";
        I129_fixed_letter_spacing_st: print "fixed-letter-spacing-style";
        I130_header_style: print "header-style";
        I131_bold_style: print "bold-style";
        I132_alert_style: print "alert-style";
        I133_note_style: print "note-style";
        I134_blockquote_style: print "blockquote-style";
        I135_input_style: print "input-style";
        I136_special_style_1: print "special-style-1";
        I137_special_style_2: print "special-style-2";
        default: print "<illegal glulx text style>";
    }
];
[ A_E67 
    value ! Implied call parameter
    ;
    return (value % 12)+1;
];
[ B_E67 
    value ! Implied call parameter
    ;
    return ((value+10) % 12)+1;
];
[ R_E67 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(12));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E68 
    value ! Implied call parameter
    ;
    switch(value) {
        I139_left_justified: print "left-justified";
        I140_left_right_justified: print "left-right-justified";
        I141_center_justified: print "center-justified";
        I142_right_justified: print "right-justified";
        default: print "<illegal text justification>";
    }
];
[ A_E68 
    value ! Implied call parameter
    ;
    return (value % 4)+1;
];
[ B_E68 
    value ! Implied call parameter
    ;
    return ((value+2) % 4)+1;
];
[ R_E68 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(4));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E69 
    value ! Implied call parameter
    ;
    switch(value) {
        I144_light_weight: print "light-weight";
        I145_regular_weight: print "regular-weight";
        I146_bold_weight: print "bold-weight";
        default: print "<illegal font weight>";
    }
];
[ A_E69 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E69 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E69 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E70 
    value ! Implied call parameter
    ;
    switch(value) {
        I148_brief: print "brief";
        I149_verbose: print "verbose";
        I150_superbrief: print "superbrief";
        default: print "<illegal verbosity>";
    }
];
[ A_E70 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E70 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E70 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E71 
    value ! Implied call parameter
    ;
    switch(value) {
        I152_quip_null: print "quip_null";
        I153_quip_dtell: print "quip_dtell";
        I154_escucha_pastor: print "escucha-pastor";
        I155_ayuda_pastor: print "ayuda-pastor";
        I156_hola_pastor: print "hola-pastor";
        I157_tu_crimen: print "tu-crimen";
        I158_azotadle: print "azotadle";
        I159_hambriento: print "hambriento";
        I160_espada_buena: print "espada-buena";
        I161_sufrimiento: print "sufrimiento";
        I162_palabras: print "palabras";
        I163_deja_ya: print "deja-ya";
        I164_buenas_noches: print "buenas-noches";
        I165_cabello_hermoso: print "cabello-hermoso";
        I166_mi_ofrenda: print "mi-ofrenda";
        I167_ternero_hermano: print "ternero-hermano";
        I168_hola_hermano: print "hola-hermano";
        default: print "<illegal quip>";
    }
];
[ A_E71 
    value ! Implied call parameter
    ;
    return (value % 17)+1;
];
[ B_E71 
    value ! Implied call parameter
    ;
    return ((value+15) % 17)+1;
];
[ R_E71 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(17));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E72 
    value ! Implied call parameter
    ;
    switch(value) {
        I170_timer_event: print "timer-event";
        I171_char_event: print "char-event";
        I172_line_event: print "line-event";
        I173_mouse_event: print "mouse-event";
        I174_arrange_event: print "arrange-event";
        I175_redraw_event: print "redraw-event";
        I176_sound_notify_event: print "sound-notify-event";
        I177_hyperlink_event: print "hyperlink-event";
        I178_volume_event: print "volume-event";
        default: print "<illegal g-event>";
    }
];
[ A_E72 
    value ! Implied call parameter
    ;
    return (value % 9)+1;
];
[ B_E72 
    value ! Implied call parameter
    ;
    return ((value+7) % 9)+1;
];
[ R_E72 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(9));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E74 
    value ! Implied call parameter
    ;
    switch(value) {
        I181_g_text_buffer: print "g-text-buffer";
        I182_g_text_grid: print "g-text-grid";
        I183_g_graphics: print "g-graphics";
        default: print "<illegal g-window type>";
    }
];
[ A_E74 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E74 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E74 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E78 
    value ! Implied call parameter
    ;
    switch(value) {
        I188_g_placenull: print "g-placenull";
        I189_g_placeleft: print "g-placeleft";
        I190_g_placeright: print "g-placeright";
        I191_g_placeabove: print "g-placeabove";
        I192_g_placebelow: print "g-placebelow";
        default: print "<illegal g-window position>";
    }
];
[ A_E78 
    value ! Implied call parameter
    ;
    return (value % 5)+1;
];
[ B_E78 
    value ! Implied call parameter
    ;
    return ((value+3) % 5)+1;
];
[ R_E78 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E79 
    value ! Implied call parameter
    ;
    switch(value) {
        I194_g_proportional: print "g-proportional";
        I195_g_fixed_size: print "g-fixed-size";
        I196_g_using_minimum: print "g-using-minimum";
        default: print "<illegal g-window scale method>";
    }
];
[ A_E79 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E79 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E79 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair 
    k ! Implied call parameter
    v ! Implied call parameter
    ;
    k = KindAtomic(k);
      switch(k) {
        2: print (DA_Number) v;
        3: print (DA_Number) v;
        4: print (DA_Number) v;
        5: print (DA_Number) v;
        6: print (DA_Number) v;
        7: print (DA_Number) v;
        8: print (DA_Number) v;
        9: print (DA_Number) v;
        10: print (PrintShortName) v;
        11: print (DecimalNumber) v;
        12: print (REAL_NUMBER_TY_Say) v;
        13: print (DA_TruthState) v;
        14: print (TEXT_TY_Say) v;
        15: print (DecimalNumber) v;
        16: print (PrintUseOption) v;
        17: print (PrintResponse) v;
        18: print (PrintVerbAsValue) v;
        19: print (PrintSnippet) v;
        20: print (PrintTableName) v;
        21: print (DA_Number) v;
        22: print (RulebookOutcomePrintingRule) v;
        23: print (DecimalNumber) v;
        25: print (DecimalNumber) v;
        27: print (SayPhraseName) v;
        28: print (DecimalNumber) v;
        29: print (DecimalNumber) v;
        30: print (RELATION_TY_Say) v;
        31: print (RulePrintingRule) v;
        32: print (RulePrintingRule) v;
        33: print (DecimalNumber) v;
        34: print (LIST_OF_TY_Say) v;
        35: print (DecimalNumber) v;
        36: print (PROPERTY_TY_Say) v;
        37: print (DecimalNumber) v;
        38: print (COMBINATION_TY_Say) v;
        39: print (DecimalNumber) v;
        40: print (STORED_ACTION_TY_Say) v;
        41: print (SayActionName) v;
        42: print (PrintTimeOfDay) v;
        43: print (PrintSceneName) v;
        44: print (PrintFigureName) v;
        45: print (PrintSoundName) v;
        46: print (PrintExternalFileName) v;
        47: print (E61) v;
        48: print (E62) v;
        49: print (E63) v;
        50: print (E64) v;
        51: print (E65) v;
        52: print (E66) v;
        53: print (E67) v;
        54: print (E68) v;
        55: print (E69) v;
        56: print (E70) v;
        57: print (E71) v;
        58: print (E72) v;
        59: print (E74) v;
        60: print (E78) v;
        61: print (E79) v;
        default: print v;
    }
];
[ DefaultValueOfKOV 
    sk ! Implied call parameter
    k ! weak kind ID
    ;
    k = KindAtomic(sk);
    switch(k) {
        10: return nothing;
        11: return 0;
        12: return 0;
        13: return false;
        14: return BlkValueCreate(sk);
        15: return 32;
        16: return 0;
        17: return 0;
        18: return ConjugateVerb_0;
        19: return 101;
        20: return TheEmptyTable;
        21: return 0;
        22: return RBNO_0;
        23: return DefaultTopic;
        25: return ;
        34: return BlkValueCreate(sk);
        39: return ;
        40: return BlkValueCreate(sk);
        41: return ##Wait;
        42: return 540;
        43: return I78_entire_game;
        44: return I77_figure_of_cover;
        45: return I215_sound_of_ending;
        46: return ;
        47: return I71_english_language;
        48: return I80_didn_t_understand_error;
        49: return I106_present_tense;
        50: return I112_first_person_singular;
        51: return I119_nominative;
        52: return I122_neuter_gender;
        53: return I126_all_styles;
        54: return I139_left_justified;
        55: return I144_light_weight;
        56: return I148_brief;
        57: return I152_quip_null;
        58: return I170_timer_event;
        59: return I181_g_text_buffer;
        60: return I188_g_placenull;
        61: return I194_g_proportional;
        default: return 0;
    }
];
[ KOVComparisonFunction 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        10: return UnsignedCompare;
        12: return REAL_NUMBER_TY_Compare;
        13: return UnsignedCompare;
        14: return BlkValueCompare;
        15: return UnsignedCompare;
        16: return UnsignedCompare;
        17: return UnsignedCompare;
        18: return UnsignedCompare;
        19: return UnsignedCompare;
        20: return UnsignedCompare;
        21: return UnsignedCompare;
        22: return UnsignedCompare;
        23: return UnsignedCompare;
        25: return UnsignedCompare;
        34: return BlkValueCompare;
        39: return UnsignedCompare;
        40: return BlkValueCompare;
        41: return UnsignedCompare;
        43: return UnsignedCompare;
        44: return UnsignedCompare;
        45: return UnsignedCompare;
        46: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        43: return 1;
        44: return 13;
        45: return 3;
        46: return 0;
        47: return 6;
        48: return 25;
        49: return 5;
        50: return 6;
        51: return 2;
        52: return 3;
        53: return 12;
        54: return 4;
        55: return 3;
        56: return 3;
        57: return 17;
        58: return 9;
        59: return 3;
        60: return 5;
        61: return 3;
        default: return 0;
    }
];
[ KOVIsBlockValue 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    if (k == 14 or 30 or 34 or 38 or 40) rtrue;
    rfalse;
];
[ KOVSupportFunction 
    k ! Implied call parameter
    fail ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        14: return TEXT_TY_Support;
        30: return RELATION_TY_Support;
        34: return LIST_OF_TY_Support;
        38: return COMBINATION_TY_Support;
        40: return STORED_ACTION_TY_Support;
    }
    if (fail) BlkValueError(fail);
    rfalse;
];

[ I7_Kind_Name 
    k ! Implied call parameter
    ;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K10_man) print "man";
    if (k == K11_woman) print "woman";
    if (k == K12_animal) print "animal";
    if (k == K13_device) print "device";
    if (k == K14_vehicle) print "vehicle";
    if (k == K15_player_s_holdall) print "player's holdall";
    if (k == K16_g_window) print "g-window";
    if (k == K17_graphics_g_window) print "graphics g-window";
    if (k == K18_text_buffer_g_window) print "text buffer g-window";
    if (k == K19_text_grid_g_window) print "text grid g-window";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
Constant RBNO_13 = "replace player input";
Constant RBNO_14 = "require input to continue";
[ RulebookOutcomePrintingRule 
    rbno ! Implied call parameter
    ;
    if (rbno == 0) print "(no outcome)";
    else print (string) rbno; rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K10_man (8) K11_woman (8) K12_animal (8) K13_device (2) K14_vehicle (5) K15_player_s_holdall (5) K16_g_window (5) K17_graphics_g_window (16) K18_text_buffer_g_window (16) K19_text_grid_g_window (16) ;
Constant IK1_First = I218_en_la_oscuridad;
Constant IK2_First = selfobj;
Constant IK3_First = I51_north;
Constant IK4_First = nothing;
Constant IK5_First = I197_all_windows;
Constant IK6_First = nothing;
Constant IK7_First = I231_presencia;
Constant IK8_First = selfobj;
Constant IK9_First = I223_abismo;
Constant IK10_First = I234_pastor;
Constant IK11_First = I220_musa;
Constant IK12_First = nothing;
Constant IK13_First = nothing;
Constant IK14_First = nothing;
Constant IK15_First = nothing;
Constant IK16_First = I197_all_windows;
Constant IK17_First = nothing;
Constant IK18_First = I200_main_window;
Constant IK19_First = I201_status_window;
Constant No_Directions = 12;
! Table of direction object alias constants:
Constant DirectionObject_0 = I51_north;
Constant DirectionObject_1 = I52_northeast;
Constant DirectionObject_2 = I53_northwest;
Constant DirectionObject_3 = I54_south;
Constant DirectionObject_4 = I55_southeast;
Constant DirectionObject_5 = I56_southwest;
Constant DirectionObject_6 = I57_east;
Constant DirectionObject_7 = I58_west;
Constant DirectionObject_8 = I59_up;
Constant DirectionObject_9 = I60_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Array Map_Storage -->
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I218_en_la_oscuridad
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I224_primer_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I225_segundo_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I226_tercer_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I227_cuarto_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I228_quinto_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I229_sexto_acto
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I230_septimo_acto
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_43 0 0 0 ValuePropertyHolder_47 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_57 0 0 0 0 ;
VPH_Class ValuePropertyHolder_43
    with value_range 1
    with p70_recurring KOVP_43_P70
    with description KOVP_43_P7
;
! Storage for property p70_recurring of kind SCENE_TY
Array KOVP_43_P70 table 0 0 (true) ;
! Storage for property description of kind SCENE_TY
Array KOVP_43_P7 table 0 0 (BC_3) ;
VPH_Class ValuePropertyHolder_47
    with value_range 6
    with p14_adaptive_text_viewpoint KOVP_47_P14
;
! Storage for property p14_adaptive_text_viewpoint of kind 
Array KOVP_47_P14 table 0 0 (I115_first_person_plural) (I112_first_person_singular) (I112_first_person_singular) (I112_first_person_singular) (I113_second_person_singular) (I112_first_person_singular) ;
VPH_Class ValuePropertyHolder_57
    with value_range 17
    with p73_quiptext tab_17_1
;
! Storage for property p73_quiptext of kind 
Array KOVP_57_P73 table 0 0 (BC_4) (BC_5) (BC_6) (BC_7) (BC_8) (BC_9) (BC_10) (BC_11) (BC_12) (BC_13) (BC_14) (BC_15) (BC_16) (BC_17) (BC_18) (BC_19) (BC_20) ;
Class K0_kind 
    has ~pluralname
    has ~proper
    with p72_grammatical_gender I123_masculine_gender
    with list_together BC_21
    with short_name BC_22
    with plural BC_23
    with article BC_24
    has ~ambigpluralname
;

Class K1_room 
    class K0_kind
    with description BC_25
    with map_region nothing
    has ~privately_named
    has light
    has ~visited
    has ~female
    with list_together BC_26
    with short_name BC_27
    with plural BC_28
    with article BC_29
;

Class K2_thing 
    class K0_kind
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with action_bitmap 0 0 0 0 0 0 
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description BC_30
    with initial BC_31
    with with_key nothing
    has ~female
    with list_together BC_32
    with short_name BC_33
    with plural BC_34
    with article BC_35
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    with plural BC_36
    with capacity 100
    has static
    has ~enterable
    with description BC_37
    with initial BC_38
    with list_together BC_39
    with short_name BC_40
    with article BC_41
;

Class K8_person 
    class K2_thing

    	has transparent animate
    	with before NULL,

    with plural BC_42
    with capacity 100
    with p15_default_ask_quip I152_quip_null
    with p16_default_tell_quip I153_quip_dtell
    with p17_greeting I152_quip_null
    with p18_litany T21_no_conversation
    has ~female
    has ~neuter
    with description BC_43
    with initial BC_44
    with list_together BC_45
    with short_name BC_46
    with article BC_47
;

Class K10_man 
    class K8_person
    with plural BC_48
    has ~female
    has ~neuter
    with description BC_49
    with initial BC_50
    with list_together BC_51
    with short_name BC_52
    with article BC_53
;

Class K11_woman 
    class K8_person
    with plural BC_54
    has female
    has ~neuter
    with p72_grammatical_gender I124_feminine_gender
    with description BC_55
    with initial BC_56
    with list_together BC_57
    with short_name BC_58
    with article BC_59
;

Class K12_animal 
    class K8_person
    with plural BC_60
    with description BC_61
    with initial BC_62
    with list_together BC_63
    with short_name BC_64
    with article BC_65
;

Class K4_door 
    class K2_thing
     has door, 
    with plural BC_66
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to nothing
    with with_key nothing
    with description BC_67
    with initial BC_68
    with list_together BC_69
    with short_name BC_70
    with article BC_71
;

Class K5_container 
    class K2_thing
     has container, 
    with plural BC_72
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key nothing
    with description BC_73
    with initial BC_74
    with list_together BC_75
    with short_name BC_76
    with article BC_77
;

Class K14_vehicle 
    class K5_container
    with plural BC_78
    has static
    has enterable
    with description BC_79
    with initial BC_80
    with list_together BC_81
    with short_name BC_82
    with article BC_83
;

Class K15_player_s_holdall 
    class K5_container
    with plural BC_84
    has ~static
    has openable
    with description BC_85
    with initial BC_86
    with list_together BC_87
    with short_name BC_88
    with article BC_89
;

Class K16_g_window 
    class K5_container
    with plural BC_90
    with p22_measurement 40
    with p26_border_hint 1
    has ~p74_g_required
    has ~p76_g_present
    with p19_type I181_g_text_buffer
    with p20_position I188_g_placenull
    with p21_scale_method I194_g_proportional
    with p23_minimum_size 0
    with p24_rock_number 0
    with p25_ref_number 0
    has ~p78_currently_being_processe
    with p27_background_color BC_91
    with description BC_92
    with initial BC_93
    with list_together BC_94
    with short_name BC_95
    with article BC_96
;

Class K17_graphics_g_window 
    class K16_g_window
    with plural BC_97
    with p19_type I183_g_graphics
    with p27_background_color BC_98
    with description BC_99
    with initial BC_100
    with list_together BC_101
    with short_name BC_102
    with article BC_103
;

Class K18_text_buffer_g_window 
    class K16_g_window
    with plural BC_104
    with p19_type I181_g_text_buffer
    with p27_background_color BC_105
    with description BC_106
    with initial BC_107
    with list_together BC_108
    with short_name BC_109
    with article BC_110
;

Class K19_text_grid_g_window 
    class K16_g_window
    with plural BC_111
    with p19_type I182_g_text_grid
    with p27_background_color BC_112
    with description BC_113
    with initial BC_114
    with list_together BC_115
    with short_name BC_116
    with article BC_117
;

Class K7_backdrop 
    class K2_thing
    with plural BC_118
    has static
    has scenery
    has ~pushable
    with parse_name Parse_Name_GV256
    with description BC_119
    with initial BC_120
    with list_together BC_121
    with short_name BC_122
    with article BC_123
;

Class K13_device 
    class K2_thing
     has switchable, 
    with plural BC_124
    has ~on
    with description BC_125
    with initial BC_126
    with list_together BC_127
    with short_name BC_128
    with article BC_129
;

Class K9_region 
    class K0_kind
    with plural BC_130
    has ~privately_named
    with list_together BC_131
    with short_name BC_132
    with article BC_133
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    with plural BC_134
    has ~privately_named
    has ~workflag
    with p10_opposite I51_north
    with list_together BC_135
    with short_name BC_136
    with article BC_137
;

Object I51_north "" Compass
    class K3_direction
    with short_name BC_138
    with article BC_139
    with p10_opposite I54_south
    has ~female
    with vector 0
    with IK3_Count 0
    with IK3_Link I52_northeast
    with KD_Count 3
    with name 'norte' 'direcciones//p' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_140
    with plural BC_141
;

Object I52_northeast "" Compass
    class K3_direction
    with short_name BC_142
    with article BC_143
    with p10_opposite I56_southwest
    has ~female
    with vector 0
    with IK3_Count 1
    with IK3_Link I53_northwest
    with KD_Count 3
    with name 'noreste' 'direcciones//p' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_144
    with plural BC_145
;

Object I53_northwest "" Compass
    class K3_direction
    with short_name BC_146
    with article BC_147
    with p10_opposite I55_southeast
    has ~female
    with vector 0
    with IK3_Count 2
    with IK3_Link I54_south
    with KD_Count 3
    with name 'noroeste' 'direcciones//p' 'nw' 'no' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_148
    with plural BC_149
;

Object I54_south "" Compass
    class K3_direction
    with short_name BC_150
    with article BC_151
    with p10_opposite I51_north
    has ~female
    with vector 0
    with IK3_Count 3
    with IK3_Link I55_southeast
    with KD_Count 3
    with name 'sur' 'direcciones//p' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_152
    with plural BC_153
;

Object I55_southeast "" Compass
    class K3_direction
    with short_name BC_154
    with article BC_155
    with p10_opposite I53_northwest
    has ~female
    with vector 0
    with IK3_Count 4
    with IK3_Link I56_southwest
    with KD_Count 3
    with name 'sureste' 'direcciones//p' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_156
    with plural BC_157
;

Object I56_southwest "" Compass
    class K3_direction
    with short_name BC_158
    with article BC_159
    with p10_opposite I52_northeast
    has ~female
    with vector 0
    with IK3_Count 5
    with IK3_Link I57_east
    with KD_Count 3
    with name 'suroeste' 'direcciones//p' 'sw' 'so' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_160
    with plural BC_161
;

Object I57_east "" Compass
    class K3_direction
    with short_name BC_162
    with article BC_163
    with p10_opposite I58_west
    has ~female
    with vector 0
    with IK3_Count 6
    with IK3_Link I58_west
    with KD_Count 3
    with name 'este' 'direcciones//p' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_164
    with plural BC_165
;

Object I58_west "" Compass
    class K3_direction
    with short_name BC_166
    with article BC_167
    with p10_opposite I57_east
    has ~female
    with vector 0
    with IK3_Count 7
    with IK3_Link I59_up
    with KD_Count 3
    with name 'oeste' 'direcciones//p' 'w//' 'o//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_168
    with plural BC_169
;

Object I59_up "" Compass
    class K3_direction
    with short_name BC_170
    with article BC_171
    with p10_opposite I60_down
    has proper
    has ~female
    with vector 0
    with cap_short_name BC_172
    with IK3_Count 8
    with IK3_Link I60_down
    with KD_Count 3
    with name 'arriba' 'direcciones//p' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_173
    with plural BC_174
;

Object I60_down "" Compass
    class K3_direction
    with short_name BC_175
    with article BC_176
    with p10_opposite I59_up
    has proper
    has ~female
    with vector 0
    with cap_short_name BC_177
    with IK3_Count 9
    with IK3_Link in_obj
    with KD_Count 3
    with name 'abajo' 'direcciones//p' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_178
    with plural BC_179
;

Object in_obj "" Compass
    class K3_direction
    with short_name BC_180
    with article BC_181
    with p10_opposite out_obj
    has proper
    has ~female
    with vector 0
    with cap_short_name BC_182
    with IK3_Count 10
    with IK3_Link out_obj
    with KD_Count 3
    with name 'dentro' 'direcciones//p' 'in' 'adentro' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_183
    with plural BC_184
;

Object out_obj "" Compass
    class K3_direction
    with short_name BC_185
    with article BC_186
    with p10_opposite in_obj
    has proper
    has ~female
    with vector 0
    with cap_short_name BC_187
    with IK3_Count 11
    with IK3_Link nothing
    with KD_Count 3
    with name 'fuera' 'direcciones//p' 'out' 'afuera' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_188
    with plural BC_189
;

Object selfobj ""
    class K8_person

    !	with saved_short_name TX_L_39,
    	with saved_short_name [;
    				print "ti mism", (o) player;
    	],

     
    with short_name BC_190
    with description BC_191
    has proper
    has privately_named
    has concealed
    has ~female
    with vector 0
    with cap_short_name BC_192
    has mark_as_thing
    with IK2_Count 0
    with IK2_Link I197_all_windows
    with IK8_Count 0
    with IK8_Link I220_musa
    with KD_Count 8
    with parse_name Parse_Name_GV13
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_193
    with list_together BC_194
    with plural BC_195
    with article BC_196
;

Object I197_all_windows ""
    class K16_g_window
    with short_name BC_197
    has proper
    has ~female
    with vector 0
    has mark_as_thing
    with IK2_Count 1
    with IK2_Link I198_all_buffer_windows
    with IK5_Count 0
    with IK5_Link I198_all_buffer_windows
    with IK16_Count 0
    with IK16_Link I198_all_buffer_windows
    with KD_Count 16
    with name 'all-windows' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with p27_background_color BC_198
    with description BC_199
    with initial BC_200
    with list_together BC_201
    with plural BC_202
    with article BC_203
;

Object I198_all_buffer_windows ""
    class K16_g_window
    with short_name BC_204
    has proper
    has ~female
    with vector 0
    has mark_as_thing
    with IK2_Count 2
    with IK2_Link I199_all_grid_windows
    with IK5_Count 1
    with IK5_Link I199_all_grid_windows
    with IK16_Count 1
    with IK16_Link I199_all_grid_windows
    with KD_Count 16
    with name 'all-buffer-windows' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with p27_background_color BC_205
    with description BC_206
    with initial BC_207
    with list_together BC_208
    with plural BC_209
    with article BC_210
;

Object I199_all_grid_windows ""
    class K16_g_window
    with short_name BC_211
    has proper
    has ~female
    with vector 0
    has mark_as_thing
    with IK2_Count 3
    with IK2_Link I200_main_window
    with IK5_Count 2
    with IK5_Link I200_main_window
    with IK16_Count 2
    with IK16_Link I200_main_window
    with KD_Count 16
    with name 'all-grid-windows' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with p27_background_color BC_212
    with description BC_213
    with initial BC_214
    with list_together BC_215
    with plural BC_216
    with article BC_217
;

Object I200_main_window ""
    class K18_text_buffer_g_window
    with short_name BC_218
    with p27_background_color BC_219
    has neuter
    with p72_grammatical_gender I122_neuter_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 4
    with IK2_Link I201_status_window
    with IK5_Count 3
    with IK5_Link I201_status_window
    with IK16_Count 3
    with IK16_Link I201_status_window
    with IK18_Count 0
    with IK18_Link nothing
    with KD_Count 18
    with name 'main' 'window' 'text//p' 'buffer//p' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_220
    with initial BC_221
    with list_together BC_222
    with plural BC_223
    with article BC_224
;

Object -> I201_status_window ""
    class K19_text_grid_g_window
    with short_name BC_225
    with p20_position I191_g_placeabove
    with p21_scale_method I195_g_fixed_size
    with p22_measurement 1
    has neuter
    with p72_grammatical_gender I122_neuter_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 5
    with IK2_Link I202_quote_window
    with IK5_Count 4
    with IK5_Link I202_quote_window
    with IK16_Count 4
    with IK16_Link I202_quote_window
    with IK19_Count 0
    with IK19_Link nothing
    with KD_Count 19
    with name 'status' 'window' 'text//p' 'grid//p' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with p27_background_color BC_226
    with description BC_227
    with initial BC_228
    with list_together BC_229
    with plural BC_230
    with article BC_231
;

Object -> I202_quote_window ""
    class K16_g_window
    with short_name BC_232
    has neuter
    with p72_grammatical_gender I122_neuter_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 6
    with IK2_Link I219_pluma
    with IK5_Count 5
    with IK5_Link I274_altar
    with IK16_Count 5
    with IK16_Link nothing
    with KD_Count 16
    with name 'quote' 'window' 'g-windows//p' 
    with action_bitmap 0 0 0 0 0 0 
    with p27_background_color BC_233
    with description BC_234
    with initial BC_235
    with list_together BC_236
    with plural BC_237
    with article BC_238
;

Object I218_en_la_oscuridad ""
    class K1_room
    with short_name BC_239
    with description BC_240
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 0
    with IK1_Link I224_primer_acto
    with KD_Count 1
    with name 'en' 'la' 'oscuridad' 'habitaciones//p' 
    with list_together BC_241
    with plural BC_242
    with article BC_243
;

Object -> I219_pluma ""
    class K2_thing
    with short_name BC_244
    with description BC_245
    with initial BC_246
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 7
    with IK2_Link I220_musa
    with KD_Count 2
    with name 'pluma' 'objetos//p' 'estilografica' 'lapiz' 'punta' 
    with parse_name Parse_Name_GV239
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_247
    with plural BC_248
    with article BC_249
;

Object -> I220_musa ""
    class K11_woman
    with short_name BC_250
    with description BC_251
    with initial BC_252
    has female
    with p72_grammatical_gender I124_feminine_gender
    has ~p79_complacida
    with vector 0
    has mark_as_thing
    with component_child I221_ojos
    with IK2_Count 8
    with IK2_Link I222_libro
    with IK8_Count 1
    with IK8_Link I234_pastor
    with IK11_Count 0
    with IK11_Link I259_doncella
    with KD_Count 11
    with name 'musa' 'mujeres//p' 'luz' 'mujer' 'lilith' 
    with parse_name Parse_Name_GV240
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_253
    with plural BC_254
    with article BC_255
;

Object -> I222_libro ""
    class K2_thing
    with short_name BC_256
    with description BC_257
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 10
    with IK2_Link I221_ojos
    with KD_Count 2
    with name 'libro' 'objetos//p' 'pagina' 'poemas' 'poema' 'versos' 'verso' 'paginas' 'salpicaduras' 
    with parse_name Parse_Name_GV242
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_258
    with list_together BC_259
    with plural BC_260
    with article BC_261
;

Object I221_ojos ""
    class K2_thing
    with short_name BC_262
    has pluralname
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I220_musa
    with IK2_Count 9
    with IK2_Link I232_paisaje
    with KD_Count 2
    with name 'ojos' 'objetos//p' 'mirada' 'ojo' 'sangre' 'ceniza' 'cenizas' 'oscuridad' 'punto' 'apoyo' 
    with parse_name Parse_Name_GV241
    with action_bitmap 0 0 0 0 0 0 
    with description BC_263
    with initial BC_264
    with list_together BC_265
    with plural BC_266
    with article BC_267
;

Object I223_abismo ""
    class K9_region
    with short_name BC_268
    has neuter
    with p72_grammatical_gender I122_neuter_gender
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I223_abismo)) rtrue; rfalse;],
    with IK9_Count 0
    with IK9_Link nothing
    with KD_Count 9
    with name 'abismo' 'regiones//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_269
    with plural BC_270
    with article BC_271
;

Object I224_primer_acto ""
    class K1_room
    with short_name BC_272
    with description BC_273
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 1
    with IK1_Link I225_segundo_acto
    with KD_Count 1
    with name 'primer' 'acto' 'habitaciones//p' 
    with list_together BC_274
    with plural BC_275
    with article BC_276
;

Object -> I232_paisaje ""
    class K2_thing
    with short_name BC_277
    with description BC_278
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 12
    with IK2_Link I233_ovejas
    with KD_Count 2
    with name 'paisaje' 'objetos//p' 'paisaje' 'campo' 'arbol' 'hierba' 'atardecer' 
    with parse_name Parse_Name_GV244
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_279
    with list_together BC_280
    with plural BC_281
    with article BC_282
;

Object -> I233_ovejas ""
    class K2_thing
    with short_name BC_283
    with description BC_284
    has pluralname
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 13
    with IK2_Link I234_pastor
    with KD_Count 2
    with name 'ovejas' 'objetos//p' 'oveja' 'animal' 'animales' 'rebano' 
    with parse_name Parse_Name_GV245
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_285
    with list_together BC_286
    with plural BC_287
    with article BC_288
;

Object -> I234_pastor ""
    class K10_man
    with short_name BC_289
    with description BC_290
    with p18_litany T24_pastor_conversation
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 14
    with IK2_Link I235_bandejas
    with IK8_Count 2
    with IK8_Link I240_verdugos
    with IK10_Count 0
    with IK10_Link I240_verdugos
    with KD_Count 10
    with name 'pastor' 'hombres//p' 'hombre' 
    with parse_name Parse_Name_GV246
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_291
    with list_together BC_292
    with plural BC_293
    with article BC_294
;

Object I225_segundo_acto ""
    class K1_room
    with short_name BC_295
    with description BC_296
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 2
    with IK1_Link I226_tercer_acto
    with KD_Count 1
    with name 'segundo' 'acto' 'habitaciones//p' 
    with list_together BC_297
    with plural BC_298
    with article BC_299
;

Object -> I235_bandejas ""
    class K2_thing
    with short_name BC_300
    with description BC_301
    has pluralname
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 15
    with IK2_Link I236_torreon
    with KD_Count 2
    with name 'bandejas' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_302
    with list_together BC_303
    with plural BC_304
    with article BC_305
;

Object -> I236_torreon ""
    class K2_thing
    with short_name BC_306
    with description BC_307
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 16
    with IK2_Link I237_sierra
    with KD_Count 2
    with name 'torreon' 'objetos//p' 'torre' 'castillo' 
    with parse_name Parse_Name_GV247
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_308
    with list_together BC_309
    with plural BC_310
    with article BC_311
;

Object -> I237_sierra ""
    class K2_thing
    with short_name BC_312
    with description BC_313
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 17
    with IK2_Link I238_cuervo
    with KD_Count 2
    with name 'sierra' 'objetos//p' 'cielo' 'paisaje' 
    with parse_name Parse_Name_GV248
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_314
    with list_together BC_315
    with plural BC_316
    with article BC_317
;

Object -> I238_cuervo ""
    class K2_thing
    with short_name BC_318
    with description BC_319
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 18
    with IK2_Link I239_cadenas
    with KD_Count 2
    with name 'cuervo' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_320
    with list_together BC_321
    with plural BC_322
    with article BC_323
;

Object -> I239_cadenas ""
    class K2_thing
    with short_name BC_324
    with description BC_325
    has pluralname
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 19
    with IK2_Link I240_verdugos
    with KD_Count 2
    with name 'cadenas' 'objetos//p' 'cadena' 'poste' 
    with parse_name Parse_Name_GV249
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_326
    with list_together BC_327
    with plural BC_328
    with article BC_329
;

Object -> I240_verdugos ""
    class K10_man
    with short_name BC_330
    with description BC_331
    has pluralname
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 20
    with IK2_Link I241_banquete
    with IK8_Count 3
    with IK8_Link I246_ajusticiado
    with IK10_Count 1
    with IK10_Link I246_ajusticiado
    with KD_Count 10
    with name 'verdugos' 'hombres//p' 'verdugo' 
    with parse_name Parse_Name_GV250
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_332
    with list_together BC_333
    with plural BC_334
    with article BC_335
;

Object -> I241_banquete ""
    class K2_thing
    with short_name BC_336
    with description BC_337
    has edible
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_child I242_comida
    with IK2_Count 21
    with IK2_Link I246_ajusticiado
    with KD_Count 2
    with name 'banquete' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_338
    with list_together BC_339
    with plural BC_340
    with article BC_341
;

Object -> I246_ajusticiado ""
    class K10_man
    with short_name BC_342
    with description BC_343
    with p18_litany T26_ajusticiado_conversation
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 26
    with IK2_Link I247_guerreros
    with IK8_Count 4
    with IK8_Link I249_soldado
    with IK10_Count 2
    with IK10_Link I249_soldado
    with KD_Count 10
    with name 'ajusticiado' 'hombres//p' 'prisionero' 'mirada' 'tunica' 'tunicas' 'reo' 'hombre' 
    with parse_name Parse_Name_GV251
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_344
    with list_together BC_345
    with plural BC_346
    with article BC_347
;

Object I226_tercer_acto ""
    class K1_room
    with short_name BC_348
    with description BC_349
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 3
    with IK1_Link I227_cuarto_acto
    with KD_Count 1
    with name 'tercer' 'acto' 'habitaciones//p' 
    with list_together BC_350
    with plural BC_351
    with article BC_352
;

Object -> I247_guerreros ""
    class K2_thing
    with short_name BC_353
    with description BC_354
    has pluralname
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 27
    with IK2_Link I248_armas
    with KD_Count 2
    with name 'guerreros' 'objetos//p' 'hombres' 'guerrero' 
    with parse_name Parse_Name_GV252
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_355
    with list_together BC_356
    with plural BC_357
    with article BC_358
;

Object -> I248_armas ""
    class K2_thing
    with short_name BC_359
    with description BC_360
    has pluralname
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 28
    with IK2_Link I249_soldado
    with KD_Count 2
    with name 'armas' 'objetos//p' 'artilugios' 'espadas' 
    with parse_name Parse_Name_GV253
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_361
    with list_together BC_362
    with plural BC_363
    with article BC_364
;

Object -> I249_soldado ""
    class K10_man
    with short_name BC_365
    with description BC_366
    with p18_litany T28_soldado_conversation
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_child I250_heridas
    with IK2_Count 29
    with IK2_Link I253_habitacion
    with IK8_Count 5
    with IK8_Link I259_doncella
    with IK10_Count 3
    with IK10_Link I270_mercader
    with KD_Count 10
    with name 'soldado' 'hombres//p' 'mirada' 'enemigo' 'traidor' 'infeliz' 'hombre' 
    with parse_name Parse_Name_GV254
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_367
    with list_together BC_368
    with plural BC_369
    with article BC_370
;

Object I227_cuarto_acto ""
    class K1_room
    with short_name BC_371
    with description BC_372
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 4
    with IK1_Link I228_quinto_acto
    with KD_Count 1
    with name 'cuarto' 'acto' 'habitaciones//p' 
    with list_together BC_373
    with plural BC_374
    with article BC_375
;

Object -> I253_habitacion ""
    class K2_thing
    with short_name BC_376
    with description BC_377
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_child I254_decorados
    with IK2_Count 33
    with IK2_Link I256_espejo
    with KD_Count 2
    with name 'habitacion' 'objetos//p' 'sala' 'cuarto' 
    with parse_name Parse_Name_GV255
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_378
    with list_together BC_379
    with plural BC_380
    with article BC_381
;

Object -> I256_espejo ""
    class K2_thing
    with short_name BC_382
    with description BC_383
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 36
    with IK2_Link I257_cama
    with KD_Count 2
    with name 'espejo' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_384
    with list_together BC_385
    with plural BC_386
    with article BC_387
;

Object -> I257_cama ""
    class K2_thing
    with short_name BC_388
    with description BC_389
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 37
    with IK2_Link I258_butaca
    with KD_Count 2
    with name 'cama' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_390
    with list_together BC_391
    with plural BC_392
    with article BC_393
;

Object -> I258_butaca ""
    class K2_thing
    with short_name BC_394
    with description BC_395
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 38
    with IK2_Link I259_doncella
    with KD_Count 2
    with name 'butaca' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_396
    with list_together BC_397
    with plural BC_398
    with article BC_399
;

Object -> I259_doncella ""
    class K11_woman
    with short_name BC_400
    with description BC_401
    with p18_litany T30_doncella_conversation
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_child I260_enredos
    with IK2_Count 39
    with IK2_Link I264_pinturas
    with IK8_Count 6
    with IK8_Link I270_mercader
    with IK11_Count 1
    with IK11_Link nothing
    with KD_Count 11
    with name 'doncella' 'mujeres//p' 'chica' 'rostro' 'muchacha' 'semblante' 'mujer' 
    with parse_name Parse_Name_GV257
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_402
    with list_together BC_403
    with plural BC_404
    with article BC_405
;

Object I228_quinto_acto ""
    class K1_room
    with short_name BC_406
    with description BC_407
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 5
    with IK1_Link I229_sexto_acto
    with KD_Count 1
    with name 'quinto' 'acto' 'habitaciones//p' 
    with list_together BC_408
    with plural BC_409
    with article BC_410
;

Object -> I264_pinturas ""
    class K2_thing
    with short_name BC_411
    with description BC_412
    has pluralname
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 44
    with IK2_Link I265_cama_grande
    with KD_Count 2
    with name 'pinturas' 'objetos//p' 'pintura' 'cuadro' 'decadencia' 
    with parse_name Parse_Name_GV259
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_413
    with list_together BC_414
    with plural BC_415
    with article BC_416
;

Object -> I265_cama_grande ""
    class K2_thing
    with short_name BC_417
    with description BC_418
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_child I266_almohadas
    with IK2_Count 45
    with IK2_Link I269_diamante
    with KD_Count 2
    with name 'cama' 'grande' 'objetos//p' 'cama' 'lecho' 
    with parse_name Parse_Name_GV260
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_419
    with list_together BC_420
    with plural BC_421
    with article BC_422
;

Object -> I269_diamante ""
    class K2_thing
    with short_name BC_423
    with description BC_424
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 49
    with IK2_Link I270_mercader
    with KD_Count 2
    with name 'diamante' 'objetos//p' 'joya' 'valor' 'brillante' 'brillo' 
    with parse_name Parse_Name_GV263
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_425
    with list_together BC_426
    with plural BC_427
    with article BC_428
;

Object -> I270_mercader ""
    class K10_man
    with short_name BC_429
    with description BC_430
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    has p81_vivo
    with vector 0
    has mark_as_thing
    with component_child I271_telas
    with IK2_Count 50
    with IK2_Link I272_fieles
    with IK8_Count 7
    with IK8_Link I282_hermano
    with IK10_Count 4
    with IK10_Link I282_hermano
    with KD_Count 10
    with name 'mercader' 'hombres//p' 'mirada' 'gordo' 'cabeza' 'boca' 'nariz' 'nuca' 'garganta' 'rostro' 'ojos' 'mueca' 'hombre' 
    with parse_name Parse_Name_GV264
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_431
    with list_together BC_432
    with plural BC_433
    with article BC_434
;

Object I229_sexto_acto ""
    class K1_room
    with short_name BC_435
    with description BC_436
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 6
    with IK1_Link I230_septimo_acto
    with KD_Count 1
    with name 'sexto' 'acto' 'habitaciones//p' 
    with list_together BC_437
    with plural BC_438
    with article BC_439
;

Object -> I272_fieles ""
    class K2_thing
    with short_name BC_440
    with description BC_441
    has pluralname
    has static
    has scenery
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 52
    with IK2_Link I273_hoguera
    with KD_Count 2
    with name 'fieles' 'objetos//p' 'muchedumbre' 'gente' 'acolitos' 'cultistas' 
    with parse_name Parse_Name_GV266
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_442
    with list_together BC_443
    with plural BC_444
    with article BC_445
;

Object -> I273_hoguera ""
    class K2_thing
    with short_name BC_446
    with description BC_447
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 53
    with IK2_Link I274_altar
    with KD_Count 2
    with name 'hoguera' 'objetos//p' 
    with parse_name Parse_Name_GV267
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_448
    with list_together BC_449
    with plural BC_450
    with article BC_451
;

Object -> I274_altar ""
    class K5_container
    with short_name BC_452
    with description BC_453
    with initial BC_454
    has static
    has enterable
    has transparent
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_child I275_piedras
    with IK2_Count 54
    with IK2_Link I281_tormenta
    with IK5_Count 6
    with IK5_Link nothing
    with KD_Count 5
    with name 'altar' 'contenedores//p' 
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_455
    with plural BC_456
    with article BC_457
;

Object I230_septimo_acto ""
    class K1_room
    with short_name BC_458
    with description BC_459
    with map_region I223_abismo
    has proper
    has ~female
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 7
    with IK1_Link nothing
    with KD_Count 1
    with name 'septimo' 'acto' 'habitaciones//p' 
    with list_together BC_460
    with plural BC_461
    with article BC_462
;

Object -> I281_tormenta ""
    class K2_thing
    with short_name BC_463
    with description BC_464
    has static
    has scenery
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 61
    with IK2_Link I282_hermano
    with KD_Count 2
    with name 'tormenta' 'objetos//p' 'cielo' 'nubes' 'truenos' 'relampagos' 'luz' 
    with parse_name Parse_Name_GV269
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_465
    with list_together BC_466
    with plural BC_467
    with article BC_468
;

Object -> I282_hermano ""
    class K10_man
    with short_name BC_469
    with description BC_470
    with initial BC_471
    with p18_litany T32_hermano_conversation
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 62
    with IK2_Link I231_presencia
    with IK8_Count 8
    with IK8_Link nothing
    with IK10_Count 5
    with IK10_Link nothing
    with KD_Count 10
    with name 'hermano' 'hombres//p' 'hombre' 'pastor' 
    with parse_name Parse_Name_GV270
    with action_bitmap 0 0 0 0 0 0 
    with list_together BC_472
    with plural BC_473
    with article BC_474
;

Object I231_presencia ""
    class K7_backdrop
    with short_name BC_475
    with description BC_476
    has neuter
    with p72_grammatical_gender I122_neuter_gender
    with vector 0
    with found_in [ ;
        if (TestRegionalContainment(location, I223_abismo)) rtrue; ],
    has mark_as_thing
    with IK2_Count 11
    with IK2_Link I242_comida
    with IK7_Count 0
    with IK7_Link nothing
    with KD_Count 7
    with name 'presencia' 'decorados//p' 'musa' 'decoracion' 'motivos' 'telas' 'cortinas' 
    with parse_name Parse_Name_GV243
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_477
    with list_together BC_478
    with plural BC_479
    with article BC_480
;

Object I242_comida ""
    class K2_thing
    with short_name BC_481
    has edible
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I241_banquete
    with component_sibling I243_frutas
    with IK2_Count 22
    with IK2_Link I243_frutas
    with KD_Count 2
    with name 'comida' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_482
    with initial BC_483
    with list_together BC_484
    with plural BC_485
    with article BC_486
;

Object I243_frutas ""
    class K2_thing
    with short_name BC_487
    has pluralname
    has edible
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I241_banquete
    with component_sibling I244_asado
    with IK2_Count 23
    with IK2_Link I244_asado
    with KD_Count 2
    with name 'frutas' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_488
    with initial BC_489
    with list_together BC_490
    with plural BC_491
    with article BC_492
;

Object I244_asado ""
    class K2_thing
    with short_name BC_493
    has edible
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I241_banquete
    with component_sibling I245_delicias
    with IK2_Count 24
    with IK2_Link I245_delicias
    with KD_Count 2
    with name 'asado' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_494
    with initial BC_495
    with list_together BC_496
    with plural BC_497
    with article BC_498
;

Object I245_delicias ""
    class K2_thing
    with short_name BC_499
    has pluralname
    has edible
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I241_banquete
    with IK2_Count 25
    with IK2_Link I250_heridas
    with KD_Count 2
    with name 'delicias' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_500
    with initial BC_501
    with list_together BC_502
    with plural BC_503
    with article BC_504
;

Object I250_heridas ""
    class K2_thing
    with short_name BC_505
    with description BC_506
    has pluralname
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I249_soldado
    with component_sibling I251_mano
    with IK2_Count 30
    with IK2_Link I251_mano
    with KD_Count 2
    with name 'heridas' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_507
    with list_together BC_508
    with plural BC_509
    with article BC_510
;

Object I251_mano ""
    class K2_thing
    with short_name BC_511
    with description BC_512
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I249_soldado
    with component_sibling I252_espada
    with IK2_Count 31
    with IK2_Link I252_espada
    with KD_Count 2
    with name 'mano' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_513
    with list_together BC_514
    with plural BC_515
    with article BC_516
;

Object I252_espada ""
    class K2_thing
    with short_name BC_517
    with description BC_518
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I249_soldado
    with IK2_Count 32
    with IK2_Link I254_decorados
    with KD_Count 2
    with name 'espada' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_519
    with list_together BC_520
    with plural BC_521
    with article BC_522
;

Object I254_decorados ""
    class K2_thing
    with short_name BC_523
    has pluralname
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I253_habitacion
    with IK2_Count 34
    with IK2_Link I255_decorados
    with KD_Count 2
    with name 'decorados' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_524
    with initial BC_525
    with list_together BC_526
    with plural BC_527
    with article BC_528
;

Object I255_decorados ""
    class K2_thing
    with short_name BC_529
    with description BC_530
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 35
    with IK2_Link I260_enredos
    with KD_Count 2
    with name 'decorados' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_531
    with list_together BC_532
    with plural BC_533
    with article BC_534
;

Object I260_enredos ""
    class K2_thing
    with short_name BC_535
    with description BC_536
    has pluralname
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I259_doncella
    with component_sibling I261_cabello
    with IK2_Count 40
    with IK2_Link I261_cabello
    with KD_Count 2
    with name 'enredos' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_537
    with list_together BC_538
    with plural BC_539
    with article BC_540
;

Object I261_cabello ""
    class K2_thing
    with short_name BC_541
    with description BC_542
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I259_doncella
    with component_sibling I262_mirada
    with IK2_Count 41
    with IK2_Link I262_mirada
    with KD_Count 2
    with name 'cabello' 'objetos//p' 'pelo' 
    with parse_name Parse_Name_GV258
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_543
    with list_together BC_544
    with plural BC_545
    with article BC_546
;

Object I262_mirada ""
    class K2_thing
    with short_name BC_547
    with description BC_548
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I259_doncella
    with component_sibling I263_cepillo
    with IK2_Count 42
    with IK2_Link I263_cepillo
    with KD_Count 2
    with name 'mirada' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_549
    with list_together BC_550
    with plural BC_551
    with article BC_552
;

Object I263_cepillo ""
    class K2_thing
    with short_name BC_553
    with description BC_554
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I259_doncella
    with IK2_Count 43
    with IK2_Link I266_almohadas
    with KD_Count 2
    with name 'cepillo' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_555
    with list_together BC_556
    with plural BC_557
    with article BC_558
;

Object I266_almohadas ""
    class K2_thing
    with short_name BC_559
    with description BC_560
    has pluralname
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I265_cama_grande
    with component_sibling I267_cojines
    with IK2_Count 46
    with IK2_Link I267_cojines
    with KD_Count 2
    with name 'almohadas' 'objetos//p' 'almohada' 'almoada' 
    with parse_name Parse_Name_GV261
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_561
    with list_together BC_562
    with plural BC_563
    with article BC_564
;

Object I267_cojines ""
    class K2_thing
    with short_name BC_565
    with description BC_566
    has pluralname
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I265_cama_grande
    with IK2_Count 47
    with IK2_Link I268_almohada
    with KD_Count 2
    with name 'cojines' 'objetos//p' 'cojin' 
    with parse_name Parse_Name_GV262
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_567
    with list_together BC_568
    with plural BC_569
    with article BC_570
;

Object I268_almohada ""
    class K2_thing
    with short_name BC_571
    with description BC_572
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with IK2_Count 48
    with IK2_Link I271_telas
    with KD_Count 2
    with name 'almohada' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_573
    with list_together BC_574
    with plural BC_575
    with article BC_576
;

Object I271_telas ""
    class K2_thing
    with short_name BC_577
    with description BC_578
    has pluralname
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I270_mercader
    with IK2_Count 51
    with IK2_Link I275_piedras
    with KD_Count 2
    with name 'telas' 'objetos//p' 'tela' 'ropa' 'ropas' 
    with parse_name Parse_Name_GV265
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_579
    with list_together BC_580
    with plural BC_581
    with article BC_582
;

Object I275_piedras ""
    class K2_thing
    with short_name BC_583
    has pluralname
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I274_altar
    with component_sibling I276_piedra
    with IK2_Count 55
    with IK2_Link I276_piedra
    with KD_Count 2
    with name 'piedras' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with description BC_584
    with initial BC_585
    with list_together BC_586
    with plural BC_587
    with article BC_588
;

Object I276_piedra ""
    class K2_thing
    with short_name BC_589
    with description BC_590
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I274_altar
    with component_sibling I277_ternero
    with IK2_Count 56
    with IK2_Link I277_ternero
    with KD_Count 2
    with name 'piedra' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_591
    with list_together BC_592
    with plural BC_593
    with article BC_594
;

Object I277_ternero ""
    class K2_thing
    with short_name BC_595
    with description BC_596
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I274_altar
    with component_child I278_visceras
    with IK2_Count 57
    with IK2_Link I278_visceras
    with KD_Count 2
    with name 'ternero' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_597
    with list_together BC_598
    with plural BC_599
    with article BC_600
;

Object I278_visceras ""
    class K2_thing
    with short_name BC_601
    with description BC_602
    has pluralname
    has edible
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I277_ternero
    with component_sibling I279_corazon
    with IK2_Count 58
    with IK2_Link I279_corazon
    with KD_Count 2
    with name 'visceras' 'objetos//p' 'entranas' 'viscera' 'entrana' 
    with parse_name Parse_Name_GV268
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_603
    with list_together BC_604
    with plural BC_605
    with article BC_606
;

Object I279_corazon ""
    class K2_thing
    with short_name BC_607
    with description BC_608
    has edible
    has ~female
    with p72_grammatical_gender I123_masculine_gender
    with vector 0
    has mark_as_thing
    with component_parent I277_ternero
    with component_sibling I280_sangre
    with IK2_Count 59
    with IK2_Link I280_sangre
    with KD_Count 2
    with name 'corazon' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_609
    with list_together BC_610
    with plural BC_611
    with article BC_612
;

Object I280_sangre ""
    class K2_thing
    with short_name BC_613
    with description BC_614
    has edible
    has female
    with p72_grammatical_gender I124_feminine_gender
    with vector 0
    has mark_as_thing
    with component_parent I277_ternero
    with IK2_Count 60
    with IK2_Link nothing
    with KD_Count 2
    with name 'sangre' 'objetos//p' 
    with action_bitmap 0 0 0 0 0 0 
    with initial BC_615
    with list_together BC_616
    with plural BC_617
    with article BC_618
;

Constant I71_english_language = 1;
Constant I72_french_language = 2;
Constant I73_german_language = 3;
Constant I74_italian_language = 4;
Constant I75_spanish_language = 5;
Constant I76_swedish_language = 6;
Constant I77_figure_of_cover = 1;
Constant I78_entire_game = 1;
Constant I80_didn_t_understand_error = 1;
Constant I81_only_understood_as_far_a = 2;
Constant I82_didn_t_understand_that_n = 3;
Constant I83_can_only_do_that_to_some = 4;
Constant I84_can_t_see_any_such_thing = 5;
Constant I85_said_too_little_error = 6;
Constant I86_aren_t_holding_that_erro = 7;
Constant I87_can_t_use_multiple_objec = 8;
Constant I88_can_only_use_multiple_ob = 9;
Constant I89_not_sure_what_it_refers_ = 10;
Constant I90_excepted_something_not_i = 11;
Constant I91_not_a_verb_i_recognise_e = 12;
Constant I92_not_something_you_need_t = 13;
Constant I93_can_t_see_it_at_the_mome = 14;
Constant I94_didn_t_understand_the_wa = 15;
Constant I95_not_enough_of_those_avai = 16;
Constant I96_nothing_to_do_error = 17;
Constant I97_noun_did_not_make_sense_ = 18;
Constant I98_referred_to_a_determinat = 19;
Constant I99_i_beg_your_pardon_error = 20;
Constant I100_can_t_again_the_address = 21;
Constant I101_comma_can_t_begin_error = 22;
Constant I102_can_t_see_whom_to_talk_ = 23;
Constant I103_can_t_talk_to_inanimate = 24;
Constant I104_didn_t_understand_addre = 25;
Constant I106_present_tense = 1;
Constant I107_past_tense = 2;
Constant I108_perfect_tense = 3;
Constant I109_past_perfect_tense = 4;
Constant I110_future_tense = 5;
Constant I112_first_person_singular = 1;
Constant I113_second_person_singular = 2;
Constant I114_third_person_singular = 3;
Constant I115_first_person_plural = 4;
Constant I116_second_person_plural = 5;
Constant I117_third_person_plural = 6;
Constant I119_nominative = 1;
Constant I120_accusative = 2;
Constant I122_neuter_gender = 1;
Constant I123_masculine_gender = 2;
Constant I124_feminine_gender = 3;
Constant I126_all_styles = 1;
Constant I127_normal_style = 2;
Constant I128_italic_style = 3;
Constant I129_fixed_letter_spacing_st = 4;
Constant I130_header_style = 5;
Constant I131_bold_style = 6;
Constant I132_alert_style = 7;
Constant I133_note_style = 8;
Constant I134_blockquote_style = 9;
Constant I135_input_style = 10;
Constant I136_special_style_1 = 11;
Constant I137_special_style_2 = 12;
Constant I139_left_justified = 1;
Constant I140_left_right_justified = 2;
Constant I141_center_justified = 3;
Constant I142_right_justified = 4;
Constant I144_light_weight = 1;
Constant I145_regular_weight = 2;
Constant I146_bold_weight = 3;
Constant I148_brief = 1;
Constant I149_verbose = 2;
Constant I150_superbrief = 3;
Constant I152_quip_null = 1;
Constant I153_quip_dtell = 2;
Constant I154_escucha_pastor = 3;
Constant I155_ayuda_pastor = 4;
Constant I156_hola_pastor = 5;
Constant I157_tu_crimen = 6;
Constant I158_azotadle = 7;
Constant I159_hambriento = 8;
Constant I160_espada_buena = 9;
Constant I161_sufrimiento = 10;
Constant I162_palabras = 11;
Constant I163_deja_ya = 12;
Constant I164_buenas_noches = 13;
Constant I165_cabello_hermoso = 14;
Constant I166_mi_ofrenda = 15;
Constant I167_ternero_hermano = 16;
Constant I168_hola_hermano = 17;
Constant I170_timer_event = 1;
Constant I171_char_event = 2;
Constant I172_line_event = 3;
Constant I173_mouse_event = 4;
Constant I174_arrange_event = 5;
Constant I175_redraw_event = 6;
Constant I176_sound_notify_event = 7;
Constant I177_hyperlink_event = 8;
Constant I178_volume_event = 9;
Constant I181_g_text_buffer = 1;
Constant I182_g_text_grid = 2;
Constant I183_g_graphics = 3;
Constant I188_g_placenull = 1;
Constant I189_g_placeleft = 2;
Constant I190_g_placeright = 3;
Constant I191_g_placeabove = 4;
Constant I192_g_placebelow = 5;
Constant I194_g_proportional = 1;
Constant I195_g_fixed_size = 2;
Constant I196_g_using_minimum = 3;
Constant I203_figure_portada = 2;
Constant I204_figure_musa = 3;
Constant I205_figure_musa_esperando = 4;
Constant I206_figure_musa_riendo = 5;
Constant I207_figure_musa_vigilante = 6;
Constant I208_figure_musa_llorando = 7;
Constant I209_figure_pastor = 8;
Constant I210_figure_soldado = 9;
Constant I211_figure_reo = 10;
Constant I212_figure_doncella = 11;
Constant I213_figure_mercader = 12;
Constant I214_figure_cultista = 13;
Constant I215_sound_of_ending = 1;
Constant I216_sound_of_atmosphere = 2;
Constant I217_sound_of_start = 3;
Array Global_Vars -->
  (false) ! 7 darkness witnessed
  (BC_619) ! 25 command prompt
  (I75_spanish_language) ! 29 language of play
  (BC_620) ! 32 story author
  (BC_621) ! 33 story headline
  (BC_622) ! 34 story genre
  (BC_623) ! 35 story description
  (3) ! 36 release number
  (2022) ! 37 story creation year
  (0) ! 45 locale paragraph count
  (T4_ordinary_status) ! 60 status bar table
  (14) ! 61 right alignment depth
  (0) ! 62 menu depth
  (0) ! 63 endnode flag
  (BC_624) ! 64 current menu title
  (T6_sample_options) ! 65 current menu
  (1) ! 66 current menu selection
  (I152_quip_null) ! 67 current quip
  (I152_quip_null) ! 68 pertinent quip
  (BC_625) ! 69 generic ask quip
  (BC_626) ! 70 generic tell quip
  (BC_627) ! 71 rq options prologue
  (BC_628) ! 72 rq reaction demand
  (BC_629) ! 73 rq no options
  (BC_630) ! 74 qbc talking cue
  (T21_no_conversation) ! 75 qbc_litany
  (BC_631) ! 76 qbc no conversation error
  (0) ! 77 current glulx rock
  (0) ! 78 current glulx rock-ref
  (BC_632) ! 83 glulx replacement command
  (0) ! 84 library input context
  (I197_all_windows) ! 91 current focus window
  (I200_main_window) ! 92 acting main window
  (BC_633) ! 93 gargoyle cursor color
  (0) ! 94 pecados
;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0664 0 (BC_634) (BC_635) (BC_636) (BC_637) (BC_638) ;
Array tab_0_1 table $0465 1 (0) (0) (1) (0) (0) ;
Array tab_0_2 table $2066 2 (Consult_Grammar_271) (Consult_Grammar_272) (Consult_Grammar_273) (Consult_Grammar_274) (Consult_Grammar_275) ;
Array tab_0_3 table $0067 3 (IMMEDIATELY_RESTART_VM_R) (IMMEDIATELY_RESTORE_SAVED_R) ( TABLE_NOVALUE) (IMMEDIATELY_QUIT_R) (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4 ( TABLE_NOVALUE) ( TABLE_NOVALUE) (V27_amusing_a_victorious_pla) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5 ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T3_user_styles table  tab_3_0 tab_3_1 tab_3_2 tab_3_3 tab_3_4 tab_3_5 tab_3_6 tab_3_7 tab_3_8 tab_3_9 tab_3_10 tab_3_11;
Array tab_3_0 table $086b NULL ( TABLE_NOVALUE) ( TABLE_NOVALUE) (I198_all_buffer_windows) (I198_all_buffer_windows) (I199_all_grid_windows) ;
Array tab_3_1 table $4c6c NULL ( TABLE_NOVALUE) (I126_all_styles) (I128_italic_style) (I130_header_style) (I126_all_styles) ;
Array tab_3_2 table $066d 13 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_3 table $066e 14 ( TABLE_NOVALUE) (BC_639) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_4 table $446f 15 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_5 table $0470 16 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_6 table $4c71 NULL ( TABLE_NOVALUE) ( TABLE_NOVALUE) (I145_regular_weight) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_7 table $4472 17 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_8 table $0473 18 ( TABLE_NOVALUE) (0) (1) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_9 table $4c74 NULL ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) (I139_left_justified) ( TABLE_NOVALUE) ;
Array tab_3_10 table $4475 19 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_3_11 table $0476 20 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) (1) ;
Array T4_ordinary_status table  tab_4_0 tab_4_1 tab_4_2;
Array tab_4_0 table $0677 21 (BC_640) ;
Array tab_4_1 table $0678 22 (BC_641) ;
Array tab_4_2 table $0679 23 (BC_642) ;
Array T6_sample_options table  tab_6_0 tab_6_1 tab_6_2 tab_6_3;
Array tab_6_0 table $067a 24 (BC_643) ;
Array tab_6_1 table $007b 25 ( TABLE_NOVALUE) ;
Array tab_6_2 table $067c 26 (BC_644) ;
Array tab_6_3 table $007d 27 ( TABLE_NOVALUE) ;
Array T7_menu_commands table  tab_7_0 tab_7_1;
Array tab_7_0 table $447e 28 (78) (110) (80) (112) (81) (113) (13) (32) (130) (129) (27) (-8) (-6) (-5) (-4) ;
Array tab_7_1 table $007f 30 (R_903) (R_903) (R_904) (R_904) (R_902) (R_902) (R_905) (R_905) (R_903) (R_904) (R_902) (R_902) (R_905) (R_903) (R_904) ;
Array T8_shallow_menu_status table  tab_8_0 tab_8_1 tab_8_2;
Array tab_8_0 table $0677 32 (BC_645) ;
Array tab_8_1 table $0678 33 (BC_646) ;
Array tab_8_2 table $0679 34 (BC_647) ;
Array T9_deep_menu_status table  tab_9_0 tab_9_1 tab_9_2;
Array tab_9_0 table $0677 35 (BC_648) (BC_649) (BC_650) (BC_651) ;
Array tab_9_1 table $0678 36 (BC_652) (BC_653) (BC_654) (BC_655) ;
Array tab_9_2 table $0679 37 (BC_656) (BC_657) (BC_658) (BC_659) ;
Array T10_sample_hints table  tab_10_0 tab_10_1;
Array tab_10_0 table $0680 38 (BC_660) ;
Array tab_10_1 table $4481 39 ( TABLE_NOVALUE) ;
Array T12_basic_help_options table  tab_12_0 tab_12_1 tab_12_2 tab_12_3;
Array tab_12_0 table $067a 40 (BC_661) (BC_662) (BC_663) (BC_664) (BC_665) (BC_666) ;
Array tab_12_1 table $007b 41 ( TABLE_NOVALUE) (T13_instruction_options) (T34_hints) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_12_2 table $067c 42 (BC_667) ( TABLE_NOVALUE) ( TABLE_NOVALUE) (BC_668) (BC_669) (BC_670) ;
Array tab_12_3 table $007d 43 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T13_instruction_options table  tab_13_0 tab_13_1 tab_13_2 tab_13_3;
Array tab_13_0 table $067a 44 (BC_671) (BC_672) (BC_673) (BC_674) (BC_675) (BC_676) (BC_677) (BC_678) ;
Array tab_13_1 table $007b 45 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) (T15_if_elements) (T14_stuckness_advice) ;
Array tab_13_2 table $067c 46 (BC_679) (BC_680) (BC_681) (BC_682) (BC_683) (BC_684) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_13_3 table $007d 47 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T14_stuckness_advice table  tab_14_0 tab_14_1 tab_14_2 tab_14_3;
Array tab_14_0 table $067a 48 (BC_685) (BC_686) (BC_687) (BC_688) ;
Array tab_14_1 table $007b 49 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_14_2 table $067c 50 (BC_689) (BC_690) (BC_691) (BC_692) ;
Array tab_14_3 table $007d 51 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T15_if_elements table  tab_15_0 tab_15_1 tab_15_2 tab_15_3;
Array tab_15_0 table $067a 52 (BC_693) (BC_694) (BC_695) (BC_696) ;
Array tab_15_1 table $007b 53 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_15_2 table $067c 54 (BC_697) (BC_698) (BC_699) (BC_700) ;
Array tab_15_3 table $007d 55 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T16_setting_options table  tab_16_0 tab_16_1 tab_16_2 tab_16_3;
Array tab_16_0 table $067a 56 (BC_701) (BC_702) ;
Array tab_16_1 table $007b 57 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_16_2 table $067c 58 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array tab_16_3 table $007d 59 (R_919) (R_918) ;
Array T17_quip_texts table  tab_17_0 tab_17_1;
Array tab_17_0 table $5c82 NULL (I152_quip_null) (I153_quip_dtell) (I154_escucha_pastor) (I155_ayuda_pastor) (I156_hola_pastor) (I157_tu_crimen) (I158_azotadle) (I159_hambriento) (I160_espada_buena) (I161_sufrimiento) (I162_palabras) (I163_deja_ya) (I164_buenas_noches) (I165_cabello_hermoso) (I166_mi_ofrenda) (I167_ternero_hermano) (I168_hola_hermano) ;
Array tab_17_1 table $1683 60 (BC_703) (BC_704) (BC_705) (BC_706) (BC_707) (BC_708) (BC_709) (BC_710) (BC_711) (BC_712) (BC_713) (BC_714) (BC_715) (BC_716) (BC_717) (BC_718) (BC_719) ;
Array T18_quip_followups table  tab_18_0 tab_18_1 tab_18_2;
Array tab_18_0 table $4c82 NULL ( TABLE_NOVALUE) ;
Array tab_18_1 table $0684 63 ( TABLE_NOVALUE) ;
Array tab_18_2 table $4c85 NULL ( TABLE_NOVALUE) ;
Array T19_ask_results table  tab_19_0 tab_19_1 tab_19_2;
Array tab_19_0 table $0886 NULL ( TABLE_NOVALUE) ;
Array tab_19_1 table $2066 64 ( TABLE_NOVALUE) ;
Array tab_19_2 table $4c85 NULL ( TABLE_NOVALUE) ;
Array T20_tell_results table  tab_20_0 tab_20_1 tab_20_2;
Array tab_20_0 table $0886 NULL ( TABLE_NOVALUE) ;
Array tab_20_1 table $2066 65 ( TABLE_NOVALUE) ;
Array tab_20_2 table $4c85 NULL ( TABLE_NOVALUE) ;
Array T21_no_conversation table  tab_21_0 tab_21_1 tab_21_2;
Array tab_21_0 table $0687 66 ( TABLE_NOVALUE) ;
Array tab_21_1 table $4c88 NULL ( TABLE_NOVALUE) ;
Array tab_21_2 table $4489 67 ( TABLE_NOVALUE) ;
Array T24_pastor_conversation table  tab_24_0 tab_24_1 tab_24_2;
Array tab_24_0 table $0687 68 (BC_720) (BC_721) (BC_722) ;
Array tab_24_1 table $4c88 NULL (I154_escucha_pastor) (I155_ayuda_pastor) (I156_hola_pastor) ;
Array tab_24_2 table $4489 69 (0) (0) (1) ;
Array T26_ajusticiado_conversation table  tab_26_0 tab_26_1 tab_26_2;
Array tab_26_0 table $0687 70 (BC_723) (BC_724) (BC_725) ;
Array tab_26_1 table $4c88 NULL (I157_tu_crimen) (I158_azotadle) (I159_hambriento) ;
Array tab_26_2 table $4489 71 (0) (0) (1) ;
Array T28_soldado_conversation table  tab_28_0 tab_28_1 tab_28_2;
Array tab_28_0 table $0687 72 (BC_726) (BC_727) (BC_728) ;
Array tab_28_1 table $4c88 NULL (I160_espada_buena) (I161_sufrimiento) (I162_palabras) ;
Array tab_28_2 table $4489 73 (0) (1) (0) ;
Array T30_doncella_conversation table  tab_30_0 tab_30_1 tab_30_2;
Array tab_30_0 table $0687 74 (BC_729) (BC_730) (BC_731) ;
Array tab_30_1 table $4c88 NULL (I163_deja_ya) (I164_buenas_noches) (I165_cabello_hermoso) ;
Array tab_30_2 table $4489 75 (0) (1) (0) ;
Array T32_hermano_conversation table  tab_32_0 tab_32_1 tab_32_2;
Array tab_32_0 table $0687 76 (BC_732) (BC_733) (BC_734) ;
Array tab_32_1 table $4c88 NULL (I166_mi_ofrenda) (I167_ternero_hermano) (I168_hola_hermano) ;
Array tab_32_2 table $4489 77 (0) (0) (1) ;
Array T34_hints table  tab_34_0 tab_34_1 tab_34_2 tab_34_3;
Array tab_34_0 table $067a 78 (BC_735) (BC_736) (BC_737) ;
Array tab_34_1 table $007b 79 (T35_escribir_en_libro_hints) (T36_resolver_los_actos_hints) (T37_acabar_con_musa_hints) ;
Array tab_34_2 table $067c 80 (BC_738) (BC_739) (BC_740) ;
Array tab_34_3 table $007d 81 (R_913) (R_913) (R_913) ;
Array T35_escribir_en_libro_hints table  tab_35_0 tab_35_1;
Array tab_35_0 table $0680 82 (BC_741) (BC_742) (BC_743) (BC_744) (BC_745) ;
Array tab_35_1 table $4481 83 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T36_resolver_los_actos_hints table  tab_36_0 tab_36_1;
Array tab_36_0 table $0680 84 (BC_746) (BC_747) (BC_748) (BC_749) (BC_750) (BC_751) (BC_752) (BC_753) (BC_754) ;
Array tab_36_1 table $4481 86 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T37_acabar_con_musa_hints table  tab_37_0 tab_37_1;
Array tab_37_0 table $0680 88 (BC_755) (BC_756) (BC_757) (BC_758) (BC_759) (BC_760) (BC_761) (BC_762) ;
Array tab_37_1 table $4481 89 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff  ! Column 1
  
  ! For table T3_user_styles
  $1f  ! Column 2
  $1d  ! Column 3
  $1f  ! Column 4
  $1f  ! Column 5
  $1f  ! Column 7
  $19  ! Column 8
  $1f  ! Column 10
  $0f  ! Column 11
  
  ! For table T4_ordinary_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T6_sample_options
  $00  ! Column 0
  $01  ! Column 1
  $00  ! Column 2
  $01  ! Column 3
  
  ! For table T7_menu_commands
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T8_shallow_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T9_deep_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T10_sample_hints
  $00  ! Column 0
  $01  ! Column 1
  
  ! For table T12_basic_help_options
  $00  ! Column 0
  $39  ! Column 1
  $06  ! Column 2
  $3f  ! Column 3
  
  ! For table T13_instruction_options
  $00  ! Column 0
  $3f  ! Column 1
  $c0  ! Column 2
  $ff  ! Column 3
  
  ! For table T14_stuckness_advice
  $00  ! Column 0
  $0f  ! Column 1
  $00  ! Column 2
  $0f  ! Column 3
  
  ! For table T15_if_elements
  $00  ! Column 0
  $0f  ! Column 1
  $00  ! Column 2
  $0f  ! Column 3
  
  ! For table T16_setting_options
  $00  ! Column 0
  $03  ! Column 1
  $03  ! Column 2
  $00  ! Column 3
  
  ! For table T17_quip_texts
  $00 $00 $00  ! Column 1
  
  ! For table T18_quip_followups
  $01  ! Column 1
  
  ! For table T19_ask_results
  $01  ! Column 1
  
  ! For table T20_tell_results
  $01  ! Column 1
  
  ! For table T21_no_conversation
  $01  ! Column 0
  $01  ! Column 2
  
  ! For table T24_pastor_conversation
  $00  ! Column 0
  $00  ! Column 2
  
  ! For table T26_ajusticiado_conversation
  $00  ! Column 0
  $00  ! Column 2
  
  ! For table T28_soldado_conversation
  $00  ! Column 0
  $00  ! Column 2
  
  ! For table T30_doncella_conversation
  $00  ! Column 0
  $00  ! Column 2
  
  ! For table T32_hermano_conversation
  $00  ! Column 0
  $00  ! Column 2
  
  ! For table T34_hints
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $00  ! Column 3
  
  ! For table T35_escribir_en_libro_hints
  $00  ! Column 0
  $1f  ! Column 1
  
  ! For table T36_resolver_los_actos_hints
  $00 $00  ! Column 0
  $ff $01  ! Column 1
  
  ! For table T37_acabar_con_musa_hints
  $00  ! Column 0
  $ff  ! Column 1
  
  ! End of table
  NULL NULL;
Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T3_user_styles  T4_ordinary_status  T6_sample_options  T7_menu_commands  T8_shallow_menu_status  T9_deep_menu_status  T10_sample_hints  T12_basic_help_options  T13_instruction_options  T14_stuckness_advice  T15_if_elements  T16_setting_options  T17_quip_texts  T18_quip_followups  T19_ask_results  T20_tell_results  T21_no_conversation  T24_pastor_conversation  T26_ajusticiado_conversation  T28_soldado_conversation  T30_doncella_conversation  T32_hermano_conversation  T34_hints  T35_escribir_en_libro_hints  T36_resolver_los_actos_hints  T37_acabar_con_musa_hints  0 0;
[ TC_KOV 
    tc ! Implied call parameter
    ;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD0_rule; ! final response rule: rule
        104: return KD1_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return 10; ! window: g-window
        108: return 53; ! style name: glulx text style
        109: return TEXT_TY; ! background color: text
        110: return TEXT_TY; ! color: text
        111: return NUMBER_TY; ! first line indentation: number
        112: return TRUTH_STATE_TY; ! fixed width: truth state
        113: return 55; ! font weight: font weight
        114: return NUMBER_TY; ! indentation: number
        115: return TRUTH_STATE_TY; ! italic: truth state
        116: return 54; ! justification: text justification
        117: return NUMBER_TY; ! relative size: number
        118: return TRUTH_STATE_TY; ! reversed: truth state
        119: return TEXT_TY; ! left: text
        120: return TEXT_TY; ! central: text
        121: return TEXT_TY; ! right: text
        122: return TEXT_TY; ! title: text
        123: return TABLE_TY; ! subtable: table name
        124: return TEXT_TY; ! description: text
        125: return KD0_rule; ! toggle: rule
        126: return NUMBER_TY; ! number: number
        127: return KD0_rule; ! effect: rule
        128: return TEXT_TY; ! hint: text
        129: return NUMBER_TY; ! used: number
        130: return 57; ! quip: quip
        131: return TEXT_TY; ! quiptext: text
        132: return TEXT_TY; ! option: text
        133: return 57; ! result: quip
        134: return 10; ! npc: person
        135: return TEXT_TY; ! prompt: text
        136: return 57; ! response: quip
        137: return NUMBER_TY; ! enabled: number
    }
    return UNKNOWN_TY;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Equations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====





! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====




Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  0 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$00001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$00001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Burn  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Wake  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Think  $$00000000  OBJECT_TY OBJECT_TY  0 20046
  ##Smell  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Listen  $$00001001  OBJECT_TY OBJECT_TY  0 20048
  ##Taste  $$00001001  OBJECT_TY OBJECT_TY  0 20049
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20050
  ##Jump  $$00000000  OBJECT_TY OBJECT_TY  0 20051
  ##Tie  $$00011011  OBJECT_TY OBJECT_TY  0 20052
  ##Drink  $$00001001  OBJECT_TY OBJECT_TY  0 20053
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20054
  ##Swing  $$00001001  OBJECT_TY OBJECT_TY  0 20055
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20056
  ##SetTo  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20057
  ##WaveHands  $$00000000  OBJECT_TY OBJECT_TY  0 20058
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20059
  ##Climb  $$00001001  OBJECT_TY OBJECT_TY  0 20060
  ##Sleep  $$00000000  OBJECT_TY OBJECT_TY  0 20061
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20062
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20063
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20064
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20065
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20066
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20067
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20068
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20069
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20070
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20071
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20072
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20073
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20074
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20075
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20076
  ##A77_entering_to_room  $$00000000  OBJECT_TY OBJECT_TY  0 20077
  ##A78_bajando  $$00000000  OBJECT_TY OBJECT_TY  0 20078
  ##A79_subiendo  $$00000000  OBJECT_TY OBJECT_TY  0 20079
  ##A80_asking_for_help  $$00100000  OBJECT_TY OBJECT_TY  0 20080
  ##A81_requesting_a_recap  $$00100000  OBJECT_TY OBJECT_TY  0 20081
  ##A82_responding_with  $$00001000  NUMBER_TY OBJECT_TY  0 20082
  ##A83_talking_to  $$00001000  OBJECT_TY OBJECT_TY  0 20083
  ##A84_qbc_responding_with  $$00001000  NUMBER_TY OBJECT_TY  0 20084
  ##A85_qbc_recap  $$00100000  OBJECT_TY OBJECT_TY  0 20085
  ##A86_writing_it_in  $$00011010  UNDERSTANDING_TY OBJECT_TY  0 20086
  ##A87_writenothing  $$00000000  OBJECT_TY OBJECT_TY  0 20087
  ##A88_writenoun  $$00001001  OBJECT_TY OBJECT_TY  0 20088
  ##A89_rezaring  $$00000000  OBJECT_TY OBJECT_TY  0 20089
  ##A90_remembering  $$00000000  OBJECT_TY OBJECT_TY  0 20090
  ##A91_fucking  $$00001001  OBJECT_TY OBJECT_TY  0 20091
  ##A92_faping  $$00001001  OBJECT_TY OBJECT_TY  0 20092
  ##A93_singing  $$00000000  OBJECT_TY OBJECT_TY  0 20093
;
Constant AD_RECORDS = 94;
[ ANSTVC_7 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = I218_en_la_oscuridad; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ DB_Action_Details 
    act ! Implied call parameter
    n ! Implied call parameter
    s ! Implied call parameter
    for_say ! Implied call parameter
    ;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Burn: print "burning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wake: print "waking up"; 
        ##Think: print "thinking"; 
        ##Smell: print "smelling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Listen: print "listening to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Taste: print "tasting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Jump: print "jumping"; 
        ##Tie: print "tying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drink: print "drinking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Swing: print "swinging"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SetTo: print "setting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##WaveHands: print "waving hands"; 
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Climb: print "climbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sleep: print "sleeping"; 
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A77_entering_to_room: print "entering to room"; 
        ##A78_bajando: print "bajando"; 
        ##A79_subiendo: print "subiendo"; 
        ##A80_asking_for_help: print "asking for help"; 
        ##A81_requesting_a_recap: print "requesting a recap"; 
        ##A82_responding_with: print "responding with"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A83_talking_to: print "talking to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A84_qbc_responding_with: print "qbc responding with"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A85_qbc_recap: print "qbc recap"; 
        ##A86_writing_it_in: print "writing"; print " "; if (for_say == 2) print "it"; else DA_Topic(100*consult_from + consult_words); print " "; print "in"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A87_writenothing: print "writenothing"; 
        ##A88_writenoun: print "writenoun"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A89_rezaring: print "rezaring"; 
        ##A90_remembering: print "remembering"; 
        ##A91_fucking: print "fucking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A92_faping: print "faping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A93_singing: print "singing"; 
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Swing
    ##Rub ##SetTo ##WaveHands ##Buy ##Climb ##Sleep ##Quit ##Save
    ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff ##Version ##Score ##LMode3
    ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns ##A77_entering_to_room ##A78_bajando ##A79_subiendo
    ##A80_asking_for_help ##A81_requesting_a_recap ##A82_responding_with ##A83_talking_to ##A84_qbc_responding_with ##A85_qbc_recap ##A86_writing_it_in ##A87_writenothing
    ##A88_writenoun ##A89_rezaring ##A90_remembering ##A91_fucking ##A92_faping ##A93_singing;


Array ActionHappened --> 0 0 0 0 0 0;


[ InvSub ;
    return GenericVerbSub(131,132,133);
];
[ TakeSub ;
    return GenericVerbSub(134,135,136);
];
[ RemoveSub ;
    return GenericVerbSub(137,138,139);
];
[ DropSub ;
    return GenericVerbSub(140,141,142);
];
[ PutOnSub ;
    return GenericVerbSub(143,144,145);
];
[ InsertSub ;
    return GenericVerbSub(146,147,148);
];
[ EatSub ;
    return GenericVerbSub(149,150,151);
];
[ GoSub ;
    return GenericVerbSub(152,153,154);
];
[ EnterSub ;
    return GenericVerbSub(155,156,157);
];
[ ExitSub ;
    return GenericVerbSub(158,159,160);
];
[ GetOffSub ;
    return GenericVerbSub(161,162,163);
];
[ LookSub ;
    return GenericVerbSub(164,165,166);
];
[ ExamineSub ;
    return GenericVerbSub(167,168,169);
];
[ LookUnderSub ;
    return GenericVerbSub(170,171,172);
];
[ SearchSub ;
    return GenericVerbSub(173,174,175);
];
[ ConsultSub ;
    return GenericVerbSub(176,177,178);
];
[ LockSub ;
    return GenericVerbSub(179,180,181);
];
[ UnlockSub ;
    return GenericVerbSub(182,183,184);
];
[ SwitchOnSub ;
    return GenericVerbSub(185,186,187);
];
[ SwitchOffSub ;
    return GenericVerbSub(188,189,190);
];
[ OpenSub ;
    return GenericVerbSub(191,192,193);
];
[ CloseSub ;
    return GenericVerbSub(194,195,196);
];
[ WearSub ;
    return GenericVerbSub(197,198,199);
];
[ DisrobeSub ;
    return GenericVerbSub(200,201,202);
];
[ GiveSub ;
    return GenericVerbSub(203,204,205);
];
[ ShowSub ;
    return GenericVerbSub(206,207,208);
];
[ WakeOtherSub ;
    return GenericVerbSub(209,210,211);
];
[ ThrowAtSub ;
    return GenericVerbSub(212,213,214);
];
[ AttackSub ;
    return GenericVerbSub(215,216,217);
];
[ KissSub ;
    return GenericVerbSub(218,219,220);
];
[ AnswerSub ;
    return GenericVerbSub(221,222,223);
];
[ TellSub ;
    return GenericVerbSub(224,225,226);
];
[ AskSub ;
    return GenericVerbSub(227,228,229);
];
[ AskForSub ;
    return GenericVerbSub(230,231,232);
];
[ WaitSub ;
    return GenericVerbSub(233,234,235);
];
[ TouchSub ;
    return GenericVerbSub(236,237,238);
];
[ WaveSub ;
    return GenericVerbSub(239,240,241);
];
[ PullSub ;
    return GenericVerbSub(242,243,244);
];
[ PushSub ;
    return GenericVerbSub(245,246,247);
];
[ TurnSub ;
    return GenericVerbSub(248,249,250);
];
[ PushDirSub ;
    return GenericVerbSub(251,252,253);
];
[ SqueezeSub ;
    return GenericVerbSub(254,255,256);
];
[ YesSub ;
    return GenericVerbSub(257,258,259);
];
[ NoSub ;
    return GenericVerbSub(260,261,262);
];
[ BurnSub ;
    return GenericVerbSub(263,264,265);
];
[ WakeSub ;
    return GenericVerbSub(266,267,268);
];
[ ThinkSub ;
    return GenericVerbSub(269,270,271);
];
[ SmellSub ;
    return GenericVerbSub(272,273,274);
];
[ ListenSub ;
    return GenericVerbSub(275,276,277);
];
[ TasteSub ;
    return GenericVerbSub(278,279,280);
];
[ CutSub ;
    return GenericVerbSub(281,282,283);
];
[ JumpSub ;
    return GenericVerbSub(284,285,286);
];
[ TieSub ;
    return GenericVerbSub(287,288,289);
];
[ DrinkSub ;
    return GenericVerbSub(290,291,292);
];
[ SorrySub ;
    return GenericVerbSub(293,294,295);
];
[ SwingSub ;
    return GenericVerbSub(296,297,298);
];
[ RubSub ;
    return GenericVerbSub(299,300,301);
];
[ SetToSub ;
    return GenericVerbSub(302,303,304);
];
[ WaveHandsSub ;
    return GenericVerbSub(305,306,307);
];
[ BuySub ;
    return GenericVerbSub(308,309,310);
];
[ ClimbSub ;
    return GenericVerbSub(311,312,313);
];
[ SleepSub ;
    return GenericVerbSub(314,315,316);
];
[ QuitSub ;
    return GenericVerbSub(317,318,319);
];
[ SaveSub ;
    return GenericVerbSub(320,321,322);
];
[ RestoreSub ;
    return GenericVerbSub(323,324,325);
];
[ RestartSub ;
    return GenericVerbSub(326,327,328);
];
[ VerifySub ;
    return GenericVerbSub(329,330,331);
];
[ ScriptOnSub ;
    return GenericVerbSub(332,333,334);
];
[ ScriptOffSub ;
    return GenericVerbSub(335,336,337);
];
[ VersionSub ;
    return GenericVerbSub(338,339,340);
];
[ ScoreSub ;
    return GenericVerbSub(341,342,343);
];
[ LMode3Sub ;
    return GenericVerbSub(344,345,346);
];
[ LMode2Sub ;
    return GenericVerbSub(347,348,349);
];
[ LMode1Sub ;
    return GenericVerbSub(350,351,352);
];
[ NotifyOnSub ;
    return GenericVerbSub(353,354,355);
];
[ NotifyOffSub ;
    return GenericVerbSub(356,357,358);
];
[ PronounsSub ;
    return GenericVerbSub(359,360,361);
];
[ A77_entering_to_roomSub ;
    return GenericVerbSub(362,363,364);
];
[ A78_bajandoSub ;
    return GenericVerbSub(365,366,367);
];
[ A79_subiendoSub ;
    return GenericVerbSub(368,369,370);
];
[ A80_asking_for_helpSub ;
    return GenericVerbSub(377,378,379);
];
[ A81_requesting_a_recapSub ;
    return GenericVerbSub(383,384,385);
];
[ A82_responding_withSub ;
    return GenericVerbSub(386,387,388);
];
[ A83_talking_toSub ;
    return GenericVerbSub(390,391,392);
];
[ A84_qbc_responding_withSub ;
    return GenericVerbSub(393,394,395);
];
[ A85_qbc_recapSub ;
    return GenericVerbSub(396,397,398);
];
[ A86_writing_it_inSub ;
    return GenericVerbSub(427,428,429);
];
[ A87_writenothingSub ;
    return GenericVerbSub(430,431,432);
];
[ A88_writenounSub ;
    return GenericVerbSub(433,434,435);
];
[ A89_rezaringSub ;
    return GenericVerbSub(436,437,438);
];
[ A90_rememberingSub ;
    return GenericVerbSub(439,440,441);
];
[ A91_fuckingSub ;
    return GenericVerbSub(442,443,444);
];
[ A92_fapingSub ;
    return GenericVerbSub(445,446,447);
];
[ A93_singingSub ;
    return GenericVerbSub(448,449,450);
];

[ MistakeActionSub ;
    switch(understand_as_mistake_number) {
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Definitions of rules in rulebooks


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B0_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! This is the alternative virtual machine startup rule:
!   === equally specific with ===
! Rule 2/6 ! This is the declare everything initially unmentioned rule:
! --- now the mid-placed rules ---
! Rule 3/6 ! This is the when play begins stage rule:
!   === equally specific with ===
! Rule 4/6 ! This is the fix baseline scoring rule:
!   === equally specific with ===
! Rule 5/6 ! This is the display banner rule:
!   === equally specific with ===
! Rule 6/6 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! From "Alternative Startup Rules" by Dannii Willis
! No specific request
! This is the alternative virtual machine startup rule:
[ R_960 ;
    if (debug_rules) DB_Rule(R_960, 960);
    ! [2: carry out the starting the virtual machine activity]
    CarryOutActivity(V26_starting_the_virtual_mac);
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the declare everything initially unmentioned rule:
[ R_9 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_9, 9);
    ! [2: repeat with item running through things]
    for (tmp_0=Prop_0(0), tmp_1=Prop_0(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_0(tmp_1))
    {! [3: now the item is not mentioned]
        (Adj_78_t3_v10(tmp_0));
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the when play begins stage rule:
[ R_11 ;
    if (debug_rules) DB_Rule(R_11, 11);
    ! [2: follow the when play begins rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(4));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the fix baseline scoring rule:
[ R_12 ;
    if (debug_rules) DB_Rule(R_12, 12);
    ! [2: now the last notified score is the score]
    last_score = score;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the display banner rule:
[ R_13 ;
    if (debug_rules) DB_Rule(R_13, 13);
    ! [2: say ~[banner text]~]
    say__p=1;! [3: banner text]
    ParaContent(); Banner(); .L_Say0; .L_SayX0;rfalse;
];
! From the Standard Rules
! No specific request
! This is the initial room description rule:
[ R_14 ;
    if (debug_rules) DB_Rule(R_14, 14);
    ! [2: try looking]
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B1_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/13: PARSE_COMMAND_R
!   === equally specific with ===
! Rule 2/13 ! This is the declare everything initially unmentioned rule:
!   === equally specific with ===
! Rule 3/13: GENERATE_ACTION_R
!   === equally specific with ===
! Rule 4/13 ! A first turn sequence rule:
!   === equally specific with ===
! Rule 5/13 ! This is the reaction is instantaneous rule:
!   === equally specific with ===
! Rule 6/13 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 7/13: TIMED_EVENTS_R
!   === equally specific with ===
! Rule 8/13: ADVANCE_TIME_R
!   === equally specific with ===
! Rule 9/13: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 10/13 ! A last turn sequence rule:
!   === equally specific with ===
! Rule 11/13: ADJUST_LIGHT_R
!   === equally specific with ===
! Rule 12/13: NOTE_OBJECT_ACQUISITIONS_R
!   === equally specific with ===
! Rule 13/13 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A first turn sequence rule:
[ R_16 ;
    if (debug_rules) DB_Rule(R_16, 16);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From "Reactable Quips SP" by Michael Martin
! No specific request
! This is the reaction is instantaneous rule:
[ R_930 ;
    if (debug_rules) DB_Rule(R_930, 930);
    ! [2: if rq is active]
    if (((PHR_926_r2 ())))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_15 ;
    if (debug_rules) DB_Rule(R_15, 15);
    ! [2: follow the every turn rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(8));
    rfalse;
];
! From the Standard Rules
! No specific request
! A last turn sequence rule:
[ R_17 ;
    if (debug_rules) DB_Rule(R_17, 17);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the notify score changes rule:
[ R_18 ;
    if (debug_rules) DB_Rule(R_18, 18);
    ! [2: if the score is not the last notified score]
    if (((~~((score == last_score)))))
    {! [3: issue score notification message]
        NotifyTheScore();
        ! [4: now the last notified score is the score]
        last_score = score;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B2_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the when play ends stage rule:
[ R_19 ;
    if (debug_rules) DB_Rule(R_19, 19);
    ! [2: follow the when play ends rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(5));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the print player's obituary rule:
[ R_20 ;
    if (debug_rules) DB_Rule(R_20, 20);
    ! [2: carry out the printing the player's obituary activity]
    CarryOutActivity(V28_printing_the_player_s_ob);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B4_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! When play begins:
!   === equally specific with ===
! Rule 2/2 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! From "Menus SP" by Emily Short
! No specific request
! When play begins:
[ R_914 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_0();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_0 ;
    if (debug_rules) DB_Rule(R_914, 914);
    ! [2: now the current menu title is ~Instrucciones~]
    BlkValueCopy((Global_Vars-->14), TX_L_240);
    ! [3: now the left in row 3 of the table of deep menu status is ~ S = Siguiente~]
    BlkValueCopy(TableLookUpEntry(T9_deep_menu_status,119,3,5), TX_L_241);
    ! [4: now the left in row 4 of the table of deep menu status is ~ A = Anterior~]
    BlkValueCopy(TableLookUpEntry(T9_deep_menu_status,119,4,5), TX_L_242);
    ! [5: now the right in row 3 of the table of deep menu status is ~F = [if menu depth > 1]Ult. Menú[otherwise]Fin Menú[end if]~]
    BlkValueCopy(TableLookUpEntry(T9_deep_menu_status,121,3,5), (TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_193)));
    ! [6: now the right in row 4 of the table of deep menu status is ~ENTER = Selec.~]
    BlkValueCopy(TableLookUpEntry(T9_deep_menu_status,121,4,5), TX_L_243);
    ! [7: now the number in row 1 of the table of menu commands is 83]
    TableLookUpEntry(T7_menu_commands,126,1,1,83);
    ! [8: now the number in row 2 of the table of menu commands is 115]
    TableLookUpEntry(T7_menu_commands,126,2,1,115);
    ! [9: now the number in row 3 of the table of menu commands is 65]
    TableLookUpEntry(T7_menu_commands,126,3,1,65);
    ! [10: now the number in row 4 of the table of menu commands is 97]
    TableLookUpEntry(T7_menu_commands,126,4,1,97);
    ! [11: now the number in row 5 of the table of menu commands is 70]
    TableLookUpEntry(T7_menu_commands,126,5,1,70);
    ! [12: now the number in row 6 of the table of menu commands is 102]
    TableLookUpEntry(T7_menu_commands,126,6,1,102);
    rfalse;
];
! No specific request
! When play begins:
[ R_1107 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_1();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_1 
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_1107, 1107);
    ! [2: clear the screen]
    VM_ClearScreen(0);
    ! [3: play the sound of start]
    PlaySound(ResourceIDsOfSounds-->I217_sound_of_start, 0);
    ! [4: choose row 1 in table of basic help options]
    ct_0 = T12_basic_help_options; ct_1 = 1;
    ! [5: now description entry is ~[line break]Bienvenido a [bold type]La musa[roman type], una ficción interactiva escrita por Xavier Carrascosa e ilustrada por Mónica Clavijo, remake de la original de 2005 presentada en la XComp 1. Se trata de una aventura conversacional experimental en siete actos que puede resolverse con una sola orden. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?[paragraph break][italic type]'El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa.'[roman type][paragraph break][bold type]Premios recibidos:[roman type][paragraph break][bold type]XComp 1:[roman type][line break][italic type]Premio a la Mejor Aventura[roman type][line break][bold type]Premios Hispanos 2005:[roman type][line break][italic type]Nominada en las categorías de calidad literaria, interactividad y originalidad.[roman type]~]
    BlkValueCopy(TableLookUpEntry(ct_0,124,ct_1,5), ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_194)));
    ! [6: clear the screen]
    VM_ClearScreen(0);
    ! [7: display the figure portada]
    DisplayFigure(ResourceIDsOfFigures-->I203_figure_portada, 0);
    ! [8: wait for any key]
    KeyPause();
    ! [9: say ~[paragraph break][italic type]Maldita seas musa escurridiza,[line break]me entregas tus caricias y tu beso[line break]y junto las palabras cual poseso,[line break]hundiéndome en tu arena movediza.[paragraph break]Te marchas convirtiéndome en ceniza[line break]y siento sobre el cuello un lazo grueso[line break]que asfixia deseando tu regreso,[line break]creciendo esta obsesión casi enfermiza.[paragraph break]Maldita por mostrarme las estrellas,[line break]las risas, el azul, el universo,[line break]la luz, el llanto y tantas cosas bellas.[paragraph break]Te marchas y me muestras el adverso[line break]dejándome en mi pecho mil querellas,[line break]incapaz de escribir un solo verso.[roman type][paragraph break][bold type]Roberto Menéndez[roman type][paragraph break][fixed letter spacing]Pulsa una tecla para continuar...[variable letter spacing][paragraph break]~]
    say__p=1;! [10: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [11: italic type]
    ParaContent(); style underline;! [12: ~Maldita seas musa escurridiza,~]
    ParaContent(); print "Maldita seas musa escurridiza,";! [13: line break]
    ParaContent(); new_line;! [14: ~me entregas tus caricias y tu beso~]
    ParaContent(); print "me entregas tus caricias y tu beso";! [15: line break]
    ParaContent(); new_line;! [16: ~y junto las palabras cual poseso,~]
    ParaContent(); print "y junto las palabras cual poseso,";! [17: line break]
    ParaContent(); new_line;! [18: ~hundiéndome en tu arena movediza.~]
    ParaContent(); print "hundiéndome en tu arena movediza.";! [19: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [20: ~Te marchas convirtiéndome en ceniza~]
    ParaContent(); print "Te marchas convirtiéndome en ceniza";! [21: line break]
    ParaContent(); new_line;! [22: ~y siento sobre el cuello un lazo grueso~]
    ParaContent(); print "y siento sobre el cuello un lazo grueso";! [23: line break]
    ParaContent(); new_line;! [24: ~que asfixia deseando tu regreso,~]
    ParaContent(); print "que asfixia deseando tu regreso,";! [25: line break]
    ParaContent(); new_line;! [26: ~creciendo esta obsesión casi enfermiza.~]
    ParaContent(); print "creciendo esta obsesión casi enfermiza.";! [27: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [28: ~Maldita por mostrarme las estrellas,~]
    ParaContent(); print "Maldita por mostrarme las estrellas,";! [29: line break]
    ParaContent(); new_line;! [30: ~las risas, el azul, el universo,~]
    ParaContent(); print "las risas, el azul, el universo,";! [31: line break]
    ParaContent(); new_line;! [32: ~la luz, el llanto y tantas cosas bellas.~]
    ParaContent(); print "la luz, el llanto y tantas cosas bellas.";! [33: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [34: ~Te marchas y me muestras el adverso~]
    ParaContent(); print "Te marchas y me muestras el adverso";! [35: line break]
    ParaContent(); new_line;! [36: ~dejándome en mi pecho mil querellas,~]
    ParaContent(); print "dejándome en mi pecho mil querellas,";! [37: line break]
    ParaContent(); new_line;! [38: ~incapaz de escribir un solo verso.~]
    ParaContent(); print "incapaz de escribir un solo verso.";! [39: roman type]
    ParaContent(); style roman;! [40: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [41: bold type]
    ParaContent(); style bold;! [42: ~Roberto Menéndez~]
    ParaContent(); print "Roberto Menéndez";! [43: roman type]
    ParaContent(); style roman;! [44: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [45: fixed letter spacing]
    ParaContent(); font off;! [46: ~Pulsa una tecla para continuar...~]
    ParaContent(); print "Pulsa una tecla para continuar...";! [47: variable letter spacing]
    ParaContent(); font on;! [48: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say1; .L_SayX1;! [49: wait for any key]
    KeyPause();
    ! [50: say ~[line break]Bienvenido a [bold type]'La musa'[roman type], ficción interactiva experimental escrita por Xavier Carrascosa con ilustraciones de Mónica Clavijo.[paragraph break]~]
    say__p=1;! [51: line break]
    ParaContent(); new_line;! [52: ~Bienvenido a ~]
    ParaContent(); print "Bienvenido a ";! [53: bold type]
    ParaContent(); style bold;! [54: ~'La musa'~]
    ParaContent(); print "~La musa~";! [55: roman type]
    ParaContent(); style roman;! [56: ~, ficción interactiva experimental escrita por Xavier Carrascosa con ilustraciones de Mónica Clavijo.~]
    ParaContent(); print ", ficción interactiva experimental escrita por Xavier Carrascosa con ilustraciones de Mónica Clavijo.";! [57: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say2; .L_SayX2;! [58: say ~Esta obra contiene pasajes que pueden herir la sensibilidad de algunos jugadores. No está indicada para menores de 18 años.[paragraph break]~]
    say__p=1;! [59: ~Esta obra contiene pasajes que pueden herir la sensibilidad de algunos jugadores. No está indicada para menores de 18 años.~]
    ParaContent(); print "Esta obra contiene pasajes que pueden herir la sensibilidad de algunos jugadores. No está indicada para menores de 18 años.";! [60: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say3; .L_SayX3;! [61: say ~Si es la primera vez que juegas teclea [bold type]'AYUDA'[roman type] durante la partida.[paragraph break][fixed letter spacing]Pulsa una tecla para empezar...[variable letter spacing][paragraph break]~]
    say__p=1;! [62: ~Si es la primera vez que juegas teclea ~]
    ParaContent(); print "Si es la primera vez que juegas teclea ";! [63: bold type]
    ParaContent(); style bold;! [64: ~'AYUDA'~]
    ParaContent(); print "~AYUDA~";! [65: roman type]
    ParaContent(); style roman;! [66: ~ durante la partida.~]
    ParaContent(); print " durante la partida.";! [67: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [68: fixed letter spacing]
    ParaContent(); font off;! [69: ~Pulsa una tecla para empezar...~]
    ParaContent(); print "Pulsa una tecla para empezar...";! [70: variable letter spacing]
    ParaContent(); font on;! [71: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say4; .L_SayX4;! [72: wait for any key]
    KeyPause();
    ! [73: clear the screen]
    VM_ClearScreen(0);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B6_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_65 
    tmp_0 ! Let/loop value, e.g., 'event': scene
    ;
    if ((((tmp_0 = parameter_value, (((true) && (tmp_0=(parameter_value), true))))) || (tmp_0 = I78_entire_game,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_65, 65);
    ! [2: if the description of the event is not ~~]
    if (((~~(( BlkValueCompare(GProperty(SCENE_TY, tmp_0,description), EMPTY_TEXT_VALUE) == 0)))))
    {! [3: say ~[description of the event][paragraph break]~]
        say__p=1;! [4: description of the event]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(SCENE_TY, self=tmp_0,description);@pull self; ! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say5; .L_SayX5;}
        } else if (debug_rules > 1) DB_Rule(R_65, 65, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B9_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! This is the announce items from multiple object lists rule:
!   === equally specific with ===
! Rule 2/11 ! This is the set pronouns from items from multiple object lists rule:
!   === equally specific with ===
! Rule 3/11 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/11: BASIC_VISIBILITY_R
!   === equally specific with ===
! Rule 5/11: BASIC_ACCESSIBILITY_R
!   === equally specific with ===
! Rule 6/11: CARRYING_REQUIREMENTS_R
! --- now the last-placed rules ---
! Rule 7/11 ! This is the instead stage rule:
!   === equally specific with ===
! Rule 8/11: REQUESTED_ACTIONS_REQUIRE_R
!   === equally specific with ===
! Rule 9/11: CARRY_OUT_REQUESTED_ACTIONS_R
!   === equally specific with ===
! Rule 10/11: DESCEND_TO_SPECIFIC_ACTION_R
!   === equally specific with ===
! Rule 11/11 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the announce items from multiple object lists rule:
[ R_22 ;
    if (debug_rules) DB_Rule(R_22, 22);
    ! [2: if the current item from the multiple object list is not nothing]
    if (((~~((multiple_object_item == nothing)))))
    {! [3: say ~[current item from the multiple object list]: [run paragraph on]~ ( a )]
        say__p=1;! [4: ~[current item from the multiple object list]: [run paragraph on]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_134); .L_Say6; .L_SayX6;}
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the set pronouns from items from multiple object lists rule:
[ R_21 ;
    if (debug_rules) DB_Rule(R_21, 21);
    ! [2: if the current item from the multiple object list is not nothing]
    if (((~~((multiple_object_item == nothing)))))
    {! [3: set pronouns from the current item from the multiple object list]
        PronounNotice(multiple_object_item);
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the before stage rule:
[ R_23 ;
    if (debug_rules) DB_Rule(R_23, 23);
    ! [2: abide by the before rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(19))) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the instead stage rule:
[ R_24 ;
    if (debug_rules) DB_Rule(R_24, 24);
    ! [2: abide by the instead rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(20))) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the end action-processing in success rule:
[ R_25 ;
    if (debug_rules) DB_Rule(R_25, 25);
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B10_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === equally specific with ===
! Rule 2/3 ! Setting action variables for exiting:
!   === equally specific with ===
! Rule 3/3 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_151 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_2();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_2 
    tmp_0 ! Let/loop value, e.g., 'carriage': vehicle
    tmp_1 ! Let/loop value, e.g., 'target': object
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((action ==##Go)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_151, 151);
    ! [2: now the thing gone with is the item-pushed-between-rooms]
    (MStack-->MstVO(20007,4)) = move_pushing;
    ! [3: now the room gone from is the location of the actor]
    (MStack-->MstVO(20007,0)) = LocationOf(actor);
    ! [4: if the actor is in an enterable vehicle ( called the carriage )]
    if (((ContainerOf(actor) ofclass K14_vehicle) && ((Adj_80_t1_v10(ContainerOf(actor)))) && (tmp_0=(ContainerOf(actor)), true)))
    {! [5: now the vehicle gone by is the carriage]
        (MStack-->MstVO(20007,3)) = tmp_0;
        }
    ! [6: let the target be nothing]

    		tmp_1 = nothing;
    ! [7: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [8: let direction d be the noun]

        		tmp_2 = noun;
        ! [9: let the target be the room-or-door direction d from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2287, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        } else {
        ! [10: if the noun is a door]
        if (((noun ofclass K4_door)))
        {! [11: let the target be the noun]
            tmp_1 = noun;
            }
            }
    ! [12: if the target is a door]
    if (((tmp_1 ofclass K4_door)))
    {! [13: now the door gone through is the target]
        (MStack-->MstVO(20007,2)) = tmp_1;
        ! [14: now the target is the other side of the target from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2292, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        }
    ! [15: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_1;
    } else if (debug_rules > 1) DB_Rule(R_151, 151, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for exiting:
[ R_174 ;
    if ((((action ==##Exit)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_174, 174);
    ! [2: now the container exited from is the holder of the actor]
    (MStack-->MstVO(20009,0)) = (HolderOf(actor));
    } else if (debug_rules > 1) DB_Rule(R_174, 174, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_186 ;
    if ((((action ==##Look)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_186, 186);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: calculate visibility ceiling at low level]
        FindVisibilityLevels();
        }
    ! [4: now the visibility level count is the visibility ceiling count calculated]
    (MStack-->MstVO(20011,2)) = visibility_levels;
    ! [5: now the visibility ceiling is the visibility ceiling calculated]
    (MStack-->MstVO(20011,3)) = visibility_ceiling;
    ! [6: now the room-describing action is the looking action]
    (MStack-->MstVO(20011,0)) = ##Look;
    } else if (debug_rules > 1) DB_Rule(R_186, 186, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B11_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_26 ;
    if (debug_rules) DB_Rule(R_26, 26);
    ! [2: follow the player's action awareness rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
    ! [3: if rule succeeded]
    if (((RulebookSucceeded())))
    {! [4: now within the player's sight is true]
        (MStack-->MstVO(11,5)) = 1;
        } else {
        ! [5: now within the player's sight is false]
        (MStack-->MstVO(11,5)) = 0;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the check stage rule ):
[ R_27 ;
    if (debug_rules) DB_Rule(R_27, 27);
    ! [2: anonymously abide by the specific check rulebook]
    if (temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,2))))) {
    		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
    		else ActRulebookFails(temporary_value);
    		return 2;
    	}
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_28 ;
    if (debug_rules) DB_Rule(R_28, 28);
    ! [2: follow the specific carry out rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,3))));
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the after stage rule ):
[ R_29 ;
    if (debug_rules) DB_Rule(R_29, 29);
    ! [2: if action in world is true]
    if (((((MStack-->MstVO(11,0)) && true) == (1 && true))))
    {! [3: abide by the after rules]
        if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(23))) rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_30 ;
    if (debug_rules) DB_Rule(R_30, 30);
    ! [2: if within the player's sight is false]
    if (((((MStack-->MstVO(11,5)) && true) == (0 && true))))
    {! [3: follow the player's action awareness rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
        ! [4: if rule succeeded]
        if (((RulebookSucceeded())))
        {! [5: now within the player's sight is true]
            (MStack-->MstVO(11,5)) = 1;
            }
            }
            rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the report stage rule ):
[ R_31 ;
    if (debug_rules) DB_Rule(R_31, 31);
    ! [2: if within the player's sight is true and action keeping silent is false]
    if ((((((MStack-->MstVO(11,5)) && true) == (1 && true)))) && (((((MStack-->MstVO(11,1)) && true) == (0 && true)))))
    {! [3: follow the specific report rulebook]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,4))));
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! The last specific action-processing rule:
[ R_32 ;
    if (debug_rules) DB_Rule(R_32, 32);
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B12_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_33 ;
    if (debug_rules) DB_Rule(R_33, 33);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_34 ;
    if (debug_rules) DB_Rule(R_34, 34);
    ! [2: if the player is not the actor and the player can see the actor]
    if ((((~~((player == actor))))) && (((TestVisibility(player,actor)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_35 ;
    if (debug_rules) DB_Rule(R_35, 35);
    ! [2: if the noun is a thing and the player can see the noun]
    if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_36 ;
    if (debug_rules) DB_Rule(R_36, 36);
    ! [2: if the second noun is a thing and the player can see the second noun]
    if ((((second ofclass K2_thing))) && (((TestVisibility(player,second)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B16_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_37 ;
    if (debug_rules) DB_Rule(R_37, 37);
    ! [2: if in darkness]
    if (((location==thedark)))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B19_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/15 ! Before doing something when the pertinent quip is not quip_null ( this is the force conversation rule ):
! --- now the mid-placed rules ---
! Rule 2/15 ! Before asking someone about ( this is the reject asking for talking rule ):
!   === equally specific with ===
! Rule 3/15 ! Before telling someone about ( this is the reject telling for talking rule ):
!   === equally specific with ===
! Rule 4/15 ! Before answering someone that ( this is the reject answering for talking rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 5/15 ! Before asking someone to try doing something ( this is the reject commanding for talking rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 6/15 ! Before looking when the location is En la oscuridad:
!   === equally specific with ===
! Rule 7/15 ! Before looking when the location is Primer Acto:
!   === equally specific with ===
! Rule 8/15 ! Before looking when the location is Segundo Acto:
!   === equally specific with ===
! Rule 9/15 ! Before looking when the location is Tercer Acto:
!   === equally specific with ===
! Rule 10/15 ! Before looking when the location is Cuarto Acto:
!   === equally specific with ===
! Rule 11/15 ! Before looking when the location is Quinto Acto:
!   === equally specific with ===
! Rule 12/15 ! Before looking when the location is Sexto Acto:
!   === equally specific with ===
! Rule 13/15 ! Before looking when the location is Septimo Acto:
!   >>> I - Number of aspects constrained >>>
! Rule 14/15 ! Before going:
!   === equally specific with ===
! Rule 15/15 ! Before sleeping:
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Before doing something when the pertinent quip is not quip_null ( this is the force conversation rule ):
[ R_929 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, STORED_ACTION_TY);
    BlkValueCreateOnStack(1, STORED_ACTION_TY);
    BlkValueCreateOnStack(0, STORED_ACTION_TY);
    I7RBLK = KERNEL_3();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_3 ;
    if ((( (actor==player) && (self=actor,true) && (((~~(((Global_Vars-->18) == I152_quip_null)))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_929, 929);
    ! [2: unless the current action is requesting a recap or the current action is responding with]
    if (~~(((( BlkValueCompare(STORED_ACTION_TY_Current(I7SFRAME), TryAction(0, player, ##A81_requesting_a_recap, 0, 0, STORED_ACTION_TY_Current((I7SFRAME+WORDSIZE)))) == 0))) || (((((STORED_ACTION_TY_Adopt(STORED_ACTION_TY_Current((I7SFRAME+WORDSIZE*2))), SAT_Tmp-->0=((((action ==##A82_responding_with) &&  (actor==player)))), STORED_ACTION_TY_Unadopt())))))))
    {! [3: say ~[RQ reaction demand][paragraph break]~]
        say__p=1;! [4: rq reaction demand]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->22);! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say7; .L_SayX7;! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_929, 929, 'action');
        rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Before asking someone about ( this is the reject asking for talking rule ):
[ R_937 ;
    if ((((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_937, 937);
    ! [2: clue talking]
    (PHR_941_r3 ());
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_937, 937, 'action');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Before telling someone about ( this is the reject telling for talking rule ):
[ R_938 ;
    if ((((action ==##Tell) &&  (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_938, 938);
    ! [2: clue talking]
    (PHR_941_r3 ());
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_938, 938, 'action');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Before answering someone that ( this is the reject answering for talking rule ):
[ R_939 ;
    if ((((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_939, 939);
    ! [2: clue talking]
    (PHR_941_r3 ());
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_939, 939, 'action');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Before asking someone to try doing something ( this is the reject commanding for talking rule ):
[ R_940 ;
    if ((( (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_940, 940);
    ! [2: clue talking]
    (PHR_941_r3 ());
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_940, 940, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is En la oscuridad:
[ R_1119 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I218_en_la_oscuridad)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1119, 1119);
    ! [2: display the figure musa vigilante]
    DisplayFigure(ResourceIDsOfFigures-->I207_figure_musa_vigilante, 0);
    ! [3: play the sound of ending]
    PlaySound(ResourceIDsOfSounds-->I215_sound_of_ending, 0);
    ! [4: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1119, 1119, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Primer Acto:
[ R_1120 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I224_primer_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1120, 1120);
    ! [2: display the figure musa riendo]
    DisplayFigure(ResourceIDsOfFigures-->I206_figure_musa_riendo, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1120, 1120, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Segundo Acto:
[ R_1121 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I225_segundo_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1121, 1121);
    ! [2: display the figure soldado]
    DisplayFigure(ResourceIDsOfFigures-->I210_figure_soldado, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1121, 1121, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Tercer Acto:
[ R_1122 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I226_tercer_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1122, 1122);
    ! [2: display the figure reo]
    DisplayFigure(ResourceIDsOfFigures-->I211_figure_reo, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1122, 1122, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Cuarto Acto:
[ R_1123 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I227_cuarto_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1123, 1123);
    ! [2: display the figure doncella]
    DisplayFigure(ResourceIDsOfFigures-->I212_figure_doncella, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1123, 1123, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Quinto Acto:
[ R_1124 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I228_quinto_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1124, 1124);
    ! [2: display the figure mercader]
    DisplayFigure(ResourceIDsOfFigures-->I213_figure_mercader, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1124, 1124, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Sexto Acto:
[ R_1125 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I229_sexto_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1125, 1125);
    ! [2: display the figure cultista]
    DisplayFigure(ResourceIDsOfFigures-->I214_figure_cultista, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1125, 1125, 'action');
    rfalse;
];
! No specific request
! Before looking when the location is Septimo Acto:
[ R_1126 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I230_septimo_acto)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1126, 1126);
    ! [2: display the figure pastor]
    DisplayFigure(ResourceIDsOfFigures-->I209_figure_pastor, 0);
    ! [3: wait for any key]
    KeyPause();
    } else if (debug_rules > 1) DB_Rule(R_1126, 1126, 'action');
    rfalse;
];
! No specific request
! Before going:
[ R_1108 ;
    if ((((action ==##Go) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1108, 1108);
    ! [2: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1108, 1108, 'action');
    rfalse;
];
! No specific request
! Before sleeping:
[ R_1150 ;
    if ((((action ==##Sleep) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1150, 1150);
    ! [2: if the player is in primer acto]
    if (((I224_primer_acto == ContainerOf(player))))
    {! [3: say ~Plácidamente te recuestas y cierras los ojos, sumiéndote de nuevo en la imperante oscuridad que te envuelve siempre que tu musa está contigo.[paragraph break]~]
        say__p=1;! [4: ~Plácidamente te recuestas y cierras los ojos, sumiéndote de nuevo en la imperante oscuridad que te envuelve siempre que tu musa está contigo.~]
        ParaContent(); print "Plácidamente te recuestas y cierras los ojos, sumiéndote de nuevo en la imperante oscuridad que te envuelve siempre que tu musa está contigo.";! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say8; .L_SayX8;! [6: wait for any key]
        KeyPause();
        ! [7: say ~En tus manos está la pluma y delante otra página en blanco del libro.[paragraph break]~]
        say__p=1;! [8: ~En tus manos está la pluma y delante otra página en blanco del libro.~]
        ParaContent(); print "En tus manos está la pluma y delante otra página en blanco del libro.";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say9; .L_SayX9;! [10: now the player carries the pluma]
        MoveObject(I219_pluma,player);
        ! [11: now the musa is espectante]
        (Adj_106_t2_v10(I220_musa));
        ! [12: increase the pecados by 1]
        (Global_Vars-->34) = (Global_Vars-->34) + 1;;
        ! [13: wait for any key]
        KeyPause();
        ! [14: clear the screen]
        VM_ClearScreen(0);
        ! [15: now the player is in en la oscuridad]
        MoveObject(player,I218_en_la_oscuridad);
        ! [16: stop the action]
        rtrue;
        } else {
        ! [17: if the player is in septimo acto]
        if (((I230_septimo_acto == ContainerOf(player))))
        {! [18: say ~[italic type]'No, ahora no es momento de dormir...'[roman type], dice la musa.[paragraph break]~]
            say__p=1;! [19: italic type]
            ParaContent(); style underline;! [20: ~'No, ahora no es momento de dormir...'~]
            ParaContent(); print "~No, ahora no es momento de dormir...~";! [21: roman type]
            ParaContent(); style roman;! [22: ~, dice la musa.~]
            ParaContent(); print ", dice la musa.";! [23: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say10; .L_SayX10;rtrue;
            } else {
            ! [25: if the player is in en la oscuridad]
            if (((I218_en_la_oscuridad == ContainerOf(player))))
            {! [26: say ~[italic type]'Duerme, descansa bien, no tenemos ninguna prisa aquí'[roman type], dice la musa.[paragraph break]~]
                say__p=1;! [27: italic type]
                ParaContent(); style underline;! [28: ~'Duerme, descansa bien, no tenemos ninguna prisa aquí'~]
                ParaContent(); print "~Duerme, descansa bien, no tenemos ninguna prisa aquí~";! [29: roman type]
                ParaContent(); style roman;! [30: ~, dice la musa.~]
                ParaContent(); print ", dice la musa.";! [31: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say11; .L_SayX11;rtrue;
                }
                }
                }
                } else if (debug_rules > 1) DB_Rule(R_1150, 1150, 'action');
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B20_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/91 ! Instead of going up in Sexto acto:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 2/91 ! Instead of burning something in the presence of the hoguera:
!   >>> III.2.3 - Action/Where/In The Presence Of >>>
! Rule 3/91 ! Instead of going dentro when the player is in Sexto acto:
!   === equally specific with ===
! Rule 4/91 ! Instead of going down when the player is in altar:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 5/91 ! Instead of examining or taking the piedra for the first time:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 6/91 ! Instead of drinking some edible when the player is in Sexto acto:
!   === equally specific with ===
! Rule 7/91 ! Instead of drinking some edible when the player is in the altar:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 8/91 ! Instead of examining something edible when the player is in Segundo acto:
!   === equally specific with ===
! Rule 9/91 ! Instead of eating something edible when the player is in Segundo acto:
!   === equally specific with ===
! Rule 10/91 ! Instead of smelling something edible when the player is in altar:
!   === equally specific with ===
! Rule 11/91 ! Instead of smelling something edible when the player is in Sexto acto:
!   === equally specific with ===
! Rule 12/91 ! Instead of tasting something edible when the player is in altar:
!   === equally specific with ===
! Rule 13/91 ! Instead of tasting something edible when the player is in Sexto acto:
!   === equally specific with ===
! Rule 14/91 ! Instead of eating something edible when the player is in Sexto acto:
!   === equally specific with ===
! Rule 15/91 ! Instead of eating something edible when the player is in altar:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 16/91 ! Instead of smelling or tasting or taking something edible when the player is in Segundo acto:
!   === equally specific with ===
! Rule 17/91 ! Instead of taking or smelling or tasting something edible when the player is in Sexto acto:
!   >>> I - Number of aspects constrained >>>
! Rule 18/91 ! Instead of throwing the piedra at the musa:
!   === equally specific with ===
! Rule 19/91 ! Instead of inserting the almohada into the mercader:
!   === equally specific with ===
! Rule 20/91 ! Instead of putting the almohada on the mercader:
!   === equally specific with ===
! Rule 21/91 ! Instead of throwing the piedra at the hermano:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 22/91 ! Instead of attacking the pluma:
!   === equally specific with ===
! Rule 23/91 ! Instead of attacking the ojos:
!   === equally specific with ===
! Rule 24/91 ! Instead of attacking the presencia:
!   === equally specific with ===
! Rule 25/91 ! Instead of talking to the musa:
!   === equally specific with ===
! Rule 26/91 ! Instead of talking to the presencia:
!   === equally specific with ===
! Rule 27/91 ! Instead of touching the libro:
!   === equally specific with ===
! Rule 28/91 ! Instead of talking to las ovejas:
!   === equally specific with ===
! Rule 29/91 ! Instead of taking the ovejas:
!   === equally specific with ===
! Rule 30/91 ! Instead of talking to the guerreros:
!   === equally specific with ===
! Rule 31/91 ! Instead of taking the espada:
!   === equally specific with ===
! Rule 32/91 ! Instead of attacking the soldado:
!   === equally specific with ===
! Rule 33/91 ! Instead of taking the cepillo:
!   === equally specific with ===
! Rule 34/91 ! Instead of fucking the doncella:
!   === equally specific with ===
! Rule 35/91 ! Instead of taking the almohadas:
!   === equally specific with ===
! Rule 36/91 ! Instead of talking to the mercader:
!   === equally specific with ===
! Rule 37/91 ! Instead of attacking the mercader:
!   === equally specific with ===
! Rule 38/91 ! Instead of taking the diamante:
!   === equally specific with ===
! Rule 39/91 ! Instead of talking to the fieles:
!   === equally specific with ===
! Rule 40/91 ! Instead of entering the altar:
!   === equally specific with ===
! Rule 41/91 ! Instead of getting off the altar:
!   === equally specific with ===
! Rule 42/91 ! Instead of examining the piedras:
!   === equally specific with ===
! Rule 43/91 ! Instead of taking the piedras:
!   === equally specific with ===
! Rule 44/91 ! Instead of attacking the hermano:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 45/91 ! Instead of smelling or tasting the musa:
!   === equally specific with ===
! Rule 46/91 ! Instead of smelling or tasting the libro:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 47/91 ! Instead of fucking or kissing or touching the musa:
!   === equally specific with ===
! Rule 48/91 ! Instead of fucking or kissing or touching the ojos:
!   === equally specific with ===
! Rule 49/91 ! Instead of pulling or pushing or attacking the libro:
!   === equally specific with ===
! Rule 50/91 ! Instead of talking to or attacking or taking the verdugos:
!   === equally specific with ===
! Rule 51/91 ! Instead of eating or drinking or tasting the ternero:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 52/91 ! Instead of attacking or pulling or pushing or waving the musa:
!   === equally specific with ===
! Rule 53/91 ! Instead of touching or pushing or pulling or waving the paisaje:
!   === equally specific with ===
! Rule 54/91 ! Instead of touching or pushing or pulling or waving the ovejas:
!   === equally specific with ===
! Rule 55/91 ! Instead of touching or smelling or tasting or kissing the doncella:
!   === equally specific with ===
! Rule 56/91 ! Instead of pulling or pushing or waving or attacking the doncella:
!   === equally specific with ===
! Rule 57/91 ! Instead of pulling or pushing or waving or attacking the almohadas:
!   === equally specific with ===
! Rule 58/91 ! Instead of pulling or pushing or waving or attacking the diamante:
!   === equally specific with ===
! Rule 59/91 ! Instead of pulling or pushing or waving or attacking the ternero:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 60/91 ! Instead of closing or opening or pulling or waving or pushing the musa:
!   === equally specific with ===
! Rule 61/91 ! Instead of taking or pulling or pushing or waving or attacking the heridas:
!   === equally specific with ===
! Rule 62/91 ! Instead of taking or pulling or pushing or waving or attacking the mano:
!   === equally specific with ===
! Rule 63/91 ! Instead of taking or pulling or pushing or waving or attacking the soldado:
!   === equally specific with ===
! Rule 64/91 ! Instead of touching or pulling or pushing or waving or attacking the espejo:
!   === equally specific with ===
! Rule 65/91 ! Instead of touching or pulling or pushing or waving or attacking the butaca:
!   === equally specific with ===
! Rule 66/91 ! Instead of touching or pulling or pushing or waving or attacking the cepillo:
!   === equally specific with ===
! Rule 67/91 ! Instead of touching or pulling or pushing or waving or attacking the cabello:
!   === equally specific with ===
! Rule 68/91 ! Instead of taking or pulling or pushing or waving or attacking the telas:
!   === equally specific with ===
! Rule 69/91 ! Instead of taking or pulling or pushing or waving or attacking the cojines:
!   === equally specific with ===
! Rule 70/91 ! Instead of taking or pulling or pushing or waving or attacking the mercader:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 71/91 ! Instead of examining or closing or opening or pulling or waving or pushing the ojos:
!   === equally specific with ===
! Rule 72/91 ! Instead of taking or attacking or touching or pushing or pulling or waving the guerreros:
!   === equally specific with ===
! Rule 73/91 ! Instead of taking or attacking or touching or pushing or pulling or waving the armas:
!   === equally specific with ===
! Rule 74/91 ! Instead of taking or touching or pulling or pushing or waving or attacking the enredos:
!   === equally specific with ===
! Rule 75/91 ! Instead of taking or pulling or pushing or waving or attacking or touching the hoguera:
!   === equally specific with ===
! Rule 76/91 ! Instead of pulling or pushing or waving or kissing or touching or smelling the hermano:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 77/91 ! Instead of pulling or pushing or attacking or waving or kissing or touching or smelling the ajusticiado:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 78/91 ! Instead of taking or pulling or pushing or attacking or waving or kissing or touching or smelling the pastor:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 79/91 ! Instead of listening when the player is in Primer acto:
!   === equally specific with ===
! Rule 80/91 ! Instead of smelling when the player is in Primer acto:
!   === equally specific with ===
! Rule 81/91 ! Instead of listening when the player is in Segundo acto:
!   === equally specific with ===
! Rule 82/91 ! Instead of smelling when the player is in Segundo acto:
!   === equally specific with ===
! Rule 83/91 ! Instead of listening when the player is in Quinto acto:
!   === equally specific with ===
! Rule 84/91 ! Instead of smelling when the player is in Quinto acto:
!   === equally specific with ===
! Rule 85/91 ! Instead of listening when the player is in Sexto acto:
!   === equally specific with ===
! Rule 86/91 ! Instead of smelling when the player is in Sexto acto:
!   === equally specific with ===
! Rule 87/91 ! Instead of smelling when the player is in altar:
!   === equally specific with ===
! Rule 88/91 ! Instead of exiting when the player is in altar:
!   === equally specific with ===
! Rule 89/91 ! Instead of listening when the player is in Septimo acto:
!   === equally specific with ===
! Rule 90/91 ! Instead of smelling when the player is in Septimo acto:
!   >>> I - Number of aspects constrained >>>
! Rule 91/91 ! Instead of thinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Instead of going up in Sexto acto:
[ R_1215 ;
    if ((((action ==##Go) &&  (actor==player) && ((noun == I59_up) && (true)) && ((real_location == I229_sexto_acto) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1215, 1215);
    ! [2: try silently entering the altar]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##Enter, I274_altar, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1215, 1215, 'action');
    rfalse;
];
! No specific request
! Instead of burning something in the presence of the hoguera:
[ R_1210 ;
    if ((((action ==##Burn) &&  (actor==player) && ((noun ofclass K2_thing)) && (((I273_hoguera == I273_hoguera) && (true))&& (TestScope(I273_hoguera, actor)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1210, 1210);
    ! [2: say ~El fuego purificador vendrá después, ahora haz lo que tienes que hacer.~]
    say__p=1;! [3: ~El fuego purificador vendrá después, ahora haz lo que tienes que hacer.~]
    ParaContent(); print "El fuego purificador vendrá después, ahora haz lo que tienes que hacer."; new_line; .L_Say12; .L_SayX12;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1210, 1210, 'action');
    rfalse;
];
! No specific request
! Instead of going dentro when the player is in Sexto acto:
[ R_1214 ;
    if ((((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1214, 1214);
    ! [2: try silently entering the altar]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##Enter, I274_altar, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1214, 1214, 'action');
    rfalse;
];
! No specific request
! Instead of going down when the player is in altar:
[ R_1217 ;
    if ((((action ==##Go) &&  (actor==player) && ((noun == I60_down) && (true)) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1217, 1217);
    ! [2: try silently getting off the altar]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##GetOff, I274_altar, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1217, 1217, 'action');
    rfalse;
];
! No specific request
! Instead of examining or taking the piedra for the first time:
[ R_1219 ;
    if ((PAPR_0() && (((TimesActionHasHappened-->0) == 1) && (ActionCurrentlyHappeningFlag->0)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1219, 1219);
    ! [2: now the piedra is portable]
    (Adj_69_t2_v10(I276_piedra));
    ! [3: now the player carries the piedra]
    MoveObject(I276_piedra,player);
    ! [4: say ~Observas una de las piedras que forman este altar madito. La recoges. Cabe perfectamente en la palma de tu mano. Servirá.[paragraph break][italic type]'Así es como debe ser'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [5: ~Observas una de las piedras que forman este altar madito. La recoges. Cabe perfectamente en la palma de tu mano. Servirá.~]
    ParaContent(); print "Observas una de las piedras que forman este altar madito. La recoges. Cabe perfectamente en la palma de tu mano. Servirá.";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [7: italic type]
    ParaContent(); style underline;! [8: ~'Así es como debe ser'~]
    ParaContent(); print "~Así es como debe ser~";! [9: roman type]
    ParaContent(); style roman;! [10: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say13; .L_SayX13;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1219, 1219, 'action');
    rfalse;
];
! No specific request
! Instead of drinking some edible when the player is in Sexto acto:
[ R_1222 ;
    if ((((action ==##Drink) &&  (actor==player) && (((Adj_66_t1_v10(noun))) && (true)) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1222, 1222);
    ! [2: try eating the noun]
    TryAction(0, player, ##Eat, noun, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1222, 1222, 'action');
    rfalse;
];
! No specific request
! Instead of drinking some edible when the player is in the altar:
[ R_1223 ;
    if ((((action ==##Drink) &&  (actor==player) && (((Adj_66_t1_v10(noun))) && (true)) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1223, 1223);
    ! [2: try eating the noun]
    TryAction(0, player, ##Eat, noun, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1223, 1223, 'action');
    rfalse;
];
! No specific request
! Instead of examining something edible when the player is in Segundo acto:
[ R_1157 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I225_segundo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1157, 1157);
    ! [2: say ~Es un banquete compuesto de un asado especiado, frutas y demás delicias para el paladar.[paragraph break][italic type]'¡Cómete [the noun]!'[roman type], te dice la musa desde algún lugar invisible.[paragraph break]~]
    say__p=1;! [3: ~Es un banquete compuesto de un asado especiado, frutas y demás delicias para el paladar.~]
    ParaContent(); print "Es un banquete compuesto de un asado especiado, frutas y demás delicias para el paladar.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¡Cómete ~]
    ParaContent(); print "~¡Cómete ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~!'~]
    ParaContent(); print "!~";! [9: roman type]
    ParaContent(); style roman;! [10: ~, te dice la musa desde algún lugar invisible.~]
    ParaContent(); print ", te dice la musa desde algún lugar invisible.";! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say14; .L_SayX14;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1157, 1157, 'action');
    rfalse;
];
! No specific request
! Instead of eating something edible when the player is in Segundo acto:
[ R_1159 ;
    if ((((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I225_segundo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1159, 1159);
    ! [2: say ~Te agachas para probar [the noun], más no puedes resistir a la tentación y empiezas a comer todo lo que en la bandeja hay, ante la antenta mirada de odio del ajusticiado.[paragraph break]~]
    say__p=1;! [3: ~Te agachas para probar ~]
    ParaContent(); print "Te agachas para probar ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~, más no puedes resistir a la tentación y empiezas a comer todo lo que en la bandeja hay, ante la antenta mirada de odio del ajusticiado.~]
    ParaContent(); print ", más no puedes resistir a la tentación y empiezas a comer todo lo que en la bandeja hay, ante la antenta mirada de odio del ajusticiado.";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say15; .L_SayX15;! [7: wait for any key]
    KeyPause();
    ! [8: say ~Todo está delicioso, y escuchas la aprobación y la sonrisa de tu musa, que te hace retornar a tu oscuridad, ante el libro del destino y la pluma sanguinolenta en tu mano.[paragraph break]~]
    say__p=1;! [9: ~Todo está delicioso, y escuchas la aprobación y la sonrisa de tu musa, que te hace retornar a tu oscuridad, ante el libro del destino y la pluma sanguinolenta en tu mano.~]
    ParaContent(); print "Todo está delicioso, y escuchas la aprobación y la sonrisa de tu musa, que te hace retornar a tu oscuridad, ante el libro del destino y la pluma sanguinolenta en tu mano.";! [10: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say16; .L_SayX16;! [11: now the player carries the pluma]
    MoveObject(I219_pluma,player);
    ! [12: now the musa is espectante]
    (Adj_106_t2_v10(I220_musa));
    ! [13: increase the pecados by 1]
    (Global_Vars-->34) = (Global_Vars-->34) + 1;;
    ! [14: wait for any key]
    KeyPause();
    ! [15: clear the screen]
    VM_ClearScreen(0);
    ! [16: now the player is in en la oscuridad]
    MoveObject(player,I218_en_la_oscuridad);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1159, 1159, 'action');
    rfalse;
];
! No specific request
! Instead of smelling something edible when the player is in altar:
[ R_1205 ;
    if ((((action ==##Smell) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1205, 1205);
    ! [2: say ~El dulce aroma de la sangre y las vísceras te embota los sentidos.~]
    say__p=1;! [3: ~El dulce aroma de la sangre y las vísceras te embota los sentidos.~]
    ParaContent(); print "El dulce aroma de la sangre y las vísceras te embota los sentidos."; new_line; .L_Say17; .L_SayX17;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1205, 1205, 'action');
    rfalse;
];
! No specific request
! Instead of smelling something edible when the player is in Sexto acto:
[ R_1206 ;
    if ((((action ==##Smell) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1206, 1206);
    ! [2: say ~El dulce aroma de la sangre embriaga tus sentidos.~]
    say__p=1;! [3: ~El dulce aroma de la sangre embriaga tus sentidos.~]
    ParaContent(); print "El dulce aroma de la sangre embriaga tus sentidos."; new_line; .L_Say18; .L_SayX18;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1206, 1206, 'action');
    rfalse;
];
! No specific request
! Instead of tasting something edible when the player is in altar:
[ R_1207 ;
    if ((((action ==##Taste) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1207, 1207);
    ! [2: say ~Saboreas [the noun].[paragraph break][italic type]'¡Vamos! ¿A qué esperas?'[roman type], dice tu musa.~]
    say__p=1;! [3: ~Saboreas ~]
    ParaContent(); print "Saboreas ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print ".";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [7: italic type]
    ParaContent(); style underline;! [8: ~'¡Vamos! ¿A qué esperas?'~]
    ParaContent(); print "~¡Vamos! ¿A qué esperas?~";! [9: roman type]
    ParaContent(); style roman;! [10: ~, dice tu musa.~]
    ParaContent(); print ", dice tu musa."; new_line; .L_Say19; .L_SayX19;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1207, 1207, 'action');
    rfalse;
];
! No specific request
! Instead of tasting something edible when the player is in Sexto acto:
[ R_1208 ;
    if ((((action ==##Taste) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1208, 1208);
    ! [2: say ~Eso solo puedes hacerlo en el altar.~]
    say__p=1;! [3: ~Eso solo puedes hacerlo en el altar.~]
    ParaContent(); print "Eso solo puedes hacerlo en el altar."; new_line; .L_Say20; .L_SayX20;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1208, 1208, 'action');
    rfalse;
];
! No specific request
! Instead of eating something edible when the player is in Sexto acto:
[ R_1224 ;
    if ((((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1224, 1224);
    ! [2: say ~Eso solo puedes hacerlo una vez estés subido al altar.[paragraph break]~]
    say__p=1;! [3: ~Eso solo puedes hacerlo una vez estés subido al altar.~]
    ParaContent(); print "Eso solo puedes hacerlo una vez estés subido al altar.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say21; .L_SayX21;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1224, 1224, 'action');
    rfalse;
];
! No specific request
! Instead of eating something edible when the player is in altar:
[ R_1226 ;
    if ((((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1226, 1226);
    ! [2: if the piedra is carried]
    if ((((Adj_1_t1_v10(I276_piedra)))))
    {! [3: say ~Acercas tu boca hacia [the noun], sintiendo una vez más el dulce sabor de la sangre de una criatura inocente. Los cultistas gritan de júbilo, el fuego de la hoguera crepita y se yergue entre la muchedumbre como un aciago fénix.[paragraph break]~]
        say__p=1;! [4: ~Acercas tu boca hacia ~]
        ParaContent(); print "Acercas tu boca hacia ";! [5: the noun]
        ParaContent(); print (the) noun;! [6: ~, sintiendo una vez más el dulce sabor de la sangre de una criatura inocente. Los cultistas gritan de júbilo, el fuego de la hoguera crepita y se yergue entre la muchedumbre como un aciago fénix.~]
        ParaContent(); print ", sintiendo una vez más el dulce sabor de la sangre de una criatura inocente. Los cultistas gritan de júbilo, el fuego de la hoguera crepita y se yergue entre la muchedumbre como un aciago fénix.";! [7: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say22; .L_SayX22;! [8: wait for any key]
        KeyPause();
        ! [9: say ~El ritual se ha completado. Una última gota de sangre cae por entre la comisura de tus labios. El fuego se expande y los cánticos cesan a medida que los cuerpos se consumen en cenizas. Sólo queda ya el último acto...[paragraph break]~]
        say__p=1;! [10: ~El ritual se ha completado. Una última gota de sangre cae por entre la comisura de tus labios. El fuego se expande y los cánticos cesan a medida que los cuerpos se consumen en cenizas. Sólo queda ya el último acto...~]
        ParaContent(); print "El ritual se ha completado. Una última gota de sangre cae por entre la comisura de tus labios. El fuego se expande y los cánticos cesan a medida que los cuerpos se consumen en cenizas. Sólo queda ya el último acto...";! [11: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say23; .L_SayX23;! [12: wait for any key]
        KeyPause();
        ! [13: say ~Lo que sucede después te sumerge de nuevo en la oscuridad más absoluta, pero de nuevo te ilumina la malévola luz de tu musa, que sonríe mientras espera que escribas de nuevo en el libro.[paragraph break]~]
        say__p=1;! [14: ~Lo que sucede después te sumerge de nuevo en la oscuridad más absoluta, pero de nuevo te ilumina la malévola luz de tu musa, que sonríe mientras espera que escribas de nuevo en el libro.~]
        ParaContent(); print "Lo que sucede después te sumerge de nuevo en la oscuridad más absoluta, pero de nuevo te ilumina la malévola luz de tu musa, que sonríe mientras espera que escribas de nuevo en el libro.";! [15: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say24; .L_SayX24;! [16: now the player carries the pluma]
        MoveObject(I219_pluma,player);
        ! [17: now the musa is espectante]
        (Adj_106_t2_v10(I220_musa));
        ! [18: increase the pecados by 1]
        (Global_Vars-->34) = (Global_Vars-->34) + 1;;
        ! [19: now the score is 6]
        score = 6;
        ! [20: wait for any key]
        KeyPause();
        ! [21: clear the screen]
        VM_ClearScreen(0);
        ! [22: now the player is in en la oscuridad]
        MoveObject(player,I218_en_la_oscuridad);
        } else {
        ! [23: say ~[italic type]'¿Acaso no recuerdas qué tienes que hacer antes de empezar con [the noun]?'[roman type], pregunta la musa.[paragraph break]~]
        say__p=1;! [24: italic type]
        ParaContent(); style underline;! [25: ~'¿Acaso no recuerdas qué tienes que hacer antes de empezar con ~]
        ParaContent(); print "~¿Acaso no recuerdas qué tienes que hacer antes de empezar con ";! [26: the noun]
        ParaContent(); print (the) noun;! [27: ~?'~]
        ParaContent(); print "?~";! [28: roman type]
        ParaContent(); style roman;! [29: ~, pregunta la musa.~]
        ParaContent(); print ", pregunta la musa.";! [30: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say25; .L_SayX25;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1226, 1226, 'action');
        rfalse;
];
! No specific request
! Instead of smelling or tasting or taking something edible when the player is in Segundo acto:
[ R_1158 ;
    if ((((action ==##Take or ##Taste or ##Smell) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I225_segundo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1158, 1158);
    ! [2: say ~Tiene una pinta estupenda, huele muy bien y su sabor es delicioso...[paragraph break][italic type]'¡Cómete [the noun]!'[roman type], te dice la musa desde algún lugar invisible.[paragraph break]~]
    say__p=1;! [3: ~Tiene una pinta estupenda, huele muy bien y su sabor es delicioso...~]
    ParaContent(); print "Tiene una pinta estupenda, huele muy bien y su sabor es delicioso...";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¡Cómete ~]
    ParaContent(); print "~¡Cómete ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~!'~]
    ParaContent(); print "!~";! [9: roman type]
    ParaContent(); style roman;! [10: ~, te dice la musa desde algún lugar invisible.~]
    ParaContent(); print ", te dice la musa desde algún lugar invisible.";! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say26; .L_SayX26;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1158, 1158, 'action');
    rfalse;
];
! No specific request
! Instead of taking or smelling or tasting something edible when the player is in Sexto acto:
[ R_1225 ;
    if ((((action ==##Taste or ##Smell or ##Take) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_66_t1_v10(noun)))) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1225, 1225);
    ! [2: say ~¡Ah, [the noun]![paragraph break][italic type]'¡Cómete [the noun]!'[roman type], te dice la musa desde algún lugar invisible.[paragraph break]~]
    say__p=1;! [3: ~¡Ah, ~]
    ParaContent(); print "¡Ah, ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~!~]
    ParaContent(); print "!";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [7: italic type]
    ParaContent(); style underline;! [8: ~'¡Cómete ~]
    ParaContent(); print "~¡Cómete ";! [9: the noun]
    ParaContent(); print (the) noun;! [10: ~!'~]
    ParaContent(); print "!~";! [11: roman type]
    ParaContent(); style roman;! [12: ~, te dice la musa desde algún lugar invisible.~]
    ParaContent(); print ", te dice la musa desde algún lugar invisible.";! [13: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say27; .L_SayX27;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1225, 1225, 'action');
    rfalse;
];
! No specific request
! Instead of throwing the piedra at the musa:
[ R_1130 ;
    if ((((action ==##ThrowAt) &&  (actor==player) && ((noun == I276_piedra) && (true)) && ((second == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1130, 1130);
    ! [2: say ~[italic type]'¡No es a mí a quien debes lanzar esa piedra, sino a tu hermano!'[roman type], te indica la musa.[paragraph break]Y así, de una forma aún más dolorosa... comienza tu inspiración.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¡No es a mí a quien debes lanzar esa piedra, sino a tu hermano!'~]
    ParaContent(); print "~¡No es a mí a quien debes lanzar esa piedra, sino a tu hermano!~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, te indica la musa.~]
    ParaContent(); print ", te indica la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~Y así, de una forma aún más dolorosa... comienza tu inspiración.~]
    ParaContent(); print "Y así, de una forma aún más dolorosa... comienza tu inspiración.";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say28; .L_SayX28;! [10: now the musa is complacida]
    (Adj_105_t2_v10(I220_musa));
    ! [11: wait for any key]
    KeyPause();
    ! [12: try examining the musa]
    TryAction(0, player, ##Examine, I220_musa, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1130, 1130, 'action');
    rfalse;
];
! No specific request
! Instead of inserting the almohada into the mercader:
[ R_1196 ;
    if ((((action ==##Insert) &&  (actor==player) && ((noun == I268_almohada) && (true)) && ((second == I270_mercader) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1196, 1196);
    ! [2: try attacking the mercader]
    TryAction(0, player, ##Attack, I270_mercader, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1196, 1196, 'action');
    rfalse;
];
! No specific request
! Instead of putting the almohada on the mercader:
[ R_1197 ;
    if ((((action ==##PutOn) &&  (actor==player) && ((noun == I268_almohada) && (true)) && ((second == I270_mercader) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1197, 1197);
    ! [2: try attacking the mercader]
    TryAction(0, player, ##Attack, I270_mercader, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1197, 1197, 'action');
    rfalse;
];
! No specific request
! Instead of throwing the piedra at the hermano:
[ R_1234 ;
    if ((((action ==##ThrowAt) &&  (actor==player) && ((noun == I276_piedra) && (true)) && ((second == I282_hermano) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1234, 1234);
    ! [2: say ~Lanzas la piedra a la cabeza de tu hermano, acertando de lleno. La sangre brota de sus sienes y cae a plomo sobre la tierra.[paragraph break]~]
    say__p=1;! [3: ~Lanzas la piedra a la cabeza de tu hermano, acertando de lleno. La sangre brota de sus sienes y cae a plomo sobre la tierra.~]
    ParaContent(); print "Lanzas la piedra a la cabeza de tu hermano, acertando de lleno. La sangre brota de sus sienes y cae a plomo sobre la tierra.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say29; .L_SayX29;! [5: wait for any key]
    KeyPause();
    ! [6: say ~Te acercas hacia el cuerpo moribundo y de nuevo coges la piedra. Alzas tus manos y golpeas una y otra vez el rostro de tu hermano. La sangre salpica tus brazos. [paragraph break]~]
    say__p=1;! [7: ~Te acercas hacia el cuerpo moribundo y de nuevo coges la piedra. Alzas tus manos y golpeas una y otra vez el rostro de tu hermano. La sangre salpica tus brazos. ~]
    ParaContent(); print "Te acercas hacia el cuerpo moribundo y de nuevo coges la piedra. Alzas tus manos y golpeas una y otra vez el rostro de tu hermano. La sangre salpica tus brazos. ";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say30; .L_SayX30;! [9: wait for any key]
    KeyPause();
    ! [10: say ~La lluvia empieza a caer con fuerza. Te alejas del campo, dejando allí tu particular ofrenda. Deambulas por la tierra hasta que un rayo de luz emerge de entre las nubes, paralizándote...[paragraph break]~]
    say__p=1;! [11: ~La lluvia empieza a caer con fuerza. Te alejas del campo, dejando allí tu particular ofrenda. Deambulas por la tierra hasta que un rayo de luz emerge de entre las nubes, paralizándote...~]
    ParaContent(); print "La lluvia empieza a caer con fuerza. Te alejas del campo, dejando allí tu particular ofrenda. Deambulas por la tierra hasta que un rayo de luz emerge de entre las nubes, paralizándote...";! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say31; .L_SayX31;! [13: wait for any key]
    KeyPause();
    ! [14: say ~Del cielo surge una potente voz que te pregunta incesante: [italic type]'¿Dónde está tu hermano?'[roman type][paragraph break]Respondes: [italic type]'No lo sé, ¿acaso soy yo el guardián de mi hermano?'[roman type][paragraph break]~]
    say__p=1;! [15: ~Del cielo surge una potente voz que te pregunta incesante: ~]
    ParaContent(); print "Del cielo surge una potente voz que te pregunta incesante: ";! [16: italic type]
    ParaContent(); style underline;! [17: ~'¿Dónde está tu hermano?'~]
    ParaContent(); print "~¿Dónde está tu hermano?~";! [18: roman type]
    ParaContent(); style roman;! [19: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [20: ~Respondes: ~]
    ParaContent(); print "Respondes: ";! [21: italic type]
    ParaContent(); style underline;! [22: ~'No lo sé, ¿acaso soy yo el guardián de mi hermano?'~]
    ParaContent(); print "~No lo sé, ¿acaso soy yo el guardián de mi hermano?~";! [23: roman type]
    ParaContent(); style roman;! [24: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say32; .L_SayX32;! [25: wait for any key]
    KeyPause();
    ! [26: say ~La voz desde el cielo grita: [italic type]'¿Qué has hecho? La sangre de tu hermano me está gritando desde la tierra. Por eso te maldice esa tierra que ha abierto sus fauces para recibir de tus manos la sangre de tu hermano.'[roman type][paragraph break]~]
    say__p=1;! [27: ~La voz desde el cielo grita: ~]
    ParaContent(); print "La voz desde el cielo grita: ";! [28: italic type]
    ParaContent(); style underline;! [29: ~'¿Qué has hecho? La sangre de tu hermano me está gritando desde la tierra. Por eso te maldice esa tierra que ha abierto sus fauces para recibir de tus manos la sangre de tu hermano.'~]
    ParaContent(); print "~¿Qué has hecho? La sangre de tu hermano me está gritando desde la tierra. Por eso te maldice esa tierra que ha abierto sus fauces para recibir de tus manos la sangre de tu hermano.~";! [30: roman type]
    ParaContent(); style roman;! [31: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say33; .L_SayX33;! [32: wait for any key]
    KeyPause();
    ! [33: say ~Una lluvia negra de ceniza y roja de sangre brota del cielo, arrastrándote al negro abismo. Caes y caes durante siglos, sumiéndote en la más absoluta oscuridad... una oscuridad sólo soportable por la bella sonrisa de tu musa, que te recoge en sus brazos y te lleva de nuevo frente al libro, que espera tu escritura. [paragraph break][italic type]'Todo acaba. Todo comienza.'[roman type][paragraph break]~]
    say__p=1;! [34: ~Una lluvia negra de ceniza y roja de sangre brota del cielo, arrastrándote al negro abismo. Caes y caes durante siglos, sumiéndote en la más absoluta oscuridad... una oscuridad sólo soportable por la bella sonrisa de tu musa, que te recoge en sus brazos y te lleva de nuevo frente al libro, que espera tu escritura. ~]
    ParaContent(); print "Una lluvia negra de ceniza y roja de sangre brota del cielo, arrastrándote al negro abismo. Caes y caes durante siglos, sumiéndote en la más absoluta oscuridad... una oscuridad sólo soportable por la bella sonrisa de tu musa, que te recoge en sus brazos y te lleva de nuevo frente al libro, que espera tu escritura. ";! [35: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [36: italic type]
    ParaContent(); style underline;! [37: ~'Todo acaba. Todo comienza.'~]
    ParaContent(); print "~Todo acaba. Todo comienza.~";! [38: roman type]
    ParaContent(); style roman;! [39: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say34; .L_SayX34;! [40: now the player carries the pluma]
    MoveObject(I219_pluma,player);
    ! [41: now the piedra is in altar]
    MoveObject(I276_piedra,I274_altar);
    ! [42: now the musa is espectante]
    (Adj_106_t2_v10(I220_musa));
    ! [43: now the pecados is 0]
    (Global_Vars-->34) = 0;
    ! [44: wait for any key]
    KeyPause();
    ! [45: disable the mi-ofrenda quip]
    (PHR_954_r5 (I166_mi_ofrenda));
    ! [46: disable the ternero-hermano quip]
    (PHR_954_r5 (I167_ternero_hermano));
    ! [47: enable the hola-hermano quip]
    (PHR_953_r6 (I168_hola_hermano));
    ! [48: clear the screen]
    VM_ClearScreen(0);
    ! [49: now the player is in en la oscuridad]
    MoveObject(player,I218_en_la_oscuridad);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1234, 1234, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the pluma:
[ R_1127 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I219_pluma) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1127, 1127);
    ! [2: say ~[italic type]'No vas a acabar con tu penitencia así, ya lo has intentado antes, ¿recuerdas?'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'No vas a acabar con tu penitencia así, ya lo has intentado antes, ¿recuerdas?'~]
    ParaContent(); print "~No vas a acabar con tu penitencia así, ya lo has intentado antes, ¿recuerdas?~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say35; .L_SayX35;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1127, 1127, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the ojos:
[ R_1131 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I221_ojos) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1131, 1131);
    ! [2: try attacking the musa]
    TryAction(0, player, ##Attack, I220_musa, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1131, 1131, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the presencia:
[ R_1132 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I231_presencia) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1132, 1132);
    ! [2: say ~Notas su presencia, pero no está aquí físicamente.~]
    say__p=1;! [3: ~Notas su presencia, pero no está aquí físicamente.~]
    ParaContent(); print "Notas su presencia, pero no está aquí físicamente."; new_line; .L_Say36; .L_SayX36;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1132, 1132, 'action');
    rfalse;
];
! No specific request
! Instead of talking to the musa:
[ R_1133 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1133, 1133);
    ! [2: say ~Ella te habla solo cuando lo desea. Sabes que lo que está esperando es que [if espectante]escribas en el libro[end if][if complacida]la mires[end if] y te inspires con su malévola belleza.[paragraph break][if espectante][italic type]'No hace falta que hables, tan solo escribe...'[roman type], dice la musa.[paragraph break][otherwise][italic type]'No hace falta que hables, tan solo mírame...'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: ~Ella te habla solo cuando lo desea. Sabes que lo que está esperando es que ~]
    ParaContent(); print "Ella te habla solo cuando lo desea. Sabes que lo que está esperando es que ";! [4: if espectante]

    	if (~~(((((Adj_106_t1_v10(self))))))) jump L_Say37;! [5: ~escribas en el libro~]
    ParaContent(); print "escribas en el libro";! [6: end if]

    	.L_Say37; .L_SayX37;! [7: if complacida]

    	if (~~(((((Adj_105_t1_v10(self))))))) jump L_Say38;! [8: ~la mires~]
    ParaContent(); print "la mires";! [9: end if]

    	.L_Say38; .L_SayX38;! [10: ~ y te inspires con su malévola belleza.~]
    ParaContent(); print " y te inspires con su malévola belleza.";! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [12: if espectante]

    	if (~~(((((Adj_106_t1_v10(self))))))) jump L_Say39;! [13: italic type]
    ParaContent(); style underline;! [14: ~'No hace falta que hables, tan solo escribe...'~]
    ParaContent(); print "~No hace falta que hables, tan solo escribe...~";! [15: roman type]
    ParaContent(); style roman;! [16: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [17: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [18: otherwise]

    	jump L_SayX39; .L_Say39;! [19: italic type]
    ParaContent(); style underline;! [20: ~'No hace falta que hables, tan solo mírame...'~]
    ParaContent(); print "~No hace falta que hables, tan solo mírame...~";! [21: roman type]
    ParaContent(); style roman;! [22: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [23: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say40; .L_SayX39;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1133, 1133, 'action');
    rfalse;
];
! No specific request
! Instead of talking to the presencia:
[ R_1134 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I231_presencia) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1134, 1134);
    ! [2: say ~Ella te habla solo cuando lo desea.[paragraph break]~]
    say__p=1;! [3: ~Ella te habla solo cuando lo desea.~]
    ParaContent(); print "Ella te habla solo cuando lo desea.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say41; .L_SayX40;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1134, 1134, 'action');
    rfalse;
];
! No specific request
! Instead of touching the libro:
[ R_1143 ;
    if ((((action ==##Touch) &&  (actor==player) && ((noun == I222_libro) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1143, 1143);
    ! [2: say ~Rugosas páginas, carcomidas por el paso de los tiempos.~]
    say__p=1;! [3: ~Rugosas páginas, carcomidas por el paso de los tiempos.~]
    ParaContent(); print "Rugosas páginas, carcomidas por el paso de los tiempos."; new_line; .L_Say42; .L_SayX41;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1143, 1143, 'action');
    rfalse;
];
! No specific request
! Instead of talking to las ovejas:
[ R_1148 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I233_ovejas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1148, 1148);
    ! [2: say ~Demasiadas, esta vez parece que el pastor no va a conseguir honrar a su padre...~]
    say__p=1;! [3: ~Demasiadas, esta vez parece que el pastor no va a conseguir honrar a su padre...~]
    ParaContent(); print "Demasiadas, esta vez parece que el pastor no va a conseguir honrar a su padre..."; new_line; .L_Say43; .L_SayX42;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1148, 1148, 'action');
    rfalse;
];
! No specific request
! Instead of taking the ovejas:
[ R_1149 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I233_ovejas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1149, 1149);
    ! [2: say ~Quizá podrías ayudar al pastor a reunir su rebaño pero... la musa quiere que descanses. [paragraph break][italic type]'Duérmete mi niño,[roman type] dice la musa. [italic type]Estás muy cansado.'[roman type][paragraph break]~]
    say__p=1;! [3: ~Quizá podrías ayudar al pastor a reunir su rebaño pero... la musa quiere que descanses. ~]
    ParaContent(); print "Quizá podrías ayudar al pastor a reunir su rebaño pero... la musa quiere que descanses. ";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'Duérmete mi niño,~]
    ParaContent(); print "~Duérmete mi niño,";! [7: roman type]
    ParaContent(); style roman;! [8: ~ dice la musa. ~]
    ParaContent(); print " dice la musa. ";! [9: italic type]
    ParaContent(); style underline;! [10: ~Estás muy cansado.'~]
    ParaContent(); print "Estás muy cansado.~";! [11: roman type]
    ParaContent(); style roman;! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say44; .L_SayX43;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1149, 1149, 'action');
    rfalse;
];
! No specific request
! Instead of talking to the guerreros:
[ R_1166 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I247_guerreros) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1166, 1166);
    ! [2: say ~[italic type]'¿Creéis que este infeliz debe morir por su vil traición?',[roman type] preguntas a tus hombres.[paragraph break][italic type]'¡Mátalo, mátalo!',[roman type] te responden.[paragraph break][italic type]'Aquí el único traidor eres tú, que has engañado a todos...',[roman type] te dice el soldado.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¿Creéis que este infeliz debe morir por su vil traición?',~]
    ParaContent(); print "~¿Creéis que este infeliz debe morir por su vil traición?~,";! [5: roman type]
    ParaContent(); style roman;! [6: ~ preguntas a tus hombres.~]
    ParaContent(); print " preguntas a tus hombres.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: italic type]
    ParaContent(); style underline;! [9: ~'¡Mátalo, mátalo!',~]
    ParaContent(); print "~¡Mátalo, mátalo!~,";! [10: roman type]
    ParaContent(); style roman;! [11: ~ te responden.~]
    ParaContent(); print " te responden.";! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [13: italic type]
    ParaContent(); style underline;! [14: ~'Aquí el único traidor eres tú, que has engañado a todos...',~]
    ParaContent(); print "~Aquí el único traidor eres tú, que has engañado a todos...~,";! [15: roman type]
    ParaContent(); style roman;! [16: ~ te dice el soldado.~]
    ParaContent(); print " te dice el soldado.";! [17: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say45; .L_SayX44;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1166, 1166, 'action');
    rfalse;
];
! No specific request
! Instead of taking the espada:
[ R_1167 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I252_espada) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1167, 1167);
    ! [2: now the espada is portable]
    (Adj_69_t2_v10(I252_espada));
    ! [3: now the player carries the espada]
    MoveObject(I252_espada,player);
    ! [4: say ~El hombre te suplica... [italic type]'¡No! ¡Por favor, no!'[roman type].~]
    say__p=1;! [5: ~El hombre te suplica... ~]
    ParaContent(); print "El hombre te suplica... ";! [6: italic type]
    ParaContent(); style underline;! [7: ~'¡No! ¡Por favor, no!'~]
    ParaContent(); print "~¡No! ¡Por favor, no!~";! [8: roman type]
    ParaContent(); style roman;! [9: ~.~]
    ParaContent(); print "."; new_line; .L_Say46; .L_SayX45;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1167, 1167, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the soldado:
[ R_1174 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I249_soldado) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1174, 1174);
    ! [2: if the player carries the espada]
    if (((player == CarrierOf(I252_espada))))
    {! [3: say ~Empuñas firmemente la espada y le rebanas el cuello de un certero tajo.[paragraph break]~]
        say__p=1;! [4: ~Empuñas firmemente la espada y le rebanas el cuello de un certero tajo.~]
        ParaContent(); print "Empuñas firmemente la espada y le rebanas el cuello de un certero tajo.";! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say47; .L_SayX46;! [6: wait for any key]
        KeyPause();
        ! [7: say ~La sangre brota a borbotones y te ensucia los ropajes...[paragraph break]Tu musa sonrie satisfecha ante la consecución lógica de tu nueva inspiración.[paragraph break]~]
        say__p=1;! [8: ~La sangre brota a borbotones y te ensucia los ropajes...~]
        ParaContent(); print "La sangre brota a borbotones y te ensucia los ropajes...";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [10: ~Tu musa sonrie satisfecha ante la consecución lógica de tu nueva inspiración.~]
        ParaContent(); print "Tu musa sonrie satisfecha ante la consecución lógica de tu nueva inspiración.";! [11: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say48; .L_SayX47;! [12: wait for any key]
        KeyPause();
        ! [13: say ~Pronto te rodea la oscuridad y de nuevo te enfrentas a una nueva página en blanco.[paragraph break]~]
        say__p=1;! [14: ~Pronto te rodea la oscuridad y de nuevo te enfrentas a una nueva página en blanco.~]
        ParaContent(); print "Pronto te rodea la oscuridad y de nuevo te enfrentas a una nueva página en blanco.";! [15: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say49; .L_SayX48;! [16: now the espada is in location]
        MoveObject(I252_espada,real_location);
        ! [17: now the player carries the pluma]
        MoveObject(I219_pluma,player);
        ! [18: now the musa is espectante]
        (Adj_106_t2_v10(I220_musa));
        ! [19: increase the pecados by 1]
        (Global_Vars-->34) = (Global_Vars-->34) + 1;;
        ! [20: wait for any key]
        KeyPause();
        ! [21: clear the screen]
        VM_ClearScreen(0);
        ! [22: now the player is in en la oscuridad]
        MoveObject(player,I218_en_la_oscuridad);
        } else {
        ! [23: say ~[italic type]'Mejor mátalo con su propia espada'[roman type], te susurra la musa.~]
        say__p=1;! [24: italic type]
        ParaContent(); style underline;! [25: ~'Mejor mátalo con su propia espada'~]
        ParaContent(); print "~Mejor mátalo con su propia espada~";! [26: roman type]
        ParaContent(); style roman;! [27: ~, te susurra la musa.~]
        ParaContent(); print ", te susurra la musa."; new_line; .L_Say50; .L_SayX49;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1174, 1174, 'action');
        rfalse;
];
! No specific request
! Instead of taking the cepillo:
[ R_1179 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I263_cepillo) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1179, 1179);
    ! [2: now the cepillo is portable]
    (Adj_69_t2_v10(I263_cepillo));
    ! [3: now the description of the cepillo is ~Es el cepillo con el que la doncella suele sacudirse el cabello.~]
    BlkValueCopy(GProperty(10, I263_cepillo,description), TX_L_244);
    ! [4: now the player carries the cepillo]
    MoveObject(I263_cepillo,player);
    ! [5: say ~La muchacha ahoga un sollozo... [italic type]'No he terminado de arreglarme... mi señor'[roman type], dice la doncella.~]
    say__p=1;! [6: ~La muchacha ahoga un sollozo... ~]
    ParaContent(); print "La muchacha ahoga un sollozo... ";! [7: italic type]
    ParaContent(); style underline;! [8: ~'No he terminado de arreglarme... mi señor'~]
    ParaContent(); print "~No he terminado de arreglarme... mi señor~";! [9: roman type]
    ParaContent(); style roman;! [10: ~, dice la doncella.~]
    ParaContent(); print ", dice la doncella."; new_line; .L_Say51; .L_SayX50;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1179, 1179, 'action');
    rfalse;
];
! No specific request
! Instead of fucking the doncella:
[ R_1186 ;
    if ((((action ==##A91_fucking) &&  (actor==player) && ((noun == I259_doncella) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1186, 1186);
    ! [2: say ~Agarras a la doncella y se desata en tí un torbellino de deseo que sólo puede culminar en la realización de aquello que anhelas....[paragraph break]~]
    say__p=1;! [3: ~Agarras a la doncella y se desata en tí un torbellino de deseo que sólo puede culminar en la realización de aquello que anhelas....~]
    ParaContent(); print "Agarras a la doncella y se desata en tí un torbellino de deseo que sólo puede culminar en la realización de aquello que anhelas....";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say52; .L_SayX51;! [5: wait for any key]
    KeyPause();
    ! [6: say ~Empujas a la doncella y ésta cae al suelo, y tú sobre ella. [paragraph break]Escuchas la dulce sonrisa de tu musa, que apaga los alaridos de la doncella ante tus acometidas.[paragraph break]~]
    say__p=1;! [7: ~Empujas a la doncella y ésta cae al suelo, y tú sobre ella. ~]
    ParaContent(); print "Empujas a la doncella y ésta cae al suelo, y tú sobre ella. ";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [9: ~Escuchas la dulce sonrisa de tu musa, que apaga los alaridos de la doncella ante tus acometidas.~]
    ParaContent(); print "Escuchas la dulce sonrisa de tu musa, que apaga los alaridos de la doncella ante tus acometidas.";! [10: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say53; .L_SayX52;! [11: wait for any key]
    KeyPause();
    ! [12: say ~Y de nuevo te envuelve la oscuridad y ante tu presencia la doncella se transforma en libro, que espera de nuevo tu escritura.[paragraph break]~]
    say__p=1;! [13: ~Y de nuevo te envuelve la oscuridad y ante tu presencia la doncella se transforma en libro, que espera de nuevo tu escritura.~]
    ParaContent(); print "Y de nuevo te envuelve la oscuridad y ante tu presencia la doncella se transforma en libro, que espera de nuevo tu escritura.";! [14: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say54; .L_SayX53;! [15: now the cepillo is in location]
    MoveObject(I263_cepillo,real_location);
    ! [16: now the player carries the pluma]
    MoveObject(I219_pluma,player);
    ! [17: now the musa is espectante]
    (Adj_106_t2_v10(I220_musa));
    ! [18: increase the pecados by 1]
    (Global_Vars-->34) = (Global_Vars-->34) + 1;;
    ! [19: wait for any key]
    KeyPause();
    ! [20: clear the screen]
    VM_ClearScreen(0);
    ! [21: now the player is in en la oscuridad]
    MoveObject(player,I218_en_la_oscuridad);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1186, 1186, 'action');
    rfalse;
];
! No specific request
! Instead of taking the almohadas:
[ R_1193 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I266_almohadas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1193, 1193);
    ! [2: if the almohada is nowhere]
    if (((LocationOf(I268_almohada) == nothing)))
    {! [3: now the player carries the almohada]
        MoveObject(I268_almohada,player);
        ! [4: say ~Suavemente coges una de las almohadas sin que el mercader se percate...[paragraph break][italic type]'Eso es, ahora hazlo...'[roman type], dice tu musa.[paragraph break]~]
        say__p=1;! [5: ~Suavemente coges una de las almohadas sin que el mercader se percate...~]
        ParaContent(); print "Suavemente coges una de las almohadas sin que el mercader se percate...";! [6: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [7: italic type]
        ParaContent(); style underline;! [8: ~'Eso es, ahora hazlo...'~]
        ParaContent(); print "~Eso es, ahora hazlo...~";! [9: roman type]
        ParaContent(); style roman;! [10: ~, dice tu musa.~]
        ParaContent(); print ", dice tu musa.";! [11: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say55; .L_SayX54;} else {
        ! [12: say ~[italic type]'Ya tienes una almohada, [if the mercader is vivo]ya sabes lo que hay que hacer...'[roman type], dice tu musa.[else if the mercader is muerto]ahora coge lo que has venido a buscar...'[roman type], dice tu musa.[end if][paragraph break]~]
        say__p=1;! [13: italic type]
        ParaContent(); style underline;! [14: ~'Ya tienes una almohada, ~]
        ParaContent(); print "~Ya tienes una almohada, ";! [15: if the mercader is vivo]

        	if (~~(((((Adj_107_t1_v10(I270_mercader))))))) jump L_Say56;! [16: ~ya sabes lo que hay que hacer...'~]
        ParaContent(); print "ya sabes lo que hay que hacer...~";! [17: roman type]
        ParaContent(); style roman;! [18: ~, dice tu musa.~]
        ParaContent(); print ", dice tu musa."; new_line;! [19: else if the mercader is muerto]
        ParaContent(); 
        	jump L_SayX55; .L_Say56; if (~~(((((Adj_108_t1_v10(I270_mercader))))))) jump L_Say57;! [20: ~ahora coge lo que has venido a buscar...'~]
        ParaContent(); print "ahora coge lo que has venido a buscar...~";! [21: roman type]
        ParaContent(); style roman;! [22: ~, dice tu musa.~]
        ParaContent(); print ", dice tu musa."; new_line;! [23: end if]

        	.L_Say57; .L_SayX55;! [24: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say58; .L_SayX56;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1193, 1193, 'action');
        rfalse;
];
! No specific request
! Instead of talking to the mercader:
[ R_1195 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I270_mercader) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1195, 1195);
    ! [2: say ~[if the mercader is vivo][italic type]'¡Silencio! No queremos que se despierte...'[roman type], dice tu musa.[paragraph break][otherwise][italic type]'Poco tiene ya que contar... céntrate en el diamante...'[roman type], dice tu musa.[paragraph break]~]
    say__p=1;! [3: if the mercader is vivo]

    	if (~~(((((Adj_107_t1_v10(I270_mercader))))))) jump L_Say59;! [4: italic type]
    ParaContent(); style underline;! [5: ~'¡Silencio! No queremos que se despierte...'~]
    ParaContent(); print "~¡Silencio! No queremos que se despierte...~";! [6: roman type]
    ParaContent(); style roman;! [7: ~, dice tu musa.~]
    ParaContent(); print ", dice tu musa.";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [9: otherwise]

    	jump L_SayX57; .L_Say59;! [10: italic type]
    ParaContent(); style underline;! [11: ~'Poco tiene ya que contar... céntrate en el diamante...'~]
    ParaContent(); print "~Poco tiene ya que contar... céntrate en el diamante...~";! [12: roman type]
    ParaContent(); style roman;! [13: ~, dice tu musa.~]
    ParaContent(); print ", dice tu musa.";! [14: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say60; .L_SayX57;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1195, 1195, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the mercader:
[ R_1198 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I270_mercader) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1198, 1198);
    ! [2: if the mercader is muerto]
    if ((((Adj_108_t1_v10(I270_mercader)))))
    {! [3: say ~Ya está muerto.~]
        say__p=1;! [4: ~Ya está muerto.~]
        ParaContent(); print "Ya está muerto."; new_line; .L_Say61; .L_SayX58;}
    ! [5: if the player carries the almohada and the mercader is vivo]
    if ((((player == CarrierOf(I268_almohada)))) && ((((Adj_107_t1_v10(I270_mercader))))))
    {! [6: now the mercader is muerto]
        (Adj_108_t2_v10(I270_mercader));
        ! [7: say ~Coges una de las almohadas y la colocas sobre el rostro del mercader, con fuerza y decisión.[paragraph break]~]
        say__p=1;! [8: ~Coges una de las almohadas y la colocas sobre el rostro del mercader, con fuerza y decisión.~]
        ParaContent(); print "Coges una de las almohadas y la colocas sobre el rostro del mercader, con fuerza y decisión.";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say62; .L_SayX59;! [10: wait for any key]
        KeyPause();
        ! [11: say ~Pronto sus ronquidos se tornan en sonidos ahogados que no logras reconocer, manotea y mueve sus pies desacompasadamente, hasta que ya no lo hace.[paragraph break]~]
        say__p=1;! [12: ~Pronto sus ronquidos se tornan en sonidos ahogados que no logras reconocer, manotea y mueve sus pies desacompasadamente, hasta que ya no lo hace.~]
        ParaContent(); print "Pronto sus ronquidos se tornan en sonidos ahogados que no logras reconocer, manotea y mueve sus pies desacompasadamente, hasta que ya no lo hace.";! [13: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say63; .L_SayX60;! [14: wait for any key]
        KeyPause();
        ! [15: say ~Retiras la almohada a un lado. Los ojos del mercader están abiertos de par en par, en una última mueca de sorpresa y terror.[paragraph break]~]
        say__p=1;! [16: ~Retiras la almohada a un lado. Los ojos del mercader están abiertos de par en par, en una última mueca de sorpresa y terror.~]
        ParaContent(); print "Retiras la almohada a un lado. Los ojos del mercader están abiertos de par en par, en una última mueca de sorpresa y terror.";! [17: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say64; .L_SayX61;} else {
        ! [18: say ~No sabes con qué atacar, no hay nada a mano... [paragraph break][italic type]'Vamos, sabes como hacerlo...'[roman type], susurra la musa.~]
        say__p=1;! [19: ~No sabes con qué atacar, no hay nada a mano... ~]
        ParaContent(); print "No sabes con qué atacar, no hay nada a mano... ";! [20: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [21: italic type]
        ParaContent(); style underline;! [22: ~'Vamos, sabes como hacerlo...'~]
        ParaContent(); print "~Vamos, sabes como hacerlo...~";! [23: roman type]
        ParaContent(); style roman;! [24: ~, susurra la musa.~]
        ParaContent(); print ", susurra la musa."; new_line; .L_Say65; .L_SayX62;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1198, 1198, 'action');
        rfalse;
];
! No specific request
! Instead of taking the diamante:
[ R_1200 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I269_diamante) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1200, 1200);
    ! [2: if the mercader is muerto]
    if ((((Adj_108_t1_v10(I270_mercader)))))
    {! [3: say ~¡Ahora sí! ¡Ya es tuyo! Tus manos lo rozan y ya sientes el placer.[paragraph break]~]
        say__p=1;! [4: ~¡Ahora sí! ¡Ya es tuyo! Tus manos lo rozan y ya sientes el placer.~]
        ParaContent(); print "¡Ahora sí! ¡Ya es tuyo! Tus manos lo rozan y ya sientes el placer.";! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say66; .L_SayX63;! [6: wait for any key]
        KeyPause();
        ! [7: say ~Es cuando lo tienes entre tus manos cuando te encuentras de nuevo ante tu libro, pluma en mano.[paragraph break]~]
        say__p=1;! [8: ~Es cuando lo tienes entre tus manos cuando te encuentras de nuevo ante tu libro, pluma en mano.~]
        ParaContent(); print "Es cuando lo tienes entre tus manos cuando te encuentras de nuevo ante tu libro, pluma en mano.";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say67; .L_SayX64;! [10: wait for any key]
        KeyPause();
        ! [11: say ~La musa sonrie maléficamente satisfecha. La página está esperando.[paragraph break]~]
        say__p=1;! [12: ~La musa sonrie maléficamente satisfecha. La página está esperando.~]
        ParaContent(); print "La musa sonrie maléficamente satisfecha. La página está esperando.";! [13: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say68; .L_SayX65;! [14: now the mercader is vivo]
        (Adj_107_t2_v10(I270_mercader));
        ! [15: now the almohada is in location]
        MoveObject(I268_almohada,real_location);
        ! [16: now the player carries the pluma]
        MoveObject(I219_pluma,player);
        ! [17: now the musa is espectante]
        (Adj_106_t2_v10(I220_musa));
        ! [18: increase the pecados by 1]
        (Global_Vars-->34) = (Global_Vars-->34) + 1;;
        ! [19: now the score is 5]
        score = 5;
        ! [20: wait for any key]
        KeyPause();
        ! [21: clear the screen]
        VM_ClearScreen(0);
        ! [22: now the player is in en la oscuridad]
        MoveObject(player,I218_en_la_oscuridad);
        } else {
        ! [23: say ~El mercader mantiene entre sus manos el diamante con fuerza, no te permite llevártelo.[paragraph break]Se gira un poco y emite un perezoso resoplido.[paragraph break]~]
        say__p=1;! [24: ~El mercader mantiene entre sus manos el diamante con fuerza, no te permite llevártelo.~]
        ParaContent(); print "El mercader mantiene entre sus manos el diamante con fuerza, no te permite llevártelo.";! [25: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [26: ~Se gira un poco y emite un perezoso resoplido.~]
        ParaContent(); print "Se gira un poco y emite un perezoso resoplido.";! [27: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say69; .L_SayX66;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1200, 1200, 'action');
        rfalse;
];
! No specific request
! Instead of talking to the fieles:
[ R_1202 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun == I272_fieles) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1202, 1202);
    ! [2: say ~[italic type]'¡Llevamos mucho tiempo esperando este momento!',[roman type] dices a tus fieles.[paragraph break]Tus acólitos se enfervorizan y sus cánticos se tornan ensordecedores.[paragraph break][italic type]'¡Esta será mi primera ofrenda para Lilith!',[roman type] gritas al cielo.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¡Llevamos mucho tiempo esperando este momento!',~]
    ParaContent(); print "~¡Llevamos mucho tiempo esperando este momento!~,";! [5: roman type]
    ParaContent(); style roman;! [6: ~ dices a tus fieles.~]
    ParaContent(); print " dices a tus fieles.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~Tus acólitos se enfervorizan y sus cánticos se tornan ensordecedores.~]
    ParaContent(); print "Tus acólitos se enfervorizan y sus cánticos se tornan ensordecedores.";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [10: italic type]
    ParaContent(); style underline;! [11: ~'¡Esta será mi primera ofrenda para Lilith!',~]
    ParaContent(); print "~¡Esta será mi primera ofrenda para Lilith!~,";! [12: roman type]
    ParaContent(); style roman;! [13: ~ gritas al cielo.~]
    ParaContent(); print " gritas al cielo.";! [14: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say70; .L_SayX67;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1202, 1202, 'action');
    rfalse;
];
! No specific request
! Instead of entering the altar:
[ R_1213 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I274_altar) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1213, 1213);
    ! [2: say ~Subes al altar. La muchedumbre enloquece y sus cánticos se aceleran.~]
    say__p=1;! [3: ~Subes al altar. La muchedumbre enloquece y sus cánticos se aceleran.~]
    ParaContent(); print "Subes al altar. La muchedumbre enloquece y sus cánticos se aceleran."; new_line; .L_Say71; .L_SayX68;! [4: now the player is in the altar]
    MoveObject(player,I274_altar);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1213, 1213, 'action');
    rfalse;
];
! No specific request
! Instead of getting off the altar:
[ R_1216 ;
    if ((((action ==##GetOff) &&  (actor==player) && ((noun == I274_altar) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1216, 1216);
    ! [2: say ~Bajas del altar. Tus acólitos se miran entre ellos extrañados.~]
    say__p=1;! [3: ~Bajas del altar. Tus acólitos se miran entre ellos extrañados.~]
    ParaContent(); print "Bajas del altar. Tus acólitos se miran entre ellos extrañados."; new_line; .L_Say72; .L_SayX69;! [4: now the player is in sexto acto]
    MoveObject(player,I229_sexto_acto);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1216, 1216, 'action');
    rfalse;
];
! No specific request
! Instead of examining the piedras:
[ R_1220 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I275_piedras) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1220, 1220);
    ! [2: say ~Son las piedras que forman el altar. Son piedras malditas.~]
    say__p=1;! [3: ~Son las piedras que forman el altar. Son piedras malditas.~]
    ParaContent(); print "Son las piedras que forman el altar. Son piedras malditas."; new_line; .L_Say73; .L_SayX70;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1220, 1220, 'action');
    rfalse;
];
! No specific request
! Instead of taking the piedras:
[ R_1221 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I275_piedras) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1221, 1221);
    ! [2: try taking the piedra]
    TryAction(0, player, ##Take, I276_piedra, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1221, 1221, 'action');
    rfalse;
];
! No specific request
! Instead of attacking the hermano:
[ R_1233 ;
    if ((((action ==##Attack) &&  (actor==player) && ((noun == I282_hermano) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1233, 1233);
    ! [2: if the player carries the piedra]
    if (((player == CarrierOf(I276_piedra))))
    {! [3: try throwing the piedra at the hermano]
        TryAction(0, player, ##ThrowAt, I276_piedra, I282_hermano);
        } else {
        ! [4: say ~[italic type]'¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!''[roman type], dice la musa.[paragraph break]~]
        say__p=1;! [5: italic type]
        ParaContent(); style underline;! [6: ~'¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!''~]
        ParaContent(); print "~¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!~~";! [7: roman type]
        ParaContent(); style roman;! [8: ~, dice la musa.~]
        ParaContent(); print ", dice la musa.";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say74; .L_SayX71;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1233, 1233, 'action');
        rfalse;
];
! No specific request
! Instead of smelling or tasting the musa:
[ R_1135 ;
    if ((((action ==##Taste or ##Smell) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1135, 1135);
    ! [2: say ~Huele a cenizas, dolor y desesperación.~]
    say__p=1;! [3: ~Huele a cenizas, dolor y desesperación.~]
    ParaContent(); print "Huele a cenizas, dolor y desesperación."; new_line; .L_Say75; .L_SayX72;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1135, 1135, 'action');
    rfalse;
];
! No specific request
! Instead of smelling or tasting the libro:
[ R_1142 ;
    if ((((action ==##Taste or ##Smell) &&  (actor==player) && ((noun == I222_libro) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1142, 1142);
    ! [2: say ~Su olor es una mezcla se sangre y cenizas...~]
    say__p=1;! [3: ~Su olor es una mezcla se sangre y cenizas...~]
    ParaContent(); print "Su olor es una mezcla se sangre y cenizas..."; new_line; .L_Say76; .L_SayX73;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1142, 1142, 'action');
    rfalse;
];
! No specific request
! Instead of fucking or kissing or touching the musa:
[ R_1138 ;
    if ((((action ==##Touch or ##Kiss or ##A91_fucking) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1138, 1138);
    ! [2: say ~[italic type]'Como desees...'[roman type], dice la musa.[paragraph break]El tiempo que pasas con ella en el abismo no siempre es doloroso.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'Como desees...'~]
    ParaContent(); print "~Como desees...~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~El tiempo que pasas con ella en el abismo no siempre es doloroso.~]
    ParaContent(); print "El tiempo que pasas con ella en el abismo no siempre es doloroso.";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say77; .L_SayX74;! [10: wait for any key]
    KeyPause();
    ! [11: say ~[italic type]'Y ahora, [if the musa is espectante]escribe en el libro del destino[else if the musa is complacida]mírame de nuevo[end if]'[roman type], dice la musa. [paragraph break]Pero a veces la inspiración no siempre es placentera.[paragraph break]~]
    say__p=1;! [12: italic type]
    ParaContent(); style underline;! [13: ~'Y ahora, ~]
    ParaContent(); print "~Y ahora, ";! [14: if the musa is espectante]

    	if (~~(((((Adj_106_t1_v10(I220_musa))))))) jump L_Say78;! [15: ~escribe en el libro del destino~]
    ParaContent(); print "escribe en el libro del destino";! [16: else if the musa is complacida]
    ParaContent(); 
    	jump L_SayX75; .L_Say78; if (~~(((((Adj_105_t1_v10(I220_musa))))))) jump L_Say79;! [17: ~mírame de nuevo~]
    ParaContent(); print "mírame de nuevo";! [18: end if]

    	.L_Say79; .L_SayX75;! [19: ~'~]
    ParaContent(); print "~";! [20: roman type]
    ParaContent(); style roman;! [21: ~, dice la musa. ~]
    ParaContent(); print ", dice la musa. ";! [22: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [23: ~Pero a veces la inspiración no siempre es placentera.~]
    ParaContent(); print "Pero a veces la inspiración no siempre es placentera.";! [24: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say80; .L_SayX76;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1138, 1138, 'action');
    rfalse;
];
! No specific request
! Instead of fucking or kissing or touching the ojos:
[ R_1139 ;
    if ((((action ==##Touch or ##Kiss or ##A91_fucking) &&  (actor==player) && ((noun == I221_ojos) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1139, 1139);
    ! [2: try fucking the musa]
    TryAction(0, player, ##A91_fucking, I220_musa, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1139, 1139, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or attacking the libro:
[ R_1141 ;
    if ((((action ==##Attack or ##Push or ##Pull) &&  (actor==player) && ((noun == I222_libro) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1141, 1141);
    ! [2: say ~No acabarás con tu agonía de esta manera, pues el libro es indestructible y bien lo sabes, al igual que lo sabe tu musa.~]
    say__p=1;! [3: ~No acabarás con tu agonía de esta manera, pues el libro es indestructible y bien lo sabes, al igual que lo sabe tu musa.~]
    ParaContent(); print "No acabarás con tu agonía de esta manera, pues el libro es indestructible y bien lo sabes, al igual que lo sabe tu musa."; new_line; .L_Say81; .L_SayX77;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1141, 1141, 'action');
    rfalse;
];
! No specific request
! Instead of talking to or attacking or taking the verdugos:
[ R_1156 ;
    if ((((action ==##Take or ##Attack or ##A83_talking_to) &&  (actor==player) && ((noun == I240_verdugos) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1156, 1156);
    ! [2: say ~Déjalos, están para cumplir tus órdenes.~]
    say__p=1;! [3: ~Déjalos, están para cumplir tus órdenes.~]
    ParaContent(); print "Déjalos, están para cumplir tus órdenes."; new_line; .L_Say82; .L_SayX78;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1156, 1156, 'action');
    rfalse;
];
! No specific request
! Instead of eating or drinking or tasting the ternero:
[ R_1212 ;
    if ((((action ==##Taste or ##Drink or ##Eat) &&  (actor==player) && ((noun == I277_ternero) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1212, 1212);
    ! [2: say ~[italic type]'¿Acaso no son sus vísceras, su corazón y su sangre lo que deseas?'[roman type], pregunta la musa.~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¿Acaso no son sus vísceras, su corazón y su sangre lo que deseas?'~]
    ParaContent(); print "~¿Acaso no son sus vísceras, su corazón y su sangre lo que deseas?~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, pregunta la musa.~]
    ParaContent(); print ", pregunta la musa."; new_line; .L_Say83; .L_SayX79;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1212, 1212, 'action');
    rfalse;
];
! No specific request
! Instead of attacking or pulling or pushing or waving the musa:
[ R_1129 ;
    if ((((action ==##Wave or ##Push or ##Pull or ##Attack) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1129, 1129);
    ! [2: if the player carries the piedra]
    if (((player == CarrierOf(I276_piedra))))
    {! [3: try throwing the piedra at the musa]
        TryAction(0, player, ##ThrowAt, I276_piedra, I220_musa);
        } else {
        ! [4: say ~[italic type]'He dicho que me mires...'[roman type], te ordena la musa.[paragraph break]No puedes dejar de mirar sus ojos...[paragraph break]~]
        say__p=1;! [5: italic type]
        ParaContent(); style underline;! [6: ~'He dicho que me mires...'~]
        ParaContent(); print "~He dicho que me mires...~";! [7: roman type]
        ParaContent(); style roman;! [8: ~, te ordena la musa.~]
        ParaContent(); print ", te ordena la musa.";! [9: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [10: ~No puedes dejar de mirar sus ojos...~]
        ParaContent(); print "No puedes dejar de mirar sus ojos...";! [11: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say84; .L_SayX80;! [12: wait for any key]
        KeyPause();
        ! [13: try examining the musa]
        TryAction(0, player, ##Examine, I220_musa, 0);
        }
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1129, 1129, 'action');
        rfalse;
];
! No specific request
! Instead of touching or pushing or pulling or waving the paisaje:
[ R_1146 ;
    if ((((action ==##Wave or ##Pull or ##Push or ##Touch) &&  (actor==player) && ((noun == I232_paisaje) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1146, 1146);
    ! [2: try examining the paisaje]
    TryAction(0, player, ##Examine, I232_paisaje, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1146, 1146, 'action');
    rfalse;
];
! No specific request
! Instead of touching or pushing or pulling or waving the ovejas:
[ R_1147 ;
    if ((((action ==##Wave or ##Pull or ##Push or ##Touch) &&  (actor==player) && ((noun == I233_ovejas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1147, 1147);
    ! [2: try taking the ovejas]
    TryAction(0, player, ##Take, I233_ovejas, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1147, 1147, 'action');
    rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or kissing the doncella:
[ R_1184 ;
    if ((((action ==##Kiss or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I259_doncella) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1184, 1184);
    ! [2: say ~[italic type]'Demasido delicado, ¡haz lo que hay que hacer!'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'Demasido delicado, ¡haz lo que hay que hacer!'~]
    ParaContent(); print "~Demasido delicado, ¡haz lo que hay que hacer!~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say85; .L_SayX81;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1184, 1184, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or waving or attacking the doncella:
[ R_1185 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull) &&  (actor==player) && ((noun == I259_doncella) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1185, 1185);
    ! [2: say ~[italic type]'¡Eso es! ¡Ahora hazlo ya!'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¡Eso es! ¡Ahora hazlo ya!'~]
    ParaContent(); print "~¡Eso es! ¡Ahora hazlo ya!~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say86; .L_SayX82;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1185, 1185, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or waving or attacking the almohadas:
[ R_1191 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull) &&  (actor==player) && ((noun == I266_almohadas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1191, 1191);
    ! [2: try taking the almohadas]
    TryAction(0, player, ##Take, I266_almohadas, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1191, 1191, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or waving or attacking the diamante:
[ R_1199 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull) &&  (actor==player) && ((noun == I269_diamante) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1199, 1199);
    ! [2: try taking the diamante]
    TryAction(0, player, ##Take, I269_diamante, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1199, 1199, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or waving or attacking the ternero:
[ R_1211 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull) &&  (actor==player) && ((noun == I277_ternero) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1211, 1211);
    ! [2: say ~El ternero está degollado, puedes ver sus vísceras y su corazón aún latiente, derramando sangre.[paragraph break][italic type]'¿Acaso no recuerdas como culminar el ritual?'[roman type], pregunta la musa.~]
    say__p=1;! [3: ~El ternero está degollado, puedes ver sus vísceras y su corazón aún latiente, derramando sangre.~]
    ParaContent(); print "El ternero está degollado, puedes ver sus vísceras y su corazón aún latiente, derramando sangre.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¿Acaso no recuerdas como culminar el ritual?'~]
    ParaContent(); print "~¿Acaso no recuerdas como culminar el ritual?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, pregunta la musa.~]
    ParaContent(); print ", pregunta la musa."; new_line; .L_Say87; .L_SayX83;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1211, 1211, 'action');
    rfalse;
];
! No specific request
! Instead of closing or opening or pulling or waving or pushing the musa:
[ R_1137 ;
    if ((((action ==##Push or ##Wave or ##Pull or ##Open or ##Close) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1137, 1137);
    ! [2: say ~[italic type]'He dicho que me mires...'[roman type], te ordena la musa.[paragraph break]No puedes dejar de mirar sus ojos...[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'He dicho que me mires...'~]
    ParaContent(); print "~He dicho que me mires...~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, te ordena la musa.~]
    ParaContent(); print ", te ordena la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~No puedes dejar de mirar sus ojos...~]
    ParaContent(); print "No puedes dejar de mirar sus ojos...";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say88; .L_SayX84;! [10: wait for any key]
    KeyPause();
    ! [11: try examining the musa]
    TryAction(0, player, ##Examine, I220_musa, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1137, 1137, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the heridas:
[ R_1168 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I250_heridas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1168, 1168);
    ! [2: say ~Déjalas, tampoco quieres mancharte tanto de sangre.~]
    say__p=1;! [3: ~Déjalas, tampoco quieres mancharte tanto de sangre.~]
    ParaContent(); print "Déjalas, tampoco quieres mancharte tanto de sangre."; new_line; .L_Say89; .L_SayX85;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1168, 1168, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the mano:
[ R_1169 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I251_mano) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1169, 1169);
    ! [2: say ~Pisas el trozo de la mano derecha que le falta, tirado ahí en el campo de batalla en un charco de sangre. Sonríes. El hombre se echa a llorar.~]
    say__p=1;! [3: ~Pisas el trozo de la mano derecha que le falta, tirado ahí en el campo de batalla en un charco de sangre. Sonríes. El hombre se echa a llorar.~]
    ParaContent(); print "Pisas el trozo de la mano derecha que le falta, tirado ahí en el campo de batalla en un charco de sangre. Sonríes. El hombre se echa a llorar."; new_line; .L_Say90; .L_SayX86;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1169, 1169, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the soldado:
[ R_1175 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I249_soldado) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1175, 1175);
    ! [2: say ~[italic type]'¿A qué esperas? ¡Mátalo!'[roman type], dice tu Musa. [paragraph break]El hombre implora piedad.~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¿A qué esperas? ¡Mátalo!'~]
    ParaContent(); print "~¿A qué esperas? ¡Mátalo!~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice tu Musa. ~]
    ParaContent(); print ", dice tu Musa. ";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~El hombre implora piedad.~]
    ParaContent(); print "El hombre implora piedad."; new_line; .L_Say91; .L_SayX87;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1175, 1175, 'action');
    rfalse;
];
! No specific request
! Instead of touching or pulling or pushing or waving or attacking the espejo:
[ R_1176 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Touch) &&  (actor==player) && ((noun == I256_espejo) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1176, 1176);
    ! [2: say ~Golpeas el espejo y la doncella cierra los ojos.[paragraph break][italic type]'¿Qué vas a hacer?'[roman type], escuchas a la musa decir... [italic type]'¿Qué debes hacer?'[roman type][paragraph break]~]
    say__p=1;! [3: ~Golpeas el espejo y la doncella cierra los ojos.~]
    ParaContent(); print "Golpeas el espejo y la doncella cierra los ojos.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¿Qué vas a hacer?'~]
    ParaContent(); print "~¿Qué vas a hacer?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, escuchas a la musa decir... ~]
    ParaContent(); print ", escuchas a la musa decir... ";! [9: italic type]
    ParaContent(); style underline;! [10: ~'¿Qué debes hacer?'~]
    ParaContent(); print "~¿Qué debes hacer?~";! [11: roman type]
    ParaContent(); style roman;! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say92; .L_SayX88;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1176, 1176, 'action');
    rfalse;
];
! No specific request
! Instead of touching or pulling or pushing or waving or attacking the butaca:
[ R_1177 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Touch) &&  (actor==player) && ((noun == I258_butaca) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1177, 1177);
    ! [2: say ~Empujas la butaca y la doncella cierra los ojos.[paragraph break][italic type]'¿Qué vas a hacer?'[roman type], escuchas a la musa decir... [italic type]'¿Qué debes hacer?'[roman type][paragraph break]~]
    say__p=1;! [3: ~Empujas la butaca y la doncella cierra los ojos.~]
    ParaContent(); print "Empujas la butaca y la doncella cierra los ojos.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¿Qué vas a hacer?'~]
    ParaContent(); print "~¿Qué vas a hacer?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, escuchas a la musa decir... ~]
    ParaContent(); print ", escuchas a la musa decir... ";! [9: italic type]
    ParaContent(); style underline;! [10: ~'¿Qué debes hacer?'~]
    ParaContent(); print "~¿Qué debes hacer?~";! [11: roman type]
    ParaContent(); style roman;! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say93; .L_SayX89;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1177, 1177, 'action');
    rfalse;
];
! No specific request
! Instead of touching or pulling or pushing or waving or attacking the cepillo:
[ R_1178 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Touch) &&  (actor==player) && ((noun == I263_cepillo) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1178, 1178);
    ! [2: try taking the cepillo]
    TryAction(0, player, ##Take, I263_cepillo, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1178, 1178, 'action');
    rfalse;
];
! No specific request
! Instead of touching or pulling or pushing or waving or attacking the cabello:
[ R_1180 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Touch) &&  (actor==player) && ((noun == I261_cabello) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1180, 1180);
    ! [2: try taking the enredos]
    TryAction(0, player, ##Take, I260_enredos, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1180, 1180, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the telas:
[ R_1190 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I271_telas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1190, 1190);
    ! [2: say ~[italic type]'Las telas pueden tener algo de valor... pero el diamante es lo que hemos venido a buscar'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'Las telas pueden tener algo de valor... pero el diamante es lo que hemos venido a buscar'~]
    ParaContent(); print "~Las telas pueden tener algo de valor... pero el diamante es lo que hemos venido a buscar~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say94; .L_SayX90;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1190, 1190, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the cojines:
[ R_1192 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I267_cojines) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1192, 1192);
    ! [2: try taking the almohadas]
    TryAction(0, player, ##Take, I266_almohadas, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1192, 1192, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking the mercader:
[ R_1194 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I270_mercader) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1194, 1194);
    ! [2: say ~No logras moverlo. [if the mercader is vivo]El mercader resopla pesadamente.[paragraph break][otherwise]Sin embargo, ya no sostiene el diamante con tanta fuerza...[paragraph break]~]
    say__p=1;! [3: ~No logras moverlo. ~]
    ParaContent(); print "No logras moverlo. ";! [4: if the mercader is vivo]

    	if (~~(((((Adj_107_t1_v10(I270_mercader))))))) jump L_Say95;! [5: ~El mercader resopla pesadamente.~]
    ParaContent(); print "El mercader resopla pesadamente.";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [7: otherwise]

    	jump L_SayX91; .L_Say95;! [8: ~Sin embargo, ya no sostiene el diamante con tanta fuerza...~]
    ParaContent(); print "Sin embargo, ya no sostiene el diamante con tanta fuerza...";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say96; .L_SayX91;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1194, 1194, 'action');
    rfalse;
];
! No specific request
! Instead of examining or closing or opening or pulling or waving or pushing the ojos:
[ R_1136 ;
    if ((((action ==##Push or ##Wave or ##Pull or ##Open or ##Close or ##Examine) &&  (actor==player) && ((noun == I221_ojos) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1136, 1136);
    ! [2: say ~[italic type]'He dicho que me mires...'[roman type], te ordena la musa.[paragraph break]No puedes dejar de mirar sus ojos...[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'He dicho que me mires...'~]
    ParaContent(); print "~He dicho que me mires...~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, te ordena la musa.~]
    ParaContent(); print ", te ordena la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [8: ~No puedes dejar de mirar sus ojos...~]
    ParaContent(); print "No puedes dejar de mirar sus ojos...";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say97; .L_SayX92;! [10: wait for any key]
    KeyPause();
    ! [11: try examining the musa]
    TryAction(0, player, ##Examine, I220_musa, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1136, 1136, 'action');
    rfalse;
];
! No specific request
! Instead of taking or attacking or touching or pushing or pulling or waving the guerreros:
[ R_1164 ;
    if ((((action ==##Wave or ##Pull or ##Push or ##Touch or ##Attack or ##Take) &&  (actor==player) && ((noun == I247_guerreros) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1164, 1164);
    ! [2: try examining the guerreros]
    TryAction(0, player, ##Examine, I247_guerreros, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1164, 1164, 'action');
    rfalse;
];
! No specific request
! Instead of taking or attacking or touching or pushing or pulling or waving the armas:
[ R_1165 ;
    if ((((action ==##Wave or ##Pull or ##Push or ##Touch or ##Attack or ##Take) &&  (actor==player) && ((noun == I248_armas) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1165, 1165);
    ! [2: try examining the armas]
    TryAction(0, player, ##Examine, I248_armas, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1165, 1165, 'action');
    rfalse;
];
! No specific request
! Instead of taking or touching or pulling or pushing or waving or attacking the enredos:
[ R_1181 ;
    if ((((action ==##Attack or ##Wave or ##Push or ##Pull or ##Touch or ##Take) &&  (actor==player) && ((noun == I260_enredos) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1181, 1181);
    ! [2: say ~Le estiras del cabello a la doncella. Ella apenas opone resistencia.[paragraph break]~]
    say__p=1;! [3: ~Le estiras del cabello a la doncella. Ella apenas opone resistencia.~]
    ParaContent(); print "Le estiras del cabello a la doncella. Ella apenas opone resistencia.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say98; .L_SayX93;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1181, 1181, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or waving or attacking or touching the hoguera:
[ R_1209 ;
    if ((((action ==##Touch or ##Attack or ##Wave or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I273_hoguera) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1209, 1209);
    ! [2: say ~Observas el crepitante fuego de la hoguera...[paragraph break][italic type]'No, el fuego podría matarte, eso no lo hagas...'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: ~Observas el crepitante fuego de la hoguera...~]
    ParaContent(); print "Observas el crepitante fuego de la hoguera...";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'No, el fuego podría matarte, eso no lo hagas...'~]
    ParaContent(); print "~No, el fuego podría matarte, eso no lo hagas...~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say99; .L_SayX94;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1209, 1209, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or waving or kissing or touching or smelling the hermano:
[ R_1232 ;
    if ((((action ==##Smell or ##Touch or ##Kiss or ##Wave or ##Push or ##Pull) &&  (actor==player) && ((noun == I282_hermano) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1232, 1232);
    ! [2: say ~[italic type]'¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!'[roman type], dice la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!'~]
    ParaContent(); print "~¿Para qué te he dado esa piedra? ¡Vamos! ¡Lánzasela a tu hermano!~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, dice la musa.~]
    ParaContent(); print ", dice la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say100; .L_SayX95;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1232, 1232, 'action');
    rfalse;
];
! No specific request
! Instead of pulling or pushing or attacking or waving or kissing or touching or smelling the ajusticiado:
[ R_1163 ;
    if ((((action ==##Smell or ##Touch or ##Kiss or ##Wave or ##Attack or ##Push or ##Pull) &&  (actor==player) && ((noun == I246_ajusticiado) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1163, 1163);
    ! [2: say ~No vale la pena, ya está muerto en vida.[paragraph break]~]
    say__p=1;! [3: ~No vale la pena, ya está muerto en vida.~]
    ParaContent(); print "No vale la pena, ya está muerto en vida.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say101; .L_SayX96;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1163, 1163, 'action');
    rfalse;
];
! No specific request
! Instead of taking or pulling or pushing or attacking or waving or kissing or touching or smelling the pastor:
[ R_1151 ;
    if ((((action ==##Smell or ##Touch or ##Kiss or ##Wave or ##Attack or ##Push or ##Pull or ##Take) &&  (actor==player) && ((noun == I234_pastor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1151, 1151);
    ! [2: say ~[italic type]'Para qué quieres hacerlo, ¿acaso no estás cansado?''[roman type], pregunta la musa.[paragraph break]~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'Para qué quieres hacerlo, ¿acaso no estás cansado?''~]
    ParaContent(); print "~Para qué quieres hacerlo, ¿acaso no estás cansado?~~";! [5: roman type]
    ParaContent(); style roman;! [6: ~, pregunta la musa.~]
    ParaContent(); print ", pregunta la musa.";! [7: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say102; .L_SayX97;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1151, 1151, 'action');
    rfalse;
];
! No specific request
! Instead of listening when the player is in Primer acto:
[ R_1144 ;
    if ((((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((I224_primer_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1144, 1144);
    ! [2: say ~Todo parece muy apacible, no hay ningún ruido.~]
    say__p=1;! [3: ~Todo parece muy apacible, no hay ningún ruido.~]
    ParaContent(); print "Todo parece muy apacible, no hay ningún ruido."; new_line; .L_Say103; .L_SayX98;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1144, 1144, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in Primer acto:
[ R_1145 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I224_primer_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1145, 1145);
    ! [2: say ~El suave aroma del pasto invita a relajarse y descansar.~]
    say__p=1;! [3: ~El suave aroma del pasto invita a relajarse y descansar.~]
    ParaContent(); print "El suave aroma del pasto invita a relajarse y descansar."; new_line; .L_Say104; .L_SayX99;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1145, 1145, 'action');
    rfalse;
];
! No specific request
! Instead of listening when the player is in Segundo acto:
[ R_1154 ;
    if ((((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((I225_segundo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1154, 1154);
    ! [2: say ~Escuchas los graznidos de los cuervos.~]
    say__p=1;! [3: ~Escuchas los graznidos de los cuervos.~]
    ParaContent(); print "Escuchas los graznidos de los cuervos."; new_line; .L_Say105; .L_SayX100;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1154, 1154, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in Segundo acto:
[ R_1155 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I225_segundo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1155, 1155);
    ! [2: say ~El banquete huele estupendamente, para desesperación del hombre ajusticiado.~]
    say__p=1;! [3: ~El banquete huele estupendamente, para desesperación del hombre ajusticiado.~]
    ParaContent(); print "El banquete huele estupendamente, para desesperación del hombre ajusticiado."; new_line; .L_Say106; .L_SayX101;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1155, 1155, 'action');
    rfalse;
];
! No specific request
! Instead of listening when the player is in Quinto acto:
[ R_1188 ;
    if ((((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((I228_quinto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1188, 1188);
    ! [2: say ~[if mercader is vivo]Escuchas los poderosos ronquidos del mercader.[otherwise]La estancia ha quedado en silencio tras tu acto.~]
    say__p=1;! [3: if mercader is vivo]

    	if (~~(((((Adj_107_t1_v10(I270_mercader))))))) jump L_Say107;! [4: ~Escuchas los poderosos ronquidos del mercader.~]
    ParaContent(); print "Escuchas los poderosos ronquidos del mercader."; new_line;! [5: otherwise]

    	jump L_SayX102; .L_Say107;! [6: ~La estancia ha quedado en silencio tras tu acto.~]
    ParaContent(); print "La estancia ha quedado en silencio tras tu acto."; new_line; .L_Say108; .L_SayX102;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1188, 1188, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in Quinto acto:
[ R_1189 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I228_quinto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1189, 1189);
    ! [2: say ~El aire parece estar perfumado con ricas fragancias de oriente.~]
    say__p=1;! [3: ~El aire parece estar perfumado con ricas fragancias de oriente.~]
    ParaContent(); print "El aire parece estar perfumado con ricas fragancias de oriente."; new_line; .L_Say109; .L_SayX103;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1189, 1189, 'action');
    rfalse;
];
! No specific request
! Instead of listening when the player is in Sexto acto:
[ R_1201 ;
    if ((((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1201, 1201);
    ! [2: say ~Los cánticos de tus acólitos se escuchan guturales en la negra noche.~]
    say__p=1;! [3: ~Los cánticos de tus acólitos se escuchan guturales en la negra noche.~]
    ParaContent(); print "Los cánticos de tus acólitos se escuchan guturales en la negra noche."; new_line; .L_Say110; .L_SayX104;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1201, 1201, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in Sexto acto:
[ R_1203 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I229_sexto_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1203, 1203);
    ! [2: say ~El dulce aroma de la sangre embriaga tus sentidos.~]
    say__p=1;! [3: ~El dulce aroma de la sangre embriaga tus sentidos.~]
    ParaContent(); print "El dulce aroma de la sangre embriaga tus sentidos."; new_line; .L_Say111; .L_SayX105;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1203, 1203, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in altar:
[ R_1204 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1204, 1204);
    ! [2: say ~El dulce aroma de la sangre y las vísceras te embota los sentidos.~]
    say__p=1;! [3: ~El dulce aroma de la sangre y las vísceras te embota los sentidos.~]
    ParaContent(); print "El dulce aroma de la sangre y las vísceras te embota los sentidos."; new_line; .L_Say112; .L_SayX106;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1204, 1204, 'action');
    rfalse;
];
! No specific request
! Instead of exiting when the player is in altar:
[ R_1218 ;
    if ((((action ==##Exit) &&  (actor==player) && (self=actor,true) && (((I274_altar == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1218, 1218);
    ! [2: try silently getting off the altar]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##GetOff, I274_altar, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1218, 1218, 'action');
    rfalse;
];
! No specific request
! Instead of listening when the player is in Septimo acto:
[ R_1227 ;
    if ((((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((I230_septimo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1227, 1227);
    ! [2: say ~Escuchas los truenos de una fuerte tormenta que llega...~]
    say__p=1;! [3: ~Escuchas los truenos de una fuerte tormenta que llega...~]
    ParaContent(); print "Escuchas los truenos de una fuerte tormenta que llega..."; new_line; .L_Say113; .L_SayX107;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1227, 1227, 'action');
    rfalse;
];
! No specific request
! Instead of smelling when the player is in Septimo acto:
[ R_1228 ;
    if ((((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((I230_septimo_acto == ContainerOf(player))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1228, 1228);
    ! [2: say ~Se puede oler el embriagador aroma de la venganza.~]
    say__p=1;! [3: ~Se puede oler el embriagador aroma de la venganza.~]
    ParaContent(); print "Se puede oler el embriagador aroma de la venganza."; new_line; .L_Say114; .L_SayX108;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1228, 1228, 'action');
    rfalse;
];
! No specific request
! Instead of thinking:
[ R_1115 ;
    if ((((action ==##Think) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1115, 1115);
    ! [2: say ~¿Como puedo escapar de esta espiral de odio y destrucción?[paragraph break][italic type]'¿En qué piensas?'[roman type], pregunta la musa.[paragraph break]~]
    say__p=1;! [3: ~¿Como puedo escapar de esta espiral de odio y destrucción?~]
    ParaContent(); print "¿Como puedo escapar de esta espiral de odio y destrucción?";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'¿En qué piensas?'~]
    ParaContent(); print "~¿En qué piensas?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, pregunta la musa.~]
    ParaContent(); print ", pregunta la musa.";! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say115; .L_SayX109;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1115, 1115, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B23_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! After examining the musa:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! After responding with ( this is the revert to normal conversation rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! After examining the musa:
[ R_1128 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I220_musa) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1128, 1128);
    ! [2: if the musa is espectante]
    if ((((Adj_106_t1_v10(I220_musa)))))
    {! [3: display the figure musa esperando]
        DisplayFigure(ResourceIDsOfFigures-->I205_figure_musa_esperando, 0);
        ! [4: say ~[line break]La musa espera que escribas en el libro del destino.[paragraph break]~]
        say__p=1;! [5: line break]
        ParaContent(); new_line;! [6: ~La musa espera que escribas en el libro del destino.~]
        ParaContent(); print "La musa espera que escribas en el libro del destino.";! [7: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say116; .L_SayX110;} else {
        ! [8: if the musa is complacida]
        if ((((Adj_105_t1_v10(I220_musa)))))
        {! [9: display the figure musa riendo]
            DisplayFigure(ResourceIDsOfFigures-->I206_figure_musa_riendo, 0);
            ! [10: say ~Su visión te produce una extraña reacción que ahora conoces muy bien... comienza tu inspiración.~]
            say__p=1;! [11: ~Su visión te produce una extraña reacción que ahora conoces muy bien... comienza tu inspiración.~]
            ParaContent(); print "Su visión te produce una extraña reacción que ahora conoces muy bien... comienza tu inspiración."; new_line; .L_Say117; .L_SayX111;! [12: now the pluma is in location]
            MoveObject(I219_pluma,real_location);
            ! [13: if pecados is 0]
            if ((((Global_Vars-->34) == 0)))
            {! [14: if primer acto is unvisited]
                if ((((Adj_63_t1_v10(I224_primer_acto)))))
                {! [15: increase the score by 1]
                    score = score + 1;;
                    }
                ! [16: wait for any key]
                KeyPause();
                ! [17: clear the screen]
                VM_ClearScreen(0);
                ! [18: now the player is in primer acto]
                MoveObject(player,I224_primer_acto);
                } else {
                ! [19: if pecados is 1]
                if ((((Global_Vars-->34) == 1)))
                {! [20: if segundo acto is unvisited]
                    if ((((Adj_63_t1_v10(I225_segundo_acto)))))
                    {! [21: increase the score by 1]
                        score = score + 1;;
                        }
                    ! [22: wait for any key]
                    KeyPause();
                    ! [23: clear the screen]
                    VM_ClearScreen(0);
                    ! [24: now the player is in segundo acto]
                    MoveObject(player,I225_segundo_acto);
                    } else {
                    ! [25: if pecados is 2]
                    if ((((Global_Vars-->34) == 2)))
                    {! [26: if tercer acto is unvisited]
                        if ((((Adj_63_t1_v10(I226_tercer_acto)))))
                        {! [27: increase the score by 1]
                            score = score + 1;;
                            }
                        ! [28: wait for any key]
                        KeyPause();
                        ! [29: clear the screen]
                        VM_ClearScreen(0);
                        ! [30: now the player is in tercer acto]
                        MoveObject(player,I226_tercer_acto);
                        } else {
                        ! [31: if pecados is 3]
                        if ((((Global_Vars-->34) == 3)))
                        {! [32: wait for any key]
                            KeyPause();
                            ! [33: clear the screen]
                            VM_ClearScreen(0);
                            ! [34: now the player is in cuarto acto]
                            MoveObject(player,I227_cuarto_acto);
                            ! [35: if cuarto acto is unvisited]
                            if ((((Adj_63_t1_v10(I227_cuarto_acto)))))
                            {! [36: increase the score by 1]
                                score = score + 1;;
                                }
                                } else {
                            ! [37: if pecados is 4]
                            if ((((Global_Vars-->34) == 4)))
                            {! [38: if quinto acto is unvisited]
                                if ((((Adj_63_t1_v10(I228_quinto_acto)))))
                                {! [39: increase the score by 1]
                                    score = score + 1;;
                                    }
                                ! [40: wait for any key]
                                KeyPause();
                                ! [41: clear the screen]
                                VM_ClearScreen(0);
                                ! [42: now the player is in quinto acto]
                                MoveObject(player,I228_quinto_acto);
                                } else {
                                ! [43: if pecados is 5]
                                if ((((Global_Vars-->34) == 5)))
                                {! [44: if sexto acto is unvisited]
                                    if ((((Adj_63_t1_v10(I229_sexto_acto)))))
                                    {! [45: increase the score by 1]
                                        score = score + 1;;
                                        }
                                    ! [46: wait for any key]
                                    KeyPause();
                                    ! [47: clear the screen]
                                    VM_ClearScreen(0);
                                    ! [48: now the player is in sexto acto]
                                    MoveObject(player,I229_sexto_acto);
                                    } else {
                                    ! [49: if pecados is 6]
                                    if ((((Global_Vars-->34) == 6)))
                                    {! [50: if septimo acto is unvisited]
                                        if ((((Adj_63_t1_v10(I230_septimo_acto)))))
                                        {! [51: increase the score by 1]
                                            score = score + 1;;
                                            }
                                        ! [52: wait for any key]
                                        KeyPause();
                                        ! [53: clear the screen]
                                        VM_ClearScreen(0);
                                        ! [54: now the player carries the piedra]
                                        MoveObject(I276_piedra,player);
                                        ! [55: now the description of the piedra is ~Es una piedra ensangrentada, con la que cometiste tu primer asesinato.~]
                                        BlkValueCopy(GProperty(10, I276_piedra,description), TX_L_245);
                                        ! [56: now the player is in septimo acto]
                                        MoveObject(player,I230_septimo_acto);
                                        }
                                        }
                                        }
                                        }
                                        }
                                        }
                                        }
                                        } else {
            ! [57: say ~Su visión te produce una extraña reacción que ahora conoces muy bien... ~]
            say__p=1;! [58: ~Su visión te produce una extraña reacción que ahora conoces muy bien... ~]
            ParaContent(); print "Su visión te produce una extraña reacción que ahora conoces muy bien... "; .L_Say118; .L_SayX112;}
            }
            RulebookSucceeds(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1128, 1128, 'action');
            rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! After responding with ( this is the revert to normal conversation rule ):
[ R_946 ;
    if ((((action ==##A82_responding_with) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_946, 946);
    ! [2: display the qbc options]
    (PHR_947_r7 ());
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_946, 946, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B25_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Does the player mean examining or taking the almohadas in the presence of the almohada:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 3/4 ! Does the player mean taking off something worn:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 4/4 ! Does the player mean talking to a person:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Does the player mean examining or taking the almohadas in the presence of the almohada:
[ R_1187 ;
    if ((((action ==##Take or ##Examine) &&  (actor==player) && ((noun == I266_almohadas) && (true)) && (((I268_almohada == I268_almohada) && (true))&& (TestScope(I268_almohada, actor)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1187, 1187);
    ! [2: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1187, 1187, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_38 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_38, 38);
    ! [2: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_38, 38, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Does the player mean taking off something worn:
[ R_242 ;
    if ((((action ==##Disrobe) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_0_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_242, 242);
    ! [2: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_242, 242, 'action');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Does the player mean talking to a person:
[ R_948 ;
    if ((((action ==##A83_talking_to) &&  (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_948, 948);
    ! [2: it is likely]
    RulebookSucceeds(22, RBNO_7); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_948, 948, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B29_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_66 
    tmp_0 ! Let/loop value, e.g., 'item being printed': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_66, 66);
    ! [2: if expanding text for comparison purposes]
    if ((say__comp))
    {! [3: continue the activity]
        rfalse;
        }
    ! [4: now the item being printed is mentioned]
    (Adj_78_t2_v10(tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_66, 66, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B33_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_67 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_67, 67);
    ! [2: say the printed plural name of the item]
    say__p=1;! [3: the printed plural name of the item]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_0,plural);@pull self;  .L_Say119; .L_SayX113;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_67, 67, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B36_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_68 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_68, 68);
    ! [2: say ~[listing group size in words] ~]
    say__p=1;! [3: listing group size in words]
    ParaContent(); print (number) say__n=(listing_size);! [4: ~ ~]
    ParaContent(); print " "; .L_Say120; .L_SayX114;! [5: carry out the printing the plural name activity with the item]
    CarryOutActivity(V1_printing_the_plural_name, tmp_0);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_68, 68, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B66_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the look around once light available rule:
[ R_69 ;
    if (debug_rules) DB_Rule(R_69, 69);
    ! [2: try looking]
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Constructing the status line (B72_for_constructing_the_sta)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
! ----------------------------------------------------------------------------------------------------
! From "Menus" by Emily Short
! No specific request
! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
[ R_910 ;
    if (((TestActivity(V35_displaying)))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_910, 910);
    ! [2: if the endnode flag is 0]
    if ((((Global_Vars-->13) == 0)))
    {! [3: fill status bar with table of deep menu status]
        (PHR_891_r8 (T9_deep_menu_status));
        } else {
        ! [4: fill status bar with table of shallow menu status]
        (PHR_891_r8 (T8_shallow_menu_status));
        }
    ! [5: rule succeeds]
    RulebookSucceeds(); rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_910, 910, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B87_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
!   >>> III - When/while requirement >>>
! Rule 2/5 ! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/5 ! Rule for deciding whether all includes things enclosed by the person reaching while taking or taking off or removing ( this is the exclude indirect possessions from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/5 ! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 5/5 ! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
[ R_74 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Drop) &&  (actor==player))))) || (((((action ==##ThrowAt) &&  (actor==player))))) || (((((action ==##Insert) &&  (actor==player))))) || (((((action ==##PutOn) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_74, 74);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_74, 74, 'context');
    } else if (debug_rules > 1) DB_Rule(R_74, 74, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
[ R_70 ;
    if ((((((Adj_70_t1_v10(parameter_value))) && (true))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_70, 70);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'context');
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes things enclosed by the person reaching while taking or taking off or removing ( this is the exclude indirect possessions from take all rule ):
[ R_73 ;
    if (((((parameter_value ofclass K2_thing) && (IndirectlyContains(actor,parameter_value)))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_73, 73);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'context');
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
[ R_72 ;
    if (((((parameter_value ofclass K2_thing) && ((Adj_68_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_72, 72);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'context');
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
[ R_71 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_71, 71);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'context');
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing a parser error (B95_before_printing_a_parser)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing a parser error when RQ is active and the latest parser error is the didn't understand that number error:
!   === equally specific with ===
! Rule 2/2 ! Before printing a parser error when QBC is active and the latest parser error is the didn't understand that number error:
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Before printing a parser error when RQ is active and the latest parser error is the didn't understand that number error:
[ R_934 ;
    if (((((((PHR_926_r2 ()))) && (((etype == I82_didn_t_understand_that_n))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_934, 934);
    ! [2: now the latest parser error is the didn't understand error]
    etype = I80_didn_t_understand_error;
    } else if (debug_rules > 1) DB_Rule(R_934, 934, 'context');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Before printing a parser error when QBC is active and the latest parser error is the didn't understand that number error:
[ R_958 ;
    if (((((((PHR_942_r9 ()))) && (((etype == I82_didn_t_understand_that_n))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_958, 958);
    ! [2: now the latest parser error is the didn't understand error]
    etype = I80_didn_t_understand_error;
    } else if (debug_rules > 1) DB_Rule(R_958, 958, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B99_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === equally specific with ===
! Rule 2/4 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === equally specific with ===
! Rule 3/4 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
! --- now the last-placed rules ---
! Rule 4/4 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_75 ;
    if (((((((action ==##Smell) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_75, 75);
    ! [2: now the noun is the touchability ceiling of the player]
    noun = TouchabilityCeiling(player);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_75, 75, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_76 ;
    if (((((((action ==##Listen) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_76, 76);
    ! [2: now the noun is the touchability ceiling of the player]
    noun = TouchabilityCeiling(player);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_76, 76, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_77 ;
    if (((((((action ==##Go) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_77, 77);
    ! [2: say ~You'll have to say which compass direction to go in.~ ( a )]
    say__p=1;! [3: ~You'll have to say which compass direction to go in.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_135); new_line; .L_Say121; .L_SayX115;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_77, 77, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_162 
    tmp_0 ! Let/loop value, e.g., 'box': thing
    ;
    if (((((((action ==##Enter) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_162, 162);
    ! [2: if something enterable ( called the box ) is in the location]
    if ((((Prop_1() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: now the noun is the box]
        noun = tmp_0;
        } else {
        ! [4: continue the activity]
        rfalse;
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_162, 162, 'context');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing second noun (B102_for_supplying_a_missing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for supplying a missing second noun while writing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for supplying a missing second noun while writing:
[ R_1109 ;
    if (((((((action ==##A86_writing_it_in) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1109, 1109);
    ! [2: if the libro is in location and the player carries the pluma]
    if ((((real_location == ContainerOf(I222_libro)))) && (((player == CarrierOf(I219_pluma)))))
    {! [3: now the second noun is the libro]
        second = I222_libro;
        } else {
        ! [4: if the pluma is not carried by the player]
        if (((~~((player == CarrierOf(I219_pluma))))))
        {! [5: now the second noun is the player]
            second = player;
            ! [6: say ~'[italic type]Coge tu pluma y escribe algo en el libro que te ofrezco'[roman type], dice la musa.[paragraph break]~]
            say__p=1;! [7: ~'~]
            ParaContent(); print "~";! [8: italic type]
            ParaContent(); style underline;! [9: ~Coge tu pluma y escribe algo en el libro que te ofrezco'~]
            ParaContent(); print "Coge tu pluma y escribe algo en el libro que te ofrezco~";! [10: roman type]
            ParaContent(); style roman;! [11: ~, dice la musa.~]
            ParaContent(); print ", dice la musa.";! [12: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say122; .L_SayX116;} else {
            ! [13: if the libro is not in the location]
            if (((~~((real_location == ContainerOf(I222_libro))))))
            {! [14: now the second noun is the player]
                second = player;
                ! [15: say ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                say__p=1;! [16: ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                ParaContent(); print "Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar."; new_line; .L_Say123; .L_SayX117;}
                }
                }
                RulebookSucceeds(); rtrue;
                } else if (debug_rules > 1) DB_Rule(R_1109, 1109, 'context');
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Starting the virtual machine (B107_before_starting_the_vir)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7: INITIALISE_MEMORY_R
! --- now the mid-placed rules ---
! Rule 2/7 ! Before starting the virtual machine ( this is the Flexible Windows sort the Table of User Styles rule ):
!   >>> IV - Action requirement >>>
! Rule 3/7: POSITION_PLAYER_IN_MODEL_R
!   === equally specific with ===
! Rule 4/7: ENABLE_GLULX_ACCEL_R
!   === equally specific with ===
! Rule 5/7: SEED_RANDOM_NUMBER_GENERATOR_R
!   === equally specific with ===
! Rule 6/7: ASR_CheckForGlk
!   === equally specific with ===
! Rule 7/7: ASR_GGRecoverObjects
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! Before starting the virtual machine ( this is the Flexible Windows sort the Table of User Styles rule ):
[ R_1076 
    tmp_0 ! Let/loop value, e.g., 'row1': number
    tmp_1 ! Let/loop value, e.g., 'row2': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_1076, 1076);
    ! [2: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_0=T3_user_styles, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if there is no window entry]
        if (((ExistsTableLookUpEntry(ct_0,107,ct_1) == false)))
        {! [4: now the window entry is all-buffer-windows]
            TableLookUpEntry(ct_0,107,ct_1,1,I198_all_buffer_windows);
            }
        ! [5: if there is no style name entry]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1) == false)))
        {! [6: now the style name entry is all-styles]
            TableLookUpEntry(ct_0,108,ct_1,1,I126_all_styles);
            }
            }
            @pull ct_1; @pull ct_0;! [7: sort the table of user styles in style name order]
    TableSort(T3_user_styles, 108, 1);
    ! [8: sort the table of user styles in window order]
    TableSort(T3_user_styles, 107, 1);
    ! [9: let row1 be 1]

    		tmp_0 = 1;
    ! [10: let row2 be 2]

    		tmp_1 = 2;
    ! [11: while row2 <= the number of rows in the table of user styles]
    while (((tmp_1 <= TableRows(T3_user_styles))))
    {! [12: choose row row2 in the table of user styles]
        ct_0 = T3_user_styles; ct_1 = tmp_1;
        ! [13: if there is a style name entry]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1))))
        {! [14: if ( the window in row row1 of the table of user styles ) is the window entry and ( the style name in row row1 of the table of user styles ) is the style name entry]
            if ((((TableLookUpEntry(T3_user_styles,107,tmp_0) == TableLookUpEntry(ct_0,107,ct_1)))) && (((TableLookUpEntry(T3_user_styles,108,tmp_0) == TableLookUpEntry(ct_0,108,ct_1)))))
            {! [15: if there is a background color entry]
                if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
                {! [16: now the background color in row row1 of the table of user styles is the background color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,109,tmp_0,5), TableLookUpEntry(ct_0,109,ct_1));
                    }
                ! [17: if there is a color entry]
                if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
                {! [18: now the color in row row1 of the table of user styles is the color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,110,tmp_0,5), TableLookUpEntry(ct_0,110,ct_1));
                    }
                ! [19: if there is a first line indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
                {! [20: now the first line indentation in row row1 of the table of user styles is the first line indentation entry]
                    TableLookUpEntry(T3_user_styles,111,tmp_0,1,TableLookUpEntry(ct_0,111,ct_1));
                    }
                ! [21: if there is a fixed width entry]
                if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
                {! [22: now the fixed width in row row1 of the table of user styles is the fixed width entry]
                    TableLookUpEntry(T3_user_styles,112,tmp_0,1,TableLookUpEntry(ct_0,112,ct_1));
                    }
                ! [23: if there is a font weight entry]
                if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
                {! [24: now the font weight in row row1 of the table of user styles is the font weight entry]
                    TableLookUpEntry(T3_user_styles,113,tmp_0,1,TableLookUpEntry(ct_0,113,ct_1));
                    }
                ! [25: if there is a indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
                {! [26: now the indentation in row row1 of the table of user styles is the indentation entry]
                    TableLookUpEntry(T3_user_styles,114,tmp_0,1,TableLookUpEntry(ct_0,114,ct_1));
                    }
                ! [27: if there is a italic entry]
                if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
                {! [28: now the italic in row row1 of the table of user styles is the italic entry]
                    TableLookUpEntry(T3_user_styles,115,tmp_0,1,TableLookUpEntry(ct_0,115,ct_1));
                    }
                ! [29: if there is a justification entry]
                if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
                {! [30: now the justification in row row1 of the table of user styles is the justification entry]
                    TableLookUpEntry(T3_user_styles,116,tmp_0,1,TableLookUpEntry(ct_0,116,ct_1));
                    }
                ! [31: if there is a relative size entry]
                if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
                {! [32: now the relative size in row row1 of the table of user styles is the relative size entry]
                    TableLookUpEntry(T3_user_styles,117,tmp_0,1,TableLookUpEntry(ct_0,117,ct_1));
                    }
                ! [33: if there is a reversed entry]
                if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
                {! [34: now the reversed in row row1 of the table of user styles is the reversed entry]
                    TableLookUpEntry(T3_user_styles,118,tmp_0,1,TableLookUpEntry(ct_0,118,ct_1));
                    }
                ! [35: blank out the whole row]
                TableBlankOutRow(ct_0, ct_1);
                } else {
                ! [36: now row1 is row2]
                tmp_0 = tmp_1;
                }
                }
        ! [37: increment row2]
        tmp_1 = tmp_1 + 1;;
        }
    ! [38: sort the table of user styles in window order]
    TableSort(T3_user_styles, 107, 1);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Starting the virtual machine (B108_for_starting_the_virtua)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2: ASR_SoundChannelInitialisation
!   <<< IV - Action requirement <<<
! Rule 2/2 ! This is the open the built-in windows using Flexible Windows rule:
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! This is the open the built-in windows using Flexible Windows rule:
[ R_1030 ;
    if (debug_rules) DB_Rule(R_1030, 1030);
    ! [2: if the main window is g-unpresent]
    if ((((Adj_103_t1_v10(I200_main_window)))))
    {! [3: open the main window]
        (PHR_1040_r10 (I200_main_window));
        } else {
        ! [4: clear the main window]
        (PHR_1048_r11 (I200_main_window));
        }
    ! [5: if the no status line option is active]
    if ((((Adj_25_t1_v16(32)))))
    {! [6: close the status window]
        (PHR_1041_r12 (I201_status_window));
        } else {
        ! [7: open the status window]
        (PHR_1040_r10 (I201_status_window));
        }
    ! [8: close the quote window]
    (PHR_1041_r12 (I202_quote_window));
    ! [9: continue the activity]
    rfalse;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Starting the virtual machine (B109_after_starting_the_virt)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! First after starting the virtual machine rule ( this is the initial whitespace rule ):
! --- now the mid-placed rules ---
! Rule 2/3 ! After starting the virtual machine ( this is the alternative start in the correct scenes rule ):
!   >>> IV - Action requirement >>>
! Rule 3/3: UPDATE_CHRONOLOGICAL_RECORDS_R
! ----------------------------------------------------------------------------------------------------
! From "Alternative Startup Rules" by Dannii Willis
! No specific request
! First after starting the virtual machine rule ( this is the initial whitespace rule ):
[ R_961 ;
    if (debug_rules) DB_Rule(R_961, 961);
    ! [2: say ~[line break][line break][line break]~]
    say__p=1;! [3: line break]
    ParaContent(); new_line;! [4: line break]
    ParaContent(); new_line;! [5: line break]
    ParaContent(); new_line; .L_Say124; .L_SayX118;rfalse;
];
! From "Alternative Startup Rules" by Dannii Willis
! No specific request
! After starting the virtual machine ( this is the alternative start in the correct scenes rule ):
[ R_962 ;
    if (debug_rules) DB_Rule(R_962, 962);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B116_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the print the final question rule:
[ R_79 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_79, 79);
    ! [2: let named options count be 0]

    		tmp_0 = 0;
    ! [3: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [5: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [6: if there is a final question wording entry]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1))))
                {! [7: increase named options count by 1]
                    tmp_0 = tmp_0 + 1;;
                    }
                    }
                    }
                    }
                    @pull ct_1; @pull ct_0;! [8: if the named options count is less than 1]
    if (((tmp_0 < 1)))
    {! [9: abide by the immediately quit rule]
        if (FollowRulebook(IMMEDIATELY_QUIT_R)) rtrue;
        }
    ! [10: say ~Would you like to ~ ( a )]
    say__p=1;! [11: ~Would you like to ~ ( a )]
    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_136); .L_Say125; .L_SayX119;! [12: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [13: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [14: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [15: if there is a final question wording entry]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1))))
                {! [16: say final question wording entry]
                    say__p=1;! [17: final question wording entry]
                    ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,100,ct_1); .L_Say126; .L_SayX120;! [18: decrease named options count by 1]
                    tmp_0 = tmp_0 - 1;;
                    ! [19: if the named options count is 1]
                    if (((tmp_0 == 1)))
                    {! [20: if the serial comma option is active]
                        if ((((Adj_25_t1_v16(6)))))
                        {! [21: say ~,~]
                            say__p=1;! [22: ~,~]
                            ParaContent(); print ","; .L_Say127; .L_SayX121;}
                        ! [23: say ~ or ~ ( b )]
                        say__p=1;! [24: ~ or ~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_137); .L_Say128; .L_SayX122;} else {
                        ! [25: if the named options count is 0]
                        if (((tmp_0 == 0)))
                        {! [26: say ~?[line break]~]
                            say__p=1;! [27: ~?~]
                            ParaContent(); print "?";! [28: line break]
                            ParaContent(); new_line; .L_Say129; .L_SayX123;} else {
                            ! [29: say ~, ~]
                            say__p=1;! [30: ~, ~]
                            ParaContent(); print ", "; .L_Say130; .L_SayX124;}
                            }
                            }
                            }
                            }
                            }
                            @pull ct_1; @pull ct_0;rfalse;
];
! From the Standard Rules
! No specific request
! This is the print the final prompt rule:
[ R_78 ;
    if (debug_rules) DB_Rule(R_78, 78);
    ! [2: say ~> [run paragraph on]~ ( a )]
    say__p=1;! [3: ~> [run paragraph on]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_138); .L_Say131; .L_SayX125;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B117_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the standard respond to final question rule:
[ R_80 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_80, 80);
    ! [2: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_0=T0_final_question_options, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [4: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [5: if the player's command matches the topic entry]
                if (((SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1)))))
                {! [6: if there is a final response rule entry]
                    if (((ExistsTableLookUpEntry(ct_0,103,ct_1))))
                    {! [7: abide by final response rule entry]
                        if (FollowRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue;
                        } else {
                        ! [8: carry out the final response activity entry activity]
                        CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1));
                        }
                    ! [9: rule succeeds]
                    RulebookSucceeds(); rtrue;
                    }
                    }
                    }
                    }
                    @pull ct_1; @pull ct_0;! [10: say ~Please give one of the answers above.~ ( a )]
    say__p=1;! [11: ~Please give one of the answers above.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),(LocalParking-->2=tmp_0),(LocalParking-->3=tmp_1),TX_R_139); new_line; .L_Say132; .L_SayX126;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B119_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_83 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    if (debug_rules) DB_Rule(R_83, 83);
    ! [2: now the locale paragraph count is 0]
    (Global_Vars-->9) = 0;
    ! [3: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_0=T1_locale_priorities, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: blank out the whole row]
        TableBlankOutRow(ct_0, ct_1);
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_84 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    ;
    if (debug_rules) DB_Rule(R_84, 84);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: carry out the choosing notable locale objects activity with the domain]
    CarryOutActivity(V31_choosing_notable_locale_, tmp_0);
    ! [4: continue the activity]
    rfalse;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B120_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_85 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_85, 85);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: sort the table of locale priorities in locale description priority order]
    TableSort(T1_locale_priorities, 106, 1);
    ! [4: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_1=T1_locale_priorities, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: carry out the printing a locale paragraph about activity with the notable-object entry]
        CarryOutActivity(V32_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1));
        }
        @pull ct_1; @pull ct_0;! [6: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_86 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_86, 86);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: let the mentionable count be 0]

    		tmp_1 = 0;
    ! [4: repeat with item running through things]
    for (tmp_2=Prop_2(0), tmp_3=Prop_2(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_2(tmp_3))
    {! [5: now the item is not marked for listing]
        (Adj_76_t3_v10(tmp_2));
        }
    ! [6: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_2=T1_locale_priorities, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [7: if the locale description priority entry is greater than 0]
        if (((TableLookUpEntry(ct_0,106,ct_1) > 0)))
        {! [8: now the notable-object entry is marked for listing]
            (Adj_76_t2_v10(TableLookUpEntry(ct_0,105,ct_1)));
            }
        ! [9: increase the mentionable count by 1]
        tmp_1 = tmp_1 + 1;;
        }
        @pull ct_1; @pull ct_0;! [10: if the mentionable count is greater than 0]
    if (((tmp_1 > 0)))
    {! [11: repeat with item running through things]
        for (tmp_2=Prop_3(0), tmp_3=Prop_3(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_3(tmp_3))
        {! [12: if the item is mentioned]
            if ((((Adj_78_t1_v10(tmp_2)))))
            {! [13: now the item is not marked for listing]
                (Adj_76_t3_v10(tmp_2));
                }
                }
        ! [14: begin the listing nondescript items activity with the domain]
        BeginActivity(V8_listing_nondescript_items, tmp_0);
        ! [15: if the number of marked for listing things is 0]
        if ((((Prop_4()) == 0)))
        {! [16: abandon the listing nondescript items activity with the domain]
            AbandonActivity(V8_listing_nondescript_items, tmp_0);
            } else {
            ! [17: if handling the listing nondescript items activity with the domain]
            if (((~~(ForActivity(V8_listing_nondescript_items, tmp_0)))))
            {! [18: if the domain is the location]
                if (((tmp_0 == real_location)))
                {! [19: say ~[We] ~ ( a )]
                    say__p=1;! [20: ~[We] ~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_140); .L_Say133; .L_SayX127;} else {
                    ! [21: if the domain is a supporter or the domain is an animal]
                    if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K12_animal))))
                    {! [22: say ~On [the domain] [we] ~ ( b )]
                        say__p=1;! [23: ~On [the domain] [we] ~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_141); .L_Say134; .L_SayX128;} else {
                        ! [24: say ~In [the domain] [we] ~ ( c )]
                        say__p=1;! [25: ~In [the domain] [we] ~ ( c )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_142); .L_Say135; .L_SayX129;}
                        }
                ! [26: if the locale paragraph count is greater than 0]
                if ((((Global_Vars-->9) > 0)))
                {! [27: say ~[regarding the player][can] also see ~ ( d )]
                    say__p=1;! [28: ~[regarding the player][can] also see ~ ( d )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_143); .L_Say136; .L_SayX130;} else {
                    ! [29: say ~[regarding the player][can] see ~ ( e )]
                    say__p=1;! [30: ~[regarding the player][can] see ~ ( e )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_144); .L_Say137; .L_SayX131;}
                ! [31: let the common holder be nothing]

                		tmp_2 = nothing;
                ! [32: let contents form of list be true]

                		tmp_3 = 1;
                ! [33: repeat with list item running through marked for listing things]
                for (tmp_4=Prop_5(0), tmp_5=Prop_5(tmp_4): tmp_4: tmp_4=tmp_5, tmp_5=Prop_5(tmp_5))
                {! [34: if the holder of the list item is not the common holder]
                    if (((~~(((HolderOf(tmp_4)) == tmp_2)))))
                    {! [35: if the common holder is nothing]
                        if (((tmp_2 == nothing)))
                        {! [36: now the common holder is the holder of the list item]
                            tmp_2 = (HolderOf(tmp_4));
                            } else {
                            ! [37: now contents form of list is false]
                            tmp_3 = 0;
                            }
                            }
                    ! [38: if the list item is mentioned]
                    if ((((Adj_78_t1_v10(tmp_4)))))
                    {! [39: now the list item is not marked for listing]
                        (Adj_76_t3_v10(tmp_4));
                        }
                        }
                ! [40: filter list recursion to unmentioned things]
                list_filter_routine = Prop_6;
                ! [41: if contents form of list is true and the common holder is not nothing]
                if (((((tmp_3 && true) == (1 && true)))) && (((~~((tmp_2 == nothing))))))
                {! [42: list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                    WriteListFrom(child(tmp_2), 2776);
                    } else {
                    ! [43: say ~[a list of marked for listing things including contents]~]
                    say__p=1;! [44: a list of marked for listing things including contents]
                    ParaContent(); objectloop(tmp_4 ofclass Object)
                    			if (((tmp_4 ofclass K2_thing) && ((Adj_76_t1_v10(tmp_4)))))
                    				give tmp_4 workflag2;
                    			else
                    				give tmp_4 ~workflag2;
                    		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
                    			TERSE_BIT+CONCEAL_BIT); .L_Say138; .L_SayX132;}
                ! [45: if the domain is the location]
                if (((tmp_0 == real_location)))
                {! [46: say ~ here~ ( f )]
                    say__p=1;! [47: ~ here~ ( f )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),(LocalParking-->6=tmp_4),(LocalParking-->7=tmp_5),TX_R_145); .L_Say139; .L_SayX133;}
                ! [48: say ~.[paragraph break]~]
                say__p=1;! [49: ~.~]
                ParaContent(); print ".";! [50: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say140; .L_SayX134;! [51: unfilter list recursion]
                list_filter_routine = 0;
                }
            ! [52: end the listing nondescript items activity with the domain]
            EndActivity(V8_listing_nondescript_items, tmp_0);
            }
            }
    ! [53: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B123_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_87 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'held item': object
    ;
    if (debug_rules) DB_Rule(R_87, 87);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: let the held item be the first thing held by the domain]

    		tmp_1 = (child(tmp_0));
    ! [4: while the held item is a thing]
    while (((tmp_1 ofclass K2_thing)))
    {! [5: set the locale priority of the held item to 5]
        (PHR_82_r13 (tmp_1,5));
        ! [6: now the held item is the next thing held after the held item]
        tmp_1 = (sibling(tmp_1));
        }
    ! [7: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B126_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === equally specific with ===
! Rule 3/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === equally specific with ===
! Rule 4/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === equally specific with ===
! Rule 5/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === equally specific with ===
! Rule 6/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === equally specific with ===
! Rule 7/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === equally specific with ===
! Rule 8/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
!   === equally specific with ===
! Rule 9/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on mentioned supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
[ R_94 
    tmp_0 ! Let/loop value, e.g., 'tabletop': supporter
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K6_supporter) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_94, 94);
    ! [2: repeat with item running through not handled things on the tabletop which provide the property initial appearance]
    for (tmp_1=Prop_7(tmp_0,tmp_0,tmp_0,0), tmp_2=Prop_7(tmp_0,tmp_0,tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_7(tmp_0,tmp_0,tmp_0,tmp_2))
    {! [3: if the item is not a person and the initial appearance of the item is not ~~ and the item is not undescribed]
        if ((((~~((tmp_1 ofclass K8_person))))) && ((((~~(( BlkValueCompare(GProperty(10, tmp_1,initial), EMPTY_TEXT_VALUE) == 0))))) && (((~~(((Adj_75_t1_v10(tmp_1)))))))))
        {! [4: now the item is mentioned]
            (Adj_78_t2_v10(tmp_1));
            ! [5: say initial appearance of the item]
            say__p=1;! [6: initial appearance of the item]
            ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_1,initial);@pull self;  .L_Say141; .L_SayX135;! [7: say paragraph break]
            say__p=1;! [8: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say142; .L_SayX136;}
            }
    ! [9: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_94, 94, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_88 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_88, 88);
    ! [2: if the item encloses the player]
    if (((IndirectlyContains(tmp_0,player))))
    {! [3: set the locale priority of the item to 0]
        (PHR_82_r13 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_88, 88, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_89 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_89, 89);
    ! [2: if the item is scenery]
    if ((((Adj_70_t1_v10(tmp_0)))))
    {! [3: set the locale priority of the item to 0]
        (PHR_82_r13 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_89, 89, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_90 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_90, 90);
    ! [2: if the item is undescribed]
    if ((((Adj_75_t1_v10(tmp_0)))))
    {! [3: set the locale priority of the item to 0]
        (PHR_82_r13 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_90, 90, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_91 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_91, 91);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_78_t1_v10(tmp_0)))))))
    {! [3: set pronouns from the item]
        PronounNotice(tmp_0);
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_91, 91, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_92 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_92, 92);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_78_t1_v10(tmp_0)))))))
    {! [3: if a paragraph break is pending]
        if (((say__p)))
        {! [4: say ~[conditional paragraph break]~]
            say__p=1;! [5: conditional paragraph break]
            ParaContent(); DivideParagraphPoint(); .L_Say143; .L_SayX137;}
        ! [6: carry out the writing a paragraph about activity with the item]
        CarryOutActivity(V7_writing_a_paragraph_about, tmp_0);
        ! [7: if a paragraph break is pending]
        if (((say__p)))
        {! [8: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [9: now the item is mentioned]
            (Adj_78_t2_v10(tmp_0));
            ! [10: say ~[conditional paragraph break]~]
            say__p=1;! [11: conditional paragraph break]
            ParaContent(); DivideParagraphPoint(); .L_Say144; .L_SayX138;}
            }
    ! [12: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_92, 92, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_93 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_93, 93);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_78_t1_v10(tmp_0)))))))
    {! [3: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~]
        if ((((WhetherProvides(tmp_0, false, initial)))) && ((((~~(((Adj_73_t1_v10(tmp_0))))))) && (((~~(( BlkValueCompare(GProperty(10, tmp_0,initial), EMPTY_TEXT_VALUE) == 0)))))))
        {! [4: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [5: say ~[initial appearance of the item]~]
            say__p=1;! [6: initial appearance of the item]
            ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_0,initial);@pull self;  .L_Say145; .L_SayX139;! [7: say ~[paragraph break]~]
            say__p=1;! [8: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say146; .L_SayX140;! [9: if a locale-supportable thing is on the item]
            if ((((Prop_8(tmp_0)))))
            {! [10: repeat with possibility running through things on the item]
                for (tmp_1=Prop_9(tmp_0,0), tmp_2=Prop_9(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_9(tmp_0,tmp_2))
                {! [11: now the possibility is marked for listing]
                    (Adj_76_t2_v10(tmp_1));
                    ! [12: if the possibility is mentioned]
                    if ((((Adj_78_t1_v10(tmp_1)))))
                    {! [13: now the possibility is not marked for listing]
                        (Adj_76_t3_v10(tmp_1));
                        }
                        }
                ! [14: say ~On [the item] ~ ( a )]
                say__p=1;! [15: ~On [the item] ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_146); .L_Say147; .L_SayX141;! [16: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(tmp_0), 3800);
                ! [17: say ~.[paragraph break]~]
                say__p=1;! [18: ~.~]
                ParaContent(); print ".";! [19: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say148; .L_SayX142;}
            ! [20: now the item is mentioned]
            (Adj_78_t2_v10(tmp_0));
            }
            }
    ! [21: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_93, 93, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_96 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_96, 96);
    ! [2: if the item is scenery and the item does not enclose the player]
    if (((((Adj_70_t1_v10(tmp_0))))) && (((~~((IndirectlyContains(tmp_0,player)))))))
    {! [3: if a locale-supportable thing is on the item]
        if ((((Prop_10(tmp_0)))))
        {! [4: set pronouns from the item]
            PronounNotice(tmp_0);
            ! [5: repeat with possibility running through things on the item]
            for (tmp_1=Prop_11(tmp_0,0), tmp_2=Prop_11(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_11(tmp_0,tmp_2))
            {! [6: now the possibility is marked for listing]
                (Adj_76_t2_v10(tmp_1));
                ! [7: if the possibility is mentioned]
                if ((((Adj_78_t1_v10(tmp_1)))))
                {! [8: now the possibility is not marked for listing]
                    (Adj_76_t3_v10(tmp_1));
                    }
                    }
            ! [9: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [10: say ~On [the item] ~ ( a )]
            say__p=1;! [11: ~On [the item] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_147); .L_Say149; .L_SayX143;! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
            WriteListFrom(child(tmp_0), 3800);
            ! [13: say ~.[paragraph break]~]
            say__p=1;! [14: ~.~]
            ParaContent(); print ".";! [15: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say150; .L_SayX144;}
            }
    ! [16: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_96, 96, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on mentioned supporters in room descriptions rule ):
[ R_97 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_97, 97);
    ! [2: if the item is mentioned and the item is not undescribed and the item is not scenery and the item does not enclose the player]
    if (((((Adj_78_t1_v10(tmp_0))))) && ((((~~(((Adj_75_t1_v10(tmp_0))))))) && ((((~~(((Adj_70_t1_v10(tmp_0))))))) && (((~~((IndirectlyContains(tmp_0,player)))))))))
    {! [3: if a locale-supportable thing is on the item]
        if ((((Prop_12(tmp_0)))))
        {! [4: set pronouns from the item]
            PronounNotice(tmp_0);
            ! [5: repeat with possibility running through things on the item]
            for (tmp_1=Prop_13(tmp_0,0), tmp_2=Prop_13(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_13(tmp_0,tmp_2))
            {! [6: now the possibility is marked for listing]
                (Adj_76_t2_v10(tmp_1));
                ! [7: if the possibility is mentioned]
                if ((((Adj_78_t1_v10(tmp_1)))))
                {! [8: now the possibility is not marked for listing]
                    (Adj_76_t3_v10(tmp_1));
                    }
                    }
            ! [9: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [10: say ~On [the item] ~ ( a )]
            say__p=1;! [11: ~On [the item] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_148); .L_Say151; .L_SayX145;! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
            WriteListFrom(child(tmp_0), 3800);
            ! [13: say ~.[paragraph break]~]
            say__p=1;! [14: ~.~]
            ParaContent(); print ".";! [15: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say152; .L_SayX146;}
            }
    ! [16: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_97, 97, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B132_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_98 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_98, 98);
    ! [2: if the first thing held by the player is nothing]
    if ((((child(player)) == nothing)))
    {! [3: say ~[We] [are] carrying nothing.~ ( a )]
        say__p=1;! [4: ~[We] [are] carrying nothing.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_149); new_line; .L_Say153; .L_SayX147;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_98, 98, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_99 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_99, 99);
    ! [2: say ~[We] [are] carrying:[line break]~ ( a )]
    say__p=1;! [3: ~[We] [are] carrying:[line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_150); .L_Say154; .L_SayX148;! [4: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
    WriteListFrom(child(player), 8215);
    } else if (debug_rules > 1) DB_Rule(R_99, 99, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B133_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_100 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_100, 100);
    ! [2: if the actor is not the player and the action is not silent]
    if ((((~~((actor == player))))) && (((keep_silent == false))))
    {! [3: say ~[The actor] [look] through [their] possessions.~ ( a )]
        say__p=1;! [4: ~[The actor] [look] through [their] possessions.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_151); new_line; .L_Say155; .L_SayX149;}
        } else if (debug_rules > 1) DB_Rule(R_100, 100, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B134_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Check an actor taking ( this is the can't take yourself rule ):
!   === equally specific with ===
! Rule 2/12 ! Check an actor taking ( this is the can't take other people rule ):
!   === equally specific with ===
! Rule 3/12 ! Check an actor taking ( this is the can't take component parts rule ):
!   === equally specific with ===
! Rule 4/12 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === equally specific with ===
! Rule 5/12 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === equally specific with ===
! Rule 6/12 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === equally specific with ===
! Rule 7/12 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === equally specific with ===
! Rule 8/12 ! Check an actor taking ( this is the can't take scenery rule ):
!   === equally specific with ===
! Rule 9/12 ! Check an actor taking ( this is the can only take things rule ):
!   === equally specific with ===
! Rule 10/12 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === equally specific with ===
! Rule 11/12 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === equally specific with ===
! Rule 12/12 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take yourself rule ):
[ R_101 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_101, 101);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] always self-possessed.~ ( a )]
            say__p=1;! [5: ~[We] [are] always self-possessed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_152); new_line; .L_Say156; .L_SayX150;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_101, 101, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take other people rule ):
[ R_102 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_102, 102);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~I don't suppose [the noun] [would care] for that.~ ( a )]
            say__p=1;! [5: ~I don't suppose [the noun] [would care] for that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_153); new_line; .L_Say157; .L_SayX151;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_102, 102, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take component parts rule ):
[ R_103 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_103, 103);
    ! [2: if the noun is part of something ( called the whole )]
    if ((((noun.component_parent) ofclass K2_thing) && (tmp_0=((noun.component_parent)), true)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][Those] [seem] to be a part of [the whole].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][Those] [seem] to be a part of [the whole].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_154); new_line; .L_Say158; .L_SayX152;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_103, 103, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_104 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_104, 104);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: let the owner be the not-counting-parts holder of the noun]

    		tmp_1 = (CoreOfParentOfCoreOf(noun));
    ! [4: while the owner is not nothing and the owner is not the local ceiling]
    while ((((~~((tmp_1 == nothing))))) && (((~~((tmp_1 == tmp_0))))))
    {! [5: if the owner is a person]
        if (((tmp_1 ofclass K8_person)))
        {! [6: if the actor is the player]
            if (((actor == player)))
            {! [7: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
                say__p=1;! [8: ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_155); new_line; .L_Say159; .L_SayX153;}
            ! [9: stop the action]
            rtrue;
            }
        ! [10: let the owner be the not-counting-parts holder of the owner]
        tmp_1 = (CoreOfParentOfCoreOf(tmp_1));
        }
        } else if (debug_rules > 1) DB_Rule(R_104, 104, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_105 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_105, 105);
    ! [2: let h be the noun]

    		tmp_0 = noun;
    ! [3: while h is not nothing and h is not a room]
    while ((((~~((tmp_0 == nothing))))) && (((~~((tmp_0 ofclass K1_room))))))
    {! [4: let h be the not-counting-parts holder of h]
        tmp_0 = (CoreOfParentOfCoreOf(tmp_0));
        }
    ! [5: if h is nothing]
    if (((tmp_0 == nothing)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[regarding the noun][Those] [aren't] available.~ ( a )]
            say__p=1;! [8: ~[regarding the noun][Those] [aren't] available.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_156); new_line; .L_Say160; .L_SayX154;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_105, 105, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_106 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_106, 106);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: if the local ceiling is the noun]
    if (((tmp_0 == noun)))
    {! [4: if the actor is the player]
        if (((actor == player)))
        {! [5: say ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~ ( a )]
            say__p=1;! [6: ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_157); new_line; .L_Say161; .L_SayX155;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_106, 106, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_107 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_107, 107);
    ! [2: if the actor is carrying the noun or the actor is wearing the noun]
    if ((((actor == CarrierOf(noun)))) || (((actor == WearerOf(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] already [have] [regarding the noun][those].~ ( a )]
            say__p=1;! [5: ~[We] already [have] [regarding the noun][those].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_158); new_line; .L_Say162; .L_SayX156;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_107, 107, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take scenery rule ):
[ R_108 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_108, 108);
    ! [2: if the noun is scenery]
    if ((((Adj_70_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] hardly portable.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] hardly portable.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_159); new_line; .L_Say163; .L_SayX157;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_108, 108, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can only take things rule ):
[ R_109 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_109, 109);
    ! [2: if the noun is not a thing]
    if (((~~((noun ofclass K2_thing)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [cannot] carry [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [cannot] carry [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_160); new_line; .L_Say164; .L_SayX158;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_109, 109, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_110 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_110, 110);
    ! [2: if the noun is fixed in place]
    if ((((Adj_68_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_161); new_line; .L_Say165; .L_SayX159;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_110, 110, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_111 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_111, 111);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_14()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is holding a player's holdall ( called the current working sack )]
        if ((((Prop_15() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
        {! [4: let the transferred item be nothing]

            		tmp_1 = nothing;
            ! [5: repeat with the possible item running through things carried by the actor]
            for (tmp_2=Prop_16(0), tmp_3=Prop_16(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_16(tmp_3))
            {! [6: if the possible item is not lit and the possible item is not the current working sack]
                if ((((~~(((Adj_64_t1_v10(tmp_2))))))) && (((~~((tmp_2 == tmp_0))))))
                {! [7: let the transferred item be the possible item]
                    tmp_1 = tmp_2;
                    }
                    }
            ! [8: if the transferred item is not nothing]
            if (((~~((tmp_1 == nothing)))))
            {! [9: if the actor is the player]
                if (((actor == player)))
                {! [10: say ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~ ( a )]
                    say__p=1;! [11: ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),TX_R_162); .L_Say166; .L_SayX160;}
                ! [12: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
                ClearParagraphing(1);
                TryAction(0, actor, ##Insert, tmp_1, tmp_0);
                DivideParagraphPoint();
                @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

                ! [13: if the transferred item is not in the current working sack]
                if (((~~((tmp_0 == ContainerOf(tmp_1))))))
                {! [14: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_111, 111, 'action');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_112 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_112, 112);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_17()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[We]['re] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_163); new_line; .L_Say167; .L_SayX161;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_112, 112, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B135_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor taking ( this is the standard taking rule ):
[ R_113 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_113, 113);
    ! [2: now the actor carries the noun]
    MoveObject(noun,actor);
    ! [3: if the actor is the player]
    if (((actor == player)))
    {! [4: now the noun is handled]
        (Adj_73_t2_v10(noun));
        }
        } else if (debug_rules > 1) DB_Rule(R_113, 113, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B136_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking ( this is the standard report taking rule ):
[ R_114 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_114, 114);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Taken.~ ( a )]
            say__p=1;! [5: ~Taken.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_164); new_line; .L_Say168; .L_SayX162;} else {
            ! [6: say ~[The actor] [pick] up [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [pick] up [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_165); new_line; .L_Say169; .L_SayX163;}
            }
            } else if (debug_rules > 1) DB_Rule(R_114, 114, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B137_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_115 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_115, 115);
    ! [2: if the holder of the noun is not the second noun]
    if (((~~(((HolderOf(noun)) == second)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~But [regarding the noun][they] [aren't] there now.~ ( a )]
            say__p=1;! [5: ~But [regarding the noun][they] [aren't] there now.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_166); new_line; .L_Say170; .L_SayX164;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_115, 115, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_116 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_116, 116);
    ! [2: let the owner be the holder of the noun]

    		tmp_0 = (HolderOf(noun));
    ! [3: if the owner is a person]
    if (((tmp_0 ofclass K8_person)))
    {! [4: if the owner is the actor]
        if (((tmp_0 == actor)))
        {! [5: convert to the taking off action on the noun]
            return GVS_Convert(##Disrobe,noun,0);
            }
        ! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
            say__p=1;! [8: ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_167); new_line; .L_Say171; .L_SayX165;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_116, 116, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_117 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_117, 117);
    ! [2: convert to the taking action on the noun]
    return GVS_Convert(##Take,noun,0);
    } else if (debug_rules > 1) DB_Rule(R_117, 117, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B140_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
[ R_119 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing) && (actor == (noun.component_parent)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_119, 119);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [can't drop] part of [ourselves].~ ( a )]
        say__p=1;! [4: ~[We] [can't drop] part of [ourselves].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_168); new_line; .L_Say172; .L_SayX166;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_119, 119, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_118 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_118, 118);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [lack] the dexterity.~ ( a )]
            say__p=1;! [5: ~[We] [lack] the dexterity.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_169); new_line; .L_Say173; .L_SayX167;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_118, 118, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_120 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_120, 120);
    ! [2: if the noun is in the holder of the actor]
    if ((((HolderOf(actor)) == ContainerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [are] already here.~ ( a )]
            say__p=1;! [5: ~[The noun] [are] already here.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_170); new_line; .L_Say174; .L_SayX168;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_120, 120, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_121 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_121, 121);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[We] [haven't] got [regarding the noun][those].~ ( a )]
        say__p=1;! [8: ~[We] [haven't] got [regarding the noun][those].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_171); new_line; .L_Say175; .L_SayX169;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_121, 121, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_122 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_122, 122);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [the noun] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_172); .L_Say176; .L_SayX170;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_122, 122, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_123 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_123, 123);
    ! [2: let the receptacle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [3: if the receptacle is a room]
    if (((tmp_0 ofclass K1_room)))
    {! [4: continue the action]
        rfalse;
        }
    ! [5: if the receptacle provides the property carrying capacity]
    if (((WhetherProvides(tmp_0, false, capacity))))
    {! [6: if the receptacle is a supporter]
        if (((tmp_0 ofclass K6_supporter)))
        {! [7: if the number of things on the receptacle is at least the carrying capacity of the receptacle]
            if ((((Prop_18(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity))))
            {! [8: if the actor is the player]
                if (((actor == player)))
                {! [9: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [10: say ~[There] [are] no more room on [the receptacle].~ ( a )]
                    say__p=1;! [11: ~[There] [are] no more room on [the receptacle].~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_173); new_line; .L_Say177; .L_SayX171;}
                ! [12: stop the action]
                rtrue;
                }
                } else {
            ! [13: if the receptacle is a container]
            if (((tmp_0 ofclass K5_container)))
            {! [14: if the number of things in the receptacle is at least the carrying capacity of the receptacle]
                if ((((Prop_19(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity))))
                {! [15: if the actor is the player]
                    if (((actor == player)))
                    {! [16: now the prior named object is nothing]
                        prior_named_noun = nothing;
                        ! [17: say ~[There] [are] no more room in [the receptacle].~ ( b )]
                        say__p=1;! [18: ~[There] [are] no more room in [the receptacle].~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_174); new_line; .L_Say178; .L_SayX172;}
                    ! [19: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_123, 123, 'action');
                    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B141_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_124 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_124, 124);
    ! [2: now the noun is in the holder of the actor]
    MoveObject(noun,(HolderOf(actor)));
    } else if (debug_rules > 1) DB_Rule(R_124, 124, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B142_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_125 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_125, 125);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Dropped.~ ( a )]
            say__p=1;! [5: ~Dropped.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_175); new_line; .L_Say179; .L_SayX173;} else {
            ! [6: say ~[The actor] [put] down [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [put] down [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_176); new_line; .L_Say180; .L_SayX174;}
            }
            } else if (debug_rules > 1) DB_Rule(R_125, 125, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B143_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_126 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_126, 126);
    ! [2: if the second noun is down or the actor is on the second noun]
    if ((((second == I60_down))) || (((second == SupporterOf(actor)))))
    {! [3: convert to the dropping action on the noun]
        return GVS_Convert(##Drop,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_126, 126, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_127 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_127, 127);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [7: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [8: continue the action]
        rfalse;
        }
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_127, 127, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_128 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_128, 128);
    ! [2: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [3: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [4: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [5: if the transfer ceiling is the noun-cpc]
    if (((tmp_2 == tmp_0)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[We] [can't put] something on top of itself.~ ( a )]
            say__p=1;! [8: ~[We] [can't put] something on top of itself.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_177); new_line; .L_Say181; .L_SayX175;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_128, 128, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_129 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_129, 129);
    ! [2: if the second noun is not a supporter]
    if (((~~((second ofclass K6_supporter)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Putting things on [the second noun] [would achieve] nothing.~ ( a )]
            say__p=1;! [5: ~Putting things on [the second noun] [would achieve] nothing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_178); new_line; .L_Say182; .L_SayX176;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_129, 129, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_130 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_130, 130);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_179); .L_Say183; .L_SayX177;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_130, 130, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_131 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_131, 131);
    ! [2: if the second noun provides the property carrying capacity]
    if (((WhetherProvides(second, false, capacity))))
    {! [3: if the number of things on the second noun is at least the carrying capacity of the second noun]
        if ((((Prop_20()) >= GProperty(OBJECT_TY, second,capacity))))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[There] [are] no more room on [the second noun].~ ( a )]
                say__p=1;! [6: ~[There] [are] no more room on [the second noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_180); new_line; .L_Say184; .L_SayX178;}
            ! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_131, 131, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B144_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_132 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_132, 132);
    ! [2: now the noun is on the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_132, 132, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B145_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_133 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_133, 133);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player and the i6 parser is running multiple actions]
        if ((((actor == player))) && (((multiflag==1))))
        {! [4: say ~Done.~ ( a )]
            say__p=1;! [5: ~Done.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_181); new_line; .L_Say185; .L_SayX179;! [6: stop the action]
            rtrue;
            }
            }
    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_133, 133, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_134 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_134, 134);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [put] [the noun] on [the second noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [put] [the noun] on [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_182); new_line; .L_Say186; .L_SayX180;}
        } else if (debug_rules > 1) DB_Rule(R_134, 134, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B146_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_135 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_135, 135);
    ! [2: if the second noun is down or the actor is in the second noun]
    if ((((second == I60_down))) || (((second == ContainerOf(actor)))))
    {! [3: convert to the dropping action on the noun]
        return GVS_Convert(##Drop,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_135, 135, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_136 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_136, 136);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [7: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [8: continue the action]
        rfalse;
        }
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_136, 136, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_137 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_137, 137);
    ! [2: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [3: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [4: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [5: if the transfer ceiling is the noun-cpc]
    if (((tmp_2 == tmp_0)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[We] [can't put] something inside itself.~ ( a )]
            say__p=1;! [8: ~[We] [can't put] something inside itself.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_183); new_line; .L_Say187; .L_SayX181;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_137, 137, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_138 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_138, 138);
    ! [2: if the second noun is a closed container]
    if (((second ofclass K5_container) && ((Adj_84_t1_v10(second)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [are] closed.~ ( a )]
            say__p=1;! [5: ~[The second noun] [are] closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_184); new_line; .L_Say188; .L_SayX182;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_138, 138, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_139 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_139, 139);
    ! [2: if the second noun is not a container]
    if (((~~((second ofclass K5_container)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [can't contain] things.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [can't contain] things.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_185); new_line; .L_Say189; .L_SayX183;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_139, 139, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_140 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_140, 140);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_186); .L_Say190; .L_SayX184;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_140, 140, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_141 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_141, 141);
    ! [2: if the second noun provides the property carrying capacity]
    if (((WhetherProvides(second, false, capacity))))
    {! [3: if the number of things in the second noun is at least the carrying capacity of the second noun]
        if ((((Prop_21()) >= GProperty(OBJECT_TY, second,capacity))))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: now the prior named object is nothing]
                prior_named_noun = nothing;
                ! [6: say ~[There] [are] no more room in [the second noun].~ ( a )]
                say__p=1;! [7: ~[There] [are] no more room in [the second noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_187); new_line; .L_Say191; .L_SayX185;}
            ! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_141, 141, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B147_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_142 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_142, 142);
    ! [2: now the noun is in the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_142, 142, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B148_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_143 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_143, 143);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player and the i6 parser is running multiple actions]
        if ((((actor == player))) && (((multiflag==1))))
        {! [4: say ~Done.~ ( a )]
            say__p=1;! [5: ~Done.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_188); new_line; .L_Say192; .L_SayX186;! [6: stop the action]
            rtrue;
            }
            }
    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_143, 143, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_144 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_144, 144);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [put] [the noun] into [the second noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [put] [the noun] into [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_189); new_line; .L_Say193; .L_SayX187;}
        } else if (debug_rules > 1) DB_Rule(R_144, 144, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B149_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor eating ( this is the can't eat other people's food rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_145 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_145, 145);
    ! [2: if the noun is not a thing or the noun is not edible]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_66_t1_v10(noun))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] plainly inedible.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] plainly inedible.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_190); new_line; .L_Say194; .L_SayX188;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_145, 145, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_146 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_146, 146);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [the noun] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_191); .L_Say195; .L_SayX189;}
        ! [6: try the actor trying taking off the noun]
        TryAction(0, actor, ##Disrobe, noun, 0);
        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_146, 146, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat other people's food rule ):
[ R_147 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_147, 147);
    ! [2: if the noun is enclosed by a person ( called the owner ) who is not the actor]
    if ((((Prop_22() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The owner] [might not appreciate] that.~ ( a )]
            say__p=1;! [5: ~[The owner] [might not appreciate] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_192); new_line; .L_Say196; .L_SayX190;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_147, 147, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
[ R_148 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_148, 148);
    ! [2: if the noun is portable and the actor is not carrying the noun]
    if (((((Adj_69_t1_v10(noun))))) && (((~~((actor == CarrierOf(noun)))))))
    {! [3: carry out the implicitly taking activity with the noun]
        CarryOutActivity(V25_implicitly_taking, noun);
        ! [4: if the actor is not carrying the noun]
        if (((~~((actor == CarrierOf(noun))))))
        {! [5: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_148, 148, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B150_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor eating ( this is the standard eating rule ):
[ R_149 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_149, 149);
    ! [2: now the noun is nowhere]
    RemoveFromPlay(noun);;
    } else if (debug_rules > 1) DB_Rule(R_149, 149, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B151_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor eating ( this is the standard report eating rule ):
[ R_150 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_150, 150);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [eat] [the noun]. Not bad.~ ( a )]
            say__p=1;! [5: ~[We] [eat] [the noun]. Not bad.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_193); new_line; .L_Say197; .L_SayX191;} else {
            ! [6: say ~[The actor] [eat] [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [eat] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_194); new_line; .L_Say198; .L_SayX192;}
            }
            } else if (debug_rules > 1) DB_Rule(R_150, 150, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B152_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor going ( this is the can't go through undescribed doors rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor going ( this is the determine map connection rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_152 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    if ((((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_152, 152);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~(first getting off [the chaise])[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first getting off [the chaise])[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_195); .L_Say199; .L_SayX193;}
    ! [5: silently try the actor exiting]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, actor, ##Exit, 0, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    } else if (debug_rules > 1) DB_Rule(R_152, 152, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_153 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_153, 153);
    ! [2: let nonvehicle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [3: if nonvehicle is the room gone from]
    if (((tmp_0 == (MStack-->MstVO(20007,0)))))
    {! [4: continue the action]
        rfalse;
        }
    ! [5: if nonvehicle is the vehicle gone by]
    if (((tmp_0 == (MStack-->MstVO(20007,3)))))
    {! [6: continue the action]
        rfalse;
        }
    ! [7: if the actor is the player]
    if (((actor == player)))
    {! [8: if nonvehicle is a supporter]
        if (((tmp_0 ofclass K6_supporter)))
        {! [9: say ~[We] [would have] to get off [the nonvehicle] first.~ ( a )]
            say__p=1;! [10: ~[We] [would have] to get off [the nonvehicle] first.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_196); new_line; .L_Say200; .L_SayX194;} else {
            ! [11: say ~[We] [would have] to get out of [the nonvehicle] first.~ ( b )]
            say__p=1;! [12: ~[We] [would have] to get out of [the nonvehicle] first.~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_197); new_line; .L_Say201; .L_SayX195;}
            }
    ! [13: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_153, 153, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_154 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_154, 154);
    ! [2: if the door gone through is not nothing and the door gone through is undescribed]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_75_t1_v10((MStack-->MstVO(20007,2))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't go] that way.~ ( a )]
            say__p=1;! [5: ~[We] [can't go] that way.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_198); new_line; .L_Say202; .L_SayX196;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_154, 154, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_155 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_155, 155);
    ! [2: if the door gone through is not nothing and the door gone through is closed]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_84_t1_v10((MStack-->MstVO(20007,2))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first opening [the door gone through])[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first opening [the door gone through])[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_199); .L_Say203; .L_SayX197;}
        ! [6: silently try the actor opening the door gone through]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the door gone through is open]
        if ((((Adj_83_t1_v10((MStack-->MstVO(20007,2)))))))
        {! [8: continue the action]
            rfalse;
            }
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_155, 155, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the determine map connection rule ):
[ R_156 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_4();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_4 
    tmp_0 ! Let/loop value, e.g., 'target': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_156, 156);
    ! [2: let the target be nothing]

    		tmp_0 = nothing;
    ! [3: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [4: let direction d be the noun]

        		tmp_1 = noun;
        ! [5: let the target be the room-or-door direction d from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2330, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        } else {
        ! [6: if the noun is a door]
        if (((noun ofclass K4_door)))
        {! [7: let the target be the noun]
            tmp_0 = noun;
            }
            }
    ! [8: if the target is a door]
    if (((tmp_0 ofclass K4_door)))
    {! [9: now the target is the other side of the target from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2334, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_0)
                    ))
            )

        ! Resolution complete
        ;
        }
    ! [10: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_156, 156, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go that way rule ):
[ R_157 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_157, 157);
    ! [2: if the room gone to is nothing]
    if ((((MStack-->MstVO(20007,1)) == nothing)))
    {! [3: if the door gone through is nothing]
        if ((((MStack-->MstVO(20007,2)) == nothing)))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[We] [can't go] that way.~ ( a )]
                say__p=1;! [6: ~[We] [can't go] that way.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_200); new_line; .L_Say204; .L_SayX198;}
            ! [7: stop the action]
            rtrue;
            }
        ! [8: if the actor is the player]
        if (((actor == player)))
        {! [9: say ~[We] [can't], since [the door gone through] [lead] nowhere.~ ( b )]
            say__p=1;! [10: ~[We] [can't], since [the door gone through] [lead] nowhere.~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_201); new_line; .L_Say205; .L_SayX199;}
        ! [11: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_157, 157, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B153_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === equally specific with ===
! Rule 2/3 ! Carry out an actor going ( this is the move floating objects rule ):
!   === equally specific with ===
! Rule 3/3 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_158 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_158, 158);
    ! [2: if the vehicle gone by is nothing]
    if ((((MStack-->MstVO(20007,3)) == nothing)))
    {! [3: surreptitiously move the actor to the room gone to during going]
        MoveDuringGoing(actor, (MStack-->MstVO(20007,1)));
        } else {
        ! [4: surreptitiously move the vehicle gone by to the room gone to during going]
        MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));
        }
    ! [5: if the location is not the location of the player]
    if (((~~((real_location == LocationOf(player))))))
    {! [6: now the location is the location of the player]
        real_location = LocationOf(player);
        }
        } else if (debug_rules > 1) DB_Rule(R_158, 158, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move floating objects rule ):
[ R_159 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_159, 159);
    ! [2: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
    {! [3: update backdrop positions]
        MoveFloatingObjects();
        }
        } else if (debug_rules > 1) DB_Rule(R_159, 159, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the check light in new location rule ):
[ R_160 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_160, 160);
    ! [2: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
    {! [3: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        }
        } else if (debug_rules > 1) DB_Rule(R_160, 160, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B154_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor going ( this is the describe room gone into rule ):
[ R_161 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_5();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_5 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_161, 161);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: produce a room description with going spacing conventions]
            LookAfterGoing();
            }
            } else {
        ! [5: if the noun is a direction]
        if (((noun ofclass K3_direction)))
        {! [6: if the location is the room gone from or the player is within the vehicle gone by or the player is within the thing gone with]
            if ((((real_location == (MStack-->MstVO(20007,0))))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
            {! [7: if the room gone from is the room gone to]
                if ((((MStack-->MstVO(20007,0)) == (MStack-->MstVO(20007,1)))))
                {! [8: continue the action]
                    rfalse;
                    } else {
                    ! [9: if the noun is up]
                    if (((noun == I59_up)))
                    {! [10: say ~[The actor] [go] up~ ( a )]
                        say__p=1;! [11: ~[The actor] [go] up~ ( a )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_202); .L_Say206; .L_SayX200;} else {
                        ! [12: if the noun is down]
                        if (((noun == I60_down)))
                        {! [13: say ~[The actor] [go] down~ ( b )]
                            say__p=1;! [14: ~[The actor] [go] down~ ( b )]
                            ParaContent(); print (TEXT_TY_Say) (TX_R_203); .L_Say207; .L_SayX201;} else {
                            ! [15: say ~[The actor] [go] [noun]~ ( c )]
                            say__p=1;! [16: ~[The actor] [go] [noun]~ ( c )]
                            ParaContent(); print (TEXT_TY_Say) (TX_R_204); .L_Say208; .L_SayX202;}
                            }
                            }
                            } else {
                ! [17: let the back way be the opposite of the noun]

                		tmp_0 = GProperty(OBJECT_TY, noun,p10_opposite);
                ! [18: if the location is the room gone to]
                if (((real_location == (MStack-->MstVO(20007,1)))))
                {! [19: let the room back the other way be the room back way from the location]

                    		tmp_1 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2385, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = real_location) +
                                (formal_par0 = tmp_0)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [20: let the room normally this way be the room noun from the room gone from]

                    		tmp_2 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2387, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = (MStack-->MstVO(20007,0))) +
                                (formal_par0 = noun)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [21: if the room back the other way is the room gone from or the room back the other way is the room normally this way]
                    if ((((tmp_1 == (MStack-->MstVO(20007,0))))) || (((tmp_1 == tmp_2))))
                    {! [22: if the back way is up]
                        if (((tmp_0 == I59_up)))
                        {! [23: say ~[The actor] [arrive] from above~ ( d )]
                            say__p=1;! [24: ~[The actor] [arrive] from above~ ( d )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_205); .L_Say209; .L_SayX203;} else {
                            ! [25: if the back way is down]
                            if (((tmp_0 == I60_down)))
                            {! [26: say ~[The actor] [arrive] from below~ ( e )]
                                say__p=1;! [27: ~[The actor] [arrive] from below~ ( e )]
                                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_206); .L_Say210; .L_SayX204;} else {
                                ! [28: say ~[The actor] [arrive] from [the back way]~ ( f )]
                                say__p=1;! [29: ~[The actor] [arrive] from [the back way]~ ( f )]
                                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_207); .L_Say211; .L_SayX205;}
                                }
                                } else {
                        ! [30: say ~[The actor] [arrive]~ ( g )]
                        say__p=1;! [31: ~[The actor] [arrive]~ ( g )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_208); .L_Say212; .L_SayX206;}
                        } else {
                    ! [32: if the back way is up]
                    if (((tmp_0 == I59_up)))
                    {! [33: say ~[The actor] [arrive] at [the room gone to] from above~ ( h )]
                        say__p=1;! [34: ~[The actor] [arrive] at [the room gone to] from above~ ( h )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_209); .L_Say213; .L_SayX207;} else {
                        ! [35: if the back way is down]
                        if (((tmp_0 == I60_down)))
                        {! [36: say ~[The actor] [arrive] at [the room gone to] from below~ ( i )]
                            say__p=1;! [37: ~[The actor] [arrive] at [the room gone to] from below~ ( i )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_210); .L_Say214; .L_SayX208;} else {
                            ! [38: say ~[The actor] [arrive] at [the room gone to] from [the back way]~ ( j )]
                            say__p=1;! [39: ~[The actor] [arrive] at [the room gone to] from [the back way]~ ( j )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_211); .L_Say215; .L_SayX209;}
                            }
                            }
                            }
                            } else {
            ! [40: if the location is the room gone from]
            if (((real_location == (MStack-->MstVO(20007,0)))))
            {! [41: say ~[The actor] [go] through [the noun]~ ( k )]
                say__p=1;! [42: ~[The actor] [go] through [the noun]~ ( k )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_212); .L_Say216; .L_SayX210;} else {
                ! [43: say ~[The actor] [arrive] from [the noun]~ ( l )]
                say__p=1;! [44: ~[The actor] [arrive] from [the noun]~ ( l )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_213); .L_Say217; .L_SayX211;}
                }
        ! [45: if the vehicle gone by is not nothing]
        if (((~~(((MStack-->MstVO(20007,3)) == nothing)))))
        {! [46: say ~ ~]
            say__p=1;! [47: ~ ~]
            ParaContent(); print " "; .L_Say218; .L_SayX212;! [48: if the vehicle gone by is a supporter]
            if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter)))
            {! [49: say ~on [the vehicle gone by]~ ( m )]
                say__p=1;! [50: ~on [the vehicle gone by]~ ( m )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_214); .L_Say219; .L_SayX213;} else {
                ! [51: say ~in [the vehicle gone by]~ ( n )]
                say__p=1;! [52: ~in [the vehicle gone by]~ ( n )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_215); .L_Say220; .L_SayX214;}
                }
        ! [53: if the thing gone with is not nothing]
        if (((~~(((MStack-->MstVO(20007,4)) == nothing)))))
        {! [54: if the player is within the thing gone with]
            if ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))
            {! [55: say ~, pushing [the thing gone with] in front, and [us] along too~ ( o )]
                say__p=1;! [56: ~, pushing [the thing gone with] in front, and [us] along too~ ( o )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_216); .L_Say221; .L_SayX215;} else {
                ! [57: if the player is within the vehicle gone by]
                if ((((MStack-->MstVO(20007,3)) == ContainerOf(player))))
                {! [58: say ~, pushing [the thing gone with] in front~ ( p )]
                    say__p=1;! [59: ~, pushing [the thing gone with] in front~ ( p )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_217); .L_Say222; .L_SayX216;} else {
                    ! [60: if the location is the room gone from]
                    if (((real_location == (MStack-->MstVO(20007,0)))))
                    {! [61: say ~, pushing [the thing gone with] away~ ( q )]
                        say__p=1;! [62: ~, pushing [the thing gone with] away~ ( q )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_218); .L_Say223; .L_SayX217;} else {
                        ! [63: say ~, pushing [the thing gone with] in~ ( r )]
                        say__p=1;! [64: ~, pushing [the thing gone with] in~ ( r )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_219); .L_Say224; .L_SayX218;}
                        }
                        }
                        }
        ! [65: if the player is within the vehicle gone by and the player is not within the thing gone with]
        if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player)))))))
        {! [66: say ~, taking [us] along~ ( s )]
            say__p=1;! [67: ~, taking [us] along~ ( s )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_220); .L_Say225; .L_SayX219;! [68: say ~.~]
            say__p=1;! [69: ~.~]
            ParaContent(); print "."; new_line; .L_Say226; .L_SayX220;! [70: try looking]
            TryAction(0, player, ##Look, 0, 0);
            ! [71: continue the action]
            rfalse;
            }
        ! [72: say ~.~]
        say__p=1;! [73: ~.~]
        ParaContent(); print "."; new_line; .L_Say227; .L_SayX221;}
        } else if (debug_rules > 1) DB_Rule(R_161, 161, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B155_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === equally specific with ===
! Rule 2/8 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === equally specific with ===
! Rule 3/8 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === equally specific with ===
! Rule 4/8 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === equally specific with ===
! Rule 5/8 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === equally specific with ===
! Rule 6/8 ! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
!   === equally specific with ===
! Rule 7/8 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === equally specific with ===
! Rule 8/8 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_163 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_163, 163);
    ! [2: if the noun is a door]
    if (((noun ofclass K4_door)))
    {! [3: convert to the going action on the noun]
        return GVS_Convert(##Go,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_163, 163, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_164 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_164, 164);
    ! [2: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [3: convert to the going action on the noun]
        return GVS_Convert(##Go,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_164, 164, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_165 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_165, 165);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: make no decision]
        rfalse;
        }
    ! [4: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [5: if the local ceiling is the noun]
    if (((tmp_0 == noun)))
    {! [6: if the player is the actor]
        if (((player == actor)))
        {! [7: if the noun is a supporter]
            if (((noun ofclass K6_supporter)))
            {! [8: say ~But [we]['re] already on [the noun].~ ( a )]
                say__p=1;! [9: ~But [we]['re] already on [the noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_221); new_line; .L_Say228; .L_SayX222;} else {
                ! [10: say ~But [we]['re] already in [the noun].~ ( b )]
                say__p=1;! [11: ~But [we]['re] already in [the noun].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_222); new_line; .L_Say229; .L_SayX223;}
                }
        ! [12: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_165, 165, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_166 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_166, 166);
    ! [2: if the noun is not enterable]
    if (((~~(((Adj_80_t1_v10(noun)))))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: if the player's command includes ~stand~]
            if (((matched_text=SnippetIncludes(Consult_Grammar_276,players_command))))
            {! [5: say ~[regarding the noun][They're] not something [we] [can] stand on.~ ( a )]
                say__p=1;! [6: ~[regarding the noun][They're] not something [we] [can] stand on.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_223); new_line; .L_Say230; .L_SayX224;} else {
                ! [7: if the player's command includes ~sit~]
                if (((matched_text=SnippetIncludes(Consult_Grammar_277,players_command))))
                {! [8: say ~[regarding the noun][They're] not something [we] [can] sit down on.~ ( b )]
                    say__p=1;! [9: ~[regarding the noun][They're] not something [we] [can] sit down on.~ ( b )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_224); new_line; .L_Say231; .L_SayX225;} else {
                    ! [10: if the player's command includes ~lie~]
                    if (((matched_text=SnippetIncludes(Consult_Grammar_278,players_command))))
                    {! [11: say ~[regarding the noun][They're] not something [we] [can] lie down on.~ ( c )]
                        say__p=1;! [12: ~[regarding the noun][They're] not something [we] [can] lie down on.~ ( c )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_225); new_line; .L_Say232; .L_SayX226;} else {
                        ! [13: say ~[regarding the noun][They're] not something [we] [can] enter.~ ( d )]
                        say__p=1;! [14: ~[regarding the noun][They're] not something [we] [can] enter.~ ( d )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_226); new_line; .L_Say233; .L_SayX227;}
                        }
                        }
                        }
        ! [15: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_166, 166, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_167 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_167, 167);
    ! [2: if the noun is a closed container]
    if (((noun ofclass K5_container) && ((Adj_84_t1_v10(noun)))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [can't get] into the closed [noun].~ ( a )]
            say__p=1;! [5: ~[We] [can't get] into the closed [noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_227); new_line; .L_Say234; .L_SayX228;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_167, 167, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
[ R_168 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_168, 168);
    ! [2: if the noun provides the property carrying capacity]
    if (((WhetherProvides(noun, false, capacity))))
    {! [3: if the noun is a supporter]
        if (((noun ofclass K6_supporter)))
        {! [4: if the number of things on the noun is at least the carrying capacity of the noun]
            if ((((Prop_23()) >= GProperty(OBJECT_TY, noun,capacity))))
            {! [5: if the actor is the player]
                if (((actor == player)))
                {! [6: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [7: say ~[There] [are] no more room on [the noun].~ ( a )]
                    say__p=1;! [8: ~[There] [are] no more room on [the noun].~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_228); new_line; .L_Say235; .L_SayX229;}
                ! [9: stop the action]
                rtrue;
                }
                } else {
            ! [10: if the noun is a container]
            if (((noun ofclass K5_container)))
            {! [11: if the number of things in the noun is at least the carrying capacity of the noun]
                if ((((Prop_24()) >= GProperty(OBJECT_TY, noun,capacity))))
                {! [12: if the actor is the player]
                    if (((actor == player)))
                    {! [13: now the prior named object is nothing]
                        prior_named_noun = nothing;
                        ! [14: say ~[There] [are] no more room in [the noun].~ ( b )]
                        say__p=1;! [15: ~[There] [are] no more room in [the noun].~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_229); new_line; .L_Say236; .L_SayX230;}
                    ! [16: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_168, 168, 'action');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_169 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_169, 169);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: if the local ceiling is the actor]
    if (((tmp_0 == actor)))
    {! [4: if the player is the actor]
        if (((player == actor)))
        {! [5: say ~[We] [can] only get into something free-standing.~ ( a )]
            say__p=1;! [6: ~[We] [can] only get into something free-standing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_230); new_line; .L_Say237; .L_SayX231;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_169, 169, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_170 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_170, 170);
    ! [2: if the holder of the actor is the holder of the noun]
    if ((((HolderOf(actor)) == (HolderOf(noun)))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [5: while the holder of the actor is not the local ceiling]
    while (((~~(((HolderOf(actor)) == tmp_0)))))
    {! [6: let the current home be the holder of the actor]

        		tmp_1 = (HolderOf(actor));
        ! [7: if the player is the actor]
        if (((player == actor)))
        {! [8: if the current home is a supporter or the current home is an animal]
            if ((((tmp_1 ofclass K6_supporter))) || (((tmp_1 ofclass K12_animal))))
            {! [9: say ~(getting off [the current home])[command clarification break]~ ( a )]
                say__p=1;! [10: ~(getting off [the current home])[command clarification break]~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_231); .L_Say238; .L_SayX232;} else {
                ! [11: say ~(getting out of [the current home])[command clarification break]~ ( b )]
                say__p=1;! [12: ~(getting out of [the current home])[command clarification break]~ ( b )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_232); .L_Say239; .L_SayX233;}
                }
        ! [13: silently try the actor trying exiting]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [14: if the holder of the actor is the current home]
        if ((((HolderOf(actor)) == tmp_1)))
        {! [15: stop the action]
            rtrue;
            }
            }
    ! [16: if the holder of the actor is the noun]
    if ((((HolderOf(actor)) == noun)))
    {! [17: stop the action]
        rtrue;
        }
    ! [18: if the holder of the actor is the holder of the noun]
    if ((((HolderOf(actor)) == (HolderOf(noun)))))
    {! [19: continue the action]
        rfalse;
        }
    ! [20: let the target be the holder of the noun]

    		tmp_1 = (HolderOf(noun));
    ! [21: if the noun is part of the target]
    if (((tmp_1 == (noun.component_parent))))
    {! [22: let the target be the holder of the target]
        tmp_1 = (HolderOf(tmp_1));
        }
    ! [23: while the target is a thing]
    while (((tmp_1 ofclass K2_thing)))
    {! [24: if the holder of the target is the local ceiling]
        if ((((HolderOf(tmp_1)) == tmp_0)))
        {! [25: if the player is the actor]
            if (((player == actor)))
            {! [26: if the target is a supporter]
                if (((tmp_1 ofclass K6_supporter)))
                {! [27: say ~(getting onto [the target])[command clarification break]~ ( c )]
                    say__p=1;! [28: ~(getting onto [the target])[command clarification break]~ ( c )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_233); .L_Say240; .L_SayX234;} else {
                    ! [29: if the target is a container]
                    if (((tmp_1 ofclass K5_container)))
                    {! [30: say ~(getting into [the target])[command clarification break]~ ( d )]
                        say__p=1;! [31: ~(getting into [the target])[command clarification break]~ ( d )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_234); .L_Say241; .L_SayX235;} else {
                        ! [32: say ~(entering [the target])[command clarification break]~ ( e )]
                        say__p=1;! [33: ~(entering [the target])[command clarification break]~ ( e )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_235); .L_Say242; .L_SayX236;}
                        }
                        }
            ! [34: silently try the actor trying entering the target]
            @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Enter, tmp_1, 0);
            DivideParagraphPoint();
            @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

            ! [35: if the holder of the actor is not the target]
            if (((~~(((HolderOf(actor)) == tmp_1)))))
            {! [36: stop the action]
                rtrue;
                }
            ! [37: convert to the entering action on the noun]
            return GVS_Convert(##Enter,noun,0);
            ! [38: continue the action]
            rfalse;
            }
        ! [39: let the target be the holder of the target]
        tmp_1 = (HolderOf(tmp_1));
        }
        } else if (debug_rules > 1) DB_Rule(R_170, 170, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B156_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor entering ( this is the standard entering rule ):
[ R_171 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_171, 171);
    ! [2: surreptitiously move the actor to the noun]
    move actor to noun;
    } else if (debug_rules > 1) DB_Rule(R_171, 171, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B157_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the standard report entering rule ):
[ R_172 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_172, 172);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: if the noun is a supporter]
            if (((noun ofclass K6_supporter)))
            {! [5: say ~[We] [get] onto [the noun].~ ( a )]
                say__p=1;! [6: ~[We] [get] onto [the noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_236); new_line; .L_Say243; .L_SayX237;} else {
                ! [7: say ~[We] [get] into [the noun].~ ( b )]
                say__p=1;! [8: ~[We] [get] into [the noun].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_237); new_line; .L_Say244; .L_SayX238;}
                }
                } else {
        ! [9: if the noun is a container]
        if (((noun ofclass K5_container)))
        {! [10: say ~[The actor] [get] into [the noun].~ ( c )]
            say__p=1;! [11: ~[The actor] [get] into [the noun].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_238); new_line; .L_Say245; .L_SayX239;} else {
            ! [12: say ~[The actor] [get] onto [the noun].~ ( d )]
            say__p=1;! [13: ~[The actor] [get] onto [the noun].~ ( d )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_239); new_line; .L_Say246; .L_SayX240;}
            }
    ! [14: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_172, 172, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_173 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_173, 173);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: describe locale for the noun]
        (PHR_81_r14 (noun));
        }
        } else if (debug_rules > 1) DB_Rule(R_173, 173, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B158_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_175 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_175, 175);
    ! [2: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [3: if the container exited from is the local room]
    if ((((MStack-->MstVO(20009,0)) == tmp_0)))
    {! [4: if the room-or-door outside from the local room is not nothing]
        if (((~~((RoomOrDoorFrom(tmp_0,out_obj) == nothing)))))
        {! [5: convert to the going action on the outside]
            return GVS_Convert(##Go,out_obj,0);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_175, 175, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_176 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_176, 176);
    ! [2: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [3: if the container exited from is the local room]
    if ((((MStack-->MstVO(20009,0)) == tmp_0)))
    {! [4: if the player is the actor]
        if (((player == actor)))
        {! [5: say ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [6: ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_240); new_line; .L_Say247; .L_SayX241;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_176, 176, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_177 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_177, 177);
    ! [2: if the actor is in a closed container ( called the cage )]
    if (((ContainerOf(actor) ofclass K5_container) && ((Adj_84_t1_v10(ContainerOf(actor)))) && (tmp_0=(ContainerOf(actor)), true)))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~You can't get out of the closed [cage].~ ( a )]
            say__p=1;! [5: ~You can't get out of the closed [cage].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_241); new_line; .L_Say248; .L_SayX242;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_177, 177, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_178 
    tmp_0 ! Let/loop value, e.g., 'platform': supporter
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_178, 178);
    ! [2: if the actor is on a supporter ( called the platform )]
    if (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true)))
    {! [3: convert to the getting off action on the platform]
        return GVS_Convert(##GetOff,tmp_0,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_178, 178, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B159_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_179 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_179, 179);
    ! [2: let the former exterior be the not-counting-parts holder of the container exited from]

    		tmp_0 = (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0))));
    ! [3: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_179, 179, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B160_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_180 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_180, 180);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the container exited from is a supporter]
            if ((((MStack-->MstVO(20009,0)) ofclass K6_supporter)))
            {! [5: say ~[We] [get] off [the container exited from].~ ( a )]
                say__p=1;! [6: ~[We] [get] off [the container exited from].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_242); new_line; .L_Say249; .L_SayX243;} else {
                ! [7: say ~[We] [get] out of [the container exited from].~ ( b )]
                say__p=1;! [8: ~[We] [get] out of [the container exited from].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_243); new_line; .L_Say250; .L_SayX244;}
                } else {
            ! [9: say ~[The actor] [get] out of [the container exited from].~ ( c )]
            say__p=1;! [10: ~[The actor] [get] out of [the container exited from].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_244); new_line; .L_Say251; .L_SayX245;}
            }
    ! [11: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_180, 180, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_181 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_181, 181);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        ! [4: produce a room description with going spacing conventions]
        LookAfterGoing();
        }
        } else if (debug_rules > 1) DB_Rule(R_181, 181, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B161_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor getting off ( this is the can't get off things rule ):
[ R_182 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_182, 182);
    ! [2: if the actor is on the noun]
    if (((noun == SupporterOf(actor))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is carried by the noun]
    if (((noun == CarrierOf(actor))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
        say__p=1;! [8: ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_245); new_line; .L_Say252; .L_SayX246;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_182, 182, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B162_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_183 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_183, 183);
    ! [2: let the former exterior be the not-counting-parts holder of the noun]

    		tmp_0 = (CoreOfParentOfCoreOf(noun));
    ! [3: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_183, 183, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B163_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_184 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_184, 184);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [get] off [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [get] off [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_246); new_line; .L_Say253; .L_SayX247;}
    ! [5: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_184, 184, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_185 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_185, 185);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: produce a room description with going spacing conventions]
        LookAfterGoing();
        }
        } else if (debug_rules > 1) DB_Rule(R_185, 185, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B165_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Carry out looking ( this is the declare everything unmentioned rule ):
!   === equally specific with ===
! Rule 2/5 ! Carry out looking ( this is the spanish room description heading rule ):
!   === equally specific with ===
! Rule 3/5 ! Carry out looking ( this is the room description body text rule ):
!   === equally specific with ===
! Rule 4/5 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === equally specific with ===
! Rule 5/5 ! Carry out looking ( this is the check new arrival rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out looking ( this is the declare everything unmentioned rule ):
[ R_187 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_187, 187);
    ! [2: repeat with item running through things]
    for (tmp_0=Prop_25(0), tmp_1=Prop_25(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_25(tmp_1))
    {! [3: now the item is not mentioned]
        (Adj_78_t3_v10(tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_187, 187, 'actor');
        rfalse;
];
! From "Spanish Language" by Sebastian Arg
! No specific request
! Carry out looking ( this is the spanish room description heading rule ):
[ R_799 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_6();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_6 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_799, 799);
    ! [2: say bold type]
    say__p=1;! [3: bold type]
    ParaContent(); style bold; .L_Say254; .L_SayX248;! [4: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [5: begin the printing the name of a dark room activity]
        BeginActivity(V9_printing_the_name_of_a_da);
        ! [6: if handling the printing the name of a dark room activity]
        if (((~~(ForActivity(V9_printing_the_name_of_a_da)))))
        {! [7: say ~Oscuridad~ ( a )]
            say__p=1;! [8: ~Oscuridad~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_247); .L_Say255; .L_SayX249;}
        ! [9: end the printing the name of a dark room activity]
        EndActivity(V9_printing_the_name_of_a_da);
        } else {
        ! [10: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [11: johan mode ~[visibility ceiling]~]
            (PHR_800_r15 (BlkValueCopy(I7SFRAME, (TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_309)))));
            } else {
            ! [12: say ~[The visibility ceiling]~]
            say__p=1;! [13: the visibility ceiling]
            ParaContent(); print (The) (MStack-->MstVO(20011,3)); .L_Say256; .L_SayX250;}
            }
    ! [14: say roman type]
    say__p=1;! [15: roman type]
    ParaContent(); style roman; .L_Say257; .L_SayX251;! [16: let intermediate level be the visibility-holder of the actor]

    		tmp_0 = VisibilityParent(actor);
    ! [17: repeat with intermediate level count running from 2 to the visibility level count]
    for (tmp_1=2: tmp_1<=(MStack-->MstVO(20011,2)): tmp_1++)
    {! [18: if the intermediate level is a supporter or the intermediate level is an animal]
        if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K12_animal))))
        {! [19: say ~ (sobre [the intermediate level])~ ( b )]
            say__p=1;! [20: ~ (sobre [the intermediate level])~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_248); .L_Say258; .L_SayX252;} else {
            ! [21: say ~ (en [the intermediate level])~ ( c )]
            say__p=1;! [22: ~ (en [the intermediate level])~ ( c )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_249); .L_Say259; .L_SayX253;}
        ! [23: let the intermediate level be the visibility-holder of the intermediate level]
        tmp_0 = VisibilityParent(tmp_0);
        }
    ! [24: say line break]
    say__p=1;! [25: line break]
    ParaContent(); new_line; .L_Say260; .L_SayX254;! [26: say run paragraph on with special look spacing]
    say__p=1;! [27: run paragraph on with special look spacing]
    ParaContent(); SpecialLookSpacingBreak(); .L_Say261; .L_SayX255;} else if (debug_rules > 1) DB_Rule(R_799, 799, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description body text rule ):
[ R_189 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_189, 189);
    ! [2: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [3: if set to abbreviated room descriptions]
        if (((lookmode == 3)))
        {! [4: continue the action]
            rfalse;
            }
        ! [5: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true]
        if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && (((((Global_Vars-->0) && true) == (1 && true))))))
        {! [6: continue the action]
            rfalse;
            }
        ! [7: begin the printing the description of a dark room activity]
        BeginActivity(V10_printing_the_description);
        ! [8: if handling the printing the description of a dark room activity]
        if (((~~(ForActivity(V10_printing_the_description)))))
        {! [9: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [10: say ~[It] [are] pitch dark, and [we] [can't see] a thing.~ ( a )]
            say__p=1;! [11: ~[It] [are] pitch dark, and [we] [can't see] a thing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_250); new_line; .L_Say262; .L_SayX256;}
        ! [12: end the printing the description of a dark room activity]
        EndActivity(V10_printing_the_description);
        } else {
        ! [13: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [14: if set to abbreviated room descriptions]
            if (((lookmode == 3)))
            {! [15: continue the action]
                rfalse;
                }
            ! [16: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited]
            if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && ((((Adj_62_t1_v10(real_location)))))))
            {! [17: continue the action]
                rfalse;
                }
            ! [18: print the location's description]
            PrintOrRun(location, description);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_189, 189, 'actor');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_190 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_190, 190);
    ! [2: if the visibility level count is greater than 0]
    if ((((MStack-->MstVO(20011,2)) > 0)))
    {! [3: let the intermediate position be the actor]

        		tmp_0 = actor;
        ! [4: let the ip count be the visibility level count]

        		tmp_1 = (MStack-->MstVO(20011,2));
        ! [5: while the ip count is greater than 0]
        while (((tmp_1 > 0)))
        {! [6: now the intermediate position is marked for listing]
            (Adj_76_t2_v10(tmp_0));
            ! [7: let the intermediate position be the visibility-holder of the intermediate position]
            tmp_0 = VisibilityParent(tmp_0);
            ! [8: decrease the ip count by 1]
            tmp_1 = tmp_1 - 1;;
            }
        ! [9: let the top-down ip count be the visibility level count]

        		tmp_2 = (MStack-->MstVO(20011,2));
        ! [10: while the top-down ip count is greater than 0]
        while (((tmp_2 > 0)))
        {! [11: let the intermediate position be the actor]
            tmp_0 = actor;
            ! [12: let the ip count be 0]
            tmp_1 = 0;
            ! [13: while the ip count is less than the top-down ip count]
            while (((tmp_1 < tmp_2)))
            {! [14: let the intermediate position be the visibility-holder of the intermediate position]
                tmp_0 = VisibilityParent(tmp_0);
                ! [15: increase the ip count by 1]
                tmp_1 = tmp_1 + 1;;
                }
            ! [16: describe locale for the intermediate position]
            (PHR_81_r14 (tmp_0));
            ! [17: decrease the top-down ip count by 1]
            tmp_2 = tmp_2 - 1;;
            }
            }
    ! [18: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_190, 190, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the check new arrival rule ):
[ R_191 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_191, 191);
    ! [2: if in darkness]
    if (((location==thedark)))
    {! [3: now the darkness witnessed is true]
        (Global_Vars-->0) = 1;
        } else {
        ! [4: if the location is a room]
        if (((real_location ofclass K1_room)))
        {! [5: now the location is visited]
            (Adj_62_t2_v10(real_location));
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_191, 191, 'actor');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B166_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking ( this is the other people looking rule ):
[ R_192 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_192, 192);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [look] around.~ ( a )]
        say__p=1;! [4: ~[The actor] [look] around.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_251); new_line; .L_Say263; .L_SayX257;}
        } else if (debug_rules > 1) DB_Rule(R_192, 192, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B168_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out examining ( this is the standard examining rule ):
!   === equally specific with ===
! Rule 2/6 ! Carry out examining ( this is the examine directions rule ):
!   === equally specific with ===
! Rule 3/6 ! Carry out examining ( this is the examine containers rule ):
!   === equally specific with ===
! Rule 4/6 ! Carry out examining ( this is the examine supporters rule ):
!   === equally specific with ===
! Rule 5/6 ! Carry out examining ( this is the examine devices rule ):
!   === equally specific with ===
! Rule 6/6 ! Carry out examining ( this is the examine undescribed things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out examining ( this is the standard examining rule ):
[ R_193 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_193, 193);
    ! [2: if the noun provides the property description and the description of the noun is not ~~]
    if ((((WhetherProvides(noun, false, description)))) && (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,description), EMPTY_TEXT_VALUE) == 0))))))
    {! [3: say ~[description of the noun][line break]~]
        say__p=1;! [4: description of the noun]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,description);@pull self; ! [5: line break]
        ParaContent(); new_line; .L_Say264; .L_SayX258;! [6: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_193, 193, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine directions rule ):
[ R_194 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_194, 194);
    ! [2: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [3: say ~[We] [see] nothing unexpected in that direction.~ ( a )]
        say__p=1;! [4: ~[We] [see] nothing unexpected in that direction.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_252); new_line; .L_Say265; .L_SayX259;! [5: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_194, 194, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine containers rule ):
[ R_195 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_195, 195);
    ! [2: if the noun is a container]
    if (((noun ofclass K5_container)))
    {! [3: if the noun is open or the noun is transparent]
        if (((((Adj_83_t1_v10(noun))))) || ((((Adj_82_t1_v10(noun))))))
        {! [4: if something described which is not scenery is in the noun and something which is not the player is in the noun]
            if (((((Prop_26())))) && ((((Prop_27())))))
            {! [5: say ~In [the noun] ~ ( a )]
                say__p=1;! [6: ~In [the noun] ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_253); .L_Say266; .L_SayX260;! [7: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
                WriteListFrom(child(noun), 3144);
                ! [8: say ~.~]
                say__p=1;! [9: ~.~]
                ParaContent(); print "."; new_line; .L_Say267; .L_SayX261;! [10: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                } else {
                ! [11: if examine text printed is false]
                if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))
                {! [12: if the player is in the noun]
                    if (((noun == ContainerOf(player))))
                    {! [13: make no decision]
                        rfalse;
                        }
                    ! [14: say ~[The noun] [are] empty.~ ( b )]
                    say__p=1;! [15: ~[The noun] [are] empty.~ ( b )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_254); new_line; .L_Say268; .L_SayX262;! [16: now examine text printed is true]
                    (MStack-->MstVO(20012,0)) = 1;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_195, 195, 'actor');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine supporters rule ):
[ R_196 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_196, 196);
    ! [2: if the noun is a supporter]
    if (((noun ofclass K6_supporter)))
    {! [3: if something described which is not scenery is on the noun and something which is not the player is on the noun]
        if (((((Prop_28())))) && ((((Prop_29())))))
        {! [4: say ~On [the noun] ~ ( a )]
            say__p=1;! [5: ~On [the noun] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_255); .L_Say269; .L_SayX263;! [6: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are , including contents , giving brief inventory information]
            WriteListFrom(child(noun), 3288);
            ! [7: say ~.~]
            say__p=1;! [8: ~.~]
            ParaContent(); print "."; new_line; .L_Say270; .L_SayX264;! [9: now examine text printed is true]
            (MStack-->MstVO(20012,0)) = 1;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_196, 196, 'actor');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine devices rule ):
[ R_197 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_197, 197);
    ! [2: if the noun is a device]
    if (((noun ofclass K13_device)))
    {! [3: say ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~ ( a )]
        say__p=1;! [4: ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_256); new_line; .L_Say271; .L_SayX265;! [5: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_197, 197, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine undescribed things rule ):
[ R_198 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_198, 198);
    ! [2: if examine text printed is false]
    if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))
    {! [3: say ~[We] [see] nothing special about [the noun].~ ( a )]
        say__p=1;! [4: ~[We] [see] nothing special about [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_257); new_line; .L_Say272; .L_SayX266;}
        } else if (debug_rules > 1) DB_Rule(R_198, 198, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B169_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor examining ( this is the report other people examining rule ):
[ R_199 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_199, 199);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [look] closely at [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [look] closely at [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_258); new_line; .L_Say273; .L_SayX267;}
        } else if (debug_rules > 1) DB_Rule(R_199, 199, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B171_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_200 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_200, 200);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: say ~[We] [find] nothing of interest.~ ( a )]
        say__p=1;! [4: ~[We] [find] nothing of interest.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_259); new_line; .L_Say274; .L_SayX268;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_200, 200, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B172_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_201 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_201, 201);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is not the player]
        if (((~~((actor == player)))))
        {! [4: say ~[The actor] [look] under [the noun].~ ( a )]
            say__p=1;! [5: ~[The actor] [look] under [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_260); new_line; .L_Say275; .L_SayX269;}
            }
            } else if (debug_rules > 1) DB_Rule(R_201, 201, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B173_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_202 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_202, 202);
    ! [2: if the noun is not a container and the noun is not a supporter]
    if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter))))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [find] nothing of interest.~ ( a )]
            say__p=1;! [5: ~[We] [find] nothing of interest.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_261); new_line; .L_Say276; .L_SayX270;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_202, 202, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_203 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_203, 203);
    ! [2: if the noun is a closed opaque container]
    if (((noun ofclass K5_container) && ((Adj_84_t1_v10(noun))) && ((Adj_81_t1_v10(noun)))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [can't see] inside, since [the noun] [are] closed.~ ( a )]
            say__p=1;! [5: ~[We] [can't see] inside, since [the noun] [are] closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_262); new_line; .L_Say277; .L_SayX271;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_203, 203, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B175_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report searching a container ( this is the standard search containers rule ):
[ R_204 ;
    if ((( (actor==player) && ((noun ofclass K5_container))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_204, 204);
    ! [2: if the noun contains a described thing which is not scenery]
    if ((((Prop_30()))))
    {! [3: say ~In [the noun] ~ ( a )]
        say__p=1;! [4: ~In [the noun] ~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_263); .L_Say278; .L_SayX272;! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [6: say ~.~]
        say__p=1;! [7: ~.~]
        ParaContent(); print "."; new_line; .L_Say279; .L_SayX273;} else {
        ! [8: say ~[The noun] [are] empty.~ ( b )]
        say__p=1;! [9: ~[The noun] [are] empty.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_264); new_line; .L_Say280; .L_SayX274;}
        } else if (debug_rules > 1) DB_Rule(R_204, 204, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_205 ;
    if ((( (actor==player) && ((noun ofclass K6_supporter))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_205, 205);
    ! [2: if the noun supports a described thing which is not scenery]
    if ((((Prop_31()))))
    {! [3: say ~On [the noun] ~ ( a )]
        say__p=1;! [4: ~On [the noun] ~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_265); .L_Say281; .L_SayX275;! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [6: say ~.~]
        say__p=1;! [7: ~.~]
        ParaContent(); print "."; new_line; .L_Say282; .L_SayX276;} else {
        ! [8: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [9: say ~[There] [are] nothing on [the noun].~ ( b )]
        say__p=1;! [10: ~[There] [are] nothing on [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_266); new_line; .L_Say283; .L_SayX277;}
        } else if (debug_rules > 1) DB_Rule(R_205, 205, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor searching ( this is the report other people searching rule ):
[ R_206 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_206, 206);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [search] [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [search] [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_267); new_line; .L_Say284; .L_SayX278;}
        } else if (debug_rules > 1) DB_Rule(R_206, 206, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B178_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_207 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_207, 207);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [discover] nothing of interest in [the noun].~ ( a )]
        say__p=1;! [4: ~[We] [discover] nothing of interest in [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_268); new_line; .L_Say285; .L_SayX279;} else {
        ! [5: say ~[The actor] [look] at [the noun].~ ( b )]
        say__p=1;! [6: ~[The actor] [look] at [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_269); new_line; .L_Say286; .L_SayX280;}
        } else if (debug_rules > 1) DB_Rule(R_207, 207, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B179_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_208 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_208, 208);
    ! [2: if the noun provides the property lockable and the noun is lockable]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_87_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_270); new_line; .L_Say287; .L_SayX281;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_208, 208, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_209 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_209, 209);
    ! [2: if the noun is locked]
    if ((((Adj_88_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_271); new_line; .L_Say288; .L_SayX282;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_209, 209, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_210 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_210, 210);
    ! [2: if the noun is open]
    if ((((Adj_83_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~First [we] [would have] to close [the noun].~ ( a )]
            say__p=1;! [5: ~First [we] [would have] to close [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_272); new_line; .L_Say289; .L_SayX283;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_210, 210, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_211 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_211, 211);
    ! [2: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_273); new_line; .L_Say290; .L_SayX284;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_211, 211, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B180_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_212 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_212, 212);
    ! [2: now the noun is locked]
    (Adj_88_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_212, 212, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B181_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_213 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_213, 213);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [lock] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [lock] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_274); new_line; .L_Say291; .L_SayX285;}
            } else {
        ! [6: if the actor is visible]
        if ((((Adj_3_t1_v10(actor)))))
        {! [7: say ~[The actor] [lock] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [lock] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_275); new_line; .L_Say292; .L_SayX286;}
            }
            } else if (debug_rules > 1) DB_Rule(R_213, 213, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B182_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_214 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_214, 214);
    ! [2: if the noun provides the property lockable and the noun is lockable]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_87_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_276); new_line; .L_Say293; .L_SayX287;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_214, 214, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_215 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_215, 215);
    ! [2: if the noun is not locked]
    if (((~~(((Adj_88_t1_v10(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_277); new_line; .L_Say294; .L_SayX288;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_215, 215, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_216 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_216, 216);
    ! [2: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_278); new_line; .L_Say295; .L_SayX289;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_216, 216, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B183_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_217 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_217, 217);
    ! [2: now the noun is not locked]
    (Adj_88_t3_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_217, 217, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B184_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_218 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_218, 218);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [unlock] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [unlock] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_279); new_line; .L_Say296; .L_SayX290;}
            } else {
        ! [6: if the actor is visible]
        if ((((Adj_3_t1_v10(actor)))))
        {! [7: say ~[The actor] [unlock] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [unlock] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_280); new_line; .L_Say297; .L_SayX291;}
            }
            } else if (debug_rules > 1) DB_Rule(R_218, 218, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B185_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_219 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_219, 219);
    ! [2: if the noun provides the property switched on]
    if (((WhetherProvides(noun, true, on))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_281); new_line; .L_Say298; .L_SayX292;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_219, 219, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_220 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_220, 220);
    ! [2: if the noun is switched on]
    if ((((Adj_93_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already on.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already on.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_282); new_line; .L_Say299; .L_SayX293;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_220, 220, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B186_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_221 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_221, 221);
    ! [2: now the noun is switched on]
    (Adj_93_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_221, 221, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B187_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_222 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_222, 222);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [switch] [the noun] on.~ ( a )]
        say__p=1;! [4: ~[The actor] [switch] [the noun] on.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_283); new_line; .L_Say300; .L_SayX294;}
        } else if (debug_rules > 1) DB_Rule(R_222, 222, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B188_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_223 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_223, 223);
    ! [2: if the noun provides the property switched on]
    if (((WhetherProvides(noun, true, on))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_284); new_line; .L_Say301; .L_SayX295;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_223, 223, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_224 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_224, 224);
    ! [2: if the noun is switched off]
    if ((((Adj_94_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already off.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already off.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_285); new_line; .L_Say302; .L_SayX296;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_224, 224, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B189_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_225 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_225, 225);
    ! [2: now the noun is switched off]
    (Adj_94_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_225, 225, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B190_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_226 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_226, 226);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [switch] [the noun] off.~ ( a )]
        say__p=1;! [4: ~[The actor] [switch] [the noun] off.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_286); new_line; .L_Say303; .L_SayX297;}
        } else if (debug_rules > 1) DB_Rule(R_226, 226, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B191_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_227 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_227, 227);
    ! [2: if the noun provides the property openable and the noun is openable]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_85_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_287); new_line; .L_Say304; .L_SayX298;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_227, 227, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_228 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_228, 228);
    ! [2: if the noun provides the property lockable and the noun is locked]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_88_t1_v10(noun))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_288); new_line; .L_Say305; .L_SayX299;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_228, 228, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_229 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_229, 229);
    ! [2: if the noun is open]
    if ((((Adj_83_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already open.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already open.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_289); new_line; .L_Say306; .L_SayX300;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_229, 229, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B192_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor opening ( this is the standard opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor opening ( this is the standard opening rule ):
[ R_230 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_230, 230);
    ! [2: now the noun is open]
    (Adj_83_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_230, 230, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B193_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_231 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_231, 231);
    ! [2: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor]
    if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_81_t1_v10(noun))))) && ((((~~(((child(noun)) == nothing))))) && (((~~((IndirectlyContains(noun,actor)))))))))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[We] [open] [the noun], revealing ~ ( a )]
                say__p=1;! [6: ~[We] [open] [the noun], revealing ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_290); .L_Say307; .L_SayX301;! [7: list the contents of the noun , as a sentence , tersely , not listing concealed items]
                WriteListFrom(child(noun), 2120);
                ! [8: say ~.~]
                say__p=1;! [9: ~.~]
                ParaContent(); print "."; new_line; .L_Say308; .L_SayX302;}
                }
        ! [10: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_231, 231, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the standard report opening rule ):
[ R_232 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_232, 232);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [open] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [open] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_291); new_line; .L_Say309; .L_SayX303;}
            } else {
        ! [6: if the player can see the actor]
        if (((TestVisibility(player,actor))))
        {! [7: say ~[The actor] [open] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [open] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_292); new_line; .L_Say310; .L_SayX304;} else {
            ! [9: say ~[The noun] [open].~ ( c )]
            say__p=1;! [10: ~[The noun] [open].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_293); new_line; .L_Say311; .L_SayX305;}
            }
            } else if (debug_rules > 1) DB_Rule(R_232, 232, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B194_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_233 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_233, 233);
    ! [2: if the noun provides the property openable and the noun is openable]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_85_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_294); new_line; .L_Say312; .L_SayX306;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_233, 233, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_234 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_234, 234);
    ! [2: if the noun is closed]
    if ((((Adj_84_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already closed.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_295); new_line; .L_Say313; .L_SayX307;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_234, 234, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B195_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor closing ( this is the standard closing rule ):
[ R_235 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_235, 235);
    ! [2: now the noun is closed]
    (Adj_84_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_235, 235, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B196_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor closing ( this is the standard report closing rule ):
[ R_236 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_236, 236);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [close] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [close] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_296); new_line; .L_Say314; .L_SayX308;}
            } else {
        ! [6: if the player can see the actor]
        if (((TestVisibility(player,actor))))
        {! [7: say ~[The actor] [close] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [close] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_297); new_line; .L_Say315; .L_SayX309;} else {
            ! [9: say ~[The noun] [close].~ ( c )]
            say__p=1;! [10: ~[The noun] [close].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_298); new_line; .L_Say316; .L_SayX310;}
            }
            } else if (debug_rules > 1) DB_Rule(R_236, 236, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B197_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_237 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_237, 237);
    ! [2: if the noun is not a thing or the noun is not wearable]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_71_t1_v10(noun))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't wear] [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We] [can't wear] [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_299); new_line; .L_Say317; .L_SayX311;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_237, 237, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_238 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_238, 238);
    ! [2: if the holder of the noun is not the actor]
    if (((~~(((HolderOf(noun)) == actor)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_300); new_line; .L_Say318; .L_SayX312;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_238, 238, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_239 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_239, 239);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] already wearing [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We]['re] already wearing [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_301); new_line; .L_Say319; .L_SayX313;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_239, 239, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B198_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_240 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_240, 240);
    ! [2: now the actor wears the noun]
    WearObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_240, 240, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B199_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_241 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_241, 241);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [put] on [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [put] on [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_302); new_line; .L_Say320; .L_SayX314;}
            } else {
        ! [6: say ~[The actor] [put] on [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [put] on [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_303); new_line; .L_Say321; .L_SayX315;}
        } else if (debug_rules > 1) DB_Rule(R_241, 241, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B200_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_243 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_243, 243);
    ! [2: if the actor is not wearing the noun]
    if (((~~((actor == WearerOf(noun))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] wearing [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] wearing [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_304); new_line; .L_Say322; .L_SayX316;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_243, 243, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
[ R_244 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_244, 244);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_32()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[We]['re] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_305); new_line; .L_Say323; .L_SayX317;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_244, 244, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B201_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_245 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_245, 245);
    ! [2: now the actor carries the noun]
    MoveObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_245, 245, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B202_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_246 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_246, 246);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [take] off [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [take] off [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_306); new_line; .L_Say324; .L_SayX318;}
            } else {
        ! [6: say ~[The actor] [take] off [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [take] off [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_307); new_line; .L_Say325; .L_SayX319;}
        } else if (debug_rules > 1) DB_Rule(R_246, 246, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B203_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor giving something to ( this is the block giving rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_247 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_247, 247);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_308); new_line; .L_Say326; .L_SayX320;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_247, 247, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_248 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_248, 248);
    ! [2: if the actor is the second noun]
    if (((actor == second)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't give] [the noun] to [ourselves].~ ( a )]
            say__p=1;! [5: ~[We] [can't give] [the noun] to [ourselves].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_309); new_line; .L_Say327; .L_SayX321;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_248, 248, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_249 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_249, 249);
    ! [2: if the second noun is not a person]
    if (((~~((second ofclass K8_person)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [aren't] able to receive things.~ ( a )]
            say__p=1;! [5: ~[The second noun] [aren't] able to receive things.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_310); new_line; .L_Say328; .L_SayX322;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_249, 249, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_250 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_250, 250);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first taking [the noun] off)[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_311); .L_Say329; .L_SayX323;! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [6: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_250, 250, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the block giving rule ):
[ R_251 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_251, 251);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The second noun] [don't] seem interested.~ ( a )]
        say__p=1;! [4: ~[The second noun] [don't] seem interested.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_312); new_line; .L_Say330; .L_SayX324;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_251, 251, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
[ R_252 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_252, 252);
    ! [2: if the number of things carried by the second noun is at least the carrying capacity of the second noun]
    if ((((Prop_33()) >= GProperty(OBJECT_TY, second,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [are] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[The second noun] [are] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_313); new_line; .L_Say331; .L_SayX325;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_252, 252, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B204_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_253 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_253, 253);
    ! [2: move the noun to the second noun]
    MoveObject(noun, second, 0, false);
    } else if (debug_rules > 1) DB_Rule(R_253, 253, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B205_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_254 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_254, 254);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [give] [the noun] to [the second noun].~ ( a )]
        say__p=1;! [4: ~[We] [give] [the noun] to [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_314); new_line; .L_Say332; .L_SayX326;} else {
        ! [5: if the second noun is the player]
        if (((second == player)))
        {! [6: say ~[The actor] [give] [the noun] to [us].~ ( b )]
            say__p=1;! [7: ~[The actor] [give] [the noun] to [us].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_315); new_line; .L_Say333; .L_SayX327;} else {
            ! [8: say ~[The actor] [give] [the noun] to [the second noun].~ ( c )]
            say__p=1;! [9: ~[The actor] [give] [the noun] to [the second noun].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_316); new_line; .L_Say334; .L_SayX328;}
            }
            } else if (debug_rules > 1) DB_Rule(R_254, 254, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B206_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_255 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_255, 255);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_317); new_line; .L_Say335; .L_SayX329;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_255, 255, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_256 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_256, 256);
    ! [2: if the actor is the second noun]
    if (((actor == second)))
    {! [3: convert to the examining action on the noun]
        return GVS_Convert(##Examine,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_256, 256, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the block showing rule ):
[ R_257 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_257, 257);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The second noun] [are] unimpressed.~ ( a )]
        say__p=1;! [4: ~[The second noun] [are] unimpressed.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_318); new_line; .L_Say336; .L_SayX330;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_257, 257, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B209_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waking ( this is the block waking rule ):
[ R_258 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_258, 258);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~That [seem] unnecessary.~ ( a )]
        say__p=1;! [5: ~That [seem] unnecessary.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_319); new_line; .L_Say337; .L_SayX331;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_258, 258, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B212_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_259 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_259, 259);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first taking [the noun] off)[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_320); .L_Say338; .L_SayX332;! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [6: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_259, 259, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_260 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_260, 260);
    ! [2: if the second noun is not a person]
    if (((~~((second ofclass K8_person)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Futile.~ ( a )]
            say__p=1;! [5: ~Futile.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_321); new_line; .L_Say339; .L_SayX333;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_260, 260, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_261 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_261, 261);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~ ( a )]
        say__p=1;! [4: ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_322); new_line; .L_Say340; .L_SayX334;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_261, 261, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B215_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor attacking ( this is the block attacking rule ):
[ R_262 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_262, 262);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~Violence [aren't] the answer to this one.~ ( a )]
        say__p=1;! [5: ~Violence [aren't] the answer to this one.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_323); new_line; .L_Say341; .L_SayX335;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_262, 262, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B218_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_263 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_263, 263);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [don't] get much from that.~ ( a )]
            say__p=1;! [5: ~[We] [don't] get much from that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_324); new_line; .L_Say342; .L_SayX336;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_263, 263, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the block kissing rule ):
[ R_264 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_264, 264);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The noun] [might not] like that.~ ( a )]
        say__p=1;! [4: ~[The noun] [might not] like that.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_325); new_line; .L_Say343; .L_SayX337;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_264, 264, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Answering it that (B222_carry_out_answering_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor answering someone that something ( this is the RQ answering that rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Carry out an actor answering someone that something ( this is the RQ answering that rule ):
[ R_933 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((act_requester==nothing) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_933, 933);
    ! [2: repeat through table of tell results]
    @push ct_0; @push ct_1;
    		for (tmp_0=T20_tell_results, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the noun is the npc entry]
        if (((noun == TableLookUpEntry(ct_0,134,ct_1))))
        {! [4: if the topic understood includes topic entry]
            if (((matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number))))
            {! [5: deliver the result entry quip]
                (PHR_924_r16 (TableLookUpEntry(ct_0,133,ct_1)));
                ! [6: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [7: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [8: say ~[quiptext of the default tell quip of the noun][paragraph break]~]
        say__p=1;! [9: quiptext of the default tell quip of the noun]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(57, self=GProperty(OBJECT_TY, noun,p16_default_tell_quip),p73_quiptext);@pull self; ! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say344; .L_SayX338;! [11: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [12: say ~[bracket]BUG: Managed to talk to [a noun], who is not a person![close bracket][paragraph break]~]
    say__p=1;! [13: bracket]
    ParaContent(); print "[";! [14: ~BUG: Managed to talk to ~]
    ParaContent(); print "BUG: Managed to talk to ";! [15: a noun]
    ParaContent(); print (a) noun;! [16: ~, who is not a person!~]
    ParaContent(); print ", who is not a person!";! [17: close bracket]
    ParaContent(); print "]";! [18: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say345; .L_SayX339;! [19: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_933, 933, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B224_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_266 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_266, 266);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [talk] to [ourselves] a while.~ ( a )]
            say__p=1;! [5: ~[We] [talk] to [ourselves] a while.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_326); new_line; .L_Say346; .L_SayX340;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_266, 266, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Telling it about (B225_carry_out_telling_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor telling someone about something ( this is the RQ telling about rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Carry out an actor telling someone about something ( this is the RQ telling about rule ):
[ R_932 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((act_requester==nothing) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_932, 932);
    ! [2: repeat through table of tell results]
    @push ct_0; @push ct_1;
    		for (tmp_0=T20_tell_results, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the noun is the npc entry]
        if (((noun == TableLookUpEntry(ct_0,134,ct_1))))
        {! [4: if the topic understood includes topic entry]
            if (((matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number))))
            {! [5: deliver the result entry quip]
                (PHR_924_r16 (TableLookUpEntry(ct_0,133,ct_1)));
                ! [6: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [7: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [8: say ~[quiptext of the default tell quip of the noun][paragraph break]~]
        say__p=1;! [9: quiptext of the default tell quip of the noun]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(57, self=GProperty(OBJECT_TY, noun,p16_default_tell_quip),p73_quiptext);@pull self; ! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say347; .L_SayX341;! [11: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [12: say ~[bracket]BUG: Managed to talk to [a noun], who is not a person![close bracket][paragraph break]~]
    say__p=1;! [13: bracket]
    ParaContent(); print "[";! [14: ~BUG: Managed to talk to ~]
    ParaContent(); print "BUG: Managed to talk to ";! [15: a noun]
    ParaContent(); print (a) noun;! [16: ~, who is not a person!~]
    ParaContent(); print ", who is not a person!";! [17: close bracket]
    ParaContent(); print "]";! [18: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say348; .L_SayX342;! [19: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_932, 932, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Asking it about (B228_carry_out_asking_it_abo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor asking someone about something ( This is the RQ asking about rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Carry out an actor asking someone about something ( This is the RQ asking about rule ):
[ R_931 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((act_requester==nothing) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_931, 931);
    ! [2: repeat through table of ask results]
    @push ct_0; @push ct_1;
    		for (tmp_0=T19_ask_results, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the noun is the npc entry]
        if (((noun == TableLookUpEntry(ct_0,134,ct_1))))
        {! [4: if the topic understood includes topic entry]
            if (((matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number))))
            {! [5: deliver the result entry quip]
                (PHR_924_r16 (TableLookUpEntry(ct_0,133,ct_1)));
                ! [6: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [7: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [8: say ~[quiptext of the default ask quip of the noun][paragraph break]~]
        say__p=1;! [9: quiptext of the default ask quip of the noun]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(57, self=GProperty(OBJECT_TY, noun,p15_default_ask_quip),p73_quiptext);@pull self; ! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say349; .L_SayX343;! [11: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [12: say ~[bracket]BUG: Managed to talk to [a noun], who is not a person![close bracket]~]
    say__p=1;! [13: bracket]
    ParaContent(); print "[";! [14: ~BUG: Managed to talk to ~]
    ParaContent(); print "BUG: Managed to talk to ";! [15: a noun]
    ParaContent(); print (a) noun;! [16: ~, who is not a person!~]
    ParaContent(); print ", who is not a person!";! [17: close bracket]
    ParaContent(); print "]"; .L_Say350; .L_SayX344;! [18: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_931, 931, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B230_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_269 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_269, 269);
    ! [2: if the actor is the noun and the actor is the player]
    if ((((actor == noun))) && (((actor == player))))
    {! [3: try taking inventory]
        TryAction(0, player, ##Inv, 0, 0);
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_269, 269, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_270 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_270, 270);
    ! [2: convert to request of the noun to perform giving it to action with the second noun and the actor]
    return ConvertToRequest(noun, ##Give, second, actor);
    } else if (debug_rules > 1) DB_Rule(R_270, 270, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B235_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_271 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_271, 271);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Time [pass].~ ( a )]
            say__p=1;! [6: ~Time [pass].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_327); new_line; .L_Say351; .L_SayX345;}
            } else {
        ! [7: say ~[The actor] [wait].~ ( b )]
        say__p=1;! [8: ~[The actor] [wait].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_328); new_line; .L_Say352; .L_SayX346;}
        } else if (debug_rules > 1) DB_Rule(R_271, 271, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B238_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching yourself rule ):
[ R_272 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_272, 272);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the action is not silent]
            if (((keep_silent == false)))
            {! [5: say ~[We] [achieve] nothing by this.~ ( a )]
                say__p=1;! [6: ~[We] [achieve] nothing by this.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_329); new_line; .L_Say353; .L_SayX347;}
                } else {
            ! [7: say ~[The actor] [touch] [themselves].~ ( b )]
            say__p=1;! [8: ~[The actor] [touch] [themselves].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_330); new_line; .L_Say354; .L_SayX348;}
        ! [9: stop the action]
        rtrue;
        }
    ! [10: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_272, 272, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching other people rule ):
[ R_273 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_273, 273);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the action is not silent]
            if (((keep_silent == false)))
            {! [5: say ~[The noun] [might not like] that.~ ( a )]
                say__p=1;! [6: ~[The noun] [might not like] that.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_331); new_line; .L_Say355; .L_SayX349;}
                } else {
            ! [7: if the noun is the player]
            if (((noun == player)))
            {! [8: say ~[The actor] [touch] [us].~ ( b )]
                say__p=1;! [9: ~[The actor] [touch] [us].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_332); new_line; .L_Say356; .L_SayX350;} else {
                ! [10: say ~[The actor] [touch] [the noun].~ ( c )]
                say__p=1;! [11: ~[The actor] [touch] [the noun].~ ( c )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_333); new_line; .L_Say357; .L_SayX351;}
                }
        ! [12: stop the action]
        rtrue;
        }
    ! [13: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_273, 273, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching things rule ):
[ R_274 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_274, 274);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [feel] nothing unexpected.~ ( a )]
            say__p=1;! [5: ~[We] [feel] nothing unexpected.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_334); new_line; .L_Say358; .L_SayX352;}
            } else {
        ! [6: say ~[The actor] [touch] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [touch] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_335); new_line; .L_Say359; .L_SayX353;}
        } else if (debug_rules > 1) DB_Rule(R_274, 274, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B239_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_275 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_275, 275);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~But [we] [aren't] holding [regarding the noun][those].~ ( a )]
            say__p=1;! [5: ~But [we] [aren't] holding [regarding the noun][those].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_336); new_line; .L_Say360; .L_SayX354;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_275, 275, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B241_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waving ( this is the report waving things rule ):
[ R_276 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_276, 276);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [wave] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [wave] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_337); new_line; .L_Say361; .L_SayX355;}
            } else {
        ! [6: say ~[The actor] [wave] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [wave] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_338); new_line; .L_Say362; .L_SayX356;}
        } else if (debug_rules > 1) DB_Rule(R_276, 276, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B242_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_277 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_277, 277);
    ! [2: if the noun is fixed in place]
    if ((((Adj_68_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_339); new_line; .L_Say363; .L_SayX357;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_277, 277, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_278 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_278, 278);
    ! [2: if the noun is scenery]
    if ((((Adj_70_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_340); new_line; .L_Say364; .L_SayX358;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_278, 278, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull people rule ):
[ R_279 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_279, 279);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_341); new_line; .L_Say365; .L_SayX359;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_279, 279, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B244_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pulling ( this is the report pulling rule ):
[ R_280 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_280, 280);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_342); new_line; .L_Say366; .L_SayX360;}
            } else {
        ! [7: say ~[The actor] [pull] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [pull] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_343); new_line; .L_Say367; .L_SayX361;}
        } else if (debug_rules > 1) DB_Rule(R_280, 280, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B245_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_281 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_281, 281);
    ! [2: if the noun is fixed in place]
    if ((((Adj_68_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_344); new_line; .L_Say368; .L_SayX362;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_281, 281, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_282 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_282, 282);
    ! [2: if the noun is scenery]
    if ((((Adj_70_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_345); new_line; .L_Say369; .L_SayX363;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_282, 282, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push people rule ):
[ R_283 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_283, 283);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_346); new_line; .L_Say370; .L_SayX364;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_283, 283, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B247_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pushing something ( this is the report pushing rule ):
[ R_284 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_284, 284);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_347); new_line; .L_Say371; .L_SayX365;}
            } else {
        ! [7: say ~[The actor] [push] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [push] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_348); new_line; .L_Say372; .L_SayX366;}
        } else if (debug_rules > 1) DB_Rule(R_284, 284, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B248_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_285 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_285, 285);
    ! [2: if the noun is fixed in place]
    if ((((Adj_68_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_349); new_line; .L_Say373; .L_SayX367;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_285, 285, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_286 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_286, 286);
    ! [2: if the noun is scenery]
    if ((((Adj_70_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_350); new_line; .L_Say374; .L_SayX368;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_286, 286, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn people rule ):
[ R_287 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_287, 287);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_351); new_line; .L_Say375; .L_SayX369;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_287, 287, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B250_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor turning ( this is the report turning rule ):
[ R_288 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_288, 288);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_352); new_line; .L_Say376; .L_SayX370;}
            } else {
        ! [7: say ~[The actor] [turn] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [turn] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_353); new_line; .L_Say377; .L_SayX371;}
        } else if (debug_rules > 1) DB_Rule(R_288, 288, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B251_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor pushing something to ( this is the can't push from within rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_289 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_289, 289);
    ! [2: if the noun is not pushable between rooms]
    if (((~~(((Adj_72_t1_v10(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed from place to place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_354); new_line; .L_Say378; .L_SayX372;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_289, 289, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_290 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_290, 290);
    ! [2: if the second noun is not a direction]
    if (((~~((second ofclass K3_direction)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [aren't] a direction.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [aren't] a direction.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_355); new_line; .L_Say379; .L_SayX373;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_290, 290, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_291 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_291, 291);
    ! [2: if the second noun is up or the second noun is down]
    if ((((second == I59_up))) || (((second == I60_down))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed up or down.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed up or down.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_356); new_line; .L_Say380; .L_SayX374;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_291, 291, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push from within rule ):
[ R_292 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_292, 292);
    ! [2: if the noun encloses the actor]
    if (((IndirectlyContains(noun,actor))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed from here.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed from here.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_357); new_line; .L_Say381; .L_SayX375;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_292, 292, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_293 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_293, 293);
    ! [2: convert to special going-with-push action]
    return ConvertToGoingWithPush();
    } else if (debug_rules > 1) DB_Rule(R_293, 293, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_294 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_294, 294);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
        say__p=1;! [4: ~[The noun] [cannot] be pushed from place to place.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_358); new_line; .L_Say382; .L_SayX376;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_294, 294, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B254_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_295 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_295, 295);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_359); new_line; .L_Say383; .L_SayX377;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_295, 295, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B256_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_296 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_296, 296);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [achieve] nothing by this.~ ( a )]
            say__p=1;! [5: ~[We] [achieve] nothing by this.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_360); new_line; .L_Say384; .L_SayX378;}
            } else {
        ! [6: say ~[The actor] [squeeze] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [squeeze] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_361); new_line; .L_Say385; .L_SayX379;}
        } else if (debug_rules > 1) DB_Rule(R_296, 296, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B257_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_297 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_297, 297);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~That was a rhetorical question.~ ( a )]
        say__p=1;! [4: ~That was a rhetorical question.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_362); new_line; .L_Say386; .L_SayX380;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_297, 297, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B260_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying no ( this is the block saying no rule ):
[ R_298 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_298, 298);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~That was a rhetorical question.~ ( a )]
        say__p=1;! [4: ~That was a rhetorical question.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_363); new_line; .L_Say387; .L_SayX381;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_298, 298, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B263_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor burning ( this is the block burning rule ):
[ R_299 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_299, 299);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~This dangerous act [would achieve] little.~ ( a )]
        say__p=1;! [4: ~This dangerous act [would achieve] little.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_364); new_line; .L_Say388; .L_SayX382;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_299, 299, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B266_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waking up ( this is the block waking up rule ):
[ R_300 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_300, 300);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~The dreadful truth [are], this [are not] a dream.~ ( a )]
        say__p=1;! [5: ~The dreadful truth [are], this [are not] a dream.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_365); new_line; .L_Say389; .L_SayX383;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_300, 300, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B269_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor thinking ( this is the block thinking rule ):
[ R_301 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_301, 301);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~What a good idea.~ ( a )]
        say__p=1;! [4: ~What a good idea.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_366); new_line; .L_Say390; .L_SayX384;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_301, 301, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Smelling (B274_report_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor smelling ( this is the report smelling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor smelling ( this is the report smelling rule ):
[ R_302 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_302, 302);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [smell] nothing unexpected.~ ( a )]
            say__p=1;! [5: ~[We] [smell] nothing unexpected.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_367); new_line; .L_Say391; .L_SayX385;}
            } else {
        ! [6: say ~[The actor] [sniff].~ ( b )]
        say__p=1;! [7: ~[The actor] [sniff].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_368); new_line; .L_Say392; .L_SayX386;}
        } else if (debug_rules > 1) DB_Rule(R_302, 302, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Listening to (B277_report_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor listening to ( this is the report listening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor listening to ( this is the report listening rule ):
[ R_303 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_303, 303);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [hear] nothing unexpected.~ ( a )]
            say__p=1;! [5: ~[We] [hear] nothing unexpected.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_369); new_line; .L_Say393; .L_SayX387;}
            } else {
        ! [6: say ~[The actor] [listen].~ ( b )]
        say__p=1;! [7: ~[The actor] [listen].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_370); new_line; .L_Say394; .L_SayX388;}
        } else if (debug_rules > 1) DB_Rule(R_303, 303, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Tasting (B280_report_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor tasting ( this is the report tasting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor tasting ( this is the report tasting rule ):
[ R_304 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_304, 304);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [taste] nothing unexpected.~ ( a )]
            say__p=1;! [5: ~[We] [taste] nothing unexpected.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_371); new_line; .L_Say395; .L_SayX389;}
            } else {
        ! [6: say ~[The actor] [taste] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [taste] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_372); new_line; .L_Say396; .L_SayX390;}
        } else if (debug_rules > 1) DB_Rule(R_304, 304, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B281_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor cutting ( this is the block cutting rule ):
[ R_305 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_305, 305);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~Cutting [regarding the noun][them] up [would achieve] little.~ ( a )]
        say__p=1;! [4: ~Cutting [regarding the noun][them] up [would achieve] little.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_373); new_line; .L_Say397; .L_SayX391;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_305, 305, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Jumping (B286_report_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor jumping ( this is the report jumping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor jumping ( this is the report jumping rule ):
[ R_306 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_306, 306);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [jump] on the spot.~ ( a )]
            say__p=1;! [5: ~[We] [jump] on the spot.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_374); new_line; .L_Say398; .L_SayX392;}
            } else {
        ! [6: say ~[The actor] [jump] on the spot.~ ( b )]
        say__p=1;! [7: ~[The actor] [jump] on the spot.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_375); new_line; .L_Say399; .L_SayX393;}
        } else if (debug_rules > 1) DB_Rule(R_306, 306, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B287_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying something to ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor tying something to ( this is the block tying rule ):
[ R_307 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_307, 307);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [would achieve] nothing by this.~ ( a )]
        say__p=1;! [4: ~[We] [would achieve] nothing by this.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_376); new_line; .L_Say400; .L_SayX394;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_307, 307, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B290_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor drinking ( this is the block drinking rule ):
[ R_308 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_308, 308);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There's] nothing suitable to drink here.~ ( a )]
        say__p=1;! [5: ~[There's] nothing suitable to drink here.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_377); new_line; .L_Say401; .L_SayX395;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_308, 308, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B293_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_309 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_309, 309);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~ ( a )]
        say__p=1;! [4: ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_378); new_line; .L_Say402; .L_SayX396;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_309, 309, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B296_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor swinging ( this is the block swinging rule ):
[ R_310 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_310, 310);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There's] nothing sensible to swing here.~ ( a )]
        say__p=1;! [5: ~[There's] nothing sensible to swing here.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_379); new_line; .L_Say403; .L_SayX397;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_310, 310, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B299_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the can't rub another person rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor rubbing ( this is the can't rub another person rule ):
[ R_311 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_311, 311);
    ! [2: if the noun is a person who is not the actor]
    if (((noun ofclass K8_person) && (~~((noun == actor)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_380); new_line; .L_Say404; .L_SayX398;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_311, 311, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Rubbing (B301_report_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor rubbing ( this is the report rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor rubbing ( this is the report rubbing rule ):
[ R_312 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_312, 312);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [rub] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [rub] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_381); new_line; .L_Say405; .L_SayX399;}
            } else {
        ! [6: say ~[The actor] [rub] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [rub] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_382); new_line; .L_Say406; .L_SayX400;}
        } else if (debug_rules > 1) DB_Rule(R_312, 312, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B302_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_313 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_313, 313);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~No, [we] [can't set] [regarding the noun][those] to anything.~ ( a )]
        say__p=1;! [4: ~No, [we] [can't set] [regarding the noun][those] to anything.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_383); new_line; .L_Say407; .L_SayX401;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_313, 313, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving hands (B307_report_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving hands ( this is the report waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waving hands ( this is the report waving hands rule ):
[ R_314 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_314, 314);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [wave].~ ( a )]
            say__p=1;! [5: ~[We] [wave].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_384); new_line; .L_Say408; .L_SayX402;}
            } else {
        ! [6: say ~[The actor] [wave].~ ( b )]
        say__p=1;! [7: ~[The actor] [wave].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_385); new_line; .L_Say409; .L_SayX403;}
        } else if (debug_rules > 1) DB_Rule(R_314, 314, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B308_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor buying ( this is the block buying rule ):
[ R_315 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_315, 315);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~Nothing [are] on sale.~ ( a )]
        say__p=1;! [5: ~Nothing [are] on sale.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_386); new_line; .L_Say410; .L_SayX404;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_315, 315, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B311_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor climbing ( this is the block climbing rule ):
[ R_316 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_316, 316);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~Little [are] to be achieved by that.~ ( a )]
        say__p=1;! [4: ~Little [are] to be achieved by that.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_387); new_line; .L_Say411; .L_SayX405;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_316, 316, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B314_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_317 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_317, 317);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [aren't] feeling especially drowsy.~ ( a )]
        say__p=1;! [4: ~[We] [aren't] feeling especially drowsy.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_388); new_line; .L_Say412; .L_SayX406;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_317, 317, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Requesting the score (B342_carry_out_requesting_th)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out requesting the score:
!   >>> IV - Action requirement >>>
! Rule 2/2: ANNOUNCE_SCORE_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out requesting the score:
[ R_1106 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1106, 1106);
    ! [2: say ~[if the score > 1][italic type]Has ganado [score in words] puntos de destino.[roman type][else if the score is 0][italic type]Todavía no has ganado ningún punto de destino.[roman type][else if the score is 1][italic type]Has ganado [score in words] punto de destino.[end if][paragraph break]~]
    say__p=1;! [3: if the score > 1]

    	if (~~((((score > 1))))) jump L_Say413;! [4: italic type]
    ParaContent(); style underline;! [5: ~Has ganado ~]
    ParaContent(); print "Has ganado ";! [6: score in words]
    ParaContent(); print (number) say__n=(score);! [7: ~ puntos de destino.~]
    ParaContent(); print " puntos de destino.";! [8: roman type]
    ParaContent(); style roman;! [9: else if the score is 0]
    ParaContent(); 
    	jump L_SayX407; .L_Say413; if (~~((((score == 0))))) jump L_Say414;! [10: italic type]
    ParaContent(); style underline;! [11: ~Todavía no has ganado ningún punto de destino.~]
    ParaContent(); print "Todavía no has ganado ningún punto de destino.";! [12: roman type]
    ParaContent(); style roman;! [13: else if the score is 1]
    ParaContent(); 
    	jump L_SayX407; .L_Say414; if (~~((((score == 1))))) jump L_Say415;! [14: italic type]
    ParaContent(); style underline;! [15: ~Has ganado ~]
    ParaContent(); print "Has ganado ";! [16: score in words]
    ParaContent(); print (number) say__n=(score);! [17: ~ punto de destino.~]
    ParaContent(); print " punto de destino."; new_line;! [18: end if]

    	.L_Say415; .L_SayX407;! [19: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say416; .L_SayX408;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1106, 1106, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering to room (B363_carry_out_entering_to_r)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out entering to room ( this is the intentar entrar rule ):
! ----------------------------------------------------------------------------------------------------
! From "Spanish Language" by Sebastian Arg
! No specific request
! Carry out entering to room ( this is the intentar entrar rule ):
[ R_828 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_828, 828);
    ! [2: try going inside]
    TryAction(0, player, ##Go, in_obj, 0);
    } else if (debug_rules > 1) DB_Rule(R_828, 828, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Bajando (B366_carry_out_bajando)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out bajando:
! ----------------------------------------------------------------------------------------------------
! From "Spanish Language" by Sebastian Arg
! No specific request
! Carry out bajando:
[ R_829 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_829, 829);
    ! [2: try going down]
    TryAction(0, player, ##Go, I60_down, 0);
    } else if (debug_rules > 1) DB_Rule(R_829, 829, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Subiendo (B369_carry_out_subiendo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out subiendo:
! ----------------------------------------------------------------------------------------------------
! From "Spanish Language" by Sebastian Arg
! No specific request
! Carry out subiendo:
[ R_830 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_830, 830);
    ! [2: try going up]
    TryAction(0, player, ##Go, I59_up, 0);
    } else if (debug_rules > 1) DB_Rule(R_830, 830, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Pausing the game (B372_for_pausing_the_game)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For pausing the game ( this is the standard pausing the game rule ):
! ----------------------------------------------------------------------------------------------------
! From "Basic Screen Effects" by Emily Short
! No specific request
! For pausing the game ( this is the standard pausing the game rule ):
[ R_880 ;
    if (debug_rules) DB_Rule(R_880, 880);
    ! [2: say ~[paragraph break]Please press SPACE to continue.~ ( a )]
    say__p=1;! [3: ~[paragraph break]Please press SPACE to continue.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_389); new_line; .L_Say417; .L_SayX409;! [4: wait for the space key]
    SPACEPause();
    ! [5: clear the screen]
    VM_ClearScreen(0);
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Displaying (B375_for_displaying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for displaying ( this is the basic menu contents rule ):
! ----------------------------------------------------------------------------------------------------
! From "Menus" by Emily Short
! No specific request
! Rule for displaying ( this is the basic menu contents rule ):
[ R_909 ;
    if (debug_rules) DB_Rule(R_909, 909);
    ! [2: now current menu selection is 1]
    (Global_Vars-->16) = 1;
    ! [3: show menu contents]
    (PHR_908_r17 ());
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Asking for help (B378_carry_out_asking_for_he)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out asking for help ( this is the help request rule ):
! ----------------------------------------------------------------------------------------------------
! From "Basic Help Menu SP" by Emily Short
! No specific request
! Carry out asking for help ( this is the help request rule ):
[ R_922 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_922, 922);
    ! [2: now the current menu is the table of basic help options]
    (Global_Vars-->15) = T12_basic_help_options;
    ! [3: carry out the displaying activity]
    CarryOutActivity(V35_displaying);
    ! [4: clear the screen]
    VM_ClearScreen(0);
    ! [5: try looking]
    TryAction(0, player, ##Look, 0, 0);
    } else if (debug_rules > 1) DB_Rule(R_922, 922, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Quipping (B381_for_quipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last for quipping rule ( this is the basic quipping rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! The last for quipping rule ( this is the basic quipping rule ):
[ R_923 ;
    if (debug_rules) DB_Rule(R_923, 923);
    ! [2: say ~[quiptext of the current quip][paragraph break]~]
    say__p=1;! [3: quiptext of the current quip]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(57, self=(Global_Vars-->17),p73_quiptext);@pull self; ! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say418; .L_SayX410;RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Quipping (B382_after_quipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/14 ! After quipping when the current quip is hola-pastor:
!   === equally specific with ===
! Rule 2/14 ! After quipping when the current quip is ayuda-pastor:
!   === equally specific with ===
! Rule 3/14 ! After quipping when the current quip is hambriento:
!   === equally specific with ===
! Rule 4/14 ! After quipping when the current quip is azotadle:
!   === equally specific with ===
! Rule 5/14 ! After quipping when the current quip is azotadle:
!   === equally specific with ===
! Rule 6/14 ! After quipping when the current quip is sufrimiento:
!   === equally specific with ===
! Rule 7/14 ! After quipping when the current quip is palabras:
!   === equally specific with ===
! Rule 8/14 ! After quipping when the current quip is espada-buena:
!   === equally specific with ===
! Rule 9/14 ! After quipping when the current quip is palabras:
!   === equally specific with ===
! Rule 10/14 ! After quipping when the current quip is buenas-noches:
!   === equally specific with ===
! Rule 11/14 ! After quipping when the current quip is deja-ya:
!   === equally specific with ===
! Rule 12/14 ! After quipping when the current quip is hola-hermano:
!   === equally specific with ===
! Rule 13/14 ! After quipping when the current quip is ternero-hermano:
!   === equally specific with ===
! Rule 14/14 ! After quipping when the current quip is mi-ofrenda:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After quipping when the current quip is hola-pastor:
[ R_1152 ;
    if (((((((Global_Vars-->17) == I156_hola_pastor)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1152, 1152);
    ! [2: enable the escucha-pastor quip]
    (PHR_953_r6 (I154_escucha_pastor));
    ! [3: enable the ayuda-pastor quip]
    (PHR_953_r6 (I155_ayuda_pastor));
    } else if (debug_rules > 1) DB_Rule(R_1152, 1152, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is ayuda-pastor:
[ R_1153 ;
    if (((((((Global_Vars-->17) == I155_ayuda_pastor)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1153, 1153);
    ! [2: enable the ayuda-pastor quip]
    (PHR_953_r6 (I155_ayuda_pastor));
    ! [3: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1153, 1153, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is hambriento:
[ R_1160 ;
    if (((((((Global_Vars-->17) == I159_hambriento)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1160, 1160);
    ! [2: enable the azotadle quip]
    (PHR_953_r6 (I158_azotadle));
    ! [3: enable the tu-crimen quip]
    (PHR_953_r6 (I157_tu_crimen));
    } else if (debug_rules > 1) DB_Rule(R_1160, 1160, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is azotadle:
[ R_1161 ;
    if (((((((Global_Vars-->17) == I158_azotadle)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1161, 1161);
    ! [2: enable the azotadle quip]
    (PHR_953_r6 (I158_azotadle));
    ! [3: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1161, 1161, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is azotadle:
[ R_1162 ;
    if (((((((Global_Vars-->17) == I158_azotadle)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1162, 1162);
    ! [2: enable the azotadle quip]
    (PHR_953_r6 (I158_azotadle));
    } else if (debug_rules > 1) DB_Rule(R_1162, 1162, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is sufrimiento:
[ R_1170 ;
    if (((((((Global_Vars-->17) == I161_sufrimiento)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1170, 1170);
    ! [2: enable the palabras quip]
    (PHR_953_r6 (I162_palabras));
    ! [3: enable the espada-buena quip]
    (PHR_953_r6 (I160_espada_buena));
    } else if (debug_rules > 1) DB_Rule(R_1170, 1170, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is palabras:
[ R_1171 ;
    if (((((((Global_Vars-->17) == I162_palabras)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1171, 1171);
    ! [2: enable the palabras quip]
    (PHR_953_r6 (I162_palabras));
    ! [3: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1171, 1171, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is espada-buena:
[ R_1172 ;
    if (((((((Global_Vars-->17) == I160_espada_buena)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1172, 1172);
    ! [2: if the espada is not carried by the player]
    if (((~~((player == CarrierOf(I252_espada))))))
    {! [3: now the espada is portable]
        (Adj_69_t2_v10(I252_espada));
        ! [4: now the player carries the espada]
        MoveObject(I252_espada,player);
        ! [5: say ~Te agachas a recoger la espada del suelo y la empuñas con fuerza. El hombre implora piedad.[paragraph break]~]
        say__p=1;! [6: ~Te agachas a recoger la espada del suelo y la empuñas con fuerza. El hombre implora piedad.~]
        ParaContent(); print "Te agachas a recoger la espada del suelo y la empuñas con fuerza. El hombre implora piedad.";! [7: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say419; .L_SayX411;} else {
        ! [8: say ~Pones la punta de la espada sobre el gaznate del aterrado soldado.[paragraph break]~]
        say__p=1;! [9: ~Pones la punta de la espada sobre el gaznate del aterrado soldado.~]
        ParaContent(); print "Pones la punta de la espada sobre el gaznate del aterrado soldado.";! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say420; .L_SayX412;}
        } else if (debug_rules > 1) DB_Rule(R_1172, 1172, 'context');
        rfalse;
];
! No specific request
! After quipping when the current quip is palabras:
[ R_1173 ;
    if (((((((Global_Vars-->17) == I162_palabras)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1173, 1173);
    ! [2: enable the palabras quip]
    (PHR_953_r6 (I162_palabras));
    } else if (debug_rules > 1) DB_Rule(R_1173, 1173, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is buenas-noches:
[ R_1182 ;
    if (((((((Global_Vars-->17) == I164_buenas_noches)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1182, 1182);
    ! [2: enable the cabello-hermoso quip]
    (PHR_953_r6 (I165_cabello_hermoso));
    ! [3: enable the deja-ya quip]
    (PHR_953_r6 (I163_deja_ya));
    } else if (debug_rules > 1) DB_Rule(R_1182, 1182, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is deja-ya:
[ R_1183 ;
    if (((((((Global_Vars-->17) == I163_deja_ya)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1183, 1183);
    ! [2: enable the deja-ya quip]
    (PHR_953_r6 (I163_deja_ya));
    ! [3: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1183, 1183, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is hola-hermano:
[ R_1229 ;
    if (((((((Global_Vars-->17) == I168_hola_hermano)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1229, 1229);
    ! [2: enable the ternero-hermano quip]
    (PHR_953_r6 (I167_ternero_hermano));
    } else if (debug_rules > 1) DB_Rule(R_1229, 1229, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is ternero-hermano:
[ R_1230 ;
    if (((((((Global_Vars-->17) == I167_ternero_hermano)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1230, 1230);
    ! [2: enable the mi-ofrenda quip]
    (PHR_953_r6 (I166_mi_ofrenda));
    } else if (debug_rules > 1) DB_Rule(R_1230, 1230, 'context');
    rfalse;
];
! No specific request
! After quipping when the current quip is mi-ofrenda:
[ R_1231 ;
    if (((((((Global_Vars-->17) == I166_mi_ofrenda)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1231, 1231);
    ! [2: enable the mi-ofrenda quip]
    (PHR_953_r6 (I166_mi_ofrenda));
    ! [3: terminate the conversation]
    (PHR_957_r4 ());
    } else if (debug_rules > 1) DB_Rule(R_1231, 1231, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Requesting a recap (B384_carry_out_requesting_a_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out requesting a recap ( this is the perform recap rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Carry out requesting a recap ( this is the perform recap rule ):
[ R_927 
    tmp_0 ! Let/loop value, e.g., 'rq_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_927, 927);
    ! [2: let rq_index be 0]

    		tmp_0 = 0;
    ! [3: repeat through table of quip followups]
    @push ct_0; @push ct_1;
    		for (tmp_1=T18_quip_followups, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the quip entry is the pertinent quip]
        if (((TableLookUpEntry(ct_0,130,ct_1) == (Global_Vars-->18))))
        {! [5: increase rq_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [6: if rq_index is 1]
            if (((tmp_0 == 1)))
            {! [7: say ~[RQ options prologue][paragraph break]~]
                say__p=1;! [8: rq options prologue]
                ParaContent(); print (TEXT_TY_Say) (Global_Vars-->21);! [9: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say421; .L_SayX413;}
            ! [10: say ~[bracket][rq_index][close bracket] [option entry][line break]~]
            say__p=1;! [11: bracket]
            ParaContent(); print "[";! [12: rq_index]
            ParaContent(); print (say__n=tmp_0);! [13: close bracket]
            ParaContent(); print "]";! [14: ~ ~]
            ParaContent(); print " ";! [15: option entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,132,ct_1);! [16: line break]
            ParaContent(); new_line; .L_Say422; .L_SayX414;}
            }
            @pull ct_1; @pull ct_0;! [17: if rq_index is 0]
    if (((tmp_0 == 0)))
    {! [18: say ~[RQ no options][paragraph break]~]
        say__p=1;! [19: rq no options]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->23);! [20: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say423; .L_SayX415;}
        } else if (debug_rules > 1) DB_Rule(R_927, 927, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Responding with (B387_carry_out_responding_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out responding with ( this is the perform responding rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! Carry out responding with ( this is the perform responding rule ):
[ R_928 
    tmp_0 ! Let/loop value, e.g., 'rq_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_928, 928);
    ! [2: let rq_index be 0]

    		tmp_0 = 0;
    ! [3: repeat through table of quip followups]
    @push ct_0; @push ct_1;
    		for (tmp_1=T18_quip_followups, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the quip entry is the pertinent quip]
        if (((TableLookUpEntry(ct_0,130,ct_1) == (Global_Vars-->18))))
        {! [5: increase rq_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [6: if rq_index is the number understood]
            if (((tmp_0 == parsed_number)))
            {! [7: deliver the result entry quip]
                (PHR_924_r16 (TableLookUpEntry(ct_0,133,ct_1)));
                ! [8: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [9: follow the rq out of range rules for rq_index]
    FollowRulebook(389, tmp_0, true);
    } else if (debug_rules > 1) DB_Rule(R_928, 928, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: RQ out of range (B389_rq_out_of_range)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! An RQ out of range rule for a number ( called max ) ( this is the spanish basic RQ out of range rule ):
! ----------------------------------------------------------------------------------------------------
! From "Reactable Quips SP" by Michael Martin
! No specific request
! An RQ out of range rule for a number ( called max ) ( this is the spanish basic RQ out of range rule ):
[ R_936 
    tmp_0 ! Let/loop value, e.g., 'max': number
    ;
    if ((((tmp_0 = parameter_value, (((true) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_936, 936);
    ! [2: say ~[bracket]Las opciones válidas van del 1 al [max]. Escribe MOSTRAR para volver a ver tus opciones.[close bracket][paragraph break]~]
    say__p=1;! [3: bracket]
    ParaContent(); print "[";! [4: ~Las opciones válidas van del 1 al ~]
    ParaContent(); print "Las opciones válidas van del 1 al ";! [5: max]
    ParaContent(); print (say__n=tmp_0);! [6: ~. Escribe MOSTRAR para volver a ver tus opciones.~]
    ParaContent(); print ". Escribe MOSTRAR para volver a ver tus opciones.";! [7: close bracket]
    ParaContent(); print "]";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say424; .L_SayX416;} else if (debug_rules > 1) DB_Rule(R_936, 936, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Talking to (B390_check_talking_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check talking to ( this is the can only talk to people with things to say rule ):
!   === equally specific with ===
! Rule 2/2 ! Check talking to ( this is the spanish can only talk to talkables rule ):
! ----------------------------------------------------------------------------------------------------
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Check talking to ( this is the can only talk to people with things to say rule ):
[ R_944 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_944, 944);
    ! [2: if the greeting of the noun is quip_null and the number of filled rows in the litany of the noun is zero]
    if ((((GProperty(OBJECT_TY, noun,p17_greeting) == I152_quip_null))) && (((TableFilledRows(GProperty(OBJECT_TY, noun,p18_litany)) == 0))))
    {! [3: say ~[generic ask quip][paragraph break]~]
        say__p=1;! [4: generic ask quip]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->19);! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say425; .L_SayX417;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_944, 944, 'actor');
        rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Check talking to ( this is the spanish can only talk to talkables rule ):
[ R_959 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_959, 959);
    ! [2: if the noun provides the property litany and the noun provides the property greeting]
    if ((((WhetherProvides(noun, false, p18_litany)))) && (((WhetherProvides(noun, false, p17_greeting)))))
    {! [3: do nothing]
        ;
        } else {
        ! [4: say ~Por lo general, es mejor hablar con cosas vivas.~]
        say__p=1;! [5: ~Por lo general, es mejor hablar con cosas vivas.~]
        ParaContent(); print "Por lo general, es mejor hablar con cosas vivas."; new_line; .L_Say426; .L_SayX418;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_959, 959, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Talking to (B391_carry_out_talking_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out talking to ( this is the basic talking to rule ):
! ----------------------------------------------------------------------------------------------------
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Carry out talking to ( this is the basic talking to rule ):
[ R_945 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_945, 945);
    ! [2: if the greeting of the noun is not quip_null]
    if (((~~((GProperty(OBJECT_TY, noun,p17_greeting) == I152_quip_null)))))
    {! [3: deliver the greeting of the noun quip]
        (PHR_924_r16 (GProperty(OBJECT_TY, noun,p17_greeting)));
        }
    ! [4: if the number of filled rows in the litany of the noun is not zero]
    if (((~~((TableFilledRows(GProperty(OBJECT_TY, noun,p18_litany)) == 0)))))
    {! [5: now the qbc_litany is the litany of the noun]
        (Global_Vars-->25) = GProperty(OBJECT_TY, noun,p18_litany);
        ! [6: display the qbc options]
        (PHR_947_r7 ());
        }
        } else if (debug_rules > 1) DB_Rule(R_945, 945, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out QBC responding with (B394_carry_out_qbc_respondin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out QBC responding with ( this is the perform talking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Carry out QBC responding with ( this is the perform talking rule ):
[ R_949 
    tmp_0 ! Let/loop value, e.g., 'qbc_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_949, 949);
    ! [2: let qbc_index be 0]

    		tmp_0 = 0;
    ! [3: repeat through the qbc_litany]
    @push ct_0; @push ct_1;
    		for (tmp_1=(Global_Vars-->25), tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the enabled entry is 1]
        if (((TableLookUpEntry(ct_0,137,ct_1) == 1)))
        {! [5: increase qbc_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [6: if qbc_index is the number understood]
            if (((tmp_0 == parsed_number)))
            {! [7: now the enabled entry is 0]
                TableLookUpEntry(ct_0,137,ct_1,1,0);
                ! [8: deliver the response entry quip]
                (PHR_924_r16 (TableLookUpEntry(ct_0,136,ct_1)));
                ! [9: display the qbc options]
                (PHR_947_r7 ());
                ! [10: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [11: follow the rq out of range rules for qbc_index]
    FollowRulebook(389, tmp_0, true);
    } else if (debug_rules > 1) DB_Rule(R_949, 949, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out QBC recap (B397_carry_out_qbc_recap)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out QBC recap ( this is the perform QBC recap rule ):
! ----------------------------------------------------------------------------------------------------
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Carry out QBC recap ( this is the perform QBC recap rule ):
[ R_950 
    tmp_0 ! Let/loop value, e.g., 'qbc_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_950, 950);
    ! [2: let qbc_index be 0]

    		tmp_0 = 0;
    ! [3: repeat through qbc_litany]
    @push ct_0; @push ct_1;
    		for (tmp_1=(Global_Vars-->25), tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the enabled entry is 1]
        if (((TableLookUpEntry(ct_0,137,ct_1) == 1)))
        {! [5: increase qbc_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [6: if qbc_index is 1]
            if (((tmp_0 == 1)))
            {! [7: say ~[RQ options prologue][paragraph break]~]
                say__p=1;! [8: rq options prologue]
                ParaContent(); print (TEXT_TY_Say) (Global_Vars-->21);! [9: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say427; .L_SayX419;}
            ! [10: say ~[bracket][qbc_index][close bracket] [prompt entry][line break]~]
            say__p=1;! [11: bracket]
            ParaContent(); print "[";! [12: qbc_index]
            ParaContent(); print (say__n=tmp_0);! [13: close bracket]
            ParaContent(); print "]";! [14: ~ ~]
            ParaContent(); print " ";! [15: prompt entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,135,ct_1);! [16: line break]
            ParaContent(); new_line; .L_Say428; .L_SayX420;}
            }
            @pull ct_1; @pull ct_0;! [17: if qbc_index is 0]
    if (((tmp_0 == 0)))
    {! [18: say ~[QBC no conversation error][paragraph break]~]
        say__p=1;! [19: qbc no conversation error]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->26);! [20: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say429; .L_SayX421;}
        } else if (debug_rules > 1) DB_Rule(R_950, 950, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx zeroing-reference (B399_glulx_zeroing_reference)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4: GOR_zeroing
! --- now the mid-placed rules ---
! Rule 2/4 ! A glulx zeroing-reference rule ( this is the set g-window rocks rule ):
!   === equally specific with ===
! Rule 3/4 ! A glulx zeroing-reference rule ( this is the reset window properties rule ):
!   === equally specific with ===
! Rule 4/4 ! A glulx zeroing-reference rule ( this is the set generic text styles rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx zeroing-reference rule ( this is the set g-window rocks rule ):
[ R_1063 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1063, 1063);
    ! [2: if the rock number of the main window is 0]
    if (((GProperty(10, I200_main_window,p24_rock_number) == 0)))
    {! [3: now the rock number of the main window is gg_mainwin_rock]
        WriteGProperty(10, I200_main_window,p24_rock_number,GG_MAINWIN_ROCK);
        ! [4: now the rock number of the status window is gg_statuswin_rock]
        WriteGProperty(10, I201_status_window,p24_rock_number,GG_STATUSWIN_ROCK);
        ! [5: now the rock number of the quote window is gg_quotewin_rock]
        WriteGProperty(10, I202_quote_window,p24_rock_number,GG_QUOTEWIN_ROCK);
        ! [6: let i be 1000]

        		tmp_0 = 1000;
        ! [7: repeat with win running through g-windows]
        for (tmp_1=Prop_34(0), tmp_2=Prop_34(tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_34(tmp_2))
        {! [8: if the rock number of win is 0]
            if (((GProperty(10, tmp_1,p24_rock_number) == 0)))
            {! [9: now the rock number of win is i]
                WriteGProperty(10, tmp_1,p24_rock_number,tmp_0);
                ! [10: increase i by 10]
                tmp_0 = tmp_0 + 10;;
                }
                }
                }
                rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx zeroing-reference rule ( this is the reset window properties rule ):
[ R_1064 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1064, 1064);
    ! [2: repeat with win running through g-windows]
    for (tmp_0=Prop_35(0), tmp_1=Prop_35(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_35(tmp_1))
    {! [3: now the ref number of win is 0]
        WriteGProperty(10, tmp_0,p25_ref_number,0);
        ! [4: now win is g-unpresent]
        (Adj_103_t2_v10(tmp_0));
        ! [5: now win is not currently being processed]
        (Adj_104_t3_v10(tmp_0));
        }
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx zeroing-reference rule ( this is the set generic text styles rule ):
[ R_1097 
    tmp_0 ! Let/loop value, e.g., 'W': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_1097, 1097);
    ! [2: let w be a number]

    		tmp_0 = 0; 
    ! [3: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_1=T3_user_styles, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the window entry is]
        switch (TableLookUpEntry(ct_0,107,ct_1)) 
        {I197_all_windows:
            ! [5: now w is 0]
            tmp_0 = 0;
            ;
            I198_all_buffer_windows:
            ! [6: now w is 3]
            tmp_0 = 3;
            ;
            I199_all_grid_windows:
            ! [7: now w is 4]
            tmp_0 = 4;
            ;
            default:! [8: break]
            jump loop_break_0;
            }
        ! [9: if there is a background color entry]
        if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
        {! [10: set the background color of wintype w for the style name entry to the background color entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_BackColor, GTE_ConvertColour( TableLookUpEntry(ct_0,109,ct_1) ) );
            }
        ! [11: if there is a color entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
        {! [12: set the color of wintype w for the style name entry to the color entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_TextColor, GTE_ConvertColour( TableLookUpEntry(ct_0,110,ct_1) ) );
            }
        ! [13: if there is a first line indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
        {! [14: set the first line indentation of wintype w for the style name entry to the first line indentation entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_ParaIndentation, TableLookUpEntry(ct_0,111,ct_1) );
            }
        ! [15: if there is a fixed width entry]
        if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
        {! [16: set fixed width of wintype w for the style name entry to the fixed width entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Proportional, ( TableLookUpEntry(ct_0,112,ct_1) + 1 ) % 2 );
            }
        ! [17: if there is a font weight entry]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
        {! [18: set the font weight of wintype w for the style name entry to the font weight entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Weight, TableLookUpEntry(ct_0,113,ct_1) - 2 );
            }
        ! [19: if there is a indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
        {! [20: set the indentation of wintype w for the style name entry to the indentation entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Indentation, TableLookUpEntry(ct_0,114,ct_1) );
            }
        ! [21: if there is a italic entry]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
        {! [22: set italic of wintype w for the style name entry to the italic entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Oblique, TableLookUpEntry(ct_0,115,ct_1) );
            }
        ! [23: if there is a justification entry]
        if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
        {! [24: set the justification of wintype w for the style name entry to the justification entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Justification, TableLookUpEntry(ct_0,116,ct_1) - 1 );
            }
        ! [25: if there is a relative size entry]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
        {! [26: set the relative size of wintype w for the style name entry to the relative size entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_Size, TableLookUpEntry(ct_0,117,ct_1) );
            }
        ! [27: if there is a reversed entry]
        if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
        {! [28: set reversed of wintype w for the style name entry to the reversed entry]
            GTE_SetStylehint( tmp_0, TableLookUpEntry(ct_0,108,ct_1), stylehint_ReverseColor, TableLookUpEntry(ct_0,118,ct_1) );
            }
            }
            .loop_break_0;@pull ct_1; @pull ct_0;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx resetting-windows (B400_glulx_resetting_windows)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A glulx resetting-windows rule ( this is the find existing windows rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx resetting-windows rule ( this is the find existing windows rule ):
[ R_1065 
    tmp_0 ! Let/loop value, e.g., 'win': thing
    ;
    if (debug_rules) DB_Rule(R_1065, 1065);
    ! [2: let win be the window with rock current glulx rock]

    		tmp_0 = (PHR_1039_r18 ((Global_Vars-->27)));
    ! [3: if win is not the invalid window]
    if (((~~((tmp_0 == ( nothing ))))))
    {! [4: now the ref number of win is the current glulx rock-ref]
        WriteGProperty(10, tmp_0,p25_ref_number,(Global_Vars-->28));
        ! [5: now win is g-present]
        (Adj_102_t2_v10(tmp_0));
        ! [6: if win is the acting main window]
        if (((tmp_0 == (Global_Vars-->32))))
        {! [7: now gg_mainwin is the current glulx rock-ref]
            gg_mainwin = (Global_Vars-->28);
            }
        ! [8: if win is the status window]
        if (((tmp_0 == I201_status_window)))
        {! [9: now gg_statuswin is the current glulx rock-ref]
            gg_statuswin = (Global_Vars-->28);
            }
        ! [10: if win is the quote window]
        if (((tmp_0 == I202_quote_window)))
        {! [11: now gg_quotewin is the current glulx rock-ref]
            gg_quotewin = (Global_Vars-->28);
            }
            }
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx object-updating (B404_glulx_object_updating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! A first glulx object-updating rule ( this is the recalibrate windows rule ):
! --- now the mid-placed rules ---
! Rule 2/2 ! A glulx object-updating rule ( this is the refresh windows after restoring rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! A first glulx object-updating rule ( this is the recalibrate windows rule ):
[ R_1066 ;
    if (debug_rules) DB_Rule(R_1066, 1066);
    ! [2: if the starting the virtual machine activity is going on]
    if ((((Adj_24_t1_v33(V26_starting_the_virtual_mac)))))
    {! [3: if the main window is g-present]
        if ((((Adj_102_t1_v10(I200_main_window)))))
        {! [4: now the main window is g-required]
            (Adj_100_t2_v10(I200_main_window));
            ! [5: now the current focus window is the main window]
            (Global_Vars-->31) = I200_main_window;
            }
        ! [6: if the status window is g-present and the no status line option is not active]
        if (((((Adj_102_t1_v10(I201_status_window))))) && (((~~(((Adj_25_t1_v16(32))))))))
        {! [7: now the status window is g-required]
            (Adj_100_t2_v10(I201_status_window));
            }
            }
    ! [8: calibrate windows]
    (PHR_1044_r19 ());
    ! [9: focus the current focus window]
    (PHR_1058_r20 ((Global_Vars-->31)));
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx object-updating rule ( this is the refresh windows after restoring rule ):
[ R_1057 ;
    if (debug_rules) DB_Rule(R_1057, 1057);
    ! [2: refresh all windows]
    (PHR_1050_r21 ());
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx input handling (B405_glulx_input_handling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/10 ! A glulx input handling rule for an arrange-event ( this is the refresh windows after arranging rule ):
!   === equally specific with ===
! Rule 2/10 ! A glulx input handling rule for a redraw-event ( this is the refresh graphical windows rule ):
! --- now the last-placed rules ---
! Rule 3/10 ! Last glulx input handling rule for a timer-event when the direct event handling option is not active ( this is the redirect to GEP timed activity rule ):
!   === equally specific with ===
! Rule 4/10 ! Last glulx input handling rule for a char-event when the direct event handling option is not active ( this is the redirect to GEP character input rule ):
!   === equally specific with ===
! Rule 5/10 ! Last glulx input handling rule for a line-event when the direct event handling option is not active ( this is the redirect to GEP line input rule ):
!   === equally specific with ===
! Rule 6/10 ! Last glulx input handling rule for a mouse-event when the direct event handling option is not active ( this is the redirect to GEP mouse input rule ):
!   === equally specific with ===
! Rule 7/10 ! Last glulx input handling rule for an arrange-event when the direct event handling option is not active ( this is the redirect to GEP arranging rule ):
!   === equally specific with ===
! Rule 8/10 ! Last glulx input handling rule for a redraw-event when the direct event handling option is not active ( this is the redirect to GEP redrawing rule ):
!   === equally specific with ===
! Rule 9/10 ! Last glulx input handling rule for a sound-notify-event when the direct event handling option is not active ( this is the redirect to GEP sound notification rule ):
!   === equally specific with ===
! Rule 10/10 ! Last glulx input handling rule for a hyperlink-event when the direct event handling option is not active ( this is the redirect to GEP hyperlink rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx input handling rule for an arrange-event ( this is the refresh windows after arranging rule ):
[ R_1055 ;
    if (((((parameter_value == I174_arrange_event) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1055, 1055);
    ! [2: refresh all windows]
    (PHR_1050_r21 ());
    } else if (debug_rules > 1) DB_Rule(R_1055, 1055, 'action');
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! A glulx input handling rule for a redraw-event ( this is the refresh graphical windows rule ):
[ R_1056 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (((((parameter_value == I175_redraw_event) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1056, 1056);
    ! [2: repeat with win running through g-present graphical g-windows]
    for (tmp_0=Prop_36(0), tmp_1=Prop_36(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_36(tmp_1))
    {! [3: refresh win]
        (PHR_1049_r22 (tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_1056, 1056, 'action');
        rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a timer-event when the direct event handling option is not active ( this is the redirect to GEP timed activity rule ):
[ R_1012 ;
    if (((((parameter_value == I170_timer_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1012, 1012);
    ! [2: abide by the glulx timed activity rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(406))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1012, 1012, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1012, 1012, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a char-event when the direct event handling option is not active ( this is the redirect to GEP character input rule ):
[ R_1013 ;
    if (((((parameter_value == I171_char_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1013, 1013);
    ! [2: abide by the glulx character input rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(411))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1013, 1013, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1013, 1013, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a line-event when the direct event handling option is not active ( this is the redirect to GEP line input rule ):
[ R_1014 ;
    if (((((parameter_value == I172_line_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1014, 1014);
    ! [2: follow the glulx line input rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(412));
    ! [3: if the rule succeeded]
    if (((RulebookSucceeded())))
    {! [4: replace player input]
        RulebookSucceeds(22, RBNO_13); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1014, 1014, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1014, 1014, 'action');
        rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a mouse-event when the direct event handling option is not active ( this is the redirect to GEP mouse input rule ):
[ R_1015 ;
    if (((((parameter_value == I173_mouse_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1015, 1015);
    ! [2: abide by the glulx mouse input rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(410))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1015, 1015, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1015, 1015, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for an arrange-event when the direct event handling option is not active ( this is the redirect to GEP arranging rule ):
[ R_1016 ;
    if (((((parameter_value == I174_arrange_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1016, 1016);
    ! [2: abide by the glulx arranging rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(408))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1016, 1016, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1016, 1016, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a redraw-event when the direct event handling option is not active ( this is the redirect to GEP redrawing rule ):
[ R_1017 ;
    if (((((parameter_value == I175_redraw_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1017, 1017);
    ! [2: abide by the glulx redrawing rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(407))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1017, 1017, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1017, 1017, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a sound-notify-event when the direct event handling option is not active ( this is the redirect to GEP sound notification rule ):
[ R_1018 ;
    if (((((parameter_value == I176_sound_notify_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1018, 1018);
    ! [2: abide by the glulx sound notification rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(409))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1018, 1018, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1018, 1018, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a hyperlink-event when the direct event handling option is not active ( this is the redirect to GEP hyperlink rule ):
[ R_1019 ;
    if (((((parameter_value == I177_hyperlink_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(31)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1019, 1019);
    ! [2: abide by the glulx hyperlink rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(413))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1019, 1019, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1019, 1019, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-counting (B414_command_counting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-counting rule ( this is the ordinary checking for content rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-counting rule ( this is the ordinary checking for content rule ):
[ R_1020 ;
    if (debug_rules) DB_Rule(R_1020, 1020);
    ! [2: if the number of characters in the glulx replacement command is 0]
    if (((TEXT_TY_BlobAccess((Global_Vars-->29), CHR_BLOB) == 0)))
    {! [3: rule fails]
        RulebookFails(); rtrue;
        }
    ! [4: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: input-cancelling (B415_input_cancelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! An input-cancelling rule ( this is the cancelling input in the main window rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! An input-cancelling rule ( this is the cancelling input in the main window rule ):
[ R_1021 ;
    if (debug_rules) DB_Rule(R_1021, 1021);
    ! [2: cancel line input in the main window]
    glk_cancel_line_event(gg_mainwin, GLK_NULL);
    ! [3: cancel character input in the main window]
    glk_cancel_char_event(gg_mainwin);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-showing (B416_command_showing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-showing rule ( this is the print text to the input prompt rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-showing rule ( this is the print text to the input prompt rule ):
[ R_1024 ;
    if (debug_rules) DB_Rule(R_1024, 1024);
    ! [2: say input-style-for-glulx]
    say__p=1;! [3: input-style-for-glulx]
    ParaContent(); glk_set_style(style_Input); .L_Say430; .L_SayX422;! [4: say glulx replacement command]
    say__p=1;! [5: glulx replacement command]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->29); .L_Say431; .L_SayX423;! [6: say roman type]
    say__p=1;! [7: roman type]
    ParaContent(); style roman; .L_Say432; .L_SayX424;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-pasting (B417_command_pasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
[ R_1026 ;
    if (debug_rules) DB_Rule(R_1026, 1026);
    ! [2: change the text of the player's command to the glulx replacement command]
    SetPlayersCommand((Global_Vars-->29));
    ! [3: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Constructing (B418_before_constructing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! First before constructing a textual g-window ( called win ) ( this is the set the background color of textual windows rule ):
! --- now the mid-placed rules ---
! Rule 2/3 ! Before constructing a textual g-window ( called win ) ( this is the set the window specific styles rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/3 ! Before constructing a g-window ( called win ) ( this is the fix method and measurement rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! First before constructing a textual g-window ( called win ) ( this is the set the background color of textual windows rule ):
[ R_1101 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1101, 1101);
    ! [2: if the background color of win is not empty]
    if (((~~(((Adj_17_t1_v14(GProperty(10, tmp_0,p27_background_color))))))))
    {! [3: set the background color of wintype 0 for all-styles to the background color of win]
        GTE_SetStylehint( 0, I126_all_styles, stylehint_BackColor, GTE_ConvertColour( GProperty(10, tmp_0,p27_background_color) ) );
        }
        } else if (debug_rules > 1) DB_Rule(R_1101, 1101, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Before constructing a textual g-window ( called win ) ( this is the set the window specific styles rule ):
[ R_1099 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    tmp_1 ! Let/loop value, e.g., 'W': number
    tmp_2 ! Let/loop value, e.g., 'found the window': truth state
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1099, 1099);
    ! [2: let w be a number]

    		tmp_1 = 0; 
    ! [3: let found the window be a truth state]

    		tmp_2 = false; 
    ! [4: if the type of win is]
    switch (GProperty(10, tmp_0,p19_type)) 
    {I181_g_text_buffer:
        ! [5: now w is 3]
        tmp_1 = 3;
        ;
        I182_g_text_grid:
        ! [6: now w is 4]
        tmp_1 = 4;
        ;
        I183_g_graphics:
        ! [7: continue the activity]
        rfalse;
        }
    ! [8: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_3=T3_user_styles, tmp_4=1, ct_0=tmp_3, ct_1=tmp_4:
    			tmp_4<=TableRows(tmp_3):
    			tmp_4++, ct_0=tmp_3, ct_1=tmp_4)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [9: unless the window entry is win]
        if (~~(((TableLookUpEntry(ct_0,107,ct_1) == tmp_0))))
        {! [10: if found the window is true]
            if ((((tmp_2 && true) == (1 && true))))
            {! [11: continue the activity]
                rfalse;
                }
            ! [12: next]
            continue;
            }
        ! [13: now found the window is true]
        tmp_2 = 1;
        ! [14: if there is a background color entry]
        if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
        {! [15: set the background color of wintype w for the style name entry to the background color entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_BackColor, GTE_ConvertColour( TableLookUpEntry(ct_0,109,ct_1) ) );
            }
        ! [16: if there is a color entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
        {! [17: set the color of wintype w for the style name entry to the color entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_TextColor, GTE_ConvertColour( TableLookUpEntry(ct_0,110,ct_1) ) );
            }
        ! [18: if there is a first line indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
        {! [19: set the first line indentation of wintype w for the style name entry to the first line indentation entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_ParaIndentation, TableLookUpEntry(ct_0,111,ct_1) );
            }
        ! [20: if there is a fixed width entry]
        if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
        {! [21: set fixed width of wintype w for the style name entry to the fixed width entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Proportional, ( TableLookUpEntry(ct_0,112,ct_1) + 1 ) % 2 );
            }
        ! [22: if there is a font weight entry]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
        {! [23: set the font weight of wintype w for the style name entry to the font weight entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Weight, TableLookUpEntry(ct_0,113,ct_1) - 2 );
            }
        ! [24: if there is a indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
        {! [25: set the indentation of wintype w for the style name entry to the indentation entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Indentation, TableLookUpEntry(ct_0,114,ct_1) );
            }
        ! [26: if there is a italic entry]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
        {! [27: set italic of wintype w for the style name entry to the italic entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Oblique, TableLookUpEntry(ct_0,115,ct_1) );
            }
        ! [28: if there is a justification entry]
        if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
        {! [29: set the justification of wintype w for the style name entry to the justification entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Justification, TableLookUpEntry(ct_0,116,ct_1) - 1 );
            }
        ! [30: if there is a relative size entry]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
        {! [31: set the relative size of wintype w for the style name entry to the relative size entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Size, TableLookUpEntry(ct_0,117,ct_1) );
            }
        ! [32: if there is a reversed entry]
        if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
        {! [33: set reversed of wintype w for the style name entry to the reversed entry]
            GTE_SetStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_ReverseColor, TableLookUpEntry(ct_0,118,ct_1) );
            }
            }
            @pull ct_1; @pull ct_0;} else if (debug_rules > 1) DB_Rule(R_1099, 1099, 'action');
            rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Before constructing a g-window ( called win ) ( this is the fix method and measurement rule ):
[ R_1045 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_7();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_7 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    tmp_1 ! Let/loop value, e.g., 'parent': thing
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1045, 1045);
    ! [2: let the parent be the parent of win]

    		tmp_1 = (PHR_1037_r23 (tmp_0));
    ! [3: if parent is the invalid window]
    if (((tmp_1 == ( nothing ))))
    {! [4: continue the activity]
        rfalse;
        }
    ! [5: if the scale method of win is g-proportional]
    if (((GProperty(10, tmp_0,p21_scale_method) == I194_g_proportional)))
    {! [6: if the measurement of win > 100 or the measurement of win < 0]
        if ((((GProperty(10, tmp_0,p22_measurement) > 100))) || (((GProperty(10, tmp_0,p22_measurement) < 0))))
        {! [7: now the scale method of win is g-fixed-size]
            WriteGProperty(10, tmp_0,p21_scale_method,I195_g_fixed_size);
            }
            }
    ! [8: if the position of win is g-placenull]
    if (((GProperty(10, tmp_0,p20_position) == I188_g_placenull)))
    {! [9: if the parent is vertically positioned]
        if ((((Adj_48_t1_v10(tmp_1)))))
        {! [10: now the position of win is g-placeright]
            WriteGProperty(10, tmp_0,p20_position,I190_g_placeright);
            } else {
            ! [11: now the position of win is g-placeabove]
            WriteGProperty(10, tmp_0,p20_position,I191_g_placeabove);
            }
            }
    ! [12: if the scale method of win is g-using-minimum]
    if (((GProperty(10, tmp_0,p21_scale_method) == I196_g_using_minimum)))
    {! [13: now the scale method of win is g-proportional]
        WriteGProperty(10, tmp_0,p21_scale_method,I194_g_proportional);
        }
    ! [14: if the scale method of win is g-proportional]
    if (((GProperty(10, tmp_0,p21_scale_method) == I194_g_proportional)))
    {! [15: let the minimum size be 100 multiplied by the minimum size of win]

        		tmp_2 = (100 * GProperty(10, tmp_0,p23_minimum_size));
        ! [16: let the calculated size be the measurement of win multiplied by the width of the parent]

        		tmp_3 = (GProperty(10, tmp_0,p22_measurement) * 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window))))) && ((
                        formal_rv = FW_WindowSize( formal_par0, 0 )) | 1)
                        )|| (ArgumentTypeFailed(288, 8))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        );
        ! [17: if win is vertically positioned]
        if ((((Adj_48_t1_v10(tmp_0)))))
        {! [18: now the calculated size is the measurement of win multiplied by the height of the parent]
            tmp_3 = (GProperty(10, tmp_0,p22_measurement) * 
            ! Resolution of run-time phrase ambiguity (deciding a value):
                (
                    ! This value evaluates third (i.e., last)
                    formal_rv
                +
                    0*(
                        ! The following condition evaluates second
                        ((
                            ((((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window))))) && ((
                            formal_rv = FW_WindowSize( formal_par0, 1 )) | 1)
                            )|| (ArgumentTypeFailed(290, 8))

                        ))
                    +
                        ! The following assignments evaluate first
                        ((formal_par0 = tmp_1)
                        ))
                )

            ! Resolution complete
            );
            }
        ! [19: if the minimum size > the calculated size]
        if (((tmp_2 > tmp_3)))
        {! [20: now the scale method of win is g-using-minimum]
            WriteGProperty(10, tmp_0,p21_scale_method,I196_g_using_minimum);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1045, 1045, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Constructing (B420_after_constructing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! First after constructing a textual g-window ( called win ) ( this is the reset the background color of textual windows rule ):
!   === equally specific with ===
! Rule 2/8 ! A first after constructing a textual g-window ( called win ) ( this is the clear the window specific styles rule ):
!   === equally specific with ===
! Rule 3/8 ! First after constructing a g-window ( called win ) ( this is the check if the window was created rule ):
! --- now the mid-placed rules ---
! Rule 4/8 ! After constructing a textual g-window ( called win ) ( this is the focus the acting main window rule ):
!   === equally specific with ===
! Rule 5/8 ! After constructing a textual g-window ( called win ) ( this is the update the I6 window variables rule ):
!   === equally specific with ===
! Rule 6/8 ! After constructing a textual g-window ( this is the Gargoyle cursor color rule ):
!   === equally specific with ===
! Rule 7/8 ! After constructing a textual g-window ( this is the Gargoyle window padding rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 8/8 ! After constructing a g-window ( called win ) ( this is the refresh the window rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! First after constructing a textual g-window ( called win ) ( this is the reset the background color of textual windows rule ):
[ R_1102 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1102, 1102);
    ! [2: if the background color of win is not empty]
    if (((~~(((Adj_17_t1_v14(GProperty(10, tmp_0,p27_background_color))))))))
    {! [3: clear the background color of wintype 0 for all-styles]
        FW_ClearStylehint( 0, I126_all_styles, stylehint_BackColor, );
        }
        } else if (debug_rules > 1) DB_Rule(R_1102, 1102, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! A first after constructing a textual g-window ( called win ) ( this is the clear the window specific styles rule ):
[ R_1100 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    tmp_1 ! Let/loop value, e.g., 'W': number
    tmp_2 ! Let/loop value, e.g., 'resetting required': truth state
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1100, 1100);
    ! [2: let w be a number]

    		tmp_1 = 0; 
    ! [3: let resetting required be a truth state]

    		tmp_2 = false; 
    ! [4: if the type of win is]
    switch (GProperty(10, tmp_0,p19_type)) 
    {I181_g_text_buffer:
        ! [5: now w is 3]
        tmp_1 = 3;
        ;
        I182_g_text_grid:
        ! [6: now w is 4]
        tmp_1 = 4;
        ;
        I183_g_graphics:
        ! [7: continue the activity]
        rfalse;
        }
    ! [8: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_3=T3_user_styles, tmp_4=1, ct_0=tmp_3, ct_1=tmp_4:
    			tmp_4<=TableRows(tmp_3):
    			tmp_4++, ct_0=tmp_3, ct_1=tmp_4)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [9: unless the window entry is win]
        if (~~(((TableLookUpEntry(ct_0,107,ct_1) == tmp_0))))
        {! [10: if resetting required is true]
            if ((((tmp_2 && true) == (1 && true))))
            {! [11: break]
                jump loop_break_1;
                }
            ! [12: next]
            continue;
            }
        ! [13: now resetting required is true]
        tmp_2 = 1;
        ! [14: if there is a background color entry]
        if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
        {! [15: clear the background color of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_BackColor, );
            }
        ! [16: if there is a color entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
        {! [17: clear the color of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_TextColor );
            }
        ! [18: if there is a first line indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
        {! [19: clear the first line indentation of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_ParaIndentation );
            }
        ! [20: if there is a fixed width entry]
        if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
        {! [21: clear fixed width of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Proportional );
            }
        ! [22: if there is a font weight entry]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
        {! [23: clear the font weight of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Weight );
            }
        ! [24: if there is a indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
        {! [25: clear the indentation of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Indentation );
            }
        ! [26: if there is a italic entry]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
        {! [27: clear italic of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Oblique );
            }
        ! [28: if there is a justification entry]
        if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
        {! [29: clear the justification of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Justification );
            }
        ! [30: if there is a relative size entry]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
        {! [31: clear the relative size of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_Size );
            }
        ! [32: if there is a reversed entry]
        if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
        {! [33: clear reversed of wintype w for the style name entry]
            FW_ClearStylehint( tmp_1, TableLookUpEntry(ct_0,108,ct_1), stylehint_ReverseColor );
            }
            }
            .loop_break_1;@pull ct_1; @pull ct_0;! [34: if resetting required is true]
    if ((((tmp_2 && true) == (1 && true))))
    {! [35: follow the set generic text styles rule]
        FollowRulebook(R_1097);
        }
        } else if (debug_rules > 1) DB_Rule(R_1100, 1100, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! First after constructing a g-window ( called win ) ( this is the check if the window was created rule ):
[ R_1046 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1046, 1046);
    ! [2: if the ref number of win is zero]
    if (((GProperty(10, tmp_0,p25_ref_number) == 0)))
    {! [3: now win is g-unrequired]
        (Adj_101_t2_v10(tmp_0));
        ! [4: rule fails]
        RulebookFails(); rtrue;
        } else {
        ! [5: now win is g-present]
        (Adj_102_t2_v10(tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_1046, 1046, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! After constructing a textual g-window ( called win ) ( this is the focus the acting main window rule ):
[ R_1067 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1067, 1067);
    ! [2: if win is the acting main window]
    if (((tmp_0 == (Global_Vars-->32))))
    {! [3: focus the acting main window]
        (PHR_1058_r20 ((Global_Vars-->32)));
        }
        } else if (debug_rules > 1) DB_Rule(R_1067, 1067, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! After constructing a textual g-window ( called win ) ( this is the update the I6 window variables rule ):
[ R_1068 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1068, 1068);
    ! [2: if win is the acting main window]
    if (((tmp_0 == (Global_Vars-->32))))
    {! [3: now gg_mainwin is the ref number of win]
        gg_mainwin = GProperty(10, tmp_0,p25_ref_number);
        }
    ! [4: if win is the status window]
    if (((tmp_0 == I201_status_window)))
    {! [5: now gg_statuswin is the ref number of win]
        gg_statuswin = GProperty(10, tmp_0,p25_ref_number);
        }
    ! [6: if win is the quote window]
    if (((tmp_0 == I202_quote_window)))
    {! [7: now gg_quotewin is the ref number of win]
        gg_quotewin = GProperty(10, tmp_0,p25_ref_number);
        }
        } else if (debug_rules > 1) DB_Rule(R_1068, 1068, 'action');
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! After constructing a textual g-window ( this is the Gargoyle cursor color rule ):
[ R_1098 ;
    if (((((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1098, 1098);
    ! [2: set the color of wintype 3 for normal-style to the gargoyle cursor color]
    GTE_SetStylehint( 3, I127_normal_style, stylehint_TextColor, GTE_ConvertColour( (Global_Vars-->33) ) );
    } else if (debug_rules > 1) DB_Rule(R_1098, 1098, 'action');
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! After constructing a textual g-window ( this is the Gargoyle window padding rule ):
[ R_1105 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_8();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_8 
    tmp_0 ! Let/loop value, e.g., 'T': text
    ;
    if (((((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1105, 1105);
    ! [2: let t be the background color of the acting main window]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, GProperty(10, (Global_Vars-->32),p27_background_color));
    ! [3: if t is empty]
    if ((((Adj_17_t1_v14(tmp_0)))))
    {! [4: let t be ~#FFFFFF~]
        BlkValueCopy(tmp_0, TX_L_246);
        }
    ! [5: set the gargoyle window padding to t]
    (PHR_1103_r24 (BlkValueCopy((I7SFRAME+WORDSIZE*2), tmp_0)));
    } else if (debug_rules > 1) DB_Rule(R_1105, 1105, 'action');
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! After constructing a g-window ( called win ) ( this is the refresh the window rule ):
[ R_1054 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1054, 1054);
    ! [2: refresh win]
    (PHR_1049_r22 (tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_1054, 1054, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Deconstructing (B421_before_deconstructing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before deconstructing a textual g-window ( called win ) ( this is the fix the current windows rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! Before deconstructing a textual g-window ( called win ) ( this is the fix the current windows rule ):
[ R_1069 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_9();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_9 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    tmp_1 ! Let/loop value, e.g., 'parent': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1069, 1069);
    ! [2: let parent be the parent of win]

    		tmp_1 = (PHR_1037_r23 (tmp_0));
    ! [3: if parent is the invalid window]
    if (((tmp_1 == ( nothing ))))
    {! [4: continue the activity]
        rfalse;
        }
    ! [5: if win is the acting main window]
    if (((tmp_0 == (Global_Vars-->32))))
    {! [6: set parent as the acting main window]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_1;
            if (((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window) && ((Adj_102_t1_v10(formal_par0))) && ((~~Adj_44_t1_v10(formal_par0))))))) { (PHR_1059_r25 (formal_par0)); }
            else ArgumentTypeFailed(522, 8);

        ! Resolution complete

        }
    ! [7: if win is the current focus window]
    if (((tmp_0 == (Global_Vars-->31))))
    {! [8: focus parent]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_1;
            if (((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window))))) { (PHR_1058_r20 (formal_par0)); }
            else ArgumentTypeFailed(524, 8);

        ! Resolution complete

        }
        } else if (debug_rules > 1) DB_Rule(R_1069, 1069, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deconstructing (B422_for_deconstructing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For deconstructing a g-window ( called win ) ( this is the basic deconstruction rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! For deconstructing a g-window ( called win ) ( this is the basic deconstruction rule ):
[ R_1047 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1047, 1047);
    ! [2: now win is g-unpresent]
    (Adj_103_t2_v10(tmp_0));
    ! [3: call fw_glk_window_close for the ref number of win]
    FW_glk_window_close( GProperty(10, tmp_0,p25_ref_number), 0 );
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1047, 1047, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Deconstructing (B423_after_deconstructing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After deconstructing a textual g-window ( called win ) ( this is the clear the I6 window variables rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! After deconstructing a textual g-window ( called win ) ( this is the clear the I6 window variables rule ):
[ R_1070 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && ((~~Adj_44_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1070, 1070);
    ! [2: if the acting main window is g-unpresent]
    if ((((Adj_103_t1_v10((Global_Vars-->32))))))
    {! [3: now gg_mainwin is 0]
        gg_mainwin = 0;
        }
    ! [4: if win is the status window]
    if (((tmp_0 == I201_status_window)))
    {! [5: now gg_statuswin is 0]
        gg_statuswin = 0;
        }
    ! [6: if win is the quote window]
    if (((tmp_0 == I202_quote_window)))
    {! [7: now gg_quotewin is 0]
        gg_quotewin = 0;
        }
        } else if (debug_rules > 1) DB_Rule(R_1070, 1070, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Refreshing (B424_before_refreshing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before refreshing a g-window ( called win ) ( this is the prepare for refreshing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! Before refreshing a g-window ( called win ) ( this is the prepare for refreshing rule ):
[ R_1051 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1051, 1051);
    ! [2: now the stored current window is the current focus window]
    (MStack-->MstVO(10039,0)) = (Global_Vars-->31);
    ! [3: if win is g-present]
    if ((((Adj_102_t1_v10(tmp_0)))))
    {! [4: clear win]
        (PHR_1048_r11 (tmp_0));
        ! [5: focus win]
        (PHR_1058_r20 (tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_1051, 1051, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Refreshing (B425_for_refreshing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A first for refreshing a g-window ( called win ) ( this is the check the window is present rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! A first for refreshing a g-window ( called win ) ( this is the check the window is present rule ):
[ R_1052 
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K16_g_window) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1052, 1052);
    ! [2: if win is g-present]
    if ((((Adj_102_t1_v10(tmp_0)))))
    {! [3: continue the activity]
        rfalse;
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1052, 1052, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Refreshing (B426_after_refreshing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After refreshing a g-window ( this is the refocus the current focus window rule ):
! ----------------------------------------------------------------------------------------------------
! From "Flexible Windows" by Jon Ingold
! No specific request
! After refreshing a g-window ( this is the refocus the current focus window rule ):
[ R_1053 ;
    if (((((parameter_value ofclass K16_g_window))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1053, 1053);
    ! [2: focus the stored current window]
    (PHR_1058_r20 ((MStack-->MstVO(10039,0))));
    } else if (debug_rules > 1) DB_Rule(R_1053, 1053, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Writing it in (B427_check_writing_it_in)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check writing it in:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check writing it in:
[ R_1110 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1110, 1110);
    ! [2: if the player carries the pluma and the location is en la oscuridad and the musa is espectante]
    if ((((player == CarrierOf(I219_pluma)))) && ((((real_location == I218_en_la_oscuridad))) && ((((Adj_106_t1_v10(I220_musa)))))))
    {! [3: say ~Escribes un verso sobre [italic type]'[the topic understood]'...[roman type][paragraph break]~]
        say__p=1;! [4: ~Escribes un verso sobre ~]
        ParaContent(); print "Escribes un verso sobre ";! [5: italic type]
        ParaContent(); style underline;! [6: ~'~]
        ParaContent(); print "~";! [7: the topic understood]
        ParaContent(); PrintSnippet(parsed_number);! [8: ~'...~]
        ParaContent(); print "~...";! [9: roman type]
        ParaContent(); style roman;! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say433; .L_SayX425;! [11: continue the action]
        rfalse;
        } else {
        ! [12: if the musa is complacida]
        if ((((Adj_105_t1_v10(I220_musa)))))
        {! [13: say ~[italic type]'Ya no hace falta que escribas nada más[roman type], dice la musa.'[paragraph break]~]
            say__p=1;! [14: italic type]
            ParaContent(); style underline;! [15: ~'Ya no hace falta que escribas nada más~]
            ParaContent(); print "~Ya no hace falta que escribas nada más";! [16: roman type]
            ParaContent(); style roman;! [17: ~, dice la musa.'~]
            ParaContent(); print ", dice la musa.~";! [18: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say434; .L_SayX426;}
            }
            } else if (debug_rules > 1) DB_Rule(R_1110, 1110, 'actor');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Writing it in (B428_carry_out_writing_it_in)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out writing it in:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out writing it in:
[ R_1140 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1140, 1140);
    ! [2: if the pluma is not carried]
    if (((~~(((Adj_1_t1_v10(I219_pluma)))))))
    {! [3: stop the action]
        rtrue;
        } else {
        ! [4: if the musa is espectante]
        if ((((Adj_106_t1_v10(I220_musa)))))
        {! [5: now the musa is complacida]
            (Adj_105_t2_v10(I220_musa));
            ! [6: if the topic understood matches ~palabras/tonterias/poema/relato/cuento/versos/amado/follar~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_279))))
            {! [7: say ~A tu musa también le place que escribas vaguedades, pues alivia en parte tu maldición y tu pesar.[paragraph break]~]
                say__p=1;! [8: ~A tu musa también le place que escribas vaguedades, pues alivia en parte tu maldición y tu pesar.~]
                ParaContent(); print "A tu musa también le place que escribas vaguedades, pues alivia en parte tu maldición y tu pesar.";! [9: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say435; .L_SayX427;! [10: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [11: if the topic understood matches ~ayuda/auxilio/socorro~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_280))))
            {! [12: say ~La musa acaricia tu rostro. [italic type]'No necesitas ayuda, tan solo mírame...'[roman type][paragraph break]~]
                say__p=1;! [13: ~La musa acaricia tu rostro. ~]
                ParaContent(); print "La musa acaricia tu rostro. ";! [14: italic type]
                ParaContent(); style underline;! [15: ~'No necesitas ayuda, tan solo mírame...'~]
                ParaContent(); print "~No necesitas ayuda, tan solo mírame...~";! [16: roman type]
                ParaContent(); style roman;! [17: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say436; .L_SayX428;! [18: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [19: if the topic understood matches ~en libro~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_281))))
            {! [20: say ~[fixed letter spacing]Para escribir en el libro pon 'ESCRIBE [italic type]texto[roman type]', 'ESCRIBE [italic type]texto[roman type] EN LIBRO' o bien 'ESCRIBE EN LIBRO [italic type]texto[roman type]'.[paragraph break]Teclea 'AYUDA' para más instrucciones.[variable letter spacing][paragraph break]~]
                say__p=1;! [21: fixed letter spacing]
                ParaContent(); font off;! [22: ~Para escribir en el libro pon 'ESCRIBE ~]
                ParaContent(); print "Para escribir en el libro pon ~ESCRIBE ";! [23: italic type]
                ParaContent(); style underline;! [24: ~texto~]
                ParaContent(); print "texto";! [25: roman type]
                ParaContent(); style roman;! [26: ~', 'ESCRIBE ~]
                ParaContent(); print "~, ~ESCRIBE ";! [27: italic type]
                ParaContent(); style underline;! [28: ~texto~]
                ParaContent(); print "texto";! [29: roman type]
                ParaContent(); style roman;! [30: ~ EN LIBRO' o bien 'ESCRIBE EN LIBRO ~]
                ParaContent(); print " EN LIBRO~ o bien ~ESCRIBE EN LIBRO ";! [31: italic type]
                ParaContent(); style underline;! [32: ~texto~]
                ParaContent(); print "texto";! [33: roman type]
                ParaContent(); style roman;! [34: ~'.~]
                ParaContent(); print "~.";! [35: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line;! [36: ~Teclea 'AYUDA' para más instrucciones.~]
                ParaContent(); print "Teclea ~AYUDA~ para más instrucciones.";! [37: variable letter spacing]
                ParaContent(); font on;! [38: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say437; .L_SayX429;! [39: now the musa is espectante]
                (Adj_106_t2_v10(I220_musa));
                ! [40: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [41: if the topic understood matches ~libro/texto/verso/algo~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_282))))
            {! [42: say ~[fixed letter spacing]Para escribir en el libro pon 'ESCRIBE [italic type]texto[roman type]', 'ESCRIBE [italic type]texto[roman type] EN LIBRO' o bien 'ESCRIBE EN LIBRO [italic type]texto[roman type]'.[paragraph break]Teclea 'AYUDA' para más instrucciones.[variable letter spacing][paragraph break]~]
                say__p=1;! [43: fixed letter spacing]
                ParaContent(); font off;! [44: ~Para escribir en el libro pon 'ESCRIBE ~]
                ParaContent(); print "Para escribir en el libro pon ~ESCRIBE ";! [45: italic type]
                ParaContent(); style underline;! [46: ~texto~]
                ParaContent(); print "texto";! [47: roman type]
                ParaContent(); style roman;! [48: ~', 'ESCRIBE ~]
                ParaContent(); print "~, ~ESCRIBE ";! [49: italic type]
                ParaContent(); style underline;! [50: ~texto~]
                ParaContent(); print "texto";! [51: roman type]
                ParaContent(); style roman;! [52: ~ EN LIBRO' o bien 'ESCRIBE EN LIBRO ~]
                ParaContent(); print " EN LIBRO~ o bien ~ESCRIBE EN LIBRO ";! [53: italic type]
                ParaContent(); style underline;! [54: ~texto~]
                ParaContent(); print "texto";! [55: roman type]
                ParaContent(); style roman;! [56: ~'.~]
                ParaContent(); print "~.";! [57: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line;! [58: ~Teclea 'AYUDA' para más instrucciones.~]
                ParaContent(); print "Teclea ~AYUDA~ para más instrucciones.";! [59: variable letter spacing]
                ParaContent(); font on;! [60: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say438; .L_SayX430;! [61: now the musa is espectante]
                (Adj_106_t2_v10(I220_musa));
                ! [62: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [63: if the topic understood matches ~muerte/sacrificio/honor/soldado/guerra/mercader/castigo~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_283))))
            {! [64: say ~[italic type]'Escribir sobre el arte de dar muerte siempre se te ha dado bien'[roman type], tu musa sonrie satisfecha.[paragraph break]~]
                say__p=1;! [65: italic type]
                ParaContent(); style underline;! [66: ~'Escribir sobre el arte de dar muerte siempre se te ha dado bien'~]
                ParaContent(); print "~Escribir sobre el arte de dar muerte siempre se te ha dado bien~";! [67: roman type]
                ParaContent(); style roman;! [68: ~, tu musa sonrie satisfecha.~]
                ParaContent(); print ", tu musa sonrie satisfecha.";! [69: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say439; .L_SayX431;! [70: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [71: if the topic understood matches ~insulto/palabrota/palabrotas/puta/zorra/cerda/guarra~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_284))))
            {! [72: say ~[italic type]'¡Guarda tu ira para el momento propicio! Te iría mejor si me respetaras al menos a mí'[roman type], te advierte la musa.[paragraph break]~]
                say__p=1;! [73: italic type]
                ParaContent(); style underline;! [74: ~'¡Guarda tu ira para el momento propicio! Te iría mejor si me respetaras al menos a mí'~]
                ParaContent(); print "~¡Guarda tu ira para el momento propicio! Te iría mejor si me respetaras al menos a mí~";! [75: roman type]
                ParaContent(); style roman;! [76: ~, te advierte la musa.~]
                ParaContent(); print ", te advierte la musa.";! [77: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say440; .L_SayX432;! [78: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [79: if the topic understood matches ~vida/ternura/amor/desamor/belleza/abismo/penitencia~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_285))))
            {! [80: say ~Tu musa se estremece al ver lo que escribes, pero pronto sonrie de nuevo, aunque algo inquieta...[paragraph break]~]
                say__p=1;! [81: ~Tu musa se estremece al ver lo que escribes, pero pronto sonrie de nuevo, aunque algo inquieta...~]
                ParaContent(); print "Tu musa se estremece al ver lo que escribes, pero pronto sonrie de nuevo, aunque algo inquieta...";! [82: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say441; .L_SayX433;! [83: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [84: if the topic understood matches ~hermano/abel/eva/adan/dios~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_286))))
            {! [85: say ~[italic type]'Nunca me han gustado tus versos sobre [the topic understood]'[roman type], dice alterada la musa.[paragraph break]~]
                say__p=1;! [86: italic type]
                ParaContent(); style underline;! [87: ~'Nunca me han gustado tus versos sobre ~]
                ParaContent(); print "~Nunca me han gustado tus versos sobre ";! [88: the topic understood]
                ParaContent(); PrintSnippet(parsed_number);! [89: ~'~]
                ParaContent(); print "~";! [90: roman type]
                ParaContent(); style roman;! [91: ~, dice alterada la musa.~]
                ParaContent(); print ", dice alterada la musa.";! [92: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say442; .L_SayX434;! [93: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [94: if the topic understood matches ~sucesos/actos/ovejas/castillo/comida~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_287))))
            {! [95: say ~La musa sonrie al verte escribir tan bellamente sobre tus recuerdos...[paragraph break]~]
                say__p=1;! [96: ~La musa sonrie al verte escribir tan bellamente sobre tus recuerdos...~]
                ParaContent(); print "La musa sonrie al verte escribir tan bellamente sobre tus recuerdos...";! [97: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say443; .L_SayX435;! [98: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [99: if the topic understood matches ~musa/lilith~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_288))))
            {! [100: say ~La musa sonrie al ver que tus versos hablan sobre ella. Te abraza con su oscuridad y te envuelven las cenizas...[paragraph break][italic type]'Gracias por tus versos, amado mío'[roman type], dice tu musa.[paragraph break]~]
                say__p=1;! [101: ~La musa sonrie al ver que tus versos hablan sobre ella. Te abraza con su oscuridad y te envuelven las cenizas...~]
                ParaContent(); print "La musa sonrie al ver que tus versos hablan sobre ella. Te abraza con su oscuridad y te envuelven las cenizas...";! [102: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line;! [103: italic type]
                ParaContent(); style underline;! [104: ~'Gracias por tus versos, amado mío'~]
                ParaContent(); print "~Gracias por tus versos, amado mío~";! [105: roman type]
                ParaContent(); style roman;! [106: ~, dice tu musa.~]
                ParaContent(); print ", dice tu musa.";! [107: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say444; .L_SayX436;! [108: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [109: if the topic understood matches ~espada/doncella/violacion/banquete/diamante~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_289))))
            {! [110: say ~[italic type]'No te has de sentir culpable'[roman type], susurra la musa.[paragraph break]~]
                say__p=1;! [111: italic type]
                ParaContent(); style underline;! [112: ~'No te has de sentir culpable'~]
                ParaContent(); print "~No te has de sentir culpable~";! [113: roman type]
                ParaContent(); style roman;! [114: ~, susurra la musa.~]
                ParaContent(); print ", susurra la musa.";! [115: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say445; .L_SayX437;! [116: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [117: if the topic understood matches ~ternero/asesinato/venganza/piedra/canticos/sangre/visceras~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_290))))
            {! [118: say ~La musa se regociza ante los recuerdos de tu ofrenda...[paragraph break]~]
                say__p=1;! [119: ~La musa se regociza ante los recuerdos de tu ofrenda...~]
                ParaContent(); print "La musa se regociza ante los recuerdos de tu ofrenda...";! [120: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say446; .L_SayX438;! [121: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [122: if the topic understood matches ~pecado/avaricia/envidia/gula/mentir/pecar/matar~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_291))))
            {! [123: say ~Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.[paragraph break]~]
                say__p=1;! [124: ~Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.~]
                ParaContent(); print "Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.";! [125: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say447; .L_SayX439;! [126: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [127: if the topic understood matches ~ira/lujuria/pereza/soberbia/pecados/violar/asesinar~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_292))))
            {! [128: say ~Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.[paragraph break]~]
                say__p=1;! [129: ~Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.~]
                ParaContent(); print "Tu musa da un paso atrás, porque comprende que ahora sabes que estás cumpliendo una penitencia y que ella en realidad es tu carcelera. Pero sonrie igualmente, pues estás a su lado y aún así la amas.";! [130: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say448; .L_SayX440;! [131: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [132: if the topic understood matches ~genocidio/masacre/sacrificio/crimen/martirio/ruina/caida~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_293))))
            {! [133: say ~[italic type]'¡Oh, sí! Estás aquí en parte por eso'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [134: italic type]
                ParaContent(); style underline;! [135: ~'¡Oh, sí! Estás aquí en parte por eso'~]
                ParaContent(); print "~¡Oh, sí! Estás aquí en parte por eso~";! [136: roman type]
                ParaContent(); style roman;! [137: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [138: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say449; .L_SayX441;! [139: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [140: if the topic understood matches ~cain~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_294))))
            {! [141: say ~La musa palidece al ver tu nombre sobre la página... pues Caín es como te llamas.[paragraph break]~]
                say__p=1;! [142: ~La musa palidece al ver tu nombre sobre la página... pues Caín es como te llamas.~]
                ParaContent(); print "La musa palidece al ver tu nombre sobre la página... pues Caín es como te llamas.";! [143: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say450; .L_SayX442;! [144: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [145: if the topic understood matches ~rencor/rencores/pecados/guerras/temor/temores~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_295))))
            {! [146: say ~[italic type]'¡Oh, sí! Estás aquí en parte por eso'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [147: italic type]
                ParaContent(); style underline;! [148: ~'¡Oh, sí! Estás aquí en parte por eso'~]
                ParaContent(); print "~¡Oh, sí! Estás aquí en parte por eso~";! [149: roman type]
                ParaContent(); style roman;! [150: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [151: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say451; .L_SayX443;! [152: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [153: if the topic understood matches ~muerte/la muerte~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_296))))
            {! [154: say ~[italic type]'¿Lo preguntas acaso porque tú eres inmortal?'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [155: italic type]
                ParaContent(); style underline;! [156: ~'¿Lo preguntas acaso porque tú eres inmortal?'~]
                ParaContent(); print "~¿Lo preguntas acaso porque tú eres inmortal?~";! [157: roman type]
                ParaContent(); style roman;! [158: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [159: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say452; .L_SayX444;! [160: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [161: if the topic understood matches ~guerras/la guerra/destruccion/la destruccion~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_297))))
            {! [162: say ~[italic type]'La guerra es lo que desencadenarías tú de ser completamente libre.'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [163: italic type]
                ParaContent(); style underline;! [164: ~'La guerra es lo que desencadenarías tú de ser completamente libre.'~]
                ParaContent(); print "~La guerra es lo que desencadenarías tú de ser completamente libre.~";! [165: roman type]
                ParaContent(); style roman;! [166: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [167: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say453; .L_SayX445;! [168: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [169: if the topic understood matches ~apocalipsis/matanza/el apocalipsis~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_298))))
            {! [170: say ~[italic type]'¿Es acaso un verso que habla sobre lo que deseas?'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [171: italic type]
                ParaContent(); style underline;! [172: ~'¿Es acaso un verso que habla sobre lo que deseas?'~]
                ParaContent(); print "~¿Es acaso un verso que habla sobre lo que deseas?~";! [173: roman type]
                ParaContent(); style roman;! [174: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [175: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say454; .L_SayX446;! [176: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [177: if the topic understood matches ~holocausto/sacrificio/hecatombe/ofrenda/el holocausto~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_299))))
            {! [178: say ~[italic type]'¿Es acaso un verso que habla sobre lo que deseas?'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [179: italic type]
                ParaContent(); style underline;! [180: ~'¿Es acaso un verso que habla sobre lo que deseas?'~]
                ParaContent(); print "~¿Es acaso un verso que habla sobre lo que deseas?~";! [181: roman type]
                ParaContent(); style roman;! [182: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [183: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say455; .L_SayX447;! [184: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [185: if the topic understood matches ~gehena/la gehena/expiacion~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_300))))
            {! [186: say ~[italic type]'Por fin un verso sobre este lugar que te ata'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [187: italic type]
                ParaContent(); style underline;! [188: ~'Por fin un verso sobre este lugar que te ata'~]
                ParaContent(); print "~Por fin un verso sobre este lugar que te ata~";! [189: roman type]
                ParaContent(); style roman;! [190: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [191: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say456; .L_SayX448;! [192: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [193: if the topic understood matches ~gehenna/la gehenna~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_301))))
            {! [194: say ~[italic type]'Por fin un verso sobre este lugar que te ata'[roman type], te dice la musa.[paragraph break]~]
                say__p=1;! [195: italic type]
                ParaContent(); style underline;! [196: ~'Por fin un verso sobre este lugar que te ata'~]
                ParaContent(); print "~Por fin un verso sobre este lugar que te ata~";! [197: roman type]
                ParaContent(); style roman;! [198: ~, te dice la musa.~]
                ParaContent(); print ", te dice la musa.";! [199: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say457; .L_SayX449;! [200: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [201: if the topic understood matches ~perdon/misericordia/perdoname~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_302))))
            {! [202: try rezaring]
                TryAction(0, player, ##A89_rezaring, 0, 0);
                ! [203: rule succeeds]
                RulebookSucceeds(); rtrue;
                }
            ! [204: if the topic understood matches ~arrepentimiento/clemencia/compasion/indulgencia~]
            if (((SnippetMatches(parsed_number, Consult_Grammar_303))))
            {! [205: try rezaring]
                TryAction(0, player, ##A89_rezaring, 0, 0);
                ! [206: rule succeeds]
                RulebookSucceeds(); rtrue;
                } else {
                ! [207: say ~Otro verso ininteligible...~]
                say__p=1;! [208: ~Otro verso ininteligible...~]
                ParaContent(); print "Otro verso ininteligible..."; new_line; .L_Say458; .L_SayX450;}
                }
                }
                } else if (debug_rules > 1) DB_Rule(R_1140, 1140, 'actor');
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Writenothing (B430_check_writenothing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check Writenothing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check Writenothing:
[ R_1111 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1111, 1111);
    ! [2: if the player carries the pluma and the location is en la oscuridad and the musa is espectante]
    if ((((player == CarrierOf(I219_pluma)))) && ((((real_location == I218_en_la_oscuridad))) && ((((Adj_106_t1_v10(I220_musa)))))))
    {! [3: say ~[fixed letter spacing]Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'[variable letter spacing][paragraph break]~]
        say__p=1;! [4: fixed letter spacing]
        ParaContent(); font off;! [5: ~Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'~]
        ParaContent(); print "Para escribir en el libro pon ~escribe TEXTO~ o bien ~escribe TEXTO en libro~";! [6: variable letter spacing]
        ParaContent(); font on;! [7: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say459; .L_SayX451;} else {
        ! [8: if the musa is complacida]
        if ((((Adj_105_t1_v10(I220_musa)))))
        {! [9: say ~[italic type]'Ya no hace falta que escribas nada más[roman type], dice la musa.'[paragraph break]~]
            say__p=1;! [10: italic type]
            ParaContent(); style underline;! [11: ~'Ya no hace falta que escribas nada más~]
            ParaContent(); print "~Ya no hace falta que escribas nada más";! [12: roman type]
            ParaContent(); style roman;! [13: ~, dice la musa.'~]
            ParaContent(); print ", dice la musa.~";! [14: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say460; .L_SayX452;} else {
            ! [15: if the location is not en la oscuridad]
            if (((~~((real_location == I218_en_la_oscuridad)))))
            {! [16: say ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                say__p=1;! [17: ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                ParaContent(); print "Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar."; new_line; .L_Say461; .L_SayX453;} else {
                ! [18: say ~'[italic type]Coge tu pluma y escribe algo en el libro que te ofrezco'[roman type], dice la musa.[paragraph break]~]
                say__p=1;! [19: ~'~]
                ParaContent(); print "~";! [20: italic type]
                ParaContent(); style underline;! [21: ~Coge tu pluma y escribe algo en el libro que te ofrezco'~]
                ParaContent(); print "Coge tu pluma y escribe algo en el libro que te ofrezco~";! [22: roman type]
                ParaContent(); style roman;! [23: ~, dice la musa.~]
                ParaContent(); print ", dice la musa.";! [24: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say462; .L_SayX454;}
                }
                }
                } else if (debug_rules > 1) DB_Rule(R_1111, 1111, 'actor');
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Writenoun (B433_check_writenoun)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check Writenoun:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check Writenoun:
[ R_1112 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1112, 1112);
    ! [2: if the player carries the pluma and the location is en la oscuridad and the musa is espectante]
    if ((((player == CarrierOf(I219_pluma)))) && ((((real_location == I218_en_la_oscuridad))) && ((((Adj_106_t1_v10(I220_musa)))))))
    {! [3: say ~[fixed letter spacing]Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'[variable letter spacing][paragraph break]~]
        say__p=1;! [4: fixed letter spacing]
        ParaContent(); font off;! [5: ~Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'~]
        ParaContent(); print "Para escribir en el libro pon ~escribe TEXTO~ o bien ~escribe TEXTO en libro~";! [6: variable letter spacing]
        ParaContent(); font on;! [7: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say463; .L_SayX455;} else {
        ! [8: if the noun is not the libro]
        if (((~~((noun == I222_libro)))))
        {! [9: say ~[fixed letter spacing]Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'[variable letter spacing][paragraph break]~]
            say__p=1;! [10: fixed letter spacing]
            ParaContent(); font off;! [11: ~Para escribir en el libro pon 'escribe TEXTO' o bien 'escribe TEXTO en libro'~]
            ParaContent(); print "Para escribir en el libro pon ~escribe TEXTO~ o bien ~escribe TEXTO en libro~";! [12: variable letter spacing]
            ParaContent(); font on;! [13: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say464; .L_SayX456;} else {
            ! [14: if the musa is complacida]
            if ((((Adj_105_t1_v10(I220_musa)))))
            {! [15: say ~[italic type]'Ya no hace falta que escribas nada más[roman type], dice la musa.'[paragraph break]~]
                say__p=1;! [16: italic type]
                ParaContent(); style underline;! [17: ~'Ya no hace falta que escribas nada más~]
                ParaContent(); print "~Ya no hace falta que escribas nada más";! [18: roman type]
                ParaContent(); style roman;! [19: ~, dice la musa.'~]
                ParaContent(); print ", dice la musa.~";! [20: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say465; .L_SayX457;} else {
                ! [21: if the location is not en la oscuridad]
                if (((~~((real_location == I218_en_la_oscuridad)))))
                {! [22: say ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                    say__p=1;! [23: ~Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar.~]
                    ParaContent(); print "Debo escribir en el libro que me ofrece la musa. Aquí no es el lugar."; new_line; .L_Say466; .L_SayX458;} else {
                    ! [24: say ~'[italic type]Coge tu pluma y escribe algo en el libro que te ofrezco'[roman type], dice la musa.[paragraph break]~]
                    say__p=1;! [25: ~'~]
                    ParaContent(); print "~";! [26: italic type]
                    ParaContent(); style underline;! [27: ~Coge tu pluma y escribe algo en el libro que te ofrezco'~]
                    ParaContent(); print "Coge tu pluma y escribe algo en el libro que te ofrezco~";! [28: roman type]
                    ParaContent(); style roman;! [29: ~, dice la musa.~]
                    ParaContent(); print ", dice la musa.";! [30: paragraph break]
                    ParaContent(); DivideParagraphPoint(); new_line; .L_Say467; .L_SayX459;}
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_1112, 1112, 'actor');
                    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rezaring (B436_check_rezaring)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check rezaring:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check rezaring:
[ R_1113 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1113, 1113);
    ! [2: say ~Es un dios misericordioso, y tan solo tenías que pedir misericordia.[paragraph break]~]
    say__p=1;! [3: ~Es un dios misericordioso, y tan solo tenías que pedir misericordia.~]
    ParaContent(); print "Es un dios misericordioso, y tan solo tenías que pedir misericordia.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say468; .L_SayX460;! [5: play the sound of atmosphere]
    PlaySound(ResourceIDsOfSounds-->I216_sound_of_atmosphere, 0);
    ! [6: wait for any key]
    KeyPause();
    ! [7: display the figure musa llorando]
    DisplayFigure(ResourceIDsOfFigures-->I208_figure_musa_llorando, 0);
    ! [8: wait for any key]
    KeyPause();
    ! [9: say ~[paragraph break]Recuerdas tu primer pecado... y luego todos los demás.[paragraph break]Comienzas a recordarlo todo...[paragraph break]~]
    say__p=1;! [10: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [11: ~Recuerdas tu primer pecado... y luego todos los demás.~]
    ParaContent(); print "Recuerdas tu primer pecado... y luego todos los demás.";! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [13: ~Comienzas a recordarlo todo...~]
    ParaContent(); print "Comienzas a recordarlo todo...";! [14: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say469; .L_SayX461;! [15: wait for any key]
    KeyPause();
    ! [16: say ~Recuerdas quién eres y la oscuridad se resquebraja. [paragraph break]Empieza a girar todo a tu alrededor... y recuerdas las palabras... [paragraph break]~]
    say__p=1;! [17: ~Recuerdas quién eres y la oscuridad se resquebraja. ~]
    ParaContent(); print "Recuerdas quién eres y la oscuridad se resquebraja. ";! [18: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [19: ~Empieza a girar todo a tu alrededor... y recuerdas las palabras... ~]
    ParaContent(); print "Empieza a girar todo a tu alrededor... y recuerdas las palabras... ";! [20: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say470; .L_SayX462;! [21: wait for any key]
    KeyPause();
    ! [22: say ~[italic type]'Mi culpa es demasiado grande para soportarla. Hoy me destierras de aquí; tendré que ocultarme de ti, andando errante y perdido por el mundo; el que tropiece conmigo me matará.'[roman type][paragraph break]~]
    say__p=1;! [23: italic type]
    ParaContent(); style underline;! [24: ~'Mi culpa es demasiado grande para soportarla. Hoy me destierras de aquí; tendré que ocultarme de ti, andando errante y perdido por el mundo; el que tropiece conmigo me matará.'~]
    ParaContent(); print "~Mi culpa es demasiado grande para soportarla. Hoy me destierras de aquí; tendré que ocultarme de ti, andando errante y perdido por el mundo; el que tropiece conmigo me matará.~";! [25: roman type]
    ParaContent(); style roman;! [26: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say471; .L_SayX463;! [27: wait for any key]
    KeyPause();
    ! [28: say ~El Señor te dijo: [italic type]'El que mate a Caín lo pagará siete veces.'[roman type][paragraph break]Y el Señor puso una señal a Caín para que, si alguien tropezase con él, no le matara.[paragraph break]~]
    say__p=1;! [29: ~El Señor te dijo: ~]
    ParaContent(); print "El Señor te dijo: ";! [30: italic type]
    ParaContent(); style underline;! [31: ~'El que mate a Caín lo pagará siete veces.'~]
    ParaContent(); print "~El que mate a Caín lo pagará siete veces.~";! [32: roman type]
    ParaContent(); style roman;! [33: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [34: ~Y el Señor puso una señal a Caín para que, si alguien tropezase con él, no le matara.~]
    ParaContent(); print "Y el Señor puso una señal a Caín para que, si alguien tropezase con él, no le matara.";! [35: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say472; .L_SayX464;! [36: say ~De nuevo la mima voz, ahora, retruena en tu cabeza: [italic type]'Ahora ya has pedido perdón, puedes descansar en paz, después de tantos años, después de tantos pecados. Tu castigo llega a su fin, camina por fin libre, hijo mio.'[roman type][paragraph break]~]
    say__p=1;! [37: ~De nuevo la mima voz, ahora, retruena en tu cabeza: ~]
    ParaContent(); print "De nuevo la mima voz, ahora, retruena en tu cabeza: ";! [38: italic type]
    ParaContent(); style underline;! [39: ~'Ahora ya has pedido perdón, puedes descansar en paz, después de tantos años, después de tantos pecados. Tu castigo llega a su fin, camina por fin libre, hijo mio.'~]
    ParaContent(); print "~Ahora ya has pedido perdón, puedes descansar en paz, después de tantos años, después de tantos pecados. Tu castigo llega a su fin, camina por fin libre, hijo mio.~";! [40: roman type]
    ParaContent(); style roman;! [41: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say473; .L_SayX465;! [42: wait for any key]
    KeyPause();
    ! [43: say ~Tu espíritu que alguna vez fue celestial se escapa de entre los muros del castigo, dejando atrás a la bella y perversa Lilith, tu musa, cuyas lágrimas por tu ausencia te salpican en el rostro, a medida que te desvaneces en el éter para no volver a verla jamás.[paragraph break]~]
    say__p=1;! [44: ~Tu espíritu que alguna vez fue celestial se escapa de entre los muros del castigo, dejando atrás a la bella y perversa Lilith, tu musa, cuyas lágrimas por tu ausencia te salpican en el rostro, a medida que te desvaneces en el éter para no volver a verla jamás.~]
    ParaContent(); print "Tu espíritu que alguna vez fue celestial se escapa de entre los muros del castigo, dejando atrás a la bella y perversa Lilith, tu musa, cuyas lágrimas por tu ausencia te salpican en el rostro, a medida que te desvaneces en el éter para no volver a verla jamás.";! [45: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say474; .L_SayX466;! [46: wait for any key]
    KeyPause();
    ! [47: end the story finally]
    deadflag=3; story_complete=true;
    } else if (debug_rules > 1) DB_Rule(R_1113, 1113, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Remembering (B441_report_remembering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report remembering:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report remembering:
[ R_1114 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1114, 1114);
    ! [2: say ~Tratas de recordar, pero ha pasado ya tanto tiempo...[paragraph break][italic type]'No te preocupes por el pasado, ahora estamos aquí en el presente'[roman type], dice la musa.~]
    say__p=1;! [3: ~Tratas de recordar, pero ha pasado ya tanto tiempo...~]
    ParaContent(); print "Tratas de recordar, pero ha pasado ya tanto tiempo...";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: italic type]
    ParaContent(); style underline;! [6: ~'No te preocupes por el pasado, ahora estamos aquí en el presente'~]
    ParaContent(); print "~No te preocupes por el pasado, ahora estamos aquí en el presente~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, dice la musa.~]
    ParaContent(); print ", dice la musa."; new_line; .L_Say475; .L_SayX467;} else if (debug_rules > 1) DB_Rule(R_1114, 1114, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Fucking (B444_report_fucking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report fucking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report fucking:
[ R_1116 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1116, 1116);
    ! [2: say ~[italic type]'¿También tienes pensamientos pecaminosos con [the noun]?'[roman type], dice la musa.~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'¿También tienes pensamientos pecaminosos con ~]
    ParaContent(); print "~¿También tienes pensamientos pecaminosos con ";! [5: the noun]
    ParaContent(); print (the) noun;! [6: ~?'~]
    ParaContent(); print "?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, dice la musa.~]
    ParaContent(); print ", dice la musa."; new_line; .L_Say476; .L_SayX468;} else if (debug_rules > 1) DB_Rule(R_1116, 1116, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Faping (B447_report_faping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report faping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report faping:
[ R_1117 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1117, 1117);
    ! [2: say ~[italic type]'Interesante... ¿estás pensando en masturbarte con [the noun]?'[roman type], pregunta la musa.~]
    say__p=1;! [3: italic type]
    ParaContent(); style underline;! [4: ~'Interesante... ¿estás pensando en masturbarte con ~]
    ParaContent(); print "~Interesante... ¿estás pensando en masturbarte con ";! [5: the noun]
    ParaContent(); print (the) noun;! [6: ~?'~]
    ParaContent(); print "?~";! [7: roman type]
    ParaContent(); style roman;! [8: ~, pregunta la musa.~]
    ParaContent(); print ", pregunta la musa."; new_line; .L_Say477; .L_SayX469;} else if (debug_rules > 1) DB_Rule(R_1117, 1117, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Singing (B450_report_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report singing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report singing:
[ R_1118 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1118, 1118);
    ! [2: say ~Entonas una amarga melodia en una arcana lengua hace tiempo olvidada.~]
    say__p=1;! [3: ~Entonas una amarga melodia en una arcana lengua hace tiempo olvidada.~]
    ParaContent(); print "Entonas una amarga melodia en una arcana lengua hace tiempo olvidada."; new_line; .L_Say478; .L_SayX470;} else if (debug_rules > 1) DB_Rule(R_1118, 1118, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! From the Standard Rules
! No specific request
! This is the start in the correct scenes rule:
[ R_10 ;
    if (debug_rules) DB_Rule(R_10, 10);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description heading rule ):
[ R_188 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_188, 188);
    ! [2: say bold type]
    say__p=1;! [3: bold type]
    ParaContent(); style bold; .L_Say479; .L_SayX471;! [4: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [5: begin the printing the name of a dark room activity]
        BeginActivity(V9_printing_the_name_of_a_da);
        ! [6: if handling the printing the name of a dark room activity]
        if (((~~(ForActivity(V9_printing_the_name_of_a_da)))))
        {! [7: say ~Darkness~ ( a )]
            say__p=1;! [8: ~Darkness~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_390); .L_Say480; .L_SayX472;}
        ! [9: end the printing the name of a dark room activity]
        EndActivity(V9_printing_the_name_of_a_da);
        } else {
        ! [10: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [11: say ~[visibility ceiling]~]
            say__p=1;! [12: visibility ceiling]
            ParaContent(); PrintShortName((MStack-->MstVO(20011,3))); .L_Say481; .L_SayX473;} else {
            ! [13: say ~[The visibility ceiling]~]
            say__p=1;! [14: the visibility ceiling]
            ParaContent(); print (The) (MStack-->MstVO(20011,3)); .L_Say482; .L_SayX474;}
            }
    ! [15: say roman type]
    say__p=1;! [16: roman type]
    ParaContent(); style roman; .L_Say483; .L_SayX475;! [17: let intermediate level be the visibility-holder of the actor]

    		tmp_0 = VisibilityParent(actor);
    ! [18: repeat with intermediate level count running from 2 to the visibility level count]
    for (tmp_1=2: tmp_1<=(MStack-->MstVO(20011,2)): tmp_1++)
    {! [19: if the intermediate level is a supporter or the intermediate level is an animal]
        if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K12_animal))))
        {! [20: say ~ (on [the intermediate level])~ ( b )]
            say__p=1;! [21: ~ (on [the intermediate level])~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_391); .L_Say484; .L_SayX476;} else {
            ! [22: say ~ (in [the intermediate level])~ ( c )]
            say__p=1;! [23: ~ (in [the intermediate level])~ ( c )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_392); .L_Say485; .L_SayX477;}
        ! [24: let the intermediate level be the visibility-holder of the intermediate level]
        tmp_0 = VisibilityParent(tmp_0);
        }
    ! [25: say line break]
    say__p=1;! [26: line break]
    ParaContent(); new_line; .L_Say486; .L_SayX478;! [27: say run paragraph on with special look spacing]
    say__p=1;! [28: run paragraph on with special look spacing]
    ParaContent(); SpecialLookSpacingBreak(); .L_Say487; .L_SayX479;} else if (debug_rules > 1) DB_Rule(R_188, 188, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor answering something that ( this is the block answering rule ):
[ R_265 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_265, 265);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There] [are] no reply.~ ( a )]
        say__p=1;! [5: ~[There] [are] no reply.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_393); new_line; .L_Say488; .L_SayX480;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_265, 265, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor telling something about ( this is the block telling rule ):
[ R_267 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_267, 267);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~This [provoke] no reaction.~ ( a )]
        say__p=1;! [5: ~This [provoke] no reaction.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_394); new_line; .L_Say489; .L_SayX481;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_267, 267, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor asking something about ( this is the block asking rule ):
[ R_268 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_268, 268);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There] [are] no reply.~ ( a )]
        say__p=1;! [5: ~[There] [are] no reply.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_395); new_line; .L_Say490; .L_SayX482;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_268, 268, 'action');
    rfalse;
];
! From "Glulx Text Effects" by Emily Short
! No specific request
! Before starting the virtual machine ( this is the sort the Table of User Styles rule ):
[ R_851 
    tmp_0 ! Let/loop value, e.g., 'row1': number
    tmp_1 ! Let/loop value, e.g., 'row2': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_851, 851);
    ! [2: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_0=T3_user_styles, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if there is no style name entry]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1) == false)))
        {! [4: now the style name entry is all-styles]
            TableLookUpEntry(ct_0,108,ct_1,1,I126_all_styles);
            }
            }
            @pull ct_1; @pull ct_0;! [5: sort the table of user styles in style name order]
    TableSort(T3_user_styles, 108, 1);
    ! [6: let row1 be 1]

    		tmp_0 = 1;
    ! [7: let row2 be 2]

    		tmp_1 = 2;
    ! [8: while row2 <= the number of rows in the table of user styles]
    while (((tmp_1 <= TableRows(T3_user_styles))))
    {! [9: choose row row2 in the table of user styles]
        ct_0 = T3_user_styles; ct_1 = tmp_1;
        ! [10: if there is a style name entry]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1))))
        {! [11: if ( the style name in row row1 of the table of user styles ) is the style name entry]
            if (((TableLookUpEntry(T3_user_styles,108,tmp_0) == TableLookUpEntry(ct_0,108,ct_1))))
            {! [12: if there is a background color entry]
                if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
                {! [13: now the background color in row row1 of the table of user styles is the background color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,109,tmp_0,5), TableLookUpEntry(ct_0,109,ct_1));
                    }
                ! [14: if there is a color entry]
                if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
                {! [15: now the color in row row1 of the table of user styles is the color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,110,tmp_0,5), TableLookUpEntry(ct_0,110,ct_1));
                    }
                ! [16: if there is a first line indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
                {! [17: now the first line indentation in row row1 of the table of user styles is the first line indentation entry]
                    TableLookUpEntry(T3_user_styles,111,tmp_0,1,TableLookUpEntry(ct_0,111,ct_1));
                    }
                ! [18: if there is a fixed width entry]
                if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
                {! [19: now the fixed width in row row1 of the table of user styles is the fixed width entry]
                    TableLookUpEntry(T3_user_styles,112,tmp_0,1,TableLookUpEntry(ct_0,112,ct_1));
                    }
                ! [20: if there is a font weight entry]
                if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
                {! [21: now the font weight in row row1 of the table of user styles is the font weight entry]
                    TableLookUpEntry(T3_user_styles,113,tmp_0,1,TableLookUpEntry(ct_0,113,ct_1));
                    }
                ! [22: if there is a indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
                {! [23: now the indentation in row row1 of the table of user styles is the indentation entry]
                    TableLookUpEntry(T3_user_styles,114,tmp_0,1,TableLookUpEntry(ct_0,114,ct_1));
                    }
                ! [24: if there is a italic entry]
                if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
                {! [25: now the italic in row row1 of the table of user styles is the italic entry]
                    TableLookUpEntry(T3_user_styles,115,tmp_0,1,TableLookUpEntry(ct_0,115,ct_1));
                    }
                ! [26: if there is a justification entry]
                if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
                {! [27: now the justification in row row1 of the table of user styles is the justification entry]
                    TableLookUpEntry(T3_user_styles,116,tmp_0,1,TableLookUpEntry(ct_0,116,ct_1));
                    }
                ! [28: if there is a relative size entry]
                if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
                {! [29: now the relative size in row row1 of the table of user styles is the relative size entry]
                    TableLookUpEntry(T3_user_styles,117,tmp_0,1,TableLookUpEntry(ct_0,117,ct_1));
                    }
                ! [30: if there is a reversed entry]
                if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
                {! [31: now the reversed in row row1 of the table of user styles is the reversed entry]
                    TableLookUpEntry(T3_user_styles,118,tmp_0,1,TableLookUpEntry(ct_0,118,ct_1));
                    }
                ! [32: blank out the whole row]
                TableBlankOutRow(ct_0, ct_1);
                } else {
                ! [33: now row1 is row2]
                tmp_0 = tmp_1;
                }
                }
        ! [34: increment row2]
        tmp_1 = tmp_1 + 1;;
        }
        rfalse;
];
! From "Glulx Text Effects" by Emily Short
! No specific request
! Last before starting the virtual machine ( this is the set text styles rule ):
[ R_852 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_852, 852);
    ! [2: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_0=T3_user_styles, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if there is a background color entry]
        if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
        {! [4: set the background color for the style name entry to the background color entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_BackColor, GTE_ConvertColour( TableLookUpEntry(ct_0,109,ct_1) ) );
            }
        ! [5: if there is a color entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
        {! [6: set the color for the style name entry to the color entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_TextColor, GTE_ConvertColour( TableLookUpEntry(ct_0,110,ct_1) ) );
            }
        ! [7: if there is a first line indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
        {! [8: set the first line indentation for the style name entry to the first line indentation entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_ParaIndentation, TableLookUpEntry(ct_0,111,ct_1) );
            }
        ! [9: if there is a fixed width entry]
        if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
        {! [10: set fixed width for the style name entry to the fixed width entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Proportional, ( TableLookUpEntry(ct_0,112,ct_1) + 1 ) % 2 );
            }
        ! [11: if there is a font weight entry]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
        {! [12: set the font weight for the style name entry to the font weight entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Weight, TableLookUpEntry(ct_0,113,ct_1) - 2 );
            }
        ! [13: if there is a indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
        {! [14: set the indentation for the style name entry to the indentation entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Indentation, TableLookUpEntry(ct_0,114,ct_1) );
            }
        ! [15: if there is a italic entry]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
        {! [16: set italic for the style name entry to the italic entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Oblique, TableLookUpEntry(ct_0,115,ct_1) );
            }
        ! [17: if there is a justification entry]
        if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
        {! [18: set the justification for the style name entry to the justification entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Justification, TableLookUpEntry(ct_0,116,ct_1) - 1 );
            }
        ! [19: if there is a relative size entry]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
        {! [20: set the relative size for the style name entry to the relative size entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_Size, TableLookUpEntry(ct_0,117,ct_1) );
            }
        ! [21: if there is a reversed entry]
        if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
        {! [22: set reversed for the style name entry to the reversed entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,108,ct_1), stylehint_ReverseColor, TableLookUpEntry(ct_0,118,ct_1) );
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the quit rule:
[ R_902 ;
    if (debug_rules) DB_Rule(R_902, 902);
    ! [2: decrease the menu depth by 1]
    (Global_Vars-->12) = (Global_Vars-->12) - 1;;
    ! [3: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the move down rule:
[ R_903 ;
    if (debug_rules) DB_Rule(R_903, 903);
    ! [2: if current menu selection is less than the number of filled rows in the current menu]
    if ((((Global_Vars-->16) < TableFilledRows((Global_Vars-->15)))))
    {! [3: increase current menu selection by 1]
        (Global_Vars-->16) = (Global_Vars-->16) + 1;;
        }
    ! [4: reprint the current menu]
    (PHR_907_r26 ((Global_Vars-->15)));
    ! [5: make no decision]
    rfalse;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the move up rule:
[ R_904 ;
    if (debug_rules) DB_Rule(R_904, 904);
    ! [2: if current menu selection is greater than 1]
    if ((((Global_Vars-->16) > 1)))
    {! [3: decrease current menu selection by 1]
        (Global_Vars-->16) = (Global_Vars-->16) - 1;;
        }
    ! [4: reprint the current menu]
    (PHR_907_r26 ((Global_Vars-->15)));
    ! [5: make no decision]
    rfalse;
    rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the select rule:
[ R_905 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_10();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_10 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_905, 905);
    ! [2: choose row current menu selection in the current menu]
    ct_0 = (Global_Vars-->15); ct_1 = (Global_Vars-->16);
    ! [3: if there is a toggle entry]
    if (((ExistsTableLookUpEntry(ct_0,125,ct_1))))
    {! [4: follow the toggle entry]
        FollowRulebook(TableLookUpEntry(ct_0,125,ct_1));
        ! [5: reprint the current menu]
        (PHR_907_r26 ((Global_Vars-->15)));
        } else {
        ! [6: if there is a subtable entry]
        if (((ExistsTableLookUpEntry(ct_0,123,ct_1))))
        {! [7: now the current menu title is title entry]
            BlkValueCopy((Global_Vars-->14), TableLookUpEntry(ct_0,122,ct_1));
            ! [8: now the current menu selection is 1]
            (Global_Vars-->16) = 1;
            ! [9: now the current menu is subtable entry]
            (Global_Vars-->15) = TableLookUpEntry(ct_0,123,ct_1);
            ! [10: show menu contents]
            (PHR_908_r17 ());
            } else {
            ! [11: let the temporary title be the current menu title]
            tmp_0 = I7SFRAME; 
            		BlkValueCopy(tmp_0, (Global_Vars-->14));
            ! [12: now the current menu title is title entry]
            BlkValueCopy((Global_Vars-->14), TableLookUpEntry(ct_0,122,ct_1));
            ! [13: now the endnode flag is 1]
            (Global_Vars-->13) = 1;
            ! [14: redraw status line]
            DrawStatusLine();
            ! [15: now the endnode flag is 0]
            (Global_Vars-->13) = 0;
            ! [16: clear only the main screen]
            VM_ClearScreen(2);
            ! [17: say ~[variable letter spacing][description entry][paragraph break]~]
            say__p=1;! [18: variable letter spacing]
            ParaContent(); font on;! [19: description entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,124,ct_1);! [20: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say491; .L_SayX483;! [21: pause the game]
            (PHR_879_r27 ());
            ! [22: now the current menu title is temporary title]
            BlkValueCopy((Global_Vars-->14), tmp_0);
            ! [23: reprint the current menu]
            (PHR_907_r26 ((Global_Vars-->15)));
            }
            }
            rfalse;
];
! From "Menus" by Emily Short
! No specific request
! This is the hint toggle rule:
[ R_913 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_11();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_11 
    tmp_0 ! Let/loop value, e.g., 'temporary title': text
    tmp_1 ! Let/loop value, e.g., '__index': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_913, 913);
    ! [2: choose row current menu selection in the current menu]
    ct_0 = (Global_Vars-->15); ct_1 = (Global_Vars-->16);
    ! [3: let the temporary title be the current menu title]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, (Global_Vars-->14));
    ! [4: now the current menu title is title entry]
    BlkValueCopy((Global_Vars-->14), TableLookUpEntry(ct_0,122,ct_1));
    ! [5: now the endnode flag is 1]
    (Global_Vars-->13) = 1;
    ! [6: redraw status line]
    DrawStatusLine();
    ! [7: now the endnode flag is 0]
    (Global_Vars-->13) = 0;
    ! [8: say known hints from the subtable entry]
    say__p=1;! [9: known hints from the subtable entry]
    ParaContent(); (PHR_915_r28 (TableLookUpEntry(ct_0,123,ct_1))); .L_Say492; .L_SayX484;! [10: let __index be 0]

    		tmp_1 = 0;
    ! [11: while __index < 1]
    while (((tmp_1 < 1)))
    {! [12: let __x be the chosen letter]

        		tmp_2 = VM_KeyChar();
        ! [13: if __x is 13 or __x is 31 or __x is 32]
        if ((((tmp_2 == 13))) || ((((tmp_2 == 31))) || (((tmp_2 == 32)))))
        {! [14: let __index be 1]
            tmp_1 = 1;
            }
        ! [15: if __x is 72 or __x is 104]
        if ((((tmp_2 == 72))) || (((tmp_2 == 104))))
        {! [16: say hints from the subtable entry]
            say__p=1;! [17: hints from the subtable entry]
            ParaContent(); (PHR_916_r29 (TableLookUpEntry(ct_0,123,ct_1))); .L_Say493; .L_SayX485;}
            }
    ! [18: now the current menu title is temporary title]
    BlkValueCopy((Global_Vars-->14), tmp_0);
    rfalse;
];
! From "Basic Help Menu SP" by Emily Short
! No specific request
! This is the switch notification status rule:
[ R_918 ;
    if (debug_rules) DB_Rule(R_918, 918);
    ! [2: if notify mode is on]
    if ((notify_mode))
    {! [3: try switching score notification off]
        TryAction(0, player, ##NotifyOff, 0, 0);
        } else {
        ! [4: try switching score notification on]
        TryAction(0, player, ##NotifyOn, 0, 0);
        }
        rfalse;
];
! From "Basic Help Menu SP" by Emily Short
! No specific request
! This is the switch description types rule:
[ R_919 ;
    if (debug_rules) DB_Rule(R_919, 919);
    ! [2: if the current verbosity mode is verbose]
    if ((((PHR_920_r30 ()) == I149_verbose)))
    {! [3: try preferring sometimes abbreviated room descriptions]
        TryAction(0, player, ##LMode1, 0, 0);
        ! [4: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [5: if the current verbosity mode is brief]
    if ((((PHR_920_r30 ()) == I148_brief)))
    {! [6: try preferring abbreviated room descriptions]
        TryAction(0, player, ##LMode3, 0, 0);
        ! [7: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [8: if the current verbosity mode is superbrief]
    if ((((PHR_920_r30 ()) == I150_superbrief)))
    {! [9: try preferring unabbreviated room descriptions]
        TryAction(0, player, ##LMode2, 0, 0);
        ! [10: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From "Reactable Quips SP" by Michael Martin
! No specific request
! An RQ out of range rule for a number ( called max ) ( this is the basic RQ out of range rule ):
[ R_935 
    tmp_0 ! Let/loop value, e.g., 'max': number
    ;
    if ((((tmp_0 = parameter_value, (((true) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_935, 935);
    ! [2: say ~[bracket]Valid responses range from 1-[max].  Type REPEAT to relist the options.[close bracket][paragraph break]~]
    say__p=1;! [3: bracket]
    ParaContent(); print "[";! [4: ~Valid responses range from 1-~]
    ParaContent(); print "Valid responses range from 1-";! [5: max]
    ParaContent(); print (say__n=tmp_0);! [6: ~.  Type REPEAT to relist the options.~]
    ParaContent(); print ".  Type REPEAT to relist the options.";! [7: close bracket]
    ParaContent(); print "]";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say494; .L_SayX486;} else if (debug_rules > 1) DB_Rule(R_935, 935, 'action');
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! No specific request
! Check talking to ( this is the can only talk to talkables rule ):
[ R_943 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_943, 943);
    ! [2: if the noun provides the property litany and the noun provides the property greeting]
    if ((((WhetherProvides(noun, false, p18_litany)))) && (((WhetherProvides(noun, false, p17_greeting)))))
    {! [3: do nothing]
        ;
        } else {
        ! [4: say ~Generally, it's best to talk to living things.~]
        say__p=1;! [5: ~Generally, it's best to talk to living things.~]
        ParaContent(); print "Generally, it's best to talk to living things."; new_line; .L_Say495; .L_SayX487;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_943, 943, 'actor');
        rfalse;
];
! Definitions of adjectives

! From the Standard Rules
! No specific request
! Definition:
[ R_0 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_1 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_2 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_3 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_4 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_5 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_6 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_7 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_8 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_39 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_40 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_41 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_42 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_43 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_44 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_45 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_46 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_47 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_48 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_49 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_50 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_51 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_52 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_53 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_54 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_55 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_56 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_57 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_58 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_59 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_60 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_61 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_62 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_63 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_64 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_95 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Glulx Definitions" by Dannii Willis
! No specific request
! Definition:
[ R_996 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Definition:
[ R_1027 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Definition:
[ R_1028 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Definition:
[ R_1029 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Definition:
[ R_1042 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! No specific request
! Definition:
[ R_1043 
    t_0 ! Call parameter: object
    ;
    return false;
];
[ Adj_0_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "worn"
      if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];
[ Adj_1_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "carried"
      if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];
[ Adj_2_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "held"
      if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];
[ Adj_3_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "visible"
      if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];
[ Adj_4_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "invisible"
      if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];
[ Adj_5_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "touchable"
      if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];
[ Adj_6_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "untouchable"
      if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];
[ Adj_7_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "concealed"
      if (t_0 ofclass K2_thing) return ((((TestConcealment((HolderOf(t_0)),t_0)))));
    rfalse;
];
[ Adj_8_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "unconcealed"
      if (t_0 ofclass K2_thing) return (~~(((((TestConcealment((HolderOf(t_0)),t_0)))))));
    rfalse;
];
[ Adj_9_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];
[ Adj_10_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];
[ Adj_11_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "offstage"
      if (t_0 ofclass K2_thing) return (((((~~Adj_9_t1_v10(t_0))))));
    rfalse;
];
[ Adj_12_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "adjacent"
      if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];
[ Adj_13_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "even"
    return (((((IntegerRemainder(t_0, 2)) == 0))));
    rfalse;
];
[ Adj_14_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "odd"
    return (~~((((((IntegerRemainder(t_0, 2)) == 0))))));
    rfalse;
];
[ Adj_15_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "positive"
    return ((((t_0 > 0))));
    rfalse;
];
[ Adj_15_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "positive"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0))));
    rfalse;
];
[ Adj_16_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "negative"
    return ((((t_0 < 0))));
    rfalse;
];
[ Adj_16_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "negative"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0))));
    rfalse;
];
[ Adj_17_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((TEXT_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "empty"
    return ((((TableFilledRows(t_0) == 0))));
    rfalse;
];
[ Adj_17_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RulebookEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((ActivityEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v34 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];
[ Adj_18_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((TEXT_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-empty"
    return (~~(((((TableFilledRows(t_0) == 0))))));
    rfalse;
];
[ Adj_18_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v34 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];
[ Adj_19_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "substituted"
    return ((TEXT_TY_IsSubstituted(t_0)));
    rfalse;
];
[ Adj_20_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "unsubstituted"
    return (~~(((TEXT_TY_IsSubstituted(t_0)))));
    rfalse;
];
[ Adj_21_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "happening"
    return ((scene_status-->(t_0-1)==1));
    rfalse;
];
[ Adj_22_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "full"
    return ((((TableBlankRows(t_0) == 0))));
    rfalse;
];
[ Adj_23_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-full"
    return (~~(((((TableBlankRows(t_0) == 0))))));
    rfalse;
];
[ Adj_24_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "going on"
    return ((TestActivity(t_0)));
    rfalse;
];
[ Adj_25_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "active"
    return ((TestUseOption(t_0)));
    rfalse;
];
[ Adj_26_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "inactive"
    return (~~(((TestUseOption(t_0)))));
    rfalse;
];
[ Adj_27_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];
[ Adj_28_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];
[ Adj_29_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_30_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_31_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_32_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_33_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "modal"
    return ((VerbIsModal(t_0)));
    rfalse;
];
[ Adj_34_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-modal"
    return (~~(((VerbIsModal(t_0)))));
    rfalse;
];
[ Adj_35_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningful"
    return ((VerbIsMeaningful(t_0)));
    rfalse;
];
[ Adj_36_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningless"
    return (~~(((VerbIsMeaningful(t_0)))));
    rfalse;
];
[ Adj_37_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "infinite"
    return ((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))));
    rfalse;
];
[ Adj_38_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "finite"
    return (~~(((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))))));
    rfalse;
];
[ Adj_39_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "nonexistent"
    return ((REAL_NUMBER_TY_Nan(t_0)));
    rfalse;
];
[ Adj_40_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "existent"
    return (~~(((REAL_NUMBER_TY_Nan(t_0)))));
    rfalse;
];
[ Adj_41_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "locale-supportable"
      if (t_0 ofclass K2_thing) return (((((~~(((Adj_70_t1_v10(t_0))))))) && ((((~~(((Adj_78_t1_v10(t_0))))))) && (((~~(((Adj_75_t1_v10(t_0))))))))));
    rfalse;
];
[ Adj_42_t1_v58 
    t_0 ! Call parameter: g-event
    ;
    ! meaning of "dependent on the player"
    return (((((t_0 == I171_char_event))) || ((((t_0 == I172_line_event))) || ((((t_0 == I173_mouse_event))) || (((t_0 == I177_hyperlink_event)))))));
    rfalse;
];
[ Adj_43_t1_v58 
    t_0 ! Call parameter: g-event
    ;
    ! meaning of "independent of the player"
    return (~~((((((t_0 == I171_char_event))) || ((((t_0 == I172_line_event))) || ((((t_0 == I173_mouse_event))) || (((t_0 == I177_hyperlink_event)))))))));
    rfalse;
];
[ Adj_44_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "graphical"
      if (t_0 ofclass K16_g_window) return ((((GProperty(10, t_0,p19_type) == I183_g_graphics))));
    rfalse;
];
[ Adj_45_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "textual"
      if (t_0 ofclass K16_g_window) return (~~(((((GProperty(10, t_0,p19_type) == I183_g_graphics))))));
    rfalse;
];
[ Adj_46_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "buffering"
      if (t_0 ofclass K16_g_window) return ((((GProperty(10, t_0,p19_type) == I181_g_text_buffer))));
    rfalse;
];
[ Adj_47_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "non-buffering"
      if (t_0 ofclass K16_g_window) return (~~(((((GProperty(10, t_0,p19_type) == I181_g_text_buffer))))));
    rfalse;
];
[ Adj_48_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "vertically positioned"
      if (t_0 ofclass K16_g_window) return ((((GProperty(10, t_0,p20_position) >= I191_g_placeabove))));
    rfalse;
];
[ Adj_49_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "horizontally positioned"
      if (t_0 ofclass K16_g_window) return (~~(((((GProperty(10, t_0,p20_position) >= I191_g_placeabove))))));
    rfalse;
];
[ Adj_50_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "paternal"
      if (t_0 ofclass K16_g_window) return (((((Prop_37(t_0))))));
    rfalse;
];
[ Adj_51_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "childless"
      if (t_0 ofclass K16_g_window) return (~~((((((Prop_38(t_0))))))));
    rfalse;
];
[ Adj_52_t1_v10 
    t_0 ! Call parameter: g-window
    ;
    ! meaning of "a next-step"
      if (t_0 ofclass K16_g_window) return (((((t_0 == I200_main_window))) || (((ContainerOf(t_0) ofclass K2_thing) && ((Adj_102_t1_v10(ContainerOf(t_0))))))));
    rfalse;
];
[ Adj_53_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_54_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];
[ Adj_55_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_56_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];
[ Adj_57_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (GetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_58_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_59_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];
[ Adj_60_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_61_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_62_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_63_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];
[ Adj_64_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_65_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_66_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_67_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];
[ Adj_68_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_69_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];
[ Adj_70_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_71_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_72_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_73_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_74_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];
[ Adj_75_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_76_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_77_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];
[ Adj_78_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_79_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];
[ Adj_80_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_81_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];
[ Adj_82_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_83_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_84_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];
[ Adj_85_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_86_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];
[ Adj_87_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_88_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_89_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];
[ Adj_90_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_91_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (GetEitherOrProperty(t_0, female) == false);
    rfalse;
];
[ Adj_92_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_93_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_94_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];
[ Adj_95_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (GProperty(SCENE_TY, t_0, p70_recurring));
    rfalse;
];
[ Adj_96_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (GProperty(SCENE_TY, t_0, p70_recurring) == false);
    rfalse;
];
[ Adj_97_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter gender"
      if (t_0) return (GProperty(OBJECT_TY, t_0, p72_grammatical_gender) == 1);
    rfalse;
];
[ Adj_98_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "masculine gender"
      if (t_0) return (GProperty(OBJECT_TY, t_0, p72_grammatical_gender) == 2);
    rfalse;
];
[ Adj_99_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "feminine gender"
      if (t_0) return (GProperty(OBJECT_TY, t_0, p72_grammatical_gender) == 3);
    rfalse;
];
[ Adj_100_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-required"
      if (t_0) return (GetEitherOrProperty(t_0, p74_g_required));
    rfalse;
];
[ Adj_101_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unrequired"
      if (t_0) return (GetEitherOrProperty(t_0, p74_g_required) == false);
    rfalse;
];
[ Adj_102_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-present"
      if (t_0) return (GetEitherOrProperty(t_0, p76_g_present));
    rfalse;
];
[ Adj_103_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unpresent"
      if (t_0) return (GetEitherOrProperty(t_0, p76_g_present) == false);
    rfalse;
];
[ Adj_104_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "currently being processed"
      if (t_0) return (GetEitherOrProperty(t_0, p78_currently_being_processe));
    rfalse;
];
[ Adj_105_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "complacida"
      if (t_0) return (GetEitherOrProperty(t_0, p79_complacida));
    rfalse;
];
[ Adj_106_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "espectante"
      if (t_0) return (GetEitherOrProperty(t_0, p79_complacida) == false);
    rfalse;
];
[ Adj_107_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "vivo"
      if (t_0) return (GetEitherOrProperty(t_0, p81_vivo));
    rfalse;
];
[ Adj_108_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "muerto"
      if (t_0) return (GetEitherOrProperty(t_0, p81_vivo) == false);
    rfalse;
];
[ Adj_109_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_110_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_111_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_10_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_17_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_18_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_27_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];
[ Adj_28_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];
[ Adj_29_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_30_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_31_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_32_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_53_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_54_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_55_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_56_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_57_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_58_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_59_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_60_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_61_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_62_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_63_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_64_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_65_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_66_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_67_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_68_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_69_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_70_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_71_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_72_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_73_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_74_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_75_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_76_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_77_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_78_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_79_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_80_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_81_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_82_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_83_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_84_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_85_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_86_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_87_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_88_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_89_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_90_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_91_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];
[ Adj_92_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_93_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_94_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_95_t2_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p70_recurring, true));
    rfalse;
];
[ Adj_96_t2_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p70_recurring));
    rfalse;
];
[ Adj_97_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter gender"
      if (t_0) return (WriteGProperty(OBJECT_TY, t_0, p72_grammatical_gender, 1));
    rfalse;
];
[ Adj_98_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "masculine gender"
      if (t_0) return (WriteGProperty(OBJECT_TY, t_0, p72_grammatical_gender, 2));
    rfalse;
];
[ Adj_99_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "feminine gender"
      if (t_0) return (WriteGProperty(OBJECT_TY, t_0, p72_grammatical_gender, 3));
    rfalse;
];
[ Adj_100_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-required"
      if (t_0) return (SetEitherOrProperty(t_0, p74_g_required));
    rfalse;
];
[ Adj_101_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unrequired"
      if (t_0) return (SetEitherOrProperty(t_0, p74_g_required, true));
    rfalse;
];
[ Adj_102_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-present"
      if (t_0) return (SetEitherOrProperty(t_0, p76_g_present));
    rfalse;
];
[ Adj_103_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unpresent"
      if (t_0) return (SetEitherOrProperty(t_0, p76_g_present, true));
    rfalse;
];
[ Adj_104_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "currently being processed"
      if (t_0) return (SetEitherOrProperty(t_0, p78_currently_being_processe));
    rfalse;
];
[ Adj_105_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "complacida"
      if (t_0) return (SetEitherOrProperty(t_0, p79_complacida));
    rfalse;
];
[ Adj_106_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "espectante"
      if (t_0) return (SetEitherOrProperty(t_0, p79_complacida, true));
    rfalse;
];
[ Adj_107_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "vivo"
      if (t_0) return (SetEitherOrProperty(t_0, p81_vivo));
    rfalse;
];
[ Adj_108_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "muerto"
      if (t_0) return (SetEitherOrProperty(t_0, p81_vivo, true));
    rfalse;
];
[ Adj_109_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_110_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_111_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_10_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_17_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_18_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_27_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];
[ Adj_28_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];
[ Adj_29_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_30_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_31_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_32_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_53_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_54_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_55_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_56_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_57_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname, true));
    rfalse;
];
[ Adj_58_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_59_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_60_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_61_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_62_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_63_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_64_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_65_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_66_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_67_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_68_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_69_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_70_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];
[ Adj_71_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];
[ Adj_72_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];
[ Adj_73_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];
[ Adj_74_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_75_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_76_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_77_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_78_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_79_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_80_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];
[ Adj_81_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_82_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_83_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_84_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_85_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_86_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_87_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];
[ Adj_88_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_89_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_90_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];
[ Adj_91_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_92_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];
[ Adj_93_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_94_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_95_t3_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p70_recurring));
    rfalse;
];
[ Adj_96_t3_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p70_recurring, true));
    rfalse;
];
[ Adj_100_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-required"
      if (t_0) return (SetEitherOrProperty(t_0, p74_g_required, true));
    rfalse;
];
[ Adj_101_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unrequired"
      if (t_0) return (SetEitherOrProperty(t_0, p74_g_required));
    rfalse;
];
[ Adj_102_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-present"
      if (t_0) return (SetEitherOrProperty(t_0, p76_g_present, true));
    rfalse;
];
[ Adj_103_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "g-unpresent"
      if (t_0) return (SetEitherOrProperty(t_0, p76_g_present));
    rfalse;
];
[ Adj_104_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "currently being processed"
      if (t_0) return (SetEitherOrProperty(t_0, p78_currently_being_processe, true));
    rfalse;
];
[ Adj_105_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "complacida"
      if (t_0) return (SetEitherOrProperty(t_0, p79_complacida, true));
    rfalse;
];
[ Adj_106_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "espectante"
      if (t_0) return (SetEitherOrProperty(t_0, p79_complacida));
    rfalse;
];
[ Adj_107_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "vivo"
      if (t_0) return (SetEitherOrProperty(t_0, p81_vivo, true));
    rfalse;
];
[ Adj_108_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "muerto"
      if (t_0) return (SetEitherOrProperty(t_0, p81_vivo));
    rfalse;
];
[ Adj_109_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];
[ Adj_110_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];
[ Adj_111_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimedEventsTable table 0 0;

Array TimedEventTimesTable table 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array rulebooks_array --> B0_startup B1_turn_sequence B2_shutdown B3_scene_changing B4_when_play_begins B5_when_play_ends B6_when_scene_begins B7_when_scene_ends B8_every_turn B9_action_processing B10_setting_action_variables B11_specific_action_processi B12_player_s_action_awarenes B13_accessibility B14_reaching_inside B15_reaching_outside B16_visibility B17_persuasion B18_unsuccessful_attempt_by B19_before B20_instead B21_check B22_carry_out B23_after B24_report B25_does_the_player_mean B26_multiple_action_processi B27_when_entire_game_begins B28_when_entire_game_ends B29_before_printing_the_name B30_for_printing_the_name B31_after_printing_the_name B32_before_printing_the_plur B33_for_printing_the_plural_ B34_after_printing_the_plura B35_before_printing_a_number B36_for_printing_a_number B37_after_printing_a_number B38_before_printing_room_des B39_for_printing_room_descri B40_after_printing_room_desc B41_before_printing_inventor B42_for_printing_inventory_d B43_after_printing_inventory B44_before_listing_contents B45_for_listing_contents B46_after_listing_contents B47_before_grouping_together B48_for_grouping_together B49_after_grouping_together B50_before_writing_a_paragra B51_for_writing_a_paragraph_ B52_after_writing_a_paragrap B53_before_listing_nondescri B54_for_listing_nondescript_ B55_after_listing_nondescrip B56_before_printing_the_name B57_for_printing_the_name_of B58_after_printing_the_name_ B59_before_printing_the_desc B60_for_printing_the_descrip B61_after_printing_the_descr B62_before_printing_the_anno B63_for_printing_the_announc B64_after_printing_the_annou B65_before_printing_the_anno B66_for_printing_the_announc B67_after_printing_the_annou B68_before_printing_a_refusa B69_for_printing_a_refusal_t B70_after_printing_a_refusal B71_before_constructing_the_ B72_for_constructing_the_sta B73_after_constructing_the_s B74_before_printing_the_bann B75_for_printing_the_banner_ B76_after_printing_the_banne B77_before_reading_a_command B78_for_reading_a_command B79_after_reading_a_command B80_before_deciding_the_scop B81_for_deciding_the_scope B82_after_deciding_the_scope B83_before_deciding_the_conc B84_for_deciding_the_conceal B85_after_deciding_the_conce B86_before_deciding_whether_ B87_for_deciding_whether_all B88_after_deciding_whether_a B89_before_clarifying_the_pa B90_for_clarifying_the_parse B91_after_clarifying_the_par B92_before_asking_which_do_y B93_for_asking_which_do_you_ B94_after_asking_which_do_yo B95_before_printing_a_parser B96_for_printing_a_parser_er B97_after_printing_a_parser_ B98_before_supplying_a_missi B99_for_supplying_a_missing_ B100_after_supplying_a_missi B101_before_supplying_a_miss B102_for_supplying_a_missing B103_after_supplying_a_missi B104_before_implicitly_takin B105_for_implicitly_taking B106_after_implicitly_taking B107_before_starting_the_vir B108_for_starting_the_virtua B109_after_starting_the_virt B110_before_amusing_a_victor B111_for_amusing_a_victoriou B112_after_amusing_a_victori B113_before_printing_the_pla B114_for_printing_the_player B115_after_printing_the_play B116_before_handling_the_fin B117_for_handling_the_final_ B118_after_handling_the_fina B119_before_printing_the_loc B120_for_printing_the_locale B121_after_printing_the_loca B122_before_choosing_notable B123_for_choosing_notable_lo B124_after_choosing_notable_ B125_before_printing_a_local B126_for_printing_a_locale_p B127_after_printing_a_locale B128_before_issuing_the_resp B129_for_issuing_the_respons B130_after_issuing_the_respo B131_check_taking_inventory B132_carry_out_taking_invent B133_report_taking_inventory B134_check_taking B135_carry_out_taking B136_report_taking B137_check_removing_it_from B138_carry_out_removing_it_f B139_report_removing_it_from B140_check_dropping B141_carry_out_dropping B142_report_dropping B143_check_putting_it_on B144_carry_out_putting_it_on B145_report_putting_it_on B146_check_inserting_it_into B147_carry_out_inserting_it_ B148_report_inserting_it_int B149_check_eating B150_carry_out_eating B151_report_eating B152_check_going B153_carry_out_going B154_report_going B155_check_entering B156_carry_out_entering B157_report_entering B158_check_exiting B159_carry_out_exiting B160_report_exiting B161_check_getting_off B162_carry_out_getting_off B163_report_getting_off B164_check_looking B165_carry_out_looking B166_report_looking B167_check_examining B168_carry_out_examining B169_report_examining B170_check_looking_under B171_carry_out_looking_under B172_report_looking_under B173_check_searching B174_carry_out_searching B175_report_searching B176_check_consulting_it_abo B177_carry_out_consulting_it B178_report_consulting_it_ab B179_check_locking_it_with B180_carry_out_locking_it_wi B181_report_locking_it_with B182_check_unlocking_it_with B183_carry_out_unlocking_it_ B184_report_unlocking_it_wit B185_check_switching_on B186_carry_out_switching_on B187_report_switching_on B188_check_switching_off B189_carry_out_switching_off B190_report_switching_off B191_check_opening B192_carry_out_opening B193_report_opening B194_check_closing B195_carry_out_closing B196_report_closing B197_check_wearing B198_carry_out_wearing B199_report_wearing B200_check_taking_off B201_carry_out_taking_off B202_report_taking_off B203_check_giving_it_to B204_carry_out_giving_it_to B205_report_giving_it_to B206_check_showing_it_to B207_carry_out_showing_it_to B208_report_showing_it_to B209_check_waking B210_carry_out_waking B211_report_waking B212_check_throwing_it_at B213_carry_out_throwing_it_a B214_report_throwing_it_at B215_check_attacking B216_carry_out_attacking B217_report_attacking B218_check_kissing B219_carry_out_kissing B220_report_kissing B221_check_answering_it_that B222_carry_out_answering_it_ B223_report_answering_it_tha B224_check_telling_it_about B225_carry_out_telling_it_ab B226_report_telling_it_about B227_check_asking_it_about B228_carry_out_asking_it_abo B229_report_asking_it_about B230_check_asking_it_for B231_carry_out_asking_it_for B232_report_asking_it_for B233_check_waiting B234_carry_out_waiting B235_report_waiting B236_check_touching B237_carry_out_touching B238_report_touching B239_check_waving B240_carry_out_waving B241_report_waving B242_check_pulling B243_carry_out_pulling B244_report_pulling B245_check_pushing B246_carry_out_pushing B247_report_pushing B248_check_turning B249_carry_out_turning B250_report_turning B251_check_pushing_it_to B252_carry_out_pushing_it_to B253_report_pushing_it_to B254_check_squeezing B255_carry_out_squeezing B256_report_squeezing B257_check_saying_yes B258_carry_out_saying_yes B259_report_saying_yes B260_check_saying_no B261_carry_out_saying_no B262_report_saying_no B263_check_burning B264_carry_out_burning B265_report_burning B266_check_waking_up B267_carry_out_waking_up B268_report_waking_up B269_check_thinking B270_carry_out_thinking B271_report_thinking B272_check_smelling B273_carry_out_smelling B274_report_smelling B275_check_listening_to B276_carry_out_listening_to B277_report_listening_to B278_check_tasting B279_carry_out_tasting B280_report_tasting B281_check_cutting B282_carry_out_cutting B283_report_cutting B284_check_jumping B285_carry_out_jumping B286_report_jumping B287_check_tying_it_to B288_carry_out_tying_it_to B289_report_tying_it_to B290_check_drinking B291_carry_out_drinking B292_report_drinking B293_check_saying_sorry B294_carry_out_saying_sorry B295_report_saying_sorry B296_check_swinging B297_carry_out_swinging B298_report_swinging B299_check_rubbing B300_carry_out_rubbing B301_report_rubbing B302_check_setting_it_to B303_carry_out_setting_it_to B304_report_setting_it_to B305_check_waving_hands B306_carry_out_waving_hands B307_report_waving_hands B308_check_buying B309_carry_out_buying B310_report_buying B311_check_climbing B312_carry_out_climbing B313_report_climbing B314_check_sleeping B315_carry_out_sleeping B316_report_sleeping B317_check_quitting_the_game B318_carry_out_quitting_the_ B319_report_quitting_the_gam B320_check_saving_the_game B321_carry_out_saving_the_ga B322_report_saving_the_game B323_check_restoring_the_gam B324_carry_out_restoring_the B325_report_restoring_the_ga B326_check_restarting_the_ga B327_carry_out_restarting_th B328_report_restarting_the_g B329_check_verifying_the_sto B330_carry_out_verifying_the B331_report_verifying_the_st B332_check_switching_the_sto B333_carry_out_switching_the B334_report_switching_the_st B335_check_switching_the_sto B336_carry_out_switching_the B337_report_switching_the_st B338_check_requesting_the_st B339_carry_out_requesting_th B340_report_requesting_the_s B341_check_requesting_the_sc B342_carry_out_requesting_th B343_report_requesting_the_s B344_check_preferring_abbrev B345_carry_out_preferring_ab B346_report_preferring_abbre B347_check_preferring_unabbr B348_carry_out_preferring_un B349_report_preferring_unabb B350_check_preferring_someti B351_carry_out_preferring_so B352_report_preferring_somet B353_check_switching_score_n B354_carry_out_switching_sco B355_report_switching_score_ B356_check_switching_score_n B357_carry_out_switching_sco B358_report_switching_score_ B359_check_requesting_the_pr B360_carry_out_requesting_th B361_report_requesting_the_p B362_check_entering_to_room B363_carry_out_entering_to_r B364_report_entering_to_room B365_check_bajando B366_carry_out_bajando B367_report_bajando B368_check_subiendo B369_carry_out_subiendo B370_report_subiendo B371_before_pausing_the_game B372_for_pausing_the_game B373_after_pausing_the_game B374_before_displaying B375_for_displaying B376_after_displaying B377_check_asking_for_help B378_carry_out_asking_for_he B379_report_asking_for_help B380_before_quipping B381_for_quipping B382_after_quipping B383_check_requesting_a_reca B384_carry_out_requesting_a_ B385_report_requesting_a_rec B386_check_responding_with B387_carry_out_responding_wi B388_report_responding_with B389_rq_out_of_range B390_check_talking_to B391_carry_out_talking_to B392_report_talking_to B393_check_qbc_responding_wi B394_carry_out_qbc_respondin B395_report_qbc_responding_w B396_check_qbc_recap B397_carry_out_qbc_recap B398_report_qbc_recap B399_glulx_zeroing_reference B400_glulx_resetting_windows B401_glulx_resetting_streams B402_glulx_resetting_fileref B403_glulx_resetting_channel B404_glulx_object_updating B405_glulx_input_handling B406_glulx_timed_activity B407_glulx_redrawing B408_glulx_arranging B409_glulx_sound_notificatio B410_glulx_mouse_input B411_glulx_character_input B412_glulx_line_input B413_glulx_hyperlink B414_command_counting B415_input_cancelling B416_command_showing B417_command_pasting B418_before_constructing B419_for_constructing B420_after_constructing B421_before_deconstructing B422_for_deconstructing B423_after_deconstructing B424_before_refreshing B425_for_refreshing B426_after_refreshing B427_check_writing_it_in B428_carry_out_writing_it_in B429_report_writing_it_in B430_check_writenothing B431_carry_out_writenothing B432_report_writenothing B433_check_writenoun B434_carry_out_writenoun B435_report_writenoun B436_check_rezaring B437_carry_out_rezaring B438_report_rezaring B439_check_remembering B440_carry_out_remembering B441_report_remembering B442_check_fucking B443_carry_out_fucking B444_report_fucking B445_check_faping B446_carry_out_faping B447_report_faping B448_check_singing B449_carry_out_singing B450_report_singing 0;

[ EMPTY_RULEBOOK 
    forbid_breaks ! Implied call parameter
    ;
    rfalse;
];
[ B0_startup 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_960();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_960;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_11();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_11;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_12();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_12;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_13();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_13;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_14();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_14;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B1_turn_sequence 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = PARSE_COMMAND_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PARSE_COMMAND_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = GENERATE_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GENERATE_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_16();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_16;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_930();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_930;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_15();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_15;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = TIMED_EVENTS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return TIMED_EVENTS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADVANCE_TIME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADVANCE_TIME_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_17();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_17;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADJUST_LIGHT_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADJUST_LIGHT_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = NOTE_OBJECT_ACQUISITIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_18();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_18;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 13 rule(s)
];
[ B2_shutdown 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_19();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_19;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = RESURRECT_PLAYER_IF_ASKED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_20();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_20;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ASK_FINAL_QUESTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASK_FINAL_QUESTION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B3_scene_changing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = DetectSceneChange();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DetectSceneChange;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B4_when_play_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_914();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_914;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1107();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1107;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B5_when_play_ends = EMPTY_RULEBOOK;
[ B6_when_scene_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_65();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_65;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B7_when_scene_ends = EMPTY_RULEBOOK;
Constant B8_every_turn = EMPTY_RULEBOOK;
[ B9_action_processing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_22();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_22;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_21();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_21;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_23();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_23;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_VISIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_VISIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_ACCESSIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_ACCESSIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = CARRYING_REQUIREMENTS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CARRYING_REQUIREMENTS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_24();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_24;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = REQUESTED_ACTIONS_REQUIRE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = CARRY_OUT_REQUESTED_ACTIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = DESCEND_TO_SPECIFIC_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_25();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_25;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B10_setting_action_variables 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_151();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_151;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Exit) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_174();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_174;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_186();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_186;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 3 rule(s)
];
[ B11_specific_action_processi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_26();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_26;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_27();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_27;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_28();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_28;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_29();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_29;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_30();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_30;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_31();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_31;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_32();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_32;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B12_player_s_action_awarenes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_33();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_33;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_34();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_34;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_35();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_35;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_36();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_36;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B13_accessibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ACCESS_THROUGH_BARRIERS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ACCESS_THROUGH_BARRIERS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B14_reaching_inside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = CANT_REACH_INSIDE_ROOMS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = CANT_REACH_INSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B15_reaching_outside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = CANT_REACH_OUTSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B16_visibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_37();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_37;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B17_persuasion = EMPTY_RULEBOOK;
Constant B18_unsuccessful_attempt_by = EMPTY_RULEBOOK;
[ B19_before 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_929();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_929;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Ask) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_937();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_937;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Tell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_938();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_938;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Answer) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_939();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_939;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_940();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_940;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1119();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1119;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1120();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1120;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1121();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1121;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1122();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1122;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1123();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1123;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1124();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1124;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1125();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1125;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1126();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1126;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1108();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1108;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Sleep) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1150();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1150;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 15 rule(s)
];
[ B20_instead 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_1215();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1215;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Burn) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1210();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1210;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1214();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1214;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1217();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1217;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1219();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1219;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Drink) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1222();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1222;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1223();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1223;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1157();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1157;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Eat) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1159();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1159;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1205();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1205;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1206();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1206;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Taste) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1207();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1207;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1208();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1208;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Eat) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1224();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1224;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1226();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1226;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1158();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1158;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1225();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1225;
    }
    latest_rule_result-->0 = 0;
    if (action == ##ThrowAt) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1130();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1130;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Insert) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1196();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1196;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##PutOn) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1197();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1197;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##ThrowAt) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1234();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1234;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Attack) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1127();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1127;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1131();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1131;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1132();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1132;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1133();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1133;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1134();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1134;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Touch) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1143();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1143;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1148();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1148;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1149();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1149;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1166();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1166;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1167();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1167;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Attack) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1174();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1174;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1179();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1179;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A91_fucking) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1186();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1186;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1193();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1193;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1195();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1195;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Attack) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1198();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1198;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1200();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1200;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1202();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1202;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Enter) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1213();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1213;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##GetOff) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1216();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1216;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1220();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1220;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1221();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1221;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Attack) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1233();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1233;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1135();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1135;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1142();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1142;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1138();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1138;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1139();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1139;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1141();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1141;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1156();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1156;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1212();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1212;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1129();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1129;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1146();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1146;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1147();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1147;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1184();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1184;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1185();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1185;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1191();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1191;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1199();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1199;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1211();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1211;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1137();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1137;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1168();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1168;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1169();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1169;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1175();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1175;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1176();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1176;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1177();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1177;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1178();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1178;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1180();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1180;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1190();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1190;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1192();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1192;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1194();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1194;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1136();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1136;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1164();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1164;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1165();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1165;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1181();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1181;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1209();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1209;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1232();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1232;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1163();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1163;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1151();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1151;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Listen) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1144();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1144;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1145();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1145;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Listen) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1154();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1154;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1155();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1155;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Listen) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1188();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1188;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1189();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1189;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Listen) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1201();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1201;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1203();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1203;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1204();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1204;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Exit) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1218();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1218;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Listen) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1227();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1227;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Smell) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1228();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1228;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Think) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1115();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1115;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 91 rule(s)
];
Constant B21_check = EMPTY_RULEBOOK;
Constant B22_carry_out = EMPTY_RULEBOOK;
[ B23_after 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Examine) {
        rv = R_1128();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1128;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A82_responding_with) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_946();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_946;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 2 rule(s)
];
Constant B24_report = EMPTY_RULEBOOK;
[ B25_does_the_player_mean 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1187();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1187;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_38();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_38;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Disrobe) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_242();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_242;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A83_talking_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_948();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_948;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 4 rule(s)
];
Constant B26_multiple_action_processi = EMPTY_RULEBOOK;
Constant B27_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B28_when_entire_game_ends = EMPTY_RULEBOOK;
[ B29_before_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_66();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_66;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B30_for_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_NAME_PRINTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_NAME_PRINTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B31_after_printing_the_name = EMPTY_RULEBOOK;
Constant B32_before_printing_the_plur = EMPTY_RULEBOOK;
[ B33_for_printing_the_plural_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_67();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_67;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B34_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B35_before_printing_a_number = EMPTY_RULEBOOK;
[ B36_for_printing_a_number 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_68();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_68;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B37_after_printing_a_number = EMPTY_RULEBOOK;
Constant B38_before_printing_room_des = EMPTY_RULEBOOK;
Constant B39_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B40_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B41_before_printing_inventor = EMPTY_RULEBOOK;
Constant B42_for_printing_inventory_d = EMPTY_RULEBOOK;
Constant B43_after_printing_inventory = EMPTY_RULEBOOK;
Constant B44_before_listing_contents = EMPTY_RULEBOOK;
[ B45_for_listing_contents 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_CONTENTS_LISTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_CONTENTS_LISTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B46_after_listing_contents = EMPTY_RULEBOOK;
Constant B47_before_grouping_together = EMPTY_RULEBOOK;
Constant B48_for_grouping_together = EMPTY_RULEBOOK;
Constant B49_after_grouping_together = EMPTY_RULEBOOK;
Constant B50_before_writing_a_paragra = EMPTY_RULEBOOK;
Constant B51_for_writing_a_paragraph_ = EMPTY_RULEBOOK;
Constant B52_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B53_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B54_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B55_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B56_before_printing_the_name = EMPTY_RULEBOOK;
Constant B57_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B58_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B59_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B60_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B61_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B62_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B63_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B64_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B65_before_printing_the_anno = EMPTY_RULEBOOK;
[ B66_for_printing_the_announc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_69();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_69;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B67_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B68_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B69_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B70_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B71_before_constructing_the_ = EMPTY_RULEBOOK;
[ B72_for_constructing_the_sta 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_910();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_910;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B73_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B74_before_printing_the_bann = EMPTY_RULEBOOK;
Constant B75_for_printing_the_banner_ = EMPTY_RULEBOOK;
Constant B76_after_printing_the_banne = EMPTY_RULEBOOK;
Constant B77_before_reading_a_command = EMPTY_RULEBOOK;
Constant B78_for_reading_a_command = EMPTY_RULEBOOK;
Constant B79_after_reading_a_command = EMPTY_RULEBOOK;
Constant B80_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B81_for_deciding_the_scope = EMPTY_RULEBOOK;
Constant B82_after_deciding_the_scope = EMPTY_RULEBOOK;
Constant B83_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B84_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B85_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B86_before_deciding_whether_ = EMPTY_RULEBOOK;
[ B87_for_deciding_whether_all 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_74();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_74;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_70();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_70;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_73();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_73;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_72();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_72;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_71();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_71;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B88_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B89_before_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B90_for_clarifying_the_parse = EMPTY_RULEBOOK;
Constant B91_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B92_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B93_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B94_after_asking_which_do_yo = EMPTY_RULEBOOK;
[ B95_before_printing_a_parser 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_934();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_934;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_958();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_958;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B96_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B97_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B98_before_supplying_a_missi = EMPTY_RULEBOOK;
[ B99_for_supplying_a_missing_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_75();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_75;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_76();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_76;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_77();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_77;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_162();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_162;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B100_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B101_before_supplying_a_miss = EMPTY_RULEBOOK;
[ B102_for_supplying_a_missing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1109();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1109;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B103_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B104_before_implicitly_takin = EMPTY_RULEBOOK;
[ B105_for_implicitly_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_IMPLICIT_TAKING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_IMPLICIT_TAKING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B106_after_implicitly_taking = EMPTY_RULEBOOK;
[ B107_before_starting_the_vir 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = INITIALISE_MEMORY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return INITIALISE_MEMORY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1076();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1076;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = POSITION_PLAYER_IN_MODEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return POSITION_PLAYER_IN_MODEL_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = ENABLE_GLULX_ACCEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ENABLE_GLULX_ACCEL_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = SEED_RANDOM_NUMBER_GENERATOR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = ASR_CheckForGlk();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASR_CheckForGlk;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = ASR_GGRecoverObjects();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASR_GGRecoverObjects;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B108_for_starting_the_virtua 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = ASR_SoundChannelInitialisation();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASR_SoundChannelInitialisation;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1030();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1030;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B109_after_starting_the_virt 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_961();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_961;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_962();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_962;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B110_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B111_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B112_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B113_before_printing_the_pla = EMPTY_RULEBOOK;
[ B114_for_printing_the_player 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = PRINT_OBITUARY_HEADLINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_OBITUARY_HEADLINE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = PRINT_FINAL_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_FINAL_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = DISPLAY_FINAL_STATUS_LINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B115_after_printing_the_play = EMPTY_RULEBOOK;
[ B116_before_handling_the_fin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_79();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_79;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_78();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_78;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = READ_FINAL_ANSWER_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return READ_FINAL_ANSWER_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B117_for_handling_the_final_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_80();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_80;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B118_after_handling_the_fina = EMPTY_RULEBOOK;
[ B119_before_printing_the_loc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_83();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_83;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_84();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_84;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B120_for_printing_the_locale 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_85();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_85;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_86();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_86;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B121_after_printing_the_loca = EMPTY_RULEBOOK;
Constant B122_before_choosing_notable = EMPTY_RULEBOOK;
[ B123_for_choosing_notable_lo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_87();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_87;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B124_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B125_before_printing_a_local = EMPTY_RULEBOOK;
[ B126_for_printing_a_locale_p 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_94();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_94;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_88();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_88;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_89();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_89;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_90();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_90;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_91();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_91;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_92();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_92;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_93();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_93;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_96();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_96;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_97();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_97;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 9 rule(s)
];
Constant B127_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B128_before_issuing_the_resp = EMPTY_RULEBOOK;
[ B129_for_issuing_the_respons 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_RESPONSE_ISSUING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_RESPONSE_ISSUING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B130_after_issuing_the_respo = EMPTY_RULEBOOK;
Constant B131_check_taking_inventory = EMPTY_RULEBOOK;
[ B132_carry_out_taking_invent 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_98();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_98;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_99();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_99;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B133_report_taking_inventory 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_100();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_100;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B134_check_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_102();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_102;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_103();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_103;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_104();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_104;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_105();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_105;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_106();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_106;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_107();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_107;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_108();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_108;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_109();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_109;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_110();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_110;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_111();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_111;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_112();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_112;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 12 rule(s)
];
[ B135_carry_out_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_113();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_113;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B136_report_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_114();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_114;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B137_check_removing_it_from 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_103();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_103;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_115();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_115;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_116();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_116;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_117();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_117;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B138_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B139_report_removing_it_from = EMPTY_RULEBOOK;
[ B140_check_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_119();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_119;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_118();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_118;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_120();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_120;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_121();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_121;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_122();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_122;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_123();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_123;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B141_carry_out_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_124();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_124;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B142_report_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_125();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_125;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B143_check_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_126();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_126;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_127();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_127;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_128();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_128;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_129();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_129;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_130();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_130;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_131();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_131;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B144_carry_out_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_132();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_132;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B145_report_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_133();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_133;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_134();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_134;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B146_check_inserting_it_into 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_135();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_135;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_136();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_136;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_137();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_137;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_138();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_138;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_139();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_139;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_140();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_140;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_141();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_141;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B147_carry_out_inserting_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_142();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_142;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B148_report_inserting_it_int 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_143();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_143;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_144();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_144;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B149_check_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_145();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_145;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_146();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_146;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_147();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_147;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_148();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_148;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B150_carry_out_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_149();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_149;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B151_report_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_150();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_150;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B152_check_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_152();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_152;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_153();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_153;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_154();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_154;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_155();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_155;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_156();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_156;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_157();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_157;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B153_carry_out_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_158();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_158;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_159();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_159;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_160();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_160;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B154_report_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_161();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_161;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B155_check_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_163();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_163;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_164();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_164;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_165();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_165;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_166();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_166;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_167();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_167;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_168();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_168;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_169();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_169;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_170();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_170;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B156_carry_out_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_171();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_171;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B157_report_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_172();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_172;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_173();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_173;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B158_check_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_175();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_175;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_176();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_176;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_177();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_177;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_178();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_178;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B159_carry_out_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_179();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_179;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B160_report_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_180();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_180;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_181();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_181;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B161_check_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_182();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_182;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B162_carry_out_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_183();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_183;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B163_report_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_184();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_184;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_185();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_185;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B164_check_looking = EMPTY_RULEBOOK;
[ B165_carry_out_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_187();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_187;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_799();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_799;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_189();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_189;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_190();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_190;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_191();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_191;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B166_report_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_192();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_192;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B167_check_examining = EMPTY_RULEBOOK;
[ B168_carry_out_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_193();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_193;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_194();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_194;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_195();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_195;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_196();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_196;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_197();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_197;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_198();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_198;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B169_report_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_199();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_199;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B170_check_looking_under = EMPTY_RULEBOOK;
[ B171_carry_out_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_200();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_200;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B172_report_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_201();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_201;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B173_check_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_202();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_202;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_203();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_203;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B174_carry_out_searching = EMPTY_RULEBOOK;
[ B175_report_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_204();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_204;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_205();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_205;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_206();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_206;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B176_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B177_carry_out_consulting_it = EMPTY_RULEBOOK;
[ B178_report_consulting_it_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_207();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_207;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B179_check_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_208();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_208;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_209();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_209;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_210();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_210;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_211();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_211;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B180_carry_out_locking_it_wi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_212();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_212;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B181_report_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_213();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_213;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B182_check_unlocking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_214();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_214;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_215();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_215;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_216();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_216;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B183_carry_out_unlocking_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_217();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_217;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B184_report_unlocking_it_wit 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_218();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_218;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B185_check_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_219();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_219;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_220();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_220;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B186_carry_out_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_221();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_221;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B187_report_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_222();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_222;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B188_check_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_223();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_223;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_224();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_224;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B189_carry_out_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_225();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_225;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B190_report_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_226();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_226;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B191_check_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_227();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_227;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_228();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_228;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_229();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_229;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B192_carry_out_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_230();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_230;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B193_report_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_231();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_231;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_232();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_232;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B194_check_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_233();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_233;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_234();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_234;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B195_carry_out_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_235();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_235;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B196_report_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_236();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_236;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B197_check_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_237();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_237;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_238();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_238;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_239();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_239;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B198_carry_out_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_240();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_240;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B199_report_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_241();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_241;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B200_check_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_243();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_243;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_244();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_244;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B201_carry_out_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_245();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_245;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B202_report_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_246();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_246;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B203_check_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_247();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_247;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_248();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_248;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_249();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_249;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_250();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_250;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_251();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_251;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_252();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_252;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B204_carry_out_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_253();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_253;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B205_report_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_254();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_254;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B206_check_showing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_255();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_255;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_256();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_256;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_257();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_257;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B207_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B208_report_showing_it_to = EMPTY_RULEBOOK;
[ B209_check_waking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_258();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_258;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B210_carry_out_waking = EMPTY_RULEBOOK;
Constant B211_report_waking = EMPTY_RULEBOOK;
[ B212_check_throwing_it_at 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_259();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_259;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_260();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_260;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_261();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_261;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B213_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B214_report_throwing_it_at = EMPTY_RULEBOOK;
[ B215_check_attacking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_262();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_262;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B216_carry_out_attacking = EMPTY_RULEBOOK;
Constant B217_report_attacking = EMPTY_RULEBOOK;
[ B218_check_kissing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_263();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_263;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_264();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_264;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B219_carry_out_kissing = EMPTY_RULEBOOK;
Constant B220_report_kissing = EMPTY_RULEBOOK;
Constant B221_check_answering_it_that = EMPTY_RULEBOOK;
[ B222_carry_out_answering_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_933();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_933;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B223_report_answering_it_tha = EMPTY_RULEBOOK;
[ B224_check_telling_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_266();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_266;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B225_carry_out_telling_it_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_932();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_932;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B226_report_telling_it_about = EMPTY_RULEBOOK;
Constant B227_check_asking_it_about = EMPTY_RULEBOOK;
[ B228_carry_out_asking_it_abo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_931();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_931;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B229_report_asking_it_about = EMPTY_RULEBOOK;
[ B230_check_asking_it_for 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_269();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_269;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_270();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_270;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B231_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B232_report_asking_it_for = EMPTY_RULEBOOK;
Constant B233_check_waiting = EMPTY_RULEBOOK;
Constant B234_carry_out_waiting = EMPTY_RULEBOOK;
[ B235_report_waiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_271();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_271;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B236_check_touching = EMPTY_RULEBOOK;
Constant B237_carry_out_touching = EMPTY_RULEBOOK;
[ B238_report_touching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_272();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_272;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_273();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_273;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_274();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_274;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B239_check_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_275();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_275;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B240_carry_out_waving = EMPTY_RULEBOOK;
[ B241_report_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_276();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_276;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B242_check_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_277();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_277;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_278();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_278;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_279();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_279;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B243_carry_out_pulling = EMPTY_RULEBOOK;
[ B244_report_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_280();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_280;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B245_check_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_281();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_281;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_282();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_282;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_283();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_283;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B246_carry_out_pushing = EMPTY_RULEBOOK;
[ B247_report_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_284();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_284;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B248_check_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_285();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_285;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_286();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_286;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_287();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_287;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B249_carry_out_turning = EMPTY_RULEBOOK;
[ B250_report_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_288();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_288;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B251_check_pushing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_289();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_289;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_290();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_290;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_291();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_291;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_292();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_292;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_293();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_293;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_294();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_294;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B252_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B253_report_pushing_it_to = EMPTY_RULEBOOK;
[ B254_check_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_295();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_295;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B255_carry_out_squeezing = EMPTY_RULEBOOK;
[ B256_report_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_296();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_296;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B257_check_saying_yes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_297();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_297;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B258_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B259_report_saying_yes = EMPTY_RULEBOOK;
[ B260_check_saying_no 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_298();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_298;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B261_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B262_report_saying_no = EMPTY_RULEBOOK;
[ B263_check_burning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_299();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_299;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B264_carry_out_burning = EMPTY_RULEBOOK;
Constant B265_report_burning = EMPTY_RULEBOOK;
[ B266_check_waking_up 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_300();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_300;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B267_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B268_report_waking_up = EMPTY_RULEBOOK;
[ B269_check_thinking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_301();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_301;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B270_carry_out_thinking = EMPTY_RULEBOOK;
Constant B271_report_thinking = EMPTY_RULEBOOK;
Constant B272_check_smelling = EMPTY_RULEBOOK;
Constant B273_carry_out_smelling = EMPTY_RULEBOOK;
[ B274_report_smelling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_302();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_302;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B275_check_listening_to = EMPTY_RULEBOOK;
Constant B276_carry_out_listening_to = EMPTY_RULEBOOK;
[ B277_report_listening_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_303();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_303;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B278_check_tasting = EMPTY_RULEBOOK;
Constant B279_carry_out_tasting = EMPTY_RULEBOOK;
[ B280_report_tasting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_304();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_304;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B281_check_cutting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_305();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_305;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B282_carry_out_cutting = EMPTY_RULEBOOK;
Constant B283_report_cutting = EMPTY_RULEBOOK;
Constant B284_check_jumping = EMPTY_RULEBOOK;
Constant B285_carry_out_jumping = EMPTY_RULEBOOK;
[ B286_report_jumping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_306();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_306;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B287_check_tying_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_307();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_307;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B288_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B289_report_tying_it_to = EMPTY_RULEBOOK;
[ B290_check_drinking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_308();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_308;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B291_carry_out_drinking = EMPTY_RULEBOOK;
Constant B292_report_drinking = EMPTY_RULEBOOK;
[ B293_check_saying_sorry 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_309();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_309;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B294_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B295_report_saying_sorry = EMPTY_RULEBOOK;
[ B296_check_swinging 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_310();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_310;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B297_carry_out_swinging = EMPTY_RULEBOOK;
Constant B298_report_swinging = EMPTY_RULEBOOK;
[ B299_check_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_311();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_311;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B300_carry_out_rubbing = EMPTY_RULEBOOK;
[ B301_report_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_312();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_312;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B302_check_setting_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_313();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_313;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B303_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B304_report_setting_it_to = EMPTY_RULEBOOK;
Constant B305_check_waving_hands = EMPTY_RULEBOOK;
Constant B306_carry_out_waving_hands = EMPTY_RULEBOOK;
[ B307_report_waving_hands 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_314();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_314;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B308_check_buying 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_315();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_315;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B309_carry_out_buying = EMPTY_RULEBOOK;
Constant B310_report_buying = EMPTY_RULEBOOK;
[ B311_check_climbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_316();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_316;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B312_carry_out_climbing = EMPTY_RULEBOOK;
Constant B313_report_climbing = EMPTY_RULEBOOK;
[ B314_check_sleeping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_317();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_317;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B315_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B316_report_sleeping = EMPTY_RULEBOOK;
Constant B317_check_quitting_the_game = EMPTY_RULEBOOK;
[ B318_carry_out_quitting_the_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = QUIT_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return QUIT_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B319_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B320_check_saving_the_game = EMPTY_RULEBOOK;
[ B321_carry_out_saving_the_ga 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SAVE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SAVE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B322_report_saving_the_game = EMPTY_RULEBOOK;
Constant B323_check_restoring_the_gam = EMPTY_RULEBOOK;
[ B324_carry_out_restoring_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTORE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTORE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B325_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B326_check_restarting_the_ga = EMPTY_RULEBOOK;
[ B327_carry_out_restarting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTART_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTART_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B328_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B329_check_verifying_the_sto = EMPTY_RULEBOOK;
[ B330_carry_out_verifying_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = VERIFY_THE_STORY_FILE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return VERIFY_THE_STORY_FILE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B331_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B332_check_switching_the_sto = EMPTY_RULEBOOK;
[ B333_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B334_report_switching_the_st = EMPTY_RULEBOOK;
Constant B335_check_switching_the_sto = EMPTY_RULEBOOK;
[ B336_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B337_report_switching_the_st = EMPTY_RULEBOOK;
Constant B338_check_requesting_the_st = EMPTY_RULEBOOK;
[ B339_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_STORY_FILE_VERSION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B340_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B341_check_requesting_the_sc = EMPTY_RULEBOOK;
[ B342_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1106();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1106;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ANNOUNCE_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B343_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B344_check_preferring_abbrev = EMPTY_RULEBOOK;
[ B345_carry_out_preferring_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B346_report_preferring_abbre 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B347_check_preferring_unabbr = EMPTY_RULEBOOK;
[ B348_carry_out_preferring_un 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B349_report_preferring_unabb 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B350_check_preferring_someti = EMPTY_RULEBOOK;
[ B351_carry_out_preferring_so 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_SOMETIMES_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B352_report_preferring_somet 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_SOMETIMES_ABBR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B353_check_switching_score_n = EMPTY_RULEBOOK;
[ B354_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B355_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B356_check_switching_score_n = EMPTY_RULEBOOK;
[ B357_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B358_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B359_check_requesting_the_pr = EMPTY_RULEBOOK;
[ B360_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_PRONOUN_MEANINGS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B361_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B362_check_entering_to_room = EMPTY_RULEBOOK;
[ B363_carry_out_entering_to_r 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_828();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_828;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B364_report_entering_to_room = EMPTY_RULEBOOK;
Constant B365_check_bajando = EMPTY_RULEBOOK;
[ B366_carry_out_bajando 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_829();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_829;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B367_report_bajando = EMPTY_RULEBOOK;
Constant B368_check_subiendo = EMPTY_RULEBOOK;
[ B369_carry_out_subiendo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_830();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_830;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B370_report_subiendo = EMPTY_RULEBOOK;
Constant B371_before_pausing_the_game = EMPTY_RULEBOOK;
[ B372_for_pausing_the_game 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_880();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_880;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B373_after_pausing_the_game = EMPTY_RULEBOOK;
Constant B374_before_displaying = EMPTY_RULEBOOK;
[ B375_for_displaying 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_909();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_909;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B376_after_displaying = EMPTY_RULEBOOK;
Constant B377_check_asking_for_help = EMPTY_RULEBOOK;
[ B378_carry_out_asking_for_he 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_922();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_922;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B379_report_asking_for_help = EMPTY_RULEBOOK;
Constant B380_before_quipping = EMPTY_RULEBOOK;
[ B381_for_quipping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_923();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_923;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B382_after_quipping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1152();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1152;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1153();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1153;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1160();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1160;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1161();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1161;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1162();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1162;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1170();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1170;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1171();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1171;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1172();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1172;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1173();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1173;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1182();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1182;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1183();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1183;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1229();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1229;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1230();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1230;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1231();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1231;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 14 rule(s)
];
Constant B383_check_requesting_a_reca = EMPTY_RULEBOOK;
[ B384_carry_out_requesting_a_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_927();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_927;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B385_report_requesting_a_rec = EMPTY_RULEBOOK;
Constant B386_check_responding_with = EMPTY_RULEBOOK;
[ B387_carry_out_responding_wi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_928();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_928;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B388_report_responding_with = EMPTY_RULEBOOK;
[ B389_rq_out_of_range 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_936();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_936;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B390_check_talking_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_944();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_944;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_959();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_959;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B391_carry_out_talking_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_945();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_945;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B392_report_talking_to = EMPTY_RULEBOOK;
Constant B393_check_qbc_responding_wi = EMPTY_RULEBOOK;
[ B394_carry_out_qbc_respondin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_949();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_949;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B395_report_qbc_responding_w = EMPTY_RULEBOOK;
Constant B396_check_qbc_recap = EMPTY_RULEBOOK;
[ B397_carry_out_qbc_recap 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_950();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_950;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B398_report_qbc_recap = EMPTY_RULEBOOK;
[ B399_glulx_zeroing_reference 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = GOR_zeroing();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GOR_zeroing;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1063();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1063;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1064();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1064;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1097();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1097;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B400_glulx_resetting_windows 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1065();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1065;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B401_glulx_resetting_streams 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = GOR_indentify_streams();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GOR_indentify_streams;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B402_glulx_resetting_fileref 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = GOR_indentify_filerefs();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GOR_indentify_filerefs;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B403_glulx_resetting_channel 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = GOR_indentify_schannels();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GOR_indentify_schannels;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B404_glulx_object_updating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1066();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1066;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1057();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1057;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B405_glulx_input_handling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1055();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1055;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1056();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1056;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1012();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1012;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1013();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1013;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1014();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1014;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1015();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1015;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1016();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1016;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1017();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1017;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1018();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1018;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1019();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1019;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 10 rule(s)
];
Constant B406_glulx_timed_activity = EMPTY_RULEBOOK;
Constant B407_glulx_redrawing = EMPTY_RULEBOOK;
Constant B408_glulx_arranging = EMPTY_RULEBOOK;
Constant B409_glulx_sound_notificatio = EMPTY_RULEBOOK;
Constant B410_glulx_mouse_input = EMPTY_RULEBOOK;
Constant B411_glulx_character_input = EMPTY_RULEBOOK;
Constant B412_glulx_line_input = EMPTY_RULEBOOK;
Constant B413_glulx_hyperlink = EMPTY_RULEBOOK;
[ B414_command_counting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1020();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1020;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B415_input_cancelling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1021();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1021;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B416_command_showing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1024();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1024;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B417_command_pasting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1026();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1026;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B418_before_constructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1099();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1099;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1045();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1045;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B419_for_constructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = FW_ConstructGWindow();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return FW_ConstructGWindow;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B420_after_constructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1102();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1102;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1100();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1100;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1046();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1046;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1067();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1067;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1068();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1068;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1098();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1098;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1105();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1105;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1054();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1054;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B421_before_deconstructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1069();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1069;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B422_for_deconstructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1047();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1047;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B423_after_deconstructing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1070();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1070;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B424_before_refreshing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1051();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1051;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B425_for_refreshing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1052();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1052;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B426_after_refreshing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1053();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1053;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B427_check_writing_it_in 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1110();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1110;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B428_carry_out_writing_it_in 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1140();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1140;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B429_report_writing_it_in = EMPTY_RULEBOOK;
[ B430_check_writenothing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1111();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1111;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B431_carry_out_writenothing = EMPTY_RULEBOOK;
Constant B432_report_writenothing = EMPTY_RULEBOOK;
[ B433_check_writenoun 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1112();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1112;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B434_carry_out_writenoun = EMPTY_RULEBOOK;
Constant B435_report_writenoun = EMPTY_RULEBOOK;
[ B436_check_rezaring 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1113();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1113;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B437_carry_out_rezaring = EMPTY_RULEBOOK;
Constant B438_report_rezaring = EMPTY_RULEBOOK;
Constant B439_check_remembering = EMPTY_RULEBOOK;
Constant B440_carry_out_remembering = EMPTY_RULEBOOK;
[ B441_report_remembering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1114();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1114;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B442_check_fucking = EMPTY_RULEBOOK;
Constant B443_carry_out_fucking = EMPTY_RULEBOOK;
[ B444_report_fucking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1116();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1116;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B445_check_faping = EMPTY_RULEBOOK;
Constant B446_carry_out_faping = EMPTY_RULEBOOK;
[ B447_report_faping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1117();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1117;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B448_check_singing = EMPTY_RULEBOOK;
Constant B449_carry_out_singing = EMPTY_RULEBOOK;
[ B450_report_singing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1118();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1118;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Scenes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ DetectSceneChange 
    chs ! count of changes made
    ch ! flag: change made
    ;
    if (scene_status-->0 == 1) {
        if ((((deadflag~=0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(43, 1, p70_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; FollowRulebook(28);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((((deadflag==0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(27);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    .CScene;
    if (chs>20) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus 
    chs ! internal use only
    sc ! internal use only
    ch ! internal use only
    ;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended";
            print "^";
        }
    }
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The New Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Data
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requirements Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Try Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkValueFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: I6 Angle Brackets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	if (converted_action_outcome == true) FollowRulebook( 23, nothing, true );
	rtrue;
];

[ ConvertToRequest X AN Y Z;
	WORK_OUT_DETAILS_OF_SPECIFIC_R();
	if (X == player) TryAction(false, X, AN, Y, Z);
	else TryAction(true, X, AN, Y, Z);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Implicit Take
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ImplicitTake obj ks;
	if (actor == player) { STANDARD_IMPLICIT_TAKING_RM('A', obj); }
	else {
		if (TestVisibility(player, actor))
			STANDARD_IMPLICIT_TAKING_RM('B', obj, actor);
	}
	ClearParagraphing(3);
	@push keep_silent; keep_silent = true;
	@push say__p; @push say__pc; ClearParagraphing(4);
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	DivideParagraphPoint(); @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Look After Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Abbreviated Room Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		FollowRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Begin Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginAction a n s moi notrack  rv;
	ChronologyPoint();

	@push action; @push noun; @push second; @push self; @push multiple_object_item;

	action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	if (action < 4096) rv = ActionPrimitive();

	@pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;
	
	if (notrack == false) TrackActions(true, meta);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (actor ~= player) { ACTION_PROCESSING_INTERNAL_RM('K'); new_line; }
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	FollowRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing(5);
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	if ((meta) && (actor ~= player)) {
		ACTION_PROCESSING_INTERNAL_RM('A', actor); new_line; rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { FollowRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACTION_PROCESSING_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Type Safety
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = nothing; ! noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = nothing; ! second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }
	meta = 0;

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('B'); new_line; }
	        rtrue;
	    }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('C'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('D'); new_line; }
		        rtrue;
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('E'); new_line; }
	        rtrue;
	    }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('F'); new_line; }
	        rtrue;
	    }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('G'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('H'); new_line; }
		        rtrue;
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('I'); new_line; }
	        rtrue;
	    }
	}

	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Visibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(FollowRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) {
			BASIC_VISIBILITY_RM('A'); new_line;
		}
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Accessibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(noun, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(second, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carrying Requirements Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
 			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Standard Implicit Taking Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_IMPLICIT_TAKING_R;
	ImplicitTake(parameter_value);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requested Actions Require Persuasion Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = FollowRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) {
				REQUESTED_ACTIONS_REQUIRE_RM('A', actor);
				new_line;
			}
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carry Out Requested Actions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) {
				CARRY_OUT_REQUESTED_ACTIONS_RM('A', actor); new_line;
			}
		}
		@pull act_requester;
		FollowRulebook(AFTER_RB);
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Generic Verb Subroutine
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Work Out Details Of Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Actions Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Printing Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: The Activities Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Rule Debugging Inhibition
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or
			LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)
				inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Testing Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Emptiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_for_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_after_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (rulebooks_array-->rb ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Process Activity Rulebook
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = FollowRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Carrying Out Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Begin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: For
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Abandon
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Resource Usage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array ResourceUsageFlags ->
	(13+3+5);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Figures
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Sound Effects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Language
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF PLUGIN_FILES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Structure
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Instances
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Glulx Material
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Existence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Readiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Open File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Close File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Put Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Contents
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutContents extf text append_flag  struc str ch oldstream;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	oldstream = glk_stream_get_current();
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing(19);
	TEXT_TY_Say(text);
	FileIO_Close(extf);
	if (oldstream) glk_stream_set_current(oldstream);
	@pull say__pc; @pull say__p;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Serialising Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutTable extf tab rv  struc oldstream;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	oldstream = glk_stream_get_current();
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (oldstream) glk_stream_set_current(oldstream);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Z-Machine Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Back To Core
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: The Memory Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Create Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Destroy Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Seek Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Backtrace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Nonexistent Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Rulebook Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 RBSTVC_9 0 RBSTVC_11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#endif;
[  RBSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Activity Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 AVSTVC_39 0;
[  AVSTVC_39 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = I197_all_windows; pos++;
    } else {
        pos++;
    }
    return 1;
];


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Perform Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Perform_Undo;
	#ifdef PREVENT_UNDO; IMMEDIATELY_UNDO_RM('A'); new_line; return; #endif;
	if (IterationsOfTurnSequence == 0) { IMMEDIATELY_UNDO_RM('B'); new_line; return; }
	if (undo_flag == 0) { IMMEDIATELY_UNDO_RM('C'); new_line; return; }
	if (undo_flag == 1) { IMMEDIATELY_UNDO_RM('D'); new_line; return; }
	if (VM_Undo() == 0) { IMMEDIATELY_UNDO_RM('F'); new_line; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_RM('C'); new_line;
	#ifnot; ANNOUNCE_SCORE_RM('A'); PrintRank();
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_ON_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_OFF_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_SOMETIMES_ABBR_RM('A'); new_line;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_UNABBREVIATED_RM('A'); new_line;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_ABBREVIATED_RM('A'); new_line;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Pronoun Meanings Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	ANNOUNCE_PRONOUN_MEANINGS_RM('A');

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) { ANNOUNCE_PRONOUN_MEANINGS_RM('D'); rtrue; }

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) ANNOUNCE_PRONOUN_MEANINGS_RM('C');
		else { ANNOUNCE_PRONOUN_MEANINGS_RM('B'); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) {
			#ifdef SERIAL_COMMA; print ","; #endif;
			LIST_WRITER_INTERNAL_RM('C');
		}
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; ANNOUNCE_PRONOUN_MEANINGS_RM('B');
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Paragraph Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant TRACE_I7_SPACING;

[ ClearParagraphing r;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		say__pc_save = true;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
	say__pc_save = (say__pc & PARA_COMPLETED);
];

[ AdjustParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[APP ", say__p, " ", say__pc, " ", say__pc_save, "]^"; #endif;
	if (say__pc_save) say__pc = (say__pc | PARA_COMPLETED);
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing(10);
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing(11);
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing(12);
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	TEXT_TY_Say(matter);
	DivideParagraphPoint(13);
	say__pc = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Prompt
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintPrompt i;
	RunTimeProblemShow();
	ClearRTP();
	style roman;
	EnsureBreakBeforePrompt();
	TEXT_TY_Say( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing(14);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Boxed Quotations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing(15);
		pending_boxed_quotation();
		ClearParagraphing(16);

		pending_boxed_quotation = 0;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Score Notification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NotifyTheScore d;
#Iftrue USE_SCORING ~= 0;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		d = score-last_score;
		if (d > 0) { ANNOUNCE_SCORE_RM('D', d); }
		else if (d < 0) { ANNOUNCE_SCORE_RM('E', -d); }
		new_line;
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing(17);
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			TEXT_TY_Say(left_hand_status_line);
			VM_MoveCursorInStatusLine(1, posb);
			TEXT_TY_Say(right_hand_status_line);
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing(18);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line Utilities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array T_SL_Score_Moves --> CONSTANT_PACKED_TEXT_STORAGE SL_Score_Moves;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#Iftrue USE_SCORING > 0; print sline1, "/", sline2; #endif;
];

Array T_SL_Location --> CONSTANT_PACKED_TEXT_STORAGE SL_Location;

[ SL_Location even_before;
	if ((not_yet_in_play) && (even_before == false)) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			DARKNESS_NAME_INTERNAL_RM('A');
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ DARKNESS_NAME_INTERNAL_R; ];



[ Banner;
		!print (string) Story;!deprecated
		!print " / Inform 7 build ", (string) NI_BUILD_COUNT, " ";!deprecated
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		TEXT_TY_Say(Story);
		VM_Style(NORMAL_VMSTY);
		new_line;
		TEXT_TY_Say(Headline);
		#ifdef Story_Author;
		!print " by "; TEXT_TY_Say(Story_Author);
    print " por "; TEXT_TY_Say(Story_Author);! infsp hack 'by'
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (PrintI6Text) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (PrintI6Text) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);

];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Banner (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Decimal Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DecimalNumber num; print num; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print English Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EnglishNumber n; LanguageNumber(n); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintI6Text x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) return (x)();
	if (x == EMPTY_TEXT_PACKED) rfalse;
	rtrue;
];
[ I7_String x; TEXT_TY_Say(x); ]; ! An alternative name now used only by extensions


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Or Run
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintOrRun obj prop no_break  pv st routine_return_value;
	@push self; self = obj;
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		routine_return_value = TEXT_TY_Say(obj.prop);
	}
	@pull self;
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			DivideParagraphPoint();
		}
	}

	return routine_return_value;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Short Name Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PSN__ o;
    if (o == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Standard Name Printing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_value;
    if (obj == 0) {
    	LIST_WRITER_INTERNAL_RM('Y'); return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) PRINT_PROTAGONIST_INTERNAL_RM('A');
   	    else PRINT_PROTAGONIST_INTERNAL_RM('B');
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_PROTAGONIST_INTERNAL_R; ];



Global short_name_case;

!para q funcione con (el_):
[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);


!    if (pluralise) {
! [infsp]: para q funcione con (el_), se agrego '>0' para el correcto funcionamiento (sino al final imprime el nombre de objeto cuando yo solo quiero imprimir su articulo)
    if (pluralise>0) { ![INFSP] ej, en ListMiscellany 19,[TODO] esto podria resolverse como los italianos
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names II (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names III
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('X'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        TEXT_TY_Say_Capitalised(obj.article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];


[ IndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print "a ",(PSN__) obj; indef_mode = i; return; }!infsp
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;

];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say One Of
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = (MAX_POSITIVE_NUMBER-1)/cc;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Records
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RR_NAME     		5;
Constant RR_PERMISSIONS		6;
Constant RR_STORAGE			7;
Constant RR_KIND			8;
Constant RR_HANDLER			9;
Constant RR_DESCRIPTION		10;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Valency Adjectives
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler i;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Symmetric One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To Various Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Equivalence Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Various to Various
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Reversed One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Equivalence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) RlnGetF(relation, RR_DESCRIPTION), ":^";
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Emptying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		objectloop (obj2 provides relation_property) {
			obj1 = obj2.relation_property;
			if (obj1) {
				if (clear) obj2.relation_property = nothing;
				else rfalse;
			}
		}
	} else {
		for (obj2=1: obj2<=N2: obj2++) {
			obj1 = GProperty(t2, obj2, relation_property);
			if (obj1) {
				if (clear) WriteGProperty(t2, obj2, relation_property, 0);
				else rfalse;
			}
		}
	}
	if (t1 ~= t2) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1 provides relation_property) {
				obj2 = obj1.relation_property;
				if (obj2) {
					if (clear) obj1.relation_property = nothing;
					else rfalse;
				}
			}
		} else {
			for (obj1=1: obj1<=N2: obj1++) {
				obj2 = GProperty(t1, obj1, relation_property);
				if (obj2) {
					if (clear) WriteGProperty(t1, obj1, relation_property, 0);
					else rfalse;
				}
			}
		}
	}
	rtrue;
];
[ Relation_EmptyEquiv relation sym clear
	relation_property obj1 obj2 t N v;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (clear) {
		v = 1;
		if (t == OBJECT_TY) {
			objectloop (obj1 provides relation_property)
				obj1.relation_property = v++;
		} else {
			for (obj1=1: obj1<=N: obj1++)
				WriteGProperty(t, obj1, relation_property, v++);
		}
		rtrue;
	}	
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			objectloop (obj2 provides relation_property)
				if ((obj1 < obj2) && (obj1.relation_property == obj2.relation_property))
					rfalse;
	} else {
		for (obj1=1: obj1<=N: obj1++)
			for (obj2=obj1+1: obj1<=N: obj1++)
				if (GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))
					rfalse;
	}
	rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
			objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
			for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
			objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
		}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Map Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Cache Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUM_DOORS = 0;
Constant NUM_ROOMS = 8;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK1_Count)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK4_Count)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK1_Count)*No_Directions + dir.IK3_Count);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_ROUTE_LENGTH = 84 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((RlnGetF(relation, RR_PERMISSIONS)) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (RlnGetF(relation, RR_STORAGE) == 0) return nothing;
	handler = RlnGetF(relation, RR_HANDLER);
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To One Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (next == to) return start.vector;
		from = next;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = RlnGetF(relation, RR_STORAGE)-->2; ! Number of left instances
	left_ix = RlnGetF(relation, RR_STORAGE)-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return ox;
			return nothing;
		} else {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Iterating Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IterateRelations callback;
	callback(Rel_Record_67);
    callback(Rel_Record_69);

];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Reporting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RTP_Buffer --> 7;
[ RunTimeProblem n par1 par2 par3 ln file;
	if (RTP_Buffer-->0 == -1) {
		RTP_Buffer-->0 = n; 
		RTP_Buffer-->1 = par1; 
		RTP_Buffer-->2 = par2;
		RTP_Buffer-->3 = par3;
		RTP_Buffer-->4 = ln;
		RTP_Buffer-->5 = file;
	}
	RunTimeProblemShow();
];
[ ClearRTP;
	RTP_Buffer-->0 = -1;
	RTP_Buffer-->6 = false;
];
[ SuspendRTP;
	RTP_Buffer-->6 = true;
];
[ ResumeRTP;
	RTP_Buffer-->6 = false;
];
[ RunTimeProblemShow   n par1 par2 par3 ln file i c;
	if (RTP_Buffer-->0 == -1 or -2) return;
	if (RTP_Buffer-->6) return;

	n = RTP_Buffer-->0; 
	par1 = RTP_Buffer-->1; 
	par2 = RTP_Buffer-->2;
	par3 = RTP_Buffer-->3;
	ln = RTP_Buffer-->4;
	file = RTP_Buffer-->5;
	RTP_Buffer-->0 = -2;

	print "^*** Run-time problem P", n;
	if (ln) {
		print " (at paragraph ", ln, " in ";
		if (file == 0) print "the source text";
		else ShowOneExtension(file);
		print ")";
	}
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1, ", which is not a person.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) RlnGetF(par2, RR_DESCRIPTION), "'.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOTABLE2:
			print "Attempt to access an entry from a non-existent table.^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object: property ",
				(PrintPropertyName) par2, "^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTBEOFFSTAGE:
			print "Attempt to move the player off-stage.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_LISTSIZENEGATIVE:
			print "Attempt to resize list to ", par1, " entries - there must ",
			"always be 0 or more.^";	
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTTHING:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		RTP_WRONGASSIGNEDKIND:
			print "Attempt to set a variable to the wrong kind of object: ",
				"you wrote '", (string) par2, "', which sets the value to ", (the) par1,
				" - but that doesn't have the kind '", (string) par3, "'.^";			
		RTP_RELKINDVIOLATION:
			print "Tried to change a relation for objects with the wrong kinds: ",
				(string) RlnGetF(par3, RR_DESCRIPTION), ", but you tried to ",
				"relate (or unrelate) ", (the) par1, " to ", (the) par2, ".^";
		RTP_CANTMAKEPART:
			print "Tried to make the player part of something: ",
				(the) par1, ".^";
		RTP_TEXTTOKENTOOHARD:
			print "This use of '[text]' is too complicated.^";
		RTP_RELATIONCHANGEIMPOSSIBLE:
			print "This change of the relation's nature is impossible in play.^";
		RTP_RELMINIMAL:
			print "This operation can't be done with the relation '",
				(string) RlnGetF(par3, RR_DESCRIPTION), "'.^";
		RTP_REGIONSNOTADJACENT:
			print "You can't test whether something is adjacent to a region: ",
				"such as, in this case, ", (the) par1, ".^";
		}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Low-Level Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Argument Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ArgumentTypeFailed line file;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Return Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Whether Provides
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides KD_Count) {
		l = obj.KD_Count;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ PrintPropertyName  p  off textual;
	if (p<0) p = ~p;
	off = valued_property_offsets-->p;
	textual = property_metadata-->off;
	print (string) textual;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Scan Property Metadata
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Get Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Set Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	} else {
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
	}
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Write Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Printing Property Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PROPERTY_TY_Say v;
	print "property ", v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Latest Rule Result
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RS_NEITHER		= 0;
Constant RS_SUCCEEDS	= 1;
Constant RS_FAILS		= 2;

Array latest_rule_result --> 3;

[ RecordRuleOutcome usage rule1 rule2;
	if ((latest_rule_result-->0 == RS_SUCCEEDS or RS_FAILS) &&
		(KOVIsBlockValue(latest_rule_result-->1)))
		BlkValueFree(latest_rule_result-->2);
	if ((usage == RS_SUCCEEDS or RS_FAILS) && (KOVIsBlockValue(rule1)))
		rule2 = BlkValueCopy(BlkValueCreate(rule1), rule2);
	latest_rule_result-->0 = usage;
	latest_rule_result-->1 = rule1;
	latest_rule_result-->2 = rule2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Following
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ FollowRulebook rulebook parameter no_paragraph_skips
	rv ss spv;
	ss = self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) { self = parameter; parameter_object = parameter; }
	spv = parameter_value; parameter_value = parameter;
	! we won't need parameter again, so can reuse it
	parameter = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) {
		DebugRulebooks(rulebook, parameter);
		process_rulebook_count = process_rulebook_count + debugging_rules;
	}
	#endif;
	if ((rulebook >= 0) && (rulebook < NUMBER_RULEBOOKS_CREATED)) {
		rv = rulebooks_array-->rulebook;
		if (rv ~= EMPTY_RULEBOOK) {
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(rulebook);
			if (say__p) RulebookParBreak(no_paragraph_skips);
			rv = rv(no_paragraph_skips);
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(rulebook);
		} else {
			rv = 0;
		}
	} else {
		if (say__p) RulebookParBreak(no_paragraph_skips);
		rv = indirect(rulebook);
		if (rv == 2) rv = reason_the_action_failed;
		else if (rv) rv = rulebook;
	}
	if (rv) {
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			process_rulebook_count = process_rulebook_count - debugging_rules;
			if (process_rulebook_count < 0) process_rulebook_count = 0;
			spaces(2*process_rulebook_count);
	  	    if (latest_rule_result-->0 == RS_SUCCEEDS) print "[stopped: success]^";
	  	    if (latest_rule_result-->0 == RS_FAILS) print "[stopped: fail]^";
		}
		#endif;
	} else {
		if (debugging_rules)
			process_rulebook_count = process_rulebook_count - debugging_rules;
		latest_rule_result-->0 = RS_NEITHER;
	}
	debugging_rules = parameter;
	self = ss; parameter_value = spv;
	return rv;
];

[ RulebookParBreak no_paragraph_skips;
	if ((no_paragraph_skips == false) && (say__pc & PARA_NORULEBOOKBREAKS == 0))
		DivideParagraphPoint();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Specifying Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds weak_kind value;
	RecordRuleOutcome(RS_SUCCEEDS, weak_kind, value);
];

[ RulebookFails weak_kind value;
	RecordRuleOutcome(RS_FAILS, weak_kind, value);
];

[ RuleHasNoOutcome;
	RecordRuleOutcome(RS_NEITHER, 0, 0);
];

[ SetRulebookOutcome a;
	latest_rule_result-->0 = a;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Discovering Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulebookOutcome a;
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (latest_rule_result-->0 == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (latest_rule_result-->0 == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) FollowRulebook(RB, V, F);
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = latest_rule_result-->1;
		if (a) return latest_rule_result-->2;
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Printing Rule Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Startup rulebook" ! 0
    "Turn sequence rulebook" ! 1
    "Shutdown rulebook" ! 2
    "Scene changing rulebook" ! 3
    "When play begins rulebook" ! 4
    "When play ends rulebook" ! 5
    "When scene begins rulebook" ! 6
    "When scene ends rulebook" ! 7
    "Every turn rulebook" ! 8
    "Action-processing rulebook" ! 9
    "Setting action variables rulebook" ! 10
    "specific action-processing rulebook" ! 11
    "player's action awareness rulebook" ! 12
    "Accessibility rulebook" ! 13
    "Reaching inside rulebook" ! 14
    "Reaching outside rulebook" ! 15
    "Visibility rulebook" ! 16
    "Persuasion rulebook" ! 17
    "Unsuccessful attempt by rulebook" ! 18
    "Before rulebook" ! 19
    "Instead rulebook" ! 20
    "Check rulebook" ! 21
    "Carry out rulebook" ! 22
    "After rulebook" ! 23
    "Report rulebook" ! 24
    "does the player mean rulebook" ! 25
    "multiple action processing rulebook" ! 26
    "when Entire Game begins rulebook" ! 27
    "when Entire Game ends rulebook" ! 28
    "before Printing the name rulebook" ! 29
    "for Printing the name rulebook" ! 30
    "after Printing the name rulebook" ! 31
    "before Printing the plural name rulebook" ! 32
    "for Printing the plural name rulebook" ! 33
    "after Printing the plural name rulebook" ! 34
    "before Printing a number rulebook" ! 35
    "for Printing a number rulebook" ! 36
    "after Printing a number rulebook" ! 37
    "before Printing room description details rulebook" ! 38
    "for Printing room description details rulebook" ! 39
    "after Printing room description details rulebook" ! 40
    "before Printing inventory details rulebook" ! 41
    "for Printing inventory details rulebook" ! 42
    "after Printing inventory details rulebook" ! 43
    "before Listing contents rulebook" ! 44
    "for Listing contents rulebook" ! 45
    "after Listing contents rulebook" ! 46
    "before Grouping together rulebook" ! 47
    "for Grouping together rulebook" ! 48
    "after Grouping together rulebook" ! 49
    "before Writing a paragraph about rulebook" ! 50
    "for Writing a paragraph about rulebook" ! 51
    "after Writing a paragraph about rulebook" ! 52
    "before Listing nondescript items rulebook" ! 53
    "for Listing nondescript items rulebook" ! 54
    "after Listing nondescript items rulebook" ! 55
    "before Printing the name of a dark room rulebook" ! 56
    "for Printing the name of a dark room rulebook" ! 57
    "after Printing the name of a dark room rulebook" ! 58
    "before Printing the description of a dark room rulebook" ! 59
    "for Printing the description of a dark room rulebook" ! 60
    "after Printing the description of a dark room rulebook" ! 61
    "before Printing the announcement of darkness rulebook" ! 62
    "for Printing the announcement of darkness rulebook" ! 63
    "after Printing the announcement of darkness rulebook" ! 64
    "before Printing the announcement of light rulebook" ! 65
    "for Printing the announcement of light rulebook" ! 66
    "after Printing the announcement of light rulebook" ! 67
    "before Printing a refusal to act in the dark rulebook" ! 68
    "for Printing a refusal to act in the dark rulebook" ! 69
    "after Printing a refusal to act in the dark rulebook" ! 70
    "before Constructing the status line rulebook" ! 71
    "for Constructing the status line rulebook" ! 72
    "after Constructing the status line rulebook" ! 73
    "before Printing the banner text rulebook" ! 74
    "for Printing the banner text rulebook" ! 75
    "after Printing the banner text rulebook" ! 76
    "before Reading a command rulebook" ! 77
    "for Reading a command rulebook" ! 78
    "after Reading a command rulebook" ! 79
    "before Deciding the scope rulebook" ! 80
    "for Deciding the scope rulebook" ! 81
    "after Deciding the scope rulebook" ! 82
    "before Deciding the concealed possessions rulebook" ! 83
    "for Deciding the concealed possessions rulebook" ! 84
    "after Deciding the concealed possessions rulebook" ! 85
    "before Deciding whether all includes rulebook" ! 86
    "for Deciding whether all includes rulebook" ! 87
    "after Deciding whether all includes rulebook" ! 88
    "before Clarifying the parser's choice rulebook" ! 89
    "for Clarifying the parser's choice rulebook" ! 90
    "after Clarifying the parser's choice rulebook" ! 91
    "before Asking which do you mean rulebook" ! 92
    "for Asking which do you mean rulebook" ! 93
    "after Asking which do you mean rulebook" ! 94
    "before Printing a parser error rulebook" ! 95
    "for Printing a parser error rulebook" ! 96
    "after Printing a parser error rulebook" ! 97
    "before Supplying a missing noun rulebook" ! 98
    "for Supplying a missing noun rulebook" ! 99
    "after Supplying a missing noun rulebook" ! 100
    "before Supplying a missing second noun rulebook" ! 101
    "for Supplying a missing second noun rulebook" ! 102
    "after Supplying a missing second noun rulebook" ! 103
    "before Implicitly taking rulebook" ! 104
    "for Implicitly taking rulebook" ! 105
    "after Implicitly taking rulebook" ! 106
    "before Starting the virtual machine rulebook" ! 107
    "for Starting the virtual machine rulebook" ! 108
    "after Starting the virtual machine rulebook" ! 109
    "before Amusing a victorious player rulebook" ! 110
    "for Amusing a victorious player rulebook" ! 111
    "after Amusing a victorious player rulebook" ! 112
    "before Printing the player's obituary rulebook" ! 113
    "for Printing the player's obituary rulebook" ! 114
    "after Printing the player's obituary rulebook" ! 115
    "before Handling the final question rulebook" ! 116
    "for Handling the final question rulebook" ! 117
    "after Handling the final question rulebook" ! 118
    "before Printing the locale description rulebook" ! 119
    "for Printing the locale description rulebook" ! 120
    "after Printing the locale description rulebook" ! 121
    "before Choosing notable locale objects rulebook" ! 122
    "for Choosing notable locale objects rulebook" ! 123
    "after Choosing notable locale objects rulebook" ! 124
    "before Printing a locale paragraph about rulebook" ! 125
    "for Printing a locale paragraph about rulebook" ! 126
    "after Printing a locale paragraph about rulebook" ! 127
    "before Issuing the response text rulebook" ! 128
    "for Issuing the response text rulebook" ! 129
    "after Issuing the response text rulebook" ! 130
    "check Taking inventory rulebook" ! 131
    "carry out Taking inventory rulebook" ! 132
    "report Taking inventory rulebook" ! 133
    "check Taking rulebook" ! 134
    "carry out Taking rulebook" ! 135
    "report Taking rulebook" ! 136
    "check Removing it from rulebook" ! 137
    "carry out Removing it from rulebook" ! 138
    "report Removing it from rulebook" ! 139
    "check Dropping rulebook" ! 140
    "carry out Dropping rulebook" ! 141
    "report Dropping rulebook" ! 142
    "check Putting it on rulebook" ! 143
    "carry out Putting it on rulebook" ! 144
    "report Putting it on rulebook" ! 145
    "check Inserting it into rulebook" ! 146
    "carry out Inserting it into rulebook" ! 147
    "report Inserting it into rulebook" ! 148
    "check Eating rulebook" ! 149
    "carry out Eating rulebook" ! 150
    "report Eating rulebook" ! 151
    "check Going rulebook" ! 152
    "carry out Going rulebook" ! 153
    "report Going rulebook" ! 154
    "check Entering rulebook" ! 155
    "carry out Entering rulebook" ! 156
    "report Entering rulebook" ! 157
    "check Exiting rulebook" ! 158
    "carry out Exiting rulebook" ! 159
    "report Exiting rulebook" ! 160
    "check Getting off rulebook" ! 161
    "carry out Getting off rulebook" ! 162
    "report Getting off rulebook" ! 163
    "check Looking rulebook" ! 164
    "carry out Looking rulebook" ! 165
    "report Looking rulebook" ! 166
    "check Examining rulebook" ! 167
    "carry out Examining rulebook" ! 168
    "report Examining rulebook" ! 169
    "check Looking under rulebook" ! 170
    "carry out Looking under rulebook" ! 171
    "report Looking under rulebook" ! 172
    "check Searching rulebook" ! 173
    "carry out Searching rulebook" ! 174
    "report Searching rulebook" ! 175
    "check Consulting it about rulebook" ! 176
    "carry out Consulting it about rulebook" ! 177
    "report Consulting it about rulebook" ! 178
    "check Locking it with rulebook" ! 179
    "carry out Locking it with rulebook" ! 180
    "report Locking it with rulebook" ! 181
    "check Unlocking it with rulebook" ! 182
    "carry out Unlocking it with rulebook" ! 183
    "report Unlocking it with rulebook" ! 184
    "check Switching on rulebook" ! 185
    "carry out Switching on rulebook" ! 186
    "report Switching on rulebook" ! 187
    "check Switching off rulebook" ! 188
    "carry out Switching off rulebook" ! 189
    "report Switching off rulebook" ! 190
    "check Opening rulebook" ! 191
    "carry out Opening rulebook" ! 192
    "report Opening rulebook" ! 193
    "check Closing rulebook" ! 194
    "carry out Closing rulebook" ! 195
    "report Closing rulebook" ! 196
    "check Wearing rulebook" ! 197
    "carry out Wearing rulebook" ! 198
    "report Wearing rulebook" ! 199
    "check Taking off rulebook" ! 200
    "carry out Taking off rulebook" ! 201
    "report Taking off rulebook" ! 202
    "check Giving it to rulebook" ! 203
    "carry out Giving it to rulebook" ! 204
    "report Giving it to rulebook" ! 205
    "check Showing it to rulebook" ! 206
    "carry out Showing it to rulebook" ! 207
    "report Showing it to rulebook" ! 208
    "check Waking rulebook" ! 209
    "carry out Waking rulebook" ! 210
    "report Waking rulebook" ! 211
    "check Throwing it at rulebook" ! 212
    "carry out Throwing it at rulebook" ! 213
    "report Throwing it at rulebook" ! 214
    "check Attacking rulebook" ! 215
    "carry out Attacking rulebook" ! 216
    "report Attacking rulebook" ! 217
    "check Kissing rulebook" ! 218
    "carry out Kissing rulebook" ! 219
    "report Kissing rulebook" ! 220
    "check Answering it that rulebook" ! 221
    "carry out Answering it that rulebook" ! 222
    "report Answering it that rulebook" ! 223
    "check Telling it about rulebook" ! 224
    "carry out Telling it about rulebook" ! 225
    "report Telling it about rulebook" ! 226
    "check Asking it about rulebook" ! 227
    "carry out Asking it about rulebook" ! 228
    "report Asking it about rulebook" ! 229
    "check Asking it for rulebook" ! 230
    "carry out Asking it for rulebook" ! 231
    "report Asking it for rulebook" ! 232
    "check Waiting rulebook" ! 233
    "carry out Waiting rulebook" ! 234
    "report Waiting rulebook" ! 235
    "check Touching rulebook" ! 236
    "carry out Touching rulebook" ! 237
    "report Touching rulebook" ! 238
    "check Waving rulebook" ! 239
    "carry out Waving rulebook" ! 240
    "report Waving rulebook" ! 241
    "check Pulling rulebook" ! 242
    "carry out Pulling rulebook" ! 243
    "report Pulling rulebook" ! 244
    "check Pushing rulebook" ! 245
    "carry out Pushing rulebook" ! 246
    "report Pushing rulebook" ! 247
    "check Turning rulebook" ! 248
    "carry out Turning rulebook" ! 249
    "report Turning rulebook" ! 250
    "check Pushing it to rulebook" ! 251
    "carry out Pushing it to rulebook" ! 252
    "report Pushing it to rulebook" ! 253
    "check Squeezing rulebook" ! 254
    "carry out Squeezing rulebook" ! 255
    "report Squeezing rulebook" ! 256
    "check Saying yes rulebook" ! 257
    "carry out Saying yes rulebook" ! 258
    "report Saying yes rulebook" ! 259
    "check Saying no rulebook" ! 260
    "carry out Saying no rulebook" ! 261
    "report Saying no rulebook" ! 262
    "check Burning rulebook" ! 263
    "carry out Burning rulebook" ! 264
    "report Burning rulebook" ! 265
    "check Waking up rulebook" ! 266
    "carry out Waking up rulebook" ! 267
    "report Waking up rulebook" ! 268
    "check Thinking rulebook" ! 269
    "carry out Thinking rulebook" ! 270
    "report Thinking rulebook" ! 271
    "check Smelling rulebook" ! 272
    "carry out Smelling rulebook" ! 273
    "report Smelling rulebook" ! 274
    "check Listening to rulebook" ! 275
    "carry out Listening to rulebook" ! 276
    "report Listening to rulebook" ! 277
    "check Tasting rulebook" ! 278
    "carry out Tasting rulebook" ! 279
    "report Tasting rulebook" ! 280
    "check Cutting rulebook" ! 281
    "carry out Cutting rulebook" ! 282
    "report Cutting rulebook" ! 283
    "check Jumping rulebook" ! 284
    "carry out Jumping rulebook" ! 285
    "report Jumping rulebook" ! 286
    "check Tying it to rulebook" ! 287
    "carry out Tying it to rulebook" ! 288
    "report Tying it to rulebook" ! 289
    "check Drinking rulebook" ! 290
    "carry out Drinking rulebook" ! 291
    "report Drinking rulebook" ! 292
    "check Saying sorry rulebook" ! 293
    "carry out Saying sorry rulebook" ! 294
    "report Saying sorry rulebook" ! 295
    "check Swinging rulebook" ! 296
    "carry out Swinging rulebook" ! 297
    "report Swinging rulebook" ! 298
    "check Rubbing rulebook" ! 299
    "carry out Rubbing rulebook" ! 300
    "report Rubbing rulebook" ! 301
    "check Setting it to rulebook" ! 302
    "carry out Setting it to rulebook" ! 303
    "report Setting it to rulebook" ! 304
    "check Waving hands rulebook" ! 305
    "carry out Waving hands rulebook" ! 306
    "report Waving hands rulebook" ! 307
    "check Buying rulebook" ! 308
    "carry out Buying rulebook" ! 309
    "report Buying rulebook" ! 310
    "check Climbing rulebook" ! 311
    "carry out Climbing rulebook" ! 312
    "report Climbing rulebook" ! 313
    "check Sleeping rulebook" ! 314
    "carry out Sleeping rulebook" ! 315
    "report Sleeping rulebook" ! 316
    "check Quitting the game rulebook" ! 317
    "carry out Quitting the game rulebook" ! 318
    "report Quitting the game rulebook" ! 319
    "check Saving the game rulebook" ! 320
    "carry out Saving the game rulebook" ! 321
    "report Saving the game rulebook" ! 322
    "check Restoring the game rulebook" ! 323
    "carry out Restoring the game rulebook" ! 324
    "report Restoring the game rulebook" ! 325
    "check Restarting the game rulebook" ! 326
    "carry out Restarting the game rulebook" ! 327
    "report Restarting the game rulebook" ! 328
    "check Verifying the story file rulebook" ! 329
    "carry out Verifying the story file rulebook" ! 330
    "report Verifying the story file rulebook" ! 331
    "check Switching the story transcript on rulebook" ! 332
    "carry out Switching the story transcript on rulebook" ! 333
    "report Switching the story transcript on rulebook" ! 334
    "check Switching the story transcript off rulebook" ! 335
    "carry out Switching the story transcript off rulebook" ! 336
    "report Switching the story transcript off rulebook" ! 337
    "check Requesting the story file version rulebook" ! 338
    "carry out Requesting the story file version rulebook" ! 339
    "report Requesting the story file version rulebook" ! 340
    "check Requesting the score rulebook" ! 341
    "carry out Requesting the score rulebook" ! 342
    "report Requesting the score rulebook" ! 343
    "check Preferring abbreviated room descriptions rulebook" ! 344
    "carry out Preferring abbreviated room descriptions rulebook" ! 345
    "report Preferring abbreviated room descriptions rulebook" ! 346
    "check Preferring unabbreviated room descriptions rulebook" ! 347
    "carry out Preferring unabbreviated room descriptions rulebook" ! 348
    "report Preferring unabbreviated room descriptions rulebook" ! 349
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 350
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 351
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 352
    "check Switching score notification on rulebook" ! 353
    "carry out Switching score notification on rulebook" ! 354
    "report Switching score notification on rulebook" ! 355
    "check Switching score notification off rulebook" ! 356
    "carry out Switching score notification off rulebook" ! 357
    "report Switching score notification off rulebook" ! 358
    "check Requesting the pronoun meanings rulebook" ! 359
    "carry out Requesting the pronoun meanings rulebook" ! 360
    "report Requesting the pronoun meanings rulebook" ! 361
    "check Entering to room rulebook" ! 362
    "carry out Entering to room rulebook" ! 363
    "report Entering to room rulebook" ! 364
    "check Bajando rulebook" ! 365
    "carry out Bajando rulebook" ! 366
    "report Bajando rulebook" ! 367
    "check Subiendo rulebook" ! 368
    "carry out Subiendo rulebook" ! 369
    "report Subiendo rulebook" ! 370
    "before Pausing the game rulebook" ! 371
    "for Pausing the game rulebook" ! 372
    "after Pausing the game rulebook" ! 373
    "before Displaying rulebook" ! 374
    "for Displaying rulebook" ! 375
    "after Displaying rulebook" ! 376
    "check Asking for help rulebook" ! 377
    "carry out Asking for help rulebook" ! 378
    "report Asking for help rulebook" ! 379
    "before Quipping rulebook" ! 380
    "for Quipping rulebook" ! 381
    "after Quipping rulebook" ! 382
    "check Requesting a recap rulebook" ! 383
    "carry out Requesting a recap rulebook" ! 384
    "report Requesting a recap rulebook" ! 385
    "check Responding with rulebook" ! 386
    "carry out Responding with rulebook" ! 387
    "report Responding with rulebook" ! 388
    "RQ out of range rulebook" ! 389
    "check Talking to rulebook" ! 390
    "carry out Talking to rulebook" ! 391
    "report Talking to rulebook" ! 392
    "check QBC responding with rulebook" ! 393
    "carry out QBC responding with rulebook" ! 394
    "report QBC responding with rulebook" ! 395
    "check QBC recap rulebook" ! 396
    "carry out QBC recap rulebook" ! 397
    "report QBC recap rulebook" ! 398
    "glulx zeroing-reference rulebook" ! 399
    "glulx resetting-windows rulebook" ! 400
    "glulx resetting-streams rulebook" ! 401
    "glulx resetting-filerefs rulebook" ! 402
    "glulx resetting-channels rulebook" ! 403
    "glulx object-updating rulebook" ! 404
    "glulx input handling rulebook" ! 405
    "glulx timed activity rulebook" ! 406
    "glulx redrawing rulebook" ! 407
    "glulx arranging rulebook" ! 408
    "glulx sound notification rulebook" ! 409
    "glulx mouse input rulebook" ! 410
    "glulx character input rulebook" ! 411
    "glulx line input rulebook" ! 412
    "glulx hyperlink rulebook" ! 413
    "command-counting rulebook" ! 414
    "input-cancelling rulebook" ! 415
    "command-showing rulebook" ! 416
    "command-pasting rulebook" ! 417
    "before Constructing rulebook" ! 418
    "for Constructing rulebook" ! 419
    "after Constructing rulebook" ! 420
    "before Deconstructing rulebook" ! 421
    "for Deconstructing rulebook" ! 422
    "after Deconstructing rulebook" ! 423
    "before Refreshing rulebook" ! 424
    "for Refreshing rulebook" ! 425
    "after Refreshing rulebook" ! 426
    "check Writing it in rulebook" ! 427
    "carry out Writing it in rulebook" ! 428
    "report Writing it in rulebook" ! 429
    "check Writenothing rulebook" ! 430
    "carry out Writenothing rulebook" ! 431
    "report Writenothing rulebook" ! 432
    "check Writenoun rulebook" ! 433
    "carry out Writenoun rulebook" ! 434
    "report Writenoun rulebook" ! 435
    "check Rezaring rulebook" ! 436
    "carry out Rezaring rulebook" ! 437
    "report Rezaring rulebook" ! 438
    "check Remembering rulebook" ! 439
    "carry out Remembering rulebook" ! 440
    "report Remembering rulebook" ! 441
    "check Fucking rulebook" ! 442
    "carry out Fucking rulebook" ! 443
    "report Fucking rulebook" ! 444
    "check Faping rulebook" ! 445
    "carry out Faping rulebook" ! 446
    "report Faping rulebook" ! 447
    "check Singing rulebook" ! 448
    "carry out Singing rulebook" ! 449
    "report Singing rulebook" ! 450
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
        if (R == R_9) { print "declare everything initially unmentioned rule"; rtrue; } ! rule 0
        if (R == R_10) { print "start in the correct scenes rule"; rtrue; } ! rule 1
        if (R == R_11) { print "when play begins stage rule"; rtrue; } ! rule 2
        if (R == R_12) { print "fix baseline scoring rule"; rtrue; } ! rule 3
        if (R == R_13) { print "display banner rule"; rtrue; } ! rule 4
        if (R == R_14) { print "initial room description rule"; rtrue; } ! rule 5
        if (R == R_15) { print "every turn stage rule"; rtrue; } ! rule 6
        if (R == R_18) { print "notify score changes rule"; rtrue; } ! rule 7
        if (R == R_19) { print "when play ends stage rule"; rtrue; } ! rule 8
        if (R == R_20) { print "print player's obituary rule"; rtrue; } ! rule 9
        if (R == R_21) { print "set pronouns from items from multiple object lists rule"; rtrue; } ! rule 10
        if (R == R_22) { print "announce items from multiple object lists rule"; rtrue; } ! rule 11
        if (R == R_23) { print "before stage rule"; rtrue; } ! rule 12
        if (R == R_24) { print "instead stage rule"; rtrue; } ! rule 13
        if (R == R_25) { print "end action-processing in success rule"; rtrue; } ! rule 14
        if (R == R_26) { print "investigate player's awareness before action rule"; rtrue; } ! rule 15
        if (R == R_27) { print "check stage rule"; rtrue; } ! rule 16
        if (R == R_28) { print "carry out stage rule"; rtrue; } ! rule 17
        if (R == R_29) { print "after stage rule"; rtrue; } ! rule 18
        if (R == R_30) { print "investigate player's awareness after action rule"; rtrue; } ! rule 19
        if (R == R_31) { print "report stage rule"; rtrue; } ! rule 20
        if (R == R_33) { print "player aware of his own actions rule"; rtrue; } ! rule 21
        if (R == R_34) { print "player aware of actions by visible actors rule"; rtrue; } ! rule 22
        if (R == R_35) { print "player aware of actions on visible nouns rule"; rtrue; } ! rule 23
        if (R == R_36) { print "player aware of actions on visible second nouns rule"; rtrue; } ! rule 24
        if (R == R_37) { print "can't act in the dark rule"; rtrue; } ! rule 25
        if (R == R_38) { print "very unlikely to mean taking what's already carried rule"; rtrue; } ! rule 26
        if (R == R_65) { print "scene description text rule"; rtrue; } ! rule 27
        if (R == R_66) { print "make named things mentioned rule"; rtrue; } ! rule 28
        if (R == R_67) { print "standard printing the plural name rule"; rtrue; } ! rule 29
        if (R == R_68) { print "standard printing a number of something rule"; rtrue; } ! rule 30
        if (R == R_69) { print "look around once light available rule"; rtrue; } ! rule 31
        if (R == R_70) { print "exclude scenery from take all rule"; rtrue; } ! rule 32
        if (R == R_71) { print "exclude people from take all rule"; rtrue; } ! rule 33
        if (R == R_72) { print "exclude fixed in place things from take all rule"; rtrue; } ! rule 34
        if (R == R_73) { print "exclude indirect possessions from take all rule"; rtrue; } ! rule 35
        if (R == R_74) { print "exclude people from drop all rule"; rtrue; } ! rule 36
        if (R == R_75) { print "ambient odour rule"; rtrue; } ! rule 37
        if (R == R_76) { print "ambient sound rule"; rtrue; } ! rule 38
        if (R == R_77) { print "block vaguely going rule"; rtrue; } ! rule 39
        if (R == R_78) { print "print the final prompt rule"; rtrue; } ! rule 40
        if (R == R_79) { print "print the final question rule"; rtrue; } ! rule 41
        if (R == R_80) { print "standard respond to final question rule"; rtrue; } ! rule 42
        if (R == R_83) { print "initialise locale description rule"; rtrue; } ! rule 43
        if (R == R_84) { print "find notable locale objects rule"; rtrue; } ! rule 44
        if (R == R_85) { print "interesting locale paragraphs rule"; rtrue; } ! rule 45
        if (R == R_86) { print "you-can-also-see rule"; rtrue; } ! rule 46
        if (R == R_87) { print "standard notable locale objects rule"; rtrue; } ! rule 47
        if (R == R_88) { print "don't mention player's supporter in room descriptions rule"; rtrue; } ! rule 48
        if (R == R_89) { print "don't mention scenery in room descriptions rule"; rtrue; } ! rule 49
        if (R == R_90) { print "don't mention undescribed items in room descriptions rule"; rtrue; } ! rule 50
        if (R == R_91) { print "set pronouns from items in room descriptions rule"; rtrue; } ! rule 51
        if (R == R_92) { print "offer items to writing a paragraph about rule"; rtrue; } ! rule 52
        if (R == R_93) { print "use initial appearance in room descriptions rule"; rtrue; } ! rule 53
        if (R == R_94) { print "initial appearance on supporters rule"; rtrue; } ! rule 54
        if (R == R_96) { print "describe what's on scenery supporters in room descriptions rule"; rtrue; } ! rule 55
        if (R == R_97) { print "describe what's on mentioned supporters in room descriptions rule"; rtrue; } ! rule 56
        if (R == R_98) { print "print empty inventory rule"; rtrue; } ! rule 57
        if (R == R_99) { print "print standard inventory rule"; rtrue; } ! rule 58
        if (R == R_100) { print "report other people taking inventory rule"; rtrue; } ! rule 59
        if (R == R_101) { print "can't take yourself rule"; rtrue; } ! rule 60
        if (R == R_102) { print "can't take other people rule"; rtrue; } ! rule 61
        if (R == R_103) { print "can't take component parts rule"; rtrue; } ! rule 62
        if (R == R_104) { print "can't take people's possessions rule"; rtrue; } ! rule 63
        if (R == R_105) { print "can't take items out of play rule"; rtrue; } ! rule 64
        if (R == R_106) { print "can't take what you're inside rule"; rtrue; } ! rule 65
        if (R == R_107) { print "can't take what's already taken rule"; rtrue; } ! rule 66
        if (R == R_108) { print "can't take scenery rule"; rtrue; } ! rule 67
        if (R == R_109) { print "can only take things rule"; rtrue; } ! rule 68
        if (R == R_110) { print "can't take what's fixed in place rule"; rtrue; } ! rule 69
        if (R == R_111) { print "use player's holdall to avoid exceeding carrying capacity rule"; rtrue; } ! rule 70
        if (R == R_112) { print "can't exceed carrying capacity rule"; rtrue; } ! rule 71
        if (R == R_113) { print "standard taking rule"; rtrue; } ! rule 72
        if (R == R_114) { print "standard report taking rule"; rtrue; } ! rule 73
        if (R == R_115) { print "can't remove what's not inside rule"; rtrue; } ! rule 74
        if (R == R_116) { print "can't remove from people rule"; rtrue; } ! rule 75
        if (R == R_117) { print "convert remove to take rule"; rtrue; } ! rule 76
        if (R == R_118) { print "can't drop yourself rule"; rtrue; } ! rule 77
        if (R == R_119) { print "can't drop body parts rule"; rtrue; } ! rule 78
        if (R == R_120) { print "can't drop what's already dropped rule"; rtrue; } ! rule 79
        if (R == R_121) { print "can't drop what's not held rule"; rtrue; } ! rule 80
        if (R == R_122) { print "can't drop clothes being worn rule"; rtrue; } ! rule 81
        if (R == R_123) { print "can't drop if this exceeds carrying capacity rule"; rtrue; } ! rule 82
        if (R == R_124) { print "standard dropping rule"; rtrue; } ! rule 83
        if (R == R_125) { print "standard report dropping rule"; rtrue; } ! rule 84
        if (R == R_126) { print "convert put to drop where possible rule"; rtrue; } ! rule 85
        if (R == R_127) { print "can't put what's not held rule"; rtrue; } ! rule 86
        if (R == R_128) { print "can't put something on itself rule"; rtrue; } ! rule 87
        if (R == R_129) { print "can't put onto what's not a supporter rule"; rtrue; } ! rule 88
        if (R == R_130) { print "can't put clothes being worn rule"; rtrue; } ! rule 89
        if (R == R_131) { print "can't put if this exceeds carrying capacity rule"; rtrue; } ! rule 90
        if (R == R_132) { print "standard putting rule"; rtrue; } ! rule 91
        if (R == R_133) { print "concise report putting rule"; rtrue; } ! rule 92
        if (R == R_134) { print "standard report putting rule"; rtrue; } ! rule 93
        if (R == R_135) { print "convert insert to drop where possible rule"; rtrue; } ! rule 94
        if (R == R_136) { print "can't insert what's not held rule"; rtrue; } ! rule 95
        if (R == R_137) { print "can't insert something into itself rule"; rtrue; } ! rule 96
        if (R == R_138) { print "can't insert into closed containers rule"; rtrue; } ! rule 97
        if (R == R_139) { print "can't insert into what's not a container rule"; rtrue; } ! rule 98
        if (R == R_140) { print "can't insert clothes being worn rule"; rtrue; } ! rule 99
        if (R == R_141) { print "can't insert if this exceeds carrying capacity rule"; rtrue; } ! rule 100
        if (R == R_142) { print "standard inserting rule"; rtrue; } ! rule 101
        if (R == R_143) { print "concise report inserting rule"; rtrue; } ! rule 102
        if (R == R_144) { print "standard report inserting rule"; rtrue; } ! rule 103
        if (R == R_145) { print "can't eat unless edible rule"; rtrue; } ! rule 104
        if (R == R_146) { print "can't eat clothing without removing it first rule"; rtrue; } ! rule 105
        if (R == R_147) { print "can't eat other people's food rule"; rtrue; } ! rule 106
        if (R == R_148) { print "can't eat portable food without carrying it rule"; rtrue; } ! rule 107
        if (R == R_149) { print "standard eating rule"; rtrue; } ! rule 108
        if (R == R_150) { print "standard report eating rule"; rtrue; } ! rule 109
        if (R == R_151) { print "standard set going variables rule"; rtrue; } ! rule 110
        if (R == R_152) { print "stand up before going rule"; rtrue; } ! rule 111
        if (R == R_153) { print "can't travel in what's not a vehicle rule"; rtrue; } ! rule 112
        if (R == R_154) { print "can't go through undescribed doors rule"; rtrue; } ! rule 113
        if (R == R_155) { print "can't go through closed doors rule"; rtrue; } ! rule 114
        if (R == R_156) { print "determine map connection rule"; rtrue; } ! rule 115
        if (R == R_157) { print "can't go that way rule"; rtrue; } ! rule 116
        if (R == R_158) { print "move player and vehicle rule"; rtrue; } ! rule 117
        if (R == R_159) { print "move floating objects rule"; rtrue; } ! rule 118
        if (R == R_160) { print "check light in new location rule"; rtrue; } ! rule 119
        if (R == R_161) { print "describe room gone into rule"; rtrue; } ! rule 120
        if (R == R_162) { print "find what to enter rule"; rtrue; } ! rule 121
        if (R == R_163) { print "convert enter door into go rule"; rtrue; } ! rule 122
        if (R == R_164) { print "convert enter compass direction into go rule"; rtrue; } ! rule 123
        if (R == R_165) { print "can't enter what's already entered rule"; rtrue; } ! rule 124
        if (R == R_166) { print "can't enter what's not enterable rule"; rtrue; } ! rule 125
        if (R == R_167) { print "can't enter closed containers rule"; rtrue; } ! rule 126
        if (R == R_168) { print "can't enter if this exceeds carrying capacity rule"; rtrue; } ! rule 127
        if (R == R_169) { print "can't enter something carried rule"; rtrue; } ! rule 128
        if (R == R_170) { print "implicitly pass through other barriers rule"; rtrue; } ! rule 129
        if (R == R_171) { print "standard entering rule"; rtrue; } ! rule 130
        if (R == R_172) { print "standard report entering rule"; rtrue; } ! rule 131
        if (R == R_173) { print "describe contents entered into rule"; rtrue; } ! rule 132
        if (R == R_175) { print "convert exit into go out rule"; rtrue; } ! rule 133
        if (R == R_176) { print "can't exit when not inside anything rule"; rtrue; } ! rule 134
        if (R == R_177) { print "can't exit closed containers rule"; rtrue; } ! rule 135
        if (R == R_178) { print "convert exit into get off rule"; rtrue; } ! rule 136
        if (R == R_179) { print "standard exiting rule"; rtrue; } ! rule 137
        if (R == R_180) { print "standard report exiting rule"; rtrue; } ! rule 138
        if (R == R_181) { print "describe room emerged into rule"; rtrue; } ! rule 139
        if (R == R_182) { print "can't get off things rule"; rtrue; } ! rule 140
        if (R == R_183) { print "standard getting off rule"; rtrue; } ! rule 141
        if (R == R_184) { print "standard report getting off rule"; rtrue; } ! rule 142
        if (R == R_185) { print "describe room stood up into rule"; rtrue; } ! rule 143
        if (R == R_186) { print "determine visibility ceiling rule"; rtrue; } ! rule 144
        if (R == R_187) { print "declare everything unmentioned rule"; rtrue; } ! rule 145
        if (R == R_188) { print "room description heading rule"; rtrue; } ! rule 146
        if (R == R_189) { print "room description body text rule"; rtrue; } ! rule 147
        if (R == R_190) { print "room description paragraphs about objects rule"; rtrue; } ! rule 148
        if (R == R_191) { print "check new arrival rule"; rtrue; } ! rule 149
        if (R == R_192) { print "other people looking rule"; rtrue; } ! rule 150
        if (R == R_193) { print "standard examining rule"; rtrue; } ! rule 151
        if (R == R_194) { print "examine directions rule"; rtrue; } ! rule 152
        if (R == R_195) { print "examine containers rule"; rtrue; } ! rule 153
        if (R == R_196) { print "examine supporters rule"; rtrue; } ! rule 154
        if (R == R_197) { print "examine devices rule"; rtrue; } ! rule 155
        if (R == R_198) { print "examine undescribed things rule"; rtrue; } ! rule 156
        if (R == R_199) { print "report other people examining rule"; rtrue; } ! rule 157
        if (R == R_200) { print "standard looking under rule"; rtrue; } ! rule 158
        if (R == R_201) { print "report other people looking under rule"; rtrue; } ! rule 159
        if (R == R_202) { print "can't search unless container or supporter rule"; rtrue; } ! rule 160
        if (R == R_203) { print "can't search closed opaque containers rule"; rtrue; } ! rule 161
        if (R == R_204) { print "standard search containers rule"; rtrue; } ! rule 162
        if (R == R_205) { print "standard search supporters rule"; rtrue; } ! rule 163
        if (R == R_206) { print "report other people searching rule"; rtrue; } ! rule 164
        if (R == R_207) { print "block consulting rule"; rtrue; } ! rule 165
        if (R == R_208) { print "can't lock without a lock rule"; rtrue; } ! rule 166
        if (R == R_209) { print "can't lock what's already locked rule"; rtrue; } ! rule 167
        if (R == R_210) { print "can't lock what's open rule"; rtrue; } ! rule 168
        if (R == R_211) { print "can't lock without the correct key rule"; rtrue; } ! rule 169
        if (R == R_212) { print "standard locking rule"; rtrue; } ! rule 170
        if (R == R_213) { print "standard report locking rule"; rtrue; } ! rule 171
        if (R == R_214) { print "can't unlock without a lock rule"; rtrue; } ! rule 172
        if (R == R_215) { print "can't unlock what's already unlocked rule"; rtrue; } ! rule 173
        if (R == R_216) { print "can't unlock without the correct key rule"; rtrue; } ! rule 174
        if (R == R_217) { print "standard unlocking rule"; rtrue; } ! rule 175
        if (R == R_218) { print "standard report unlocking rule"; rtrue; } ! rule 176
        if (R == R_219) { print "can't switch on unless switchable rule"; rtrue; } ! rule 177
        if (R == R_220) { print "can't switch on what's already on rule"; rtrue; } ! rule 178
        if (R == R_221) { print "standard switching on rule"; rtrue; } ! rule 179
        if (R == R_222) { print "standard report switching on rule"; rtrue; } ! rule 180
        if (R == R_223) { print "can't switch off unless switchable rule"; rtrue; } ! rule 181
        if (R == R_224) { print "can't switch off what's already off rule"; rtrue; } ! rule 182
        if (R == R_225) { print "standard switching off rule"; rtrue; } ! rule 183
        if (R == R_226) { print "standard report switching off rule"; rtrue; } ! rule 184
        if (R == R_227) { print "can't open unless openable rule"; rtrue; } ! rule 185
        if (R == R_228) { print "can't open what's locked rule"; rtrue; } ! rule 186
        if (R == R_229) { print "can't open what's already open rule"; rtrue; } ! rule 187
        if (R == R_230) { print "standard opening rule"; rtrue; } ! rule 188
        if (R == R_231) { print "reveal any newly visible interior rule"; rtrue; } ! rule 189
        if (R == R_232) { print "standard report opening rule"; rtrue; } ! rule 190
        if (R == R_233) { print "can't close unless openable rule"; rtrue; } ! rule 191
        if (R == R_234) { print "can't close what's already closed rule"; rtrue; } ! rule 192
        if (R == R_235) { print "standard closing rule"; rtrue; } ! rule 193
        if (R == R_236) { print "standard report closing rule"; rtrue; } ! rule 194
        if (R == R_237) { print "can't wear what's not clothing rule"; rtrue; } ! rule 195
        if (R == R_238) { print "can't wear what's not held rule"; rtrue; } ! rule 196
        if (R == R_239) { print "can't wear what's already worn rule"; rtrue; } ! rule 197
        if (R == R_240) { print "standard wearing rule"; rtrue; } ! rule 198
        if (R == R_241) { print "standard report wearing rule"; rtrue; } ! rule 199
        if (R == R_243) { print "can't take off what's not worn rule"; rtrue; } ! rule 200
        if (R == R_244) { print "can't exceed carrying capacity when taking off rule"; rtrue; } ! rule 201
        if (R == R_245) { print "standard taking off rule"; rtrue; } ! rule 202
        if (R == R_246) { print "standard report taking off rule"; rtrue; } ! rule 203
        if (R == R_247) { print "can't give what you haven't got rule"; rtrue; } ! rule 204
        if (R == R_248) { print "can't give to yourself rule"; rtrue; } ! rule 205
        if (R == R_249) { print "can't give to a non-person rule"; rtrue; } ! rule 206
        if (R == R_250) { print "can't give clothes being worn rule"; rtrue; } ! rule 207
        if (R == R_251) { print "block giving rule"; rtrue; } ! rule 208
        if (R == R_252) { print "can't exceed carrying capacity when giving rule"; rtrue; } ! rule 209
        if (R == R_253) { print "standard giving rule"; rtrue; } ! rule 210
        if (R == R_254) { print "standard report giving rule"; rtrue; } ! rule 211
        if (R == R_255) { print "can't show what you haven't got rule"; rtrue; } ! rule 212
        if (R == R_256) { print "convert show to yourself to examine rule"; rtrue; } ! rule 213
        if (R == R_257) { print "block showing rule"; rtrue; } ! rule 214
        if (R == R_258) { print "block waking rule"; rtrue; } ! rule 215
        if (R == R_259) { print "implicitly remove thrown clothing rule"; rtrue; } ! rule 216
        if (R == R_260) { print "futile to throw things at inanimate objects rule"; rtrue; } ! rule 217
        if (R == R_261) { print "block throwing at rule"; rtrue; } ! rule 218
        if (R == R_262) { print "block attacking rule"; rtrue; } ! rule 219
        if (R == R_263) { print "kissing yourself rule"; rtrue; } ! rule 220
        if (R == R_264) { print "block kissing rule"; rtrue; } ! rule 221
        if (R == R_265) { print "block answering rule"; rtrue; } ! rule 222
        if (R == R_266) { print "telling yourself rule"; rtrue; } ! rule 223
        if (R == R_267) { print "block telling rule"; rtrue; } ! rule 224
        if (R == R_268) { print "block asking rule"; rtrue; } ! rule 225
        if (R == R_269) { print "asking yourself for something rule"; rtrue; } ! rule 226
        if (R == R_270) { print "translate asking for to giving rule"; rtrue; } ! rule 227
        if (R == R_271) { print "standard report waiting rule"; rtrue; } ! rule 228
        if (R == R_272) { print "report touching yourself rule"; rtrue; } ! rule 229
        if (R == R_273) { print "report touching other people rule"; rtrue; } ! rule 230
        if (R == R_274) { print "report touching things rule"; rtrue; } ! rule 231
        if (R == R_275) { print "can't wave what's not held rule"; rtrue; } ! rule 232
        if (R == R_276) { print "report waving things rule"; rtrue; } ! rule 233
        if (R == R_277) { print "can't pull what's fixed in place rule"; rtrue; } ! rule 234
        if (R == R_278) { print "can't pull scenery rule"; rtrue; } ! rule 235
        if (R == R_279) { print "can't pull people rule"; rtrue; } ! rule 236
        if (R == R_280) { print "report pulling rule"; rtrue; } ! rule 237
        if (R == R_281) { print "can't push what's fixed in place rule"; rtrue; } ! rule 238
        if (R == R_282) { print "can't push scenery rule"; rtrue; } ! rule 239
        if (R == R_283) { print "can't push people rule"; rtrue; } ! rule 240
        if (R == R_284) { print "report pushing rule"; rtrue; } ! rule 241
        if (R == R_285) { print "can't turn what's fixed in place rule"; rtrue; } ! rule 242
        if (R == R_286) { print "can't turn scenery rule"; rtrue; } ! rule 243
        if (R == R_287) { print "can't turn people rule"; rtrue; } ! rule 244
        if (R == R_288) { print "report turning rule"; rtrue; } ! rule 245
        if (R == R_289) { print "can't push unpushable things rule"; rtrue; } ! rule 246
        if (R == R_290) { print "can't push to non-directions rule"; rtrue; } ! rule 247
        if (R == R_291) { print "can't push vertically rule"; rtrue; } ! rule 248
        if (R == R_292) { print "can't push from within rule"; rtrue; } ! rule 249
        if (R == R_293) { print "standard pushing in directions rule"; rtrue; } ! rule 250
        if (R == R_294) { print "block pushing in directions rule"; rtrue; } ! rule 251
        if (R == R_295) { print "innuendo about squeezing people rule"; rtrue; } ! rule 252
        if (R == R_296) { print "report squeezing rule"; rtrue; } ! rule 253
        if (R == R_297) { print "block saying yes rule"; rtrue; } ! rule 254
        if (R == R_298) { print "block saying no rule"; rtrue; } ! rule 255
        if (R == R_299) { print "block burning rule"; rtrue; } ! rule 256
        if (R == R_300) { print "block waking up rule"; rtrue; } ! rule 257
        if (R == R_301) { print "block thinking rule"; rtrue; } ! rule 258
        if (R == R_302) { print "report smelling rule"; rtrue; } ! rule 259
        if (R == R_303) { print "report listening rule"; rtrue; } ! rule 260
        if (R == R_304) { print "report tasting rule"; rtrue; } ! rule 261
        if (R == R_305) { print "block cutting rule"; rtrue; } ! rule 262
        if (R == R_306) { print "report jumping rule"; rtrue; } ! rule 263
        if (R == R_307) { print "block tying rule"; rtrue; } ! rule 264
        if (R == R_308) { print "block drinking rule"; rtrue; } ! rule 265
        if (R == R_309) { print "block saying sorry rule"; rtrue; } ! rule 266
        if (R == R_310) { print "block swinging rule"; rtrue; } ! rule 267
        if (R == R_311) { print "can't rub another person rule"; rtrue; } ! rule 268
        if (R == R_312) { print "report rubbing rule"; rtrue; } ! rule 269
        if (R == R_313) { print "block setting it to rule"; rtrue; } ! rule 270
        if (R == R_314) { print "report waving hands rule"; rtrue; } ! rule 271
        if (R == R_315) { print "block buying rule"; rtrue; } ! rule 272
        if (R == R_316) { print "block climbing rule"; rtrue; } ! rule 273
        if (R == R_317) { print "block sleeping rule"; rtrue; } ! rule 274
        if (R == R_799) { print "spanish room description heading rule"; rtrue; } ! rule 275
        if (R == R_828) { print "intentar entrar rule"; rtrue; } ! rule 276
        if (R == R_851) { print "sort the Table of User Styles rule"; rtrue; } ! rule 277
        if (R == R_852) { print "set text styles rule"; rtrue; } ! rule 278
        if (R == R_880) { print "standard pausing the game rule"; rtrue; } ! rule 279
        if (R == R_902) { print "quit rule"; rtrue; } ! rule 280
        if (R == R_903) { print "move down rule"; rtrue; } ! rule 281
        if (R == R_904) { print "move up rule"; rtrue; } ! rule 282
        if (R == R_905) { print "select rule"; rtrue; } ! rule 283
        if (R == R_909) { print "basic menu contents rule"; rtrue; } ! rule 284
        if (R == R_910) { print "constructing status line while displaying rule"; rtrue; } ! rule 285
        if (R == R_913) { print "hint toggle rule"; rtrue; } ! rule 286
        if (R == R_918) { print "switch notification status rule"; rtrue; } ! rule 287
        if (R == R_919) { print "switch description types rule"; rtrue; } ! rule 288
        if (R == R_922) { print "help request rule"; rtrue; } ! rule 289
        if (R == R_923) { print "basic quipping rule"; rtrue; } ! rule 290
        if (R == R_927) { print "perform recap rule"; rtrue; } ! rule 291
        if (R == R_928) { print "perform responding rule"; rtrue; } ! rule 292
        if (R == R_929) { print "force conversation rule"; rtrue; } ! rule 293
        if (R == R_930) { print "reaction is instantaneous rule"; rtrue; } ! rule 294
        if (R == R_931) { print "RQ asking about rule"; rtrue; } ! rule 295
        if (R == R_932) { print "RQ telling about rule"; rtrue; } ! rule 296
        if (R == R_933) { print "RQ answering that rule"; rtrue; } ! rule 297
        if (R == R_935) { print "basic RQ out of range rule"; rtrue; } ! rule 298
        if (R == R_936) { print "spanish basic RQ out of range rule"; rtrue; } ! rule 299
        if (R == R_937) { print "reject asking for talking rule"; rtrue; } ! rule 300
        if (R == R_938) { print "reject telling for talking rule"; rtrue; } ! rule 301
        if (R == R_939) { print "reject answering for talking rule"; rtrue; } ! rule 302
        if (R == R_940) { print "reject commanding for talking rule"; rtrue; } ! rule 303
        if (R == R_943) { print "can only talk to talkables rule"; rtrue; } ! rule 304
        if (R == R_944) { print "can only talk to people with things to say rule"; rtrue; } ! rule 305
        if (R == R_945) { print "basic talking to rule"; rtrue; } ! rule 306
        if (R == R_946) { print "revert to normal conversation rule"; rtrue; } ! rule 307
        if (R == R_949) { print "perform talking rule"; rtrue; } ! rule 308
        if (R == R_950) { print "perform QBC recap rule"; rtrue; } ! rule 309
        if (R == R_959) { print "spanish can only talk to talkables rule"; rtrue; } ! rule 310
        if (R == R_960) { print "alternative virtual machine startup rule"; rtrue; } ! rule 311
        if (R == R_961) { print "initial whitespace rule"; rtrue; } ! rule 312
        if (R == R_962) { print "alternative start in the correct scenes rule"; rtrue; } ! rule 313
        if (R == R_1012) { print "redirect to GEP timed activity rule"; rtrue; } ! rule 314
        if (R == R_1013) { print "redirect to GEP character input rule"; rtrue; } ! rule 315
        if (R == R_1014) { print "redirect to GEP line input rule"; rtrue; } ! rule 316
        if (R == R_1015) { print "redirect to GEP mouse input rule"; rtrue; } ! rule 317
        if (R == R_1016) { print "redirect to GEP arranging rule"; rtrue; } ! rule 318
        if (R == R_1017) { print "redirect to GEP redrawing rule"; rtrue; } ! rule 319
        if (R == R_1018) { print "redirect to GEP sound notification rule"; rtrue; } ! rule 320
        if (R == R_1019) { print "redirect to GEP hyperlink rule"; rtrue; } ! rule 321
        if (R == R_1020) { print "ordinary checking for content rule"; rtrue; } ! rule 322
        if (R == R_1021) { print "cancelling input in the main window rule"; rtrue; } ! rule 323
        if (R == R_1024) { print "print text to the input prompt rule"; rtrue; } ! rule 324
        if (R == R_1026) { print "glue replacement command into parse buffer rule"; rtrue; } ! rule 325
        if (R == R_1030) { print "open the built-in windows using Flexible Windows rule"; rtrue; } ! rule 326
        if (R == R_1045) { print "fix method and measurement rule"; rtrue; } ! rule 327
        if (R == R_1046) { print "check if the window was created rule"; rtrue; } ! rule 328
        if (R == R_1047) { print "basic deconstruction rule"; rtrue; } ! rule 329
        if (R == R_1051) { print "prepare for refreshing rule"; rtrue; } ! rule 330
        if (R == R_1052) { print "check the window is present rule"; rtrue; } ! rule 331
        if (R == R_1053) { print "refocus the current focus window rule"; rtrue; } ! rule 332
        if (R == R_1054) { print "refresh the window rule"; rtrue; } ! rule 333
        if (R == R_1055) { print "refresh windows after arranging rule"; rtrue; } ! rule 334
        if (R == R_1056) { print "refresh graphical windows rule"; rtrue; } ! rule 335
        if (R == R_1057) { print "refresh windows after restoring rule"; rtrue; } ! rule 336
        if (R == R_1063) { print "set g-window rocks rule"; rtrue; } ! rule 337
        if (R == R_1064) { print "reset window properties rule"; rtrue; } ! rule 338
        if (R == R_1065) { print "find existing windows rule"; rtrue; } ! rule 339
        if (R == R_1066) { print "recalibrate windows rule"; rtrue; } ! rule 340
        if (R == R_1067) { print "focus the acting main window rule"; rtrue; } ! rule 341
        if (R == R_1068) { print "update the I6 window variables rule"; rtrue; } ! rule 342
        if (R == R_1069) { print "fix the current windows rule"; rtrue; } ! rule 343
        if (R == R_1070) { print "clear the I6 window variables rule"; rtrue; } ! rule 344
        if (R == R_1076) { print "Flexible Windows sort the Table of User Styles rule"; rtrue; } ! rule 345
        if (R == R_1097) { print "set generic text styles rule"; rtrue; } ! rule 346
        if (R == R_1098) { print "Gargoyle cursor color rule"; rtrue; } ! rule 347
        if (R == R_1099) { print "set the window specific styles rule"; rtrue; } ! rule 348
        if (R == R_1100) { print "clear the window specific styles rule"; rtrue; } ! rule 349
        if (R == R_1101) { print "set the background color of textual windows rule"; rtrue; } ! rule 350
        if (R == R_1102) { print "reset the background color of textual windows rule"; rtrue; } ! rule 351
        if (R == R_1105) { print "Gargoyle window padding rule"; rtrue; } ! rule 352
        if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; rtrue; } ! rule 353
        if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; rtrue; } ! rule 354
        if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; rtrue; } ! rule 355
        if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; rtrue; } ! rule 356
        if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; rtrue; } ! rule 357
        if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; rtrue; } ! rule 358
        if (R == ADJUST_LIGHT_R) { print "adjust light rule"; rtrue; } ! rule 359
        if (R == ADVANCE_TIME_R) { print "advance time rule"; rtrue; } ! rule 360
        if (R == GENERATE_ACTION_R) { print "generate action rule"; rtrue; } ! rule 361
        if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; rtrue; } ! rule 362
        if (R == PARSE_COMMAND_R) { print "parse command rule"; rtrue; } ! rule 363
        if (R == TIMED_EVENTS_R) { print "timed events rule"; rtrue; } ! rule 364
        if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; rtrue; } ! rule 365
        if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; rtrue; } ! rule 366
        if (R == DetectSceneChange) { print "scene change machinery rule"; rtrue; } ! rule 367
        if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; rtrue; } ! rule 368
        if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; rtrue; } ! rule 369
        if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; rtrue; } ! rule 370
        if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; rtrue; } ! rule 371
        if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; rtrue; } ! rule 372
        if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; rtrue; } ! rule 373
        if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; rtrue; } ! rule 374
        if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; rtrue; } ! rule 375
        if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; rtrue; } ! rule 376
        if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; rtrue; } ! rule 377
        if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; rtrue; } ! rule 378
        if (R == LIST_WRITER_INTERNAL_R) { print "list writer internal rule"; rtrue; } ! rule 379
        if (R == ACTION_PROCESSING_INTERNAL_R) { print "action processing internal rule"; rtrue; } ! rule 380
        if (R == PARSER_ERROR_INTERNAL_R) { print "parser error internal rule"; rtrue; } ! rule 381
        if (R == PARSER_N_ERROR_INTERNAL_R) { print "parser nothing error internal rule"; rtrue; } ! rule 382
        if (R == DARKNESS_NAME_INTERNAL_R) { print "darkness name internal rule"; rtrue; } ! rule 383
        if (R == PARSER_COMMAND_INTERNAL_R) { print "parser command internal rule"; rtrue; } ! rule 384
        if (R == PARSER_CLARIF_INTERNAL_R) { print "parser clarification internal rule"; rtrue; } ! rule 385
        if (R == YES_OR_NO_QUESTION_INTERNAL_R) { print "yes or no question internal rule"; rtrue; } ! rule 386
        if (R == PRINT_PROTAGONIST_INTERNAL_R) { print "print protagonist internal rule"; rtrue; } ! rule 387
        if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; rtrue; } ! rule 388
        if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; rtrue; } ! rule 389
        if (R == STANDARD_IMPLICIT_TAKING_R) { print "standard implicit taking rule"; rtrue; } ! rule 390
        if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; rtrue; } ! rule 391
        if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; rtrue; } ! rule 392
        if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; rtrue; } ! rule 393
        if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; rtrue; } ! rule 394
        if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; rtrue; } ! rule 395
        if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; rtrue; } ! rule 396
        if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; rtrue; } ! rule 397
        if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; rtrue; } ! rule 398
        if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; rtrue; } ! rule 399
        if (R == STANDARD_RESPONSE_ISSUING_R) { print "standard issuing the response text rule"; rtrue; } ! rule 400
        if (R == QUIT_THE_GAME_R) { print "quit the game rule"; rtrue; } ! rule 401
        if (R == SAVE_THE_GAME_R) { print "save the game rule"; rtrue; } ! rule 402
        if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; rtrue; } ! rule 403
        if (R == RESTART_THE_GAME_R) { print "restart the game rule"; rtrue; } ! rule 404
        if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; rtrue; } ! rule 405
        if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; rtrue; } ! rule 406
        if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; rtrue; } ! rule 407
        if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; rtrue; } ! rule 408
        if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; rtrue; } ! rule 409
        if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; rtrue; } ! rule 410
        if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; rtrue; } ! rule 411
        if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; rtrue; } ! rule 412
        if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; rtrue; } ! rule 413
        if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; rtrue; } ! rule 414
        if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; rtrue; } ! rule 415
        if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; rtrue; } ! rule 416
        if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; rtrue; } ! rule 417
        if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; rtrue; } ! rule 418
        if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; rtrue; } ! rule 419
        if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; rtrue; } ! rule 420
        if (R == INITIALISE_MEMORY_R) { print "alternative initialise memory rule"; rtrue; } ! rule 421
        if (R == POSITION_PLAYER_IN_MODEL_R) { print "alternative position player in model world rule"; rtrue; } ! rule 422
        if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "alternative seed random number generator rule"; rtrue; } ! rule 423
        if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "alternative update chronological records rule"; rtrue; } ! rule 424
        if (R == ASR_CheckForGlk) { print "check for Glk rule"; rtrue; } ! rule 425
        if (R == ASR_GGRecoverObjects) { print "recover objects rule"; rtrue; } ! rule 426
        if (R == ASR_SoundChannelInitialisation) { print "sound channel initialisation rule"; rtrue; } ! rule 427
        if (R == ASR_OpenBuiltInWindows) { print "open built-in windows rule"; rtrue; } ! rule 428
        if (R == GOR_zeroing) { print "built in object zeroing rule"; rtrue; } ! rule 429
        if (R == GOR_indentify_windows) { print "identify built in windows rule"; rtrue; } ! rule 430
        if (R == GOR_indentify_streams) { print "identify built in streams rule"; rtrue; } ! rule 431
        if (R == GOR_indentify_filerefs) { print "identify built in file refs rule"; rtrue; } ! rule 432
        if (R == GOR_indentify_schannels) { print "identify built in sound channels rule"; rtrue; } ! rule 433
        if (R == FW_ConstructGWindow) { print "construct a g-window rule"; rtrue; } ! rule 434
        if (R == R_16) { print "A first turn sequence rule"; rtrue; } ! rule 435
        if (R == R_17) { print "A last turn sequence rule"; rtrue; } ! rule 436
        if (R == R_32) { print "last specific action-processing rule"; rtrue; } ! rule 437
        if (R == R_174) { print "Setting action variables for exiting"; rtrue; } ! rule 438
        if (R == R_242) { print "Does the player mean taking off something worn"; rtrue; } ! rule 439
        if (R == R_829) { print "Carry out bajando"; rtrue; } ! rule 440
        if (R == R_830) { print "Carry out subiendo"; rtrue; } ! rule 441
        if (R == R_914) { print "When play begins"; rtrue; } ! rule 442
        if (R == R_934) { print "Before printing a parser error when RQ is active and the latest parser error is the didn't understand that number error"; rtrue; } ! rule 443
        if (R == R_948) { print "Does the player mean talking to a person"; rtrue; } ! rule 444
        if (R == R_958) { print "Before printing a parser error when QBC is active and the latest parser error is the didn't understand that number error"; rtrue; } ! rule 445
        if (R == R_1106) { print "Carry out requesting the score"; rtrue; } ! rule 446
        if (R == R_1107) { print "When play begins"; rtrue; } ! rule 447
        if (R == R_1108) { print "Before going"; rtrue; } ! rule 448
        if (R == R_1109) { print "Rule for supplying a missing second noun while writing"; rtrue; } ! rule 449
        if (R == R_1110) { print "Check writing it in"; rtrue; } ! rule 450
        if (R == R_1111) { print "Check Writenothing"; rtrue; } ! rule 451
        if (R == R_1112) { print "Check Writenoun"; rtrue; } ! rule 452
        if (R == R_1113) { print "Check rezaring"; rtrue; } ! rule 453
        if (R == R_1114) { print "Report remembering"; rtrue; } ! rule 454
        if (R == R_1115) { print "Instead of thinking"; rtrue; } ! rule 455
        if (R == R_1116) { print "Report fucking"; rtrue; } ! rule 456
        if (R == R_1117) { print "Report faping"; rtrue; } ! rule 457
        if (R == R_1118) { print "Report singing"; rtrue; } ! rule 458
        if (R == R_1119) { print "Before looking when the location is En la oscuridad"; rtrue; } ! rule 459
        if (R == R_1120) { print "Before looking when the location is Primer Acto"; rtrue; } ! rule 460
        if (R == R_1121) { print "Before looking when the location is Segundo Acto"; rtrue; } ! rule 461
        if (R == R_1122) { print "Before looking when the location is Tercer Acto"; rtrue; } ! rule 462
        if (R == R_1123) { print "Before looking when the location is Cuarto Acto"; rtrue; } ! rule 463
        if (R == R_1124) { print "Before looking when the location is Quinto Acto"; rtrue; } ! rule 464
        if (R == R_1125) { print "Before looking when the location is Sexto Acto"; rtrue; } ! rule 465
        if (R == R_1126) { print "Before looking when the location is Septimo Acto"; rtrue; } ! rule 466
        if (R == R_1127) { print "Instead of attacking the pluma"; rtrue; } ! rule 467
        if (R == R_1128) { print "After examining the musa"; rtrue; } ! rule 468
        if (R == R_1129) { print "Instead of attacking or pulling or pushing or waving the musa"; rtrue; } ! rule 469
        if (R == R_1130) { print "Instead of throwing the piedra at the musa"; rtrue; } ! rule 470
        if (R == R_1131) { print "Instead of attacking the ojos"; rtrue; } ! rule 471
        if (R == R_1132) { print "Instead of attacking the presencia"; rtrue; } ! rule 472
        if (R == R_1133) { print "Instead of talking to the musa"; rtrue; } ! rule 473
        if (R == R_1134) { print "Instead of talking to the presencia"; rtrue; } ! rule 474
        if (R == R_1135) { print "Instead of smelling or tasting the musa"; rtrue; } ! rule 475
        if (R == R_1136) { print "Instead of examining or closing or opening or pulling or waving or pushing the ojos"; rtrue; } ! rule 476
        if (R == R_1137) { print "Instead of closing or opening or pulling or waving or pushing the musa"; rtrue; } ! rule 477
        if (R == R_1138) { print "Instead of fucking or kissing or touching the musa"; rtrue; } ! rule 478
        if (R == R_1139) { print "Instead of fucking or kissing or touching the ojos"; rtrue; } ! rule 479
        if (R == R_1140) { print "Carry out writing it in"; rtrue; } ! rule 480
        if (R == R_1141) { print "Instead of pulling or pushing or attacking the libro"; rtrue; } ! rule 481
        if (R == R_1142) { print "Instead of smelling or tasting the libro"; rtrue; } ! rule 482
        if (R == R_1143) { print "Instead of touching the libro"; rtrue; } ! rule 483
        if (R == R_1144) { print "Instead of listening when the player is in Primer acto"; rtrue; } ! rule 484
        if (R == R_1145) { print "Instead of smelling when the player is in Primer acto"; rtrue; } ! rule 485
        if (R == R_1146) { print "Instead of touching or pushing or pulling or waving the paisaje"; rtrue; } ! rule 486
        if (R == R_1147) { print "Instead of touching or pushing or pulling or waving the ovejas"; rtrue; } ! rule 487
        if (R == R_1148) { print "Instead of talking to las ovejas"; rtrue; } ! rule 488
        if (R == R_1149) { print "Instead of taking the ovejas"; rtrue; } ! rule 489
        if (R == R_1150) { print "Before sleeping"; rtrue; } ! rule 490
        if (R == R_1151) { print "Instead of taking or pulling or pushing or attacking or waving or kissing or touching or smelling the pastor"; rtrue; } ! rule 491
        if (R == R_1152) { print "After quipping when the current quip is hola-pastor"; rtrue; } ! rule 492
        if (R == R_1153) { print "After quipping when the current quip is ayuda-pastor"; rtrue; } ! rule 493
        if (R == R_1154) { print "Instead of listening when the player is in Segundo acto"; rtrue; } ! rule 494
        if (R == R_1155) { print "Instead of smelling when the player is in Segundo acto"; rtrue; } ! rule 495
        if (R == R_1156) { print "Instead of talking to or attacking or taking the verdugos"; rtrue; } ! rule 496
        if (R == R_1157) { print "Instead of examining something edible when the player is in Segundo acto"; rtrue; } ! rule 497
        if (R == R_1158) { print "Instead of smelling or tasting or taking something edible when the player is in Segundo acto"; rtrue; } ! rule 498
        if (R == R_1159) { print "Instead of eating something edible when the player is in Segundo acto"; rtrue; } ! rule 499
        if (R == R_1160) { print "After quipping when the current quip is hambriento"; rtrue; } ! rule 500
        if (R == R_1161) { print "After quipping when the current quip is azotadle"; rtrue; } ! rule 501
        if (R == R_1162) { print "After quipping when the current quip is azotadle"; rtrue; } ! rule 502
        if (R == R_1163) { print "Instead of pulling or pushing or attacking or waving or kissing or touching or smelling the ajusticiado"; rtrue; } ! rule 503
        if (R == R_1164) { print "Instead of taking or attacking or touching or pushing or pulling or waving the guerreros"; rtrue; } ! rule 504
        if (R == R_1165) { print "Instead of taking or attacking or touching or pushing or pulling or waving the armas"; rtrue; } ! rule 505
        if (R == R_1166) { print "Instead of talking to the guerreros"; rtrue; } ! rule 506
        if (R == R_1167) { print "Instead of taking the espada"; rtrue; } ! rule 507
        if (R == R_1168) { print "Instead of taking or pulling or pushing or waving or attacking the heridas"; rtrue; } ! rule 508
        if (R == R_1169) { print "Instead of taking or pulling or pushing or waving or attacking the mano"; rtrue; } ! rule 509
        if (R == R_1170) { print "After quipping when the current quip is sufrimiento"; rtrue; } ! rule 510
        if (R == R_1171) { print "After quipping when the current quip is palabras"; rtrue; } ! rule 511
        if (R == R_1172) { print "After quipping when the current quip is espada-buena"; rtrue; } ! rule 512
        if (R == R_1173) { print "After quipping when the current quip is palabras"; rtrue; } ! rule 513
        if (R == R_1174) { print "Instead of attacking the soldado"; rtrue; } ! rule 514
        if (R == R_1175) { print "Instead of taking or pulling or pushing or waving or attacking the soldado"; rtrue; } ! rule 515
        if (R == R_1176) { print "Instead of touching or pulling or pushing or waving or attacking the espejo"; rtrue; } ! rule 516
        if (R == R_1177) { print "Instead of touching or pulling or pushing or waving or attacking the butaca"; rtrue; } ! rule 517
        if (R == R_1178) { print "Instead of touching or pulling or pushing or waving or attacking the cepillo"; rtrue; } ! rule 518
        if (R == R_1179) { print "Instead of taking the cepillo"; rtrue; } ! rule 519
        if (R == R_1180) { print "Instead of touching or pulling or pushing or waving or attacking the cabello"; rtrue; } ! rule 520
        if (R == R_1181) { print "Instead of taking or touching or pulling or pushing or waving or attacking the enredos"; rtrue; } ! rule 521
        if (R == R_1182) { print "After quipping when the current quip is buenas-noches"; rtrue; } ! rule 522
        if (R == R_1183) { print "After quipping when the current quip is deja-ya"; rtrue; } ! rule 523
        if (R == R_1184) { print "Instead of touching or smelling or tasting or kissing the doncella"; rtrue; } ! rule 524
        if (R == R_1185) { print "Instead of pulling or pushing or waving or attacking the doncella"; rtrue; } ! rule 525
        if (R == R_1186) { print "Instead of fucking the doncella"; rtrue; } ! rule 526
        if (R == R_1187) { print "Does the player mean examining or taking the almohadas in the presence of the almohada"; rtrue; } ! rule 527
        if (R == R_1188) { print "Instead of listening when the player is in Quinto acto"; rtrue; } ! rule 528
        if (R == R_1189) { print "Instead of smelling when the player is in Quinto acto"; rtrue; } ! rule 529
        if (R == R_1190) { print "Instead of taking or pulling or pushing or waving or attacking the telas"; rtrue; } ! rule 530
        if (R == R_1191) { print "Instead of pulling or pushing or waving or attacking the almohadas"; rtrue; } ! rule 531
        if (R == R_1192) { print "Instead of taking or pulling or pushing or waving or attacking the cojines"; rtrue; } ! rule 532
        if (R == R_1193) { print "Instead of taking the almohadas"; rtrue; } ! rule 533
        if (R == R_1194) { print "Instead of taking or pulling or pushing or waving or attacking the mercader"; rtrue; } ! rule 534
        if (R == R_1195) { print "Instead of talking to the mercader"; rtrue; } ! rule 535
        if (R == R_1196) { print "Instead of inserting the almohada into the mercader"; rtrue; } ! rule 536
        if (R == R_1197) { print "Instead of putting the almohada on the mercader"; rtrue; } ! rule 537
        if (R == R_1198) { print "Instead of attacking the mercader"; rtrue; } ! rule 538
        if (R == R_1199) { print "Instead of pulling or pushing or waving or attacking the diamante"; rtrue; } ! rule 539
        if (R == R_1200) { print "Instead of taking the diamante"; rtrue; } ! rule 540
        if (R == R_1201) { print "Instead of listening when the player is in Sexto acto"; rtrue; } ! rule 541
        if (R == R_1202) { print "Instead of talking to the fieles"; rtrue; } ! rule 542
        if (R == R_1203) { print "Instead of smelling when the player is in Sexto acto"; rtrue; } ! rule 543
        if (R == R_1204) { print "Instead of smelling when the player is in altar"; rtrue; } ! rule 544
        if (R == R_1205) { print "Instead of smelling something edible when the player is in altar"; rtrue; } ! rule 545
        if (R == R_1206) { print "Instead of smelling something edible when the player is in Sexto acto"; rtrue; } ! rule 546
        if (R == R_1207) { print "Instead of tasting something edible when the player is in altar"; rtrue; } ! rule 547
        if (R == R_1208) { print "Instead of tasting something edible when the player is in Sexto acto"; rtrue; } ! rule 548
        if (R == R_1209) { print "Instead of taking or pulling or pushing or waving or attacking or touching the hoguera"; rtrue; } ! rule 549
        if (R == R_1210) { print "Instead of burning something in the presence of the hoguera"; rtrue; } ! rule 550
        if (R == R_1211) { print "Instead of pulling or pushing or waving or attacking the ternero"; rtrue; } ! rule 551
        if (R == R_1212) { print "Instead of eating or drinking or tasting the ternero"; rtrue; } ! rule 552
        if (R == R_1213) { print "Instead of entering the altar"; rtrue; } ! rule 553
        if (R == R_1214) { print "Instead of going dentro when the player is in Sexto acto"; rtrue; } ! rule 554
        if (R == R_1215) { print "Instead of going up in Sexto acto"; rtrue; } ! rule 555
        if (R == R_1216) { print "Instead of getting off the altar"; rtrue; } ! rule 556
        if (R == R_1217) { print "Instead of going down when the player is in altar"; rtrue; } ! rule 557
        if (R == R_1218) { print "Instead of exiting when the player is in altar"; rtrue; } ! rule 558
        if (R == R_1219) { print "Instead of examining or taking the piedra for the first time"; rtrue; } ! rule 559
        if (R == R_1220) { print "Instead of examining the piedras"; rtrue; } ! rule 560
        if (R == R_1221) { print "Instead of taking the piedras"; rtrue; } ! rule 561
        if (R == R_1222) { print "Instead of drinking some edible when the player is in Sexto acto"; rtrue; } ! rule 562
        if (R == R_1223) { print "Instead of drinking some edible when the player is in the altar"; rtrue; } ! rule 563
        if (R == R_1224) { print "Instead of eating something edible when the player is in Sexto acto"; rtrue; } ! rule 564
        if (R == R_1225) { print "Instead of taking or smelling or tasting something edible when the player is in Sexto acto"; rtrue; } ! rule 565
        if (R == R_1226) { print "Instead of eating something edible when the player is in altar"; rtrue; } ! rule 566
        if (R == R_1227) { print "Instead of listening when the player is in Septimo acto"; rtrue; } ! rule 567
        if (R == R_1228) { print "Instead of smelling when the player is in Septimo acto"; rtrue; } ! rule 568
        if (R == R_1229) { print "After quipping when the current quip is hola-hermano"; rtrue; } ! rule 569
        if (R == R_1230) { print "After quipping when the current quip is ternero-hermano"; rtrue; } ! rule 570
        if (R == R_1231) { print "After quipping when the current quip is mi-ofrenda"; rtrue; } ! rule 571
        if (R == R_1232) { print "Instead of pulling or pushing or waving or kissing or touching or smelling the hermano"; rtrue; } ! rule 572
        if (R == R_1233) { print "Instead of attacking the hermano"; rtrue; } ! rule 573
        if (R == R_1234) { print "Instead of throwing the piedra at the hermano"; rtrue; } ! rule 574

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RULEBOOK_TY_to_RULE_TY r;
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	print "does not apply (wrong ", (address) blocked, ").]^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Front End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Sort Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Comparison and Exchange
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y r;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	r = I7S_Swap(I7S_Tab, x+1, y+1);
	
	return r; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: 4W37 Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Insertion Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: In-Place Mergesort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TB_COLUMN_REAL        $8000;
Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Find Column
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Number of Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blanks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Masks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Testing Blankness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkValueFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Non-Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swapping Blank Bits
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Moving Blank Bits Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Row Corresponding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowCorr tab col lookup_value lookup_col i j f v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (f) {
		for (i=1:i<=j:i++) {
			v = lookup_col-->(i+COL_HSIZE);
			if ((v == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (BlkValueCompare(v, lookup_value) == 0)
				return i;
		}
	} else {
		for (i=1:i<=j:i++) {
			if ((lookup_value == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Corresponding Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;

		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			if (write_flag == 4) ForceTableEntryBlank(tab,col1,i-COL_HSIZE);
			else ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				1: cola1-->i = write_value;
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				5: return cola1-->i;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpEntry tab col index write_flag write_value v;
	if (tab == 0) return RunTimeProblem(RTP_TABLE_NOTABLE2);
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab))) {
		RunTimeProblem(RTP_TABLE_NOROW, tab, index); index = 1;
	}
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index))) {
		RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index); rfalse;
	}
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blank Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Random Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swap Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Compare Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_REAL) {
		if (REAL_NUMBER_TY_Compare(val1, val2) > 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Row Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Shuffle
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Next Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) blk = true;
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
				if (row == 0) z = 1; else z = BlkValueCompare(v, val);
				f = (((z > 0) || ((z == 0) && (i > row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) < 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i>row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
		    	if (row == 0) z = -1; else z = BlkValueCompare(v, val);
				f = (((z < 0) || ((z == 0) && (i < row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) > 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i<row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Blanks to Back
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table Name
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T3_user_styles: print "Table of User Styles"; return;
  T4_ordinary_status: print "Table of Ordinary Status"; return;
  T6_sample_options: print "Table of Sample Options"; return;
  T7_menu_commands: print "Table of Menu Commands"; return;
  T8_shallow_menu_status: print "Table of Shallow Menu Status"; return;
  T9_deep_menu_status: print "Table of Deep Menu Status"; return;
  T10_sample_hints: print "Table of Sample Hints"; return;
  T12_basic_help_options: print "Table of Basic Help Options"; return;
  T13_instruction_options: print "Table of Instruction Options"; return;
  T14_stuckness_advice: print "Table of Stuckness Advice"; return;
  T15_if_elements: print "Table of IF Elements"; return;
  T16_setting_options: print "Table of Setting Options"; return;
  T17_quip_texts: print "Table of Quip Texts"; return;
  T18_quip_followups: print "Table of Quip Followups"; return;
  T19_ask_results: print "Table of Ask Results"; return;
  T20_tell_results: print "Table of Tell Results"; return;
  T21_no_conversation: print "Table of No Conversation"; return;
  T24_pastor_conversation: print "Table of Pastor Conversation"; return;
  T26_ajusticiado_conversation: print "Table of Ajusticiado Conversation"; return;
  T28_soldado_conversation: print "Table of Soldado Conversation"; return;
  T30_doncella_conversation: print "Table of Doncella Conversation"; return;
  T32_hermano_conversation: print "Table of Hermano Conversation"; return;
  T34_hints: print "Table of Hints"; return;
  T35_escribir_en_libro_hints: print "Table of escribir-en-libro Hints"; return;
  T36_resolver_los_actos_hints: print "Table of resolver-los-actos Hints"; return;
  T37_acabar_con_musa_hints: print "Table of acabar-con-musa Hints"; return;

		default: print "** No such table **";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table to File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Read Table from File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Rank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	ANNOUNCE_SCORE_RM('B');
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    TEXT_TY_Say(v);
		    ".";
		}
#endif;
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableColumnDebug tab col k i v tc kov;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
	kov = TC_KOV(tc);
	for (i=1:i<=k:i++) {
		if (i>1) print ", ";
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "--";
		else {
			PrintKindValuePair(kov, v);
		}
	}
	say__p = 1;
];

[ TableRowDebug tab i col k v tc kov;
	k = TableRows(tab);
	if ((i<1) || (i>k)) "No such row";
	print "(row ", i, ")  |";
	for (col=1: col<=tab-->0: col++) {
		print " ";
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "-- ";
		else {
			PrintKindValuePair(kov, v);
			print " |";
		}
	}
	say__p = 1;
];

[ TableDebug tab i k;
	PrintTableName(tab); print "^";
	k = TableRows(tab);
	for (i=1:i<=k:i++) { TableRowDebug(tab, i); print "^"; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: The Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Climbing the Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LocationOf o;
	if (~~(o ofclass K1_room or K2_thing)) return nothing;
	if (o ofclass K4_door) {
		if (parent(o) == real_location) return real_location;
		return FrontSideOfDoor(o);
	}
	if (o ofclass K7_backdrop) {
		! print "(deciding ", (the) O, " is at ", (the) BackdropLocation(o), ") ";
		return BackdropLocation(o);
	}
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2 && o2 ~= thedark : o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: To Decide Whether In
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Support Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Carrying Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Having Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Making Parts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakePart P Of First;
	if (P == player) return RunTimeProblem(RTP_CANTMAKEPART, Of);
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Movements
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveObject F T opt going_mode was L;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		if (T == FoundEverywhere) {
			give F ~absent; F.found_in = FoundEverywhere;
			return;
		}
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (T == FoundEverywhere) return RunTimeProblem(RTP_BACKDROPONLY, F);
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if (IndirectlyContains(F, player)) {
			L = LocationOf(T);
			if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
			if (LocationOf(player) ~= L) {
				was = parent(player);
				move player to real_location;
				move F to T;
				PlayerTo(was, true);
				return;
			}
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	if (IndirectlyContains(F, player)) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: On Stage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Moving the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlayerTo newplace flag L;
    L = LocationOf(newplace);
   	if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	@push actor; actor = player;
    move player to newplace;
    location = L;
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Move During Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Being Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FoundEverywhere; rtrue; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Testing Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropEverywhere O;
	if (O ofclass K7_backdrop) {
		if (O has absent) rfalse;
		if (O.found_in == FoundEverywhere) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Changing the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChangePlayer obj flag;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj.component_parent) return RunTimeProblem(RTP_CANTMAKEPART, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name;
    	player.short_name = PRINT_PROTAGONIST_INTERNAL_RM('c');
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Floating Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveFloatingObjects toroom i k l m address flag;
	if (toroom == nothing) toroom = real_location;
    if (toroom == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(toroom) ~= 0) move i to toroom;
                else { if (i in toroom) remove i; }
            } else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == toroom || m in toroom) {
                        if (i notin toroom) move i to toroom;
                        flag = true;
                    }
                }
                if (flag == false) { if (i in toroom) remove i; }
            }
            if ((i ofclass K4_door) && (parent(i) == nothing)) {
            	move i to ((i.door_to).call());
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Backdrop Location
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropLocation O target address m x i k l r sl;
	if (O has absent) return nothing;
	if ((target == nothing or real_location) && (parent(O) == real_location))
		return real_location;
	address = O.&found_in;
	if (address ~= 0) {
		k = O.#found_in;
		for (l=0 : l<k/WORDSIZE : l++) {
			m = address-->l;
			if (ZRegion(m) == 2) {
				sl = location;
				if (target) {
					location = target;
					r = m.call();
					if (r ~= 0) { location = sl; return target; }
				} else {
					objectloop (x ofclass K1_room) {
						location = x;
						r = m.call();
						if (r ~= 0) { location = sl; return x; }
					}
				}
				location = sl;
			} else {
				if (m ofclass K9_region) {
					objectloop (x ofclass K1_room)
						if (TestRegionalContainment(x, m))
							if (target == nothing or x)
								return x;
				} else {
					if (target == nothing or m) return m;
				}
			}
		}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Clothes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Map Connections
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = 0;
	return;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Adjacency Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestAdjacency R1 R2 i row;
	if (R1 ofclass K9_region) RunTimeProblem(RTP_REGIONSNOTADJACENT, R1);
	else if (R2 ofclass K9_region) RunTimeProblem(RTP_REGIONSNOTADJACENT, R2);
	row = (R1.IK1_Count)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Regional Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (obj ofclass K7_backdrop or K4_door) {
		if (obj has absent) rfalse;
		objectloop (o ofclass K1_room)
			if (TestRegionalContainment(o, region))
				if (BackdropLocation(obj, o))
					rtrue;
		rfalse;
	}
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Doors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Visibility Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Touchability Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestTouchability A B rv;
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(B));
	if (B ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(A));
	if (TestScope(B,A) == false) rv = true;
	else rv = ObjectIsUntouchable(B, true, A);
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects();
	if (rv) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Concealment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parsing Tokens
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ Cond_Token_12 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_13 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_14 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_15 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_16 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_17 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_18 ;
    if ((((~~((player == selfobj)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_440 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_448 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_443 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_453 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_437 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_449 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_438 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_450 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_439 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_447 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_441 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_454 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_442 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_455 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_444 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_452 ;
    if ((((PHR_942_r9 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_445 ;
    if ((((PHR_926_r2 ())))) return GPR_PREPOSITION;
    return GPR_FAIL;
];




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Truth states
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Absolute value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_Abs x; if (x<0) return -x; return x; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RealNumber.i6t: Printing reals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;

[ REAL_NUMBER_TY_Say fp;
	print (Float) fp;
];

[ REAL_NUMBER_TY_Compare r1 r2;
	@jflt r1 r2 ?less;
	@jfeq r1 r2 0 ?same;
	return 1;
	.same; return 0;
	.less; return -1;
];

[ NUMBER_TY_to_REAL_NUMBER_TY int real; @numtof int real; return real; ];
[ REAL_NUMBER_TY_to_NUMBER_TY real int; @ftonumn real int; return int; ];

[ REAL_NUMBER_TY_Sin in out; @sin in out; return out; ];
[ REAL_NUMBER_TY_Cos in out; @cos in out; return out; ];
[ REAL_NUMBER_TY_Tan in out; @tan in out; return out; ];
[ REAL_NUMBER_TY_Arcsin in out; @asin in out; return out; ];
[ REAL_NUMBER_TY_Arccos in out; @acos in out; return out; ];
[ REAL_NUMBER_TY_Arctan in out; @atan in out; return out; ];

[ REAL_NUMBER_TY_Sinh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fadd tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Cosh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fsub tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Tanh in tmp out;
	tmp = REAL_NUMBER_TY_Sinh(in);
	in = REAL_NUMBER_TY_Cosh(in);
	@fdiv tmp in out;
	return out;
];

[ REAL_NUMBER_TY_Reciprocal in out; @fdiv M_1 in out; return out; ];
[ REAL_NUMBER_TY_Negate in out; @fsub M_0 in out; return out; ];
[ REAL_NUMBER_TY_Plus x y out; @fadd x y out; return out; ];
[ REAL_NUMBER_TY_Minus x y out; @fsub x y out; return out; ];
[ REAL_NUMBER_TY_Times x y out; @fmul x y out; return out; ];
[ REAL_NUMBER_TY_Divide x y out; @fdiv x y out; return out; ];
[ REAL_NUMBER_TY_Remainder x y r q; @fmod x y r q; return r; ];
[ REAL_NUMBER_TY_Approximate x y quotient out;
	@fdiv x y quotient;
	@fadd quotient M_HALF quotient;
	@floor quotient quotient;
	@fmul quotient y out;
	return out;
];
[ REAL_NUMBER_TY_Root x out; @sqrt x out; return out; ];
[ REAL_NUMBER_TY_Cube_Root x out; @pow x M_THIRD out; return out; ];
[ REAL_NUMBER_TY_Pow x y out; @pow x y out; return out; ];
[ REAL_NUMBER_TY_Exp x out; @exp x out; return out; ];
[ REAL_NUMBER_TY_Log x out; @log x out; return out; ];
[ REAL_NUMBER_TY_BLog x n d out;
	@log x out;
	if (n == 10) d = M_LOG10;
	else {
		@numtof n d;
		@log d d;
	}
	@fdiv out d out;
	return out;
];
[ REAL_NUMBER_TY_Floor x out; @floor x out; return out; ];
[ REAL_NUMBER_TY_Ceiling x out; @ceil x out; return out; ];
[ REAL_NUMBER_TY_Abs x; return x & $7fffffff; ];
[ REAL_NUMBER_TY_Nan x; @jisnan x ?Nan; rfalse; .Nan; rtrue; ];

Constant M_0    = $0;
Constant M_1    = $3F800000;
Constant M_HALF = $3F000000; ! 1/3
Constant M_THIRD = $3EAAAAAB; ! 1/3
Constant M_LOG10 = $40135D8E; ! log(10)
Constant M_N1   = $BF800000; ! -1
Constant M_PI   = $40490FDB;
Constant M_NPI  = $C0490FDB;
Constant M_2PI  = $40C90FDB; ! 2*pi
Constant M_PI2  = $3FC90FDB; ! pi/2
Constant M_NPI2 = $BFC90FDB; 
Constant M_E    = $402DF854;
Constant M_E2   = $40EC7326; ! e^2
Constant M_N0   = $80000000; ! negative zero
Constant M_INF  = $7F800000; ! infinity
Constant M_NINF = $FF800000; ! negative infinity
Constant M_NAN  = $7F800001; ! one of many NaN values
Constant M_NNAN = $FF800001; ! another, with a sign bit

! Floating-point parsing routines.

! Parse a float from a text buffer. Returns a float value, or FLOAT_NAN if
! no value was understood.
!
! The recognized format, if you'll pardon a slightly bastardized regexp
! syntax, is "S?D*(PD*)?(ES?D+)?" where S is a sign character "+" or "-",
! D is a decimal digit "0" to "9", P is a decimal point ".",
! and E is the exponential modifier "E" or "e".
!
! For flexibility, the string "M10^" is also accepted for E, where M is
! "X", "x", "*", or the multiplication sign @{D7}. Optional spaces are
! allowed before and after the M sign. (But only for the "10^" form of
! the exponent, not the "e" form.)
!
! This routine does not try to recognize special names for infinity or NaN,
! but it can return FLOAT_INFINITY or FLOAT_NINFINITY if the exponent is too
! large.
!
! This routine relies on floating-point math. Therefore, the same string
! may parse to slightly different float values on different interpreters!
! Be warned.
!
! If useall is true, this insists on using all len characters from the buffer.
! (It returns FLOAT_NAN if any unrecognized characters are left over.)
! Contrariwise, if useall is false, unused characters at the end of the buffer
! are fine. (But not at the beginning; the float must start at the beginning
! of the buffer.)
! 
[ FloatParse buf len useall
	res ix val ch ten negative intpart fracpart fracdiv
	expon expnegative count;
	
!	print "FloatParse <";
!	for (ix=0: ix<len: ix++) print (char) buf->ix;
!	print ">^";

	if (len == 0)
		return FLOAT_NAN;
		
	ix = 0;
	negative = false;
	intpart = 0;
	fracpart = 0;
	@numtof 10 ten;

	! Sign character (optional)
	ch = buf->ix;
	if (ch == '-') {
		negative = true;
		ix++;
	}
	else if (ch == '+') {
		ix++;
	}

	! Some digits (optional)
	for (count=0 : ix<len : ix++, count++) {
		ch = buf->ix;
		if (ch < '0' || ch > '9')
			break;
		val = (ch - '0');
		@numtof val val;
		@fmul intpart ten intpart;
		@fadd intpart val intpart;
	}

	! Decimal point and more digits (optional)
	if (ix<len && buf->ix == '.') {
		ix++;
		@numtof 1 fracdiv;
		for ( : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			val = (ch - '0');
			@numtof	val val;
			@fmul fracpart ten fracpart;
			@fadd fracpart val fracpart;
			@fmul fracdiv ten fracdiv;
		}
		@fdiv fracpart fracdiv fracpart;
	}

	! If there are no digits before *or* after the decimal point, fail.
	if (count == 0)
		return FLOAT_NAN;

	! Combine the integer and fractional parts.
	@fadd intpart fracpart res;

	! Exponent (optional)
	if (ix<len && buf->ix == 'e' or 'E' or ' ' or '*' or 'x' or 'X' or $D7) {
		if (buf->ix == 'e' or 'E') {
			! no spaces, just the 'e'
			ix++;
			if (ix == len)
				return FLOAT_NAN;
		}
		else {
			! any number of spaces, "*", any number of spaces more, "10^"
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '*' or 'x' or 'X' or $D7)
				return FLOAT_NAN;
			ix++;
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '1')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= '0')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= $5E)
				return FLOAT_NAN;
			ix++;
		}

		! Sign character (optional)
		expnegative = false;
		ch = buf->ix;
		if (ch == '-') {
			expnegative = true;
			ix++;
		}
		else if (ch == '+') {
			ix++;
		}

		expon = 0;
		! Some digits (mandatory)
		for (count=0 : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			expon = 10*expon + (ch - '0');
		}

		if (count == 0)
			return FLOAT_NAN;

		if (expnegative)
			expon = -expon;

		if (expon) {
			@numtof expon expon;
			@pow ten expon val;
			@fmul res val res;
		}
	}

	if (negative) {
		! set the value's sign bit
		res = $80000000 | res;
	}

	if (useall && ix ~= len)
		return FLOAT_NAN;
	return res;
];

! An I6 grammar routine (GPR) for floats. On success, this returns
! GPR_NUMBER and stores a value in the global parsed_number.
!
! This is quite a nuisance, actually, because "." is a word separator.
! Also, we want to accept command sequences like "type 4. look"! So we
! need to collect a set of words made up of digits, signs, periods, and
! the letter "e", but without any intervening whitespace, and excluding
! a trailing period.
!
! (This will fail to correctly parse "type 4.e", but I think that is a
! small flaw. A player would more likely try "type 4. e" or, really,
! not concatenate commands at all. It will also parse "type 4. on keyboard"
! as two commands, even though "4." is a legitimate float literal.
! Contrariwise, "type 4. x me" will be taken as one command. (Because the "x"
! *could* be a continuation of the float, and I don't back up when it turns
! out not to be.) I don't plan to worry about these cases.)

[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
	if (wn > num_words)
		return GPR_FAIL;

	! We're going to collect a set of words. Start with zero words.
	firstwd = wn;
	buf = WordAddress(wn);
	bufend = buf;
	lastchar = 0;

	while (wn <= num_words) {
		newstart = WordAddress(wn);
		if (newstart ~= bufend) {
			! There's whitespace between the previous word and this one.
			! Whitespace is okay around an asterisk...
			if ((lastchar ~= '*' or 'x' or 'X' or $D7)
				&& (newstart->0 ~= '*' or 'x' or 'X' or $D7)) {
				! But around any other character, it's not.
				! Don't include the new word.
				break;
			}
		}
		newlen = WordLength(wn);
		for (ix=0 : ix<newlen : ix++) {
			ch = newstart->ix;
			if (~~((ch >= '0' && ch <= '9')
				|| (ch == '-' or '+' or 'E' or 'e' or '.' or 'x' or 'X' or '*' or $D7 or $5E)))
				break;
		}
		if (ix < newlen) {
			! This word contains an invalid character.
			! Don't include the new word.
			break;
		}
		! Okay, include it.
		bufend = newstart + newlen;
		wn++;
		lastchar = (bufend-1)->0;
		lastwasdot = (newlen == 1 && lastchar == '.');
	}

	if (wn > firstwd && lastwasdot) {
		! Exclude a trailing period.
		wn--;
		bufend--;
	}

	if (wn == firstwd) {
		! No words accepted.
		return GPR_FAIL;
	}

	parsed_number = FloatParse(buf, bufend-buf, true);
	if (parsed_number == FLOAT_NAN)
		return GPR_FAIL;
	return GPR_NUMBER;
];

! Floating-point printing routines. (These are based on code in
! Glulxercise.inf, but modified.)
  
! Print a float. This uses exponential notation ("[-]N.NNNe[+-]NN") if
! the exponent is not between 6 and -4. If it is (that is, if the
! absolute value is near 1.0) then it uses decimal notation ("[-]NNN.NNNNN").
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ Float val prec   pval;
	pval = val & $7FFFFFFF;

	@jz pval ?UseFloatDec;
	@jfge pval $49742400 ?UseFloatExp; ! 1000000.0
	@jflt pval $38D1B717 ?UseFloatExp; ! 0.0001

	.UseFloatDec;
	return FloatDec(val, prec);
	.UseFloatExp;
	return FloatExp(val, prec);
];

Array PowersOfTen --> 1 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000;

! Print a float in exponential notation: "[-]N.NNNe[+-]NN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatExp val prec   log10val expo fexpo idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;

	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	if (val == $0) {
		expo = 0;
		idig = 0;
		jump DoPrint;
	}

	! Take as an example val=123.5, with precision=6. The desired
	! result is "1.23000e+02".
	
	@log val sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@floor log10val fexpo;
	@ftonumn fexpo expo;
	! expo is now the exponent (as an integer). For our example, expo=2.

	@fsub log10val fexpo sp;
	@numtof prec sp;
	@fadd sp sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((log10val - fexpo + prec) * log(10)).
	! We've shifted the decimal point left by expo digits (so that
	! it's after the first nonzero digit), and then right by prec
	! digits. In our example, that would be 1235000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 1235000. Notice that this is
	! exactly the digits we want to print (if we stick a decimal point
	! after the first).

	.DoPrint;
	
	if (idig >= 10*pow10) {
		! Rounding errors have left us outside the decimal range of
		! [1.0, 10.0) where we should be. Adjust to the next higher
		! exponent.
		expo++;
		@div idig 10 idig;
	}
	
	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	for (ix=0 : ix<=prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		if (ix == 0)
			@streamchar '.';
		@div pow10 10 pow10;
	}

	! Print the exponent. There are two conventions coded here: the
	! programmatic ("1.0e+00") and the literary ("1.0 x 10^0").
	#ifndef FLOAT_PROGRAMMING_EXPONENTS;
		PrintMultiplicationSign();
		@streamstr "10";
		@streamchar $5E;
		@streamnum expo;
	#ifnot;
		! Convention is to use at least two digits.
		@streamchar 'e';
		if (expo < 0) {
			@streamchar '-';
			@neg expo expo;
		}
		else {
			@streamchar '+';
		}
		if (expo < 10)
			@streamchar '0';
		@streamnum expo;
	#endif; ! FLOAT_PROGRAMMING_EXPONENTS
	
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

! Print a float in decimal notation: "[-]NNN.NNNNN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatDec val prec   log10val int fint extra0 frac idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;
	
	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	! Take as an example val=123.5, with precision=6. The desired result
	! is "123.50000".
	
	extra0 = 0;
	@fmod val $3F800000 frac fint; ! $3F800000 is 1.0.
	@ftonumz fint int;
	! This converts the integer part of the value to an integer value;
	! in our example, 123.
	
	if (int == $7FFFFFFF) {
		! Looks like the integer part of the value is bigger than
		! we can store in an int variable. (It could be as large
		! as 3e+38.) We're going to have to use a log function to
		! reduce it by some number of factors of 10, and then pad
		! with zeroes.
		@log fint sp;
		@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
		@ftonumz log10val extra0;
		@sub extra0 8 extra0;
		! extra0 is the number of zeroes we'll be padding with.
		@numtof extra0 sp;
		@fsub log10val sp sp;
		@fmul sp $40135D8E sp;
		@exp sp sp;
		! The stack value is now exp((log10val - extra0) * log(10)).
		! We've shifted the decimal point far enough left to leave
		! about eight digits, which is all we can print as an integer.
		@ftonumz sp int;
	}

	! Print the integer part.
	@streamnum int;
	for (ix=0 : ix<extra0 : ix++)
		@streamchar '0';

	@streamchar '.';

	! Now we need to print the frac part, which is .5.
	
	@log frac sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@numtof prec sp;
	@fadd log10val sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((frac + prec) * log(10)).
	! We've shifted the decimal point right by prec
	! digits. In our example, that would be 50000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 50000. Notice that this is
	! exactly the (post-decimal-point) digits we want to print.

	.DoPrint;
	
	if (idig >= pow10) {
		! Rounding errors have left us outside the decimal range of
		! [0.0, 1.0) where we should be. I'm not sure this is possible,
		! actually, but we'll just adjust downward.
		idig = pow10 - 1;
	}

	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	@div pow10 10 pow10;
	for (ix=0 : ix<prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		@div pow10 10 pow10;
	}
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

[ PrintInfinity;
	@streamunichar $221E;
	! @streamstr "Inf";
];

[ PrintNan;
	@streamunichar $26a0;
	! @streamstr "NaN";
];

[ PrintMultiplicationSign;
	print " ";
	@streamunichar $D7;
	print " ";
	! @streamstr " x ";
];

#Ifnot; ! TARGET_GLULX

[ REAL_NUMBER_TY_Say real; print real; ]; ! Needs to exist, but likely never used

[ REAL_NUMBER_TY_Compare r1 r2; return UnsignedCompare(r1, r2); ];

#Endif; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Rounding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RoundOffTime t1 t2;
	if (t1 >= 0) return ((t1+t2/2)/t2)*t2;
	return -((-t1+t2/2)/t2)*t2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Conversion To Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_to_TIME_TY n;
	n = n%1440;
	if (n < 0) return n + 1440;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Square Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SquareRoot num
    op res one n x;
    if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }

    ! Use floating-point ops if available.
    #ifdef TARGET_GLULX;
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
   #endif;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		! print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, " nthb = ", WORD_NEXTTOHIGHBIT, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res/2 + one;
		} else {
			res = res/2;
		}
		one = one/4;
	}
	! print "Res is ", res, "^";
	return res;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Cube Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CubeRoot num neg x y n;
    ! Use floating-point ops if available.
    #ifdef TARGET_GLULX;
    @gestalt 11 0 n;
    if (n) {
        if (num < 0) {
            neg = true;
            num = -num;
        }
        @numtof num x;
        @pow x 1051372203 x; ! pow(x, 0.3333)
        @ftonumz x num;
        if (neg)
            return -num;
        else
            return num;
    }
    #endif;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Digital Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];


! Spanish Version of the saying 'time of day in words'
![ PrintTimeOfDaySpanish t h m dir aop say_minutes quad;
[ PrintTimeOfDayEnglish t h m dir aop say_minutes quad;

!   t store the minutes from 0am until now
!  se tiene en cuenta: 8:40 nueve menos veinte
!                               8:15 ocho y cuarto
!                               8:53 7 minutos para las nueve
!	                    8:14 ocho horas y catorce minutos
!           		        1:20 una y veinte (y todas las variantes con 'una')

    quad = 1; ! =1 es la primera media hora, =2 es la segunda
    h = (t/60) % 12; m = t%60; if (h==0) h=12;
	if (m==0) { if(h==1) print "una"; else print (number) h;print " en punto"; return; } !infsp hack
	dir = "y";! infsp hack
	if (m > 30) { m = 60-m; h = (h+1)%12; if (h==0) h=12; dir = "menos"; quad=2;} !infsp hack
	switch(m) {
        5: say_minutes = "cinco";
        10:say_minutes = "diez";
		15: say_minutes = "cuarto";
        20: say_minutes = "veinte";
        25: say_minutes = "veinticinco";
        30: say_minutes = "media";
		default: 
            if (quad == 2){
              print (number) m;
		      if (m%5 ~= 0) {
					if (m == 1) print " minuto"; else print " minutos"; ! infsp hack
		      }
              if(h==1) print " para la una"; else print " ", "para las ", (number) h;!infsp hack

            }
            if (quad == 1){
              if(h==1) print "una y "; else print (number) h," horas "; print (number) m;
		      if (m%5 ~= 0) {
					if (m == 1) print " minuto"; else print " minutos"; ! infsp hack
		      }
            }
        	return;
	}
	if(h==1) print "una"; else print (number) h; print " ",(string) dir, " ",(string) say_minutes;!infsp hack
]; 

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Analogue Printing (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];


[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
!	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	if (first_word == 'una' or 'un') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'media') offhour = HALF_HOUR;
		if (first_word == 'cuarto') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'de') second_word = NextWordStopped();
!			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hora') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutos', 'minuto': mult = 1;
		'hora', 'horas': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutos' or 'minuto')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Relative Time Token (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: During Scene Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Scene Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];

[ Kind_GPR_11 
    original_wn ! internal use only
    group_wn ! internal use only
    v ! internal use only
    w ! internal use only
    rv ! internal use only
    ;
    original_wn = wn;
    return GPR_FAIL;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Text generation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
[ ConjugateVerb_0 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be";
        2: print "been";
        3: print "being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am";
                    2: print "are";
                    3: print "is";
                    4: print "are";
                    5: print "are";
                    6: print "are";
                }
                2: switch (vp) {
                    1: print "was";
                    2: print "were";
                    3: print "was";
                    4: print "were";
                    5: print "were";
                    6: print "were";
                }
                3: if (vp == 3) { print "has been"; } else { print "have been"; }
                4: print "had been";
                5: print "will be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "are not";
                    3: print "is not";
                    4: print "are not";
                    5: print "are not";
                    6: print "are not";
                }
                2: switch (vp) {
                    1: print "was not";
                    2: print "were not";
                    3: print "was not";
                    4: print "were not";
                    5: print "were not";
                    6: print "were not";
                }
                3: if (vp == 3) { print "has not been"; } else { print "have not been"; }
                4: print "had not been";
                5: print "will not be";
            }
    }
];
[ ConjugateVerb_1 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "auxiliary-have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "has not"; } else { print "have not"; }
                2: print "had not";
            }
    }
];
[ ConjugateVerb_2 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_27;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
                3: if (vp == 3) { print "has had"; } else { print "have had"; }
                4: print "had had";
                5: print "will have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not have"; } else { print "do not have"; }
                2: print "did not have";
                3: if (vp == 3) { print "has not had"; } else { print "have not had"; }
                4: print "had not had";
                5: print "will not have";
            }
    }
];
[ ConjugateVerb_3 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "do";
        2: print "done";
        3: print "doing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "does"; } else { print "do"; }
                2: print "did";
                3: if (vp == 3) { print "has done"; } else { print "have done"; }
                4: print "had done";
                5: print "will do";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not"; } else { print "do not"; }
                2: print "did not";
                3: if (vp == 3) { print "has not done"; } else { print "have not done"; }
                4: print "had not done";
                5: print "will not do";
            }
    }
];
[ ConjugateVerb_4 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "relate";
        2: print "related";
        3: print "relating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_3;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "relates"; } else { print "relate"; }
                2: print "related";
                3: if (vp == 3) { print "has related"; } else { print "have related"; }
                4: print "had related";
                5: print "will relate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not relate"; } else { print "do not relate"; }
                2: print "did not relate";
                3: if (vp == 3) { print "has not related"; } else { print "have not related"; }
                4: print "had not related";
                5: print "will not relate";
            }
    }
];
[ ConjugateVerb_5 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mean";
        2: print "meant";
        3: print "meaning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_5;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "means"; } else { print "mean"; }
                2: print "meant";
                3: if (vp == 3) { print "has meant"; } else { print "have meant"; }
                4: print "had meant";
                5: print "will mean";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mean"; } else { print "do not mean"; }
                2: print "did not mean";
                3: if (vp == 3) { print "has not meant"; } else { print "have not meant"; }
                4: print "had not meant";
                5: print "will not mean";
            }
    }
];
[ ConjugateVerb_6 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provide";
        2: print "provided";
        3: print "providing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_1;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provides"; } else { print "provide"; }
                2: print "provided";
                3: if (vp == 3) { print "has provided"; } else { print "have provided"; }
                4: print "had provided";
                5: print "will provide";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provide"; } else { print "do not provide"; }
                2: print "did not provide";
                3: if (vp == 3) { print "has not provided"; } else { print "have not provided"; }
                4: print "had not provided";
                5: print "will not provide";
            }
    }
];
[ ConjugateVerb_7 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "contain";
        2: print "contained";
        3: print "containing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_15;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "contains"; } else { print "contain"; }
                2: print "contained";
                3: if (vp == 3) { print "has contained"; } else { print "have contained"; }
                4: print "had contained";
                5: print "will contain";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not contain"; } else { print "do not contain"; }
                2: print "did not contain";
                3: if (vp == 3) { print "has not contained"; } else { print "have not contained"; }
                4: print "had not contained";
                5: print "will not contain";
            }
    }
];
[ ConjugateVerb_8 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "support";
        2: print "supported";
        3: print "supporting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_17;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "supports"; } else { print "support"; }
                2: print "supported";
                3: if (vp == 3) { print "has supported"; } else { print "have supported"; }
                4: print "had supported";
                5: print "will support";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not support"; } else { print "do not support"; }
                2: print "did not support";
                3: if (vp == 3) { print "has not supported"; } else { print "have not supported"; }
                4: print "had not supported";
                5: print "will not support";
            }
    }
];
[ ConjugateVerb_9 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "incorporate";
        2: print "incorporated";
        3: print "incorporating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_19;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "incorporates"; } else { print "incorporate"; }
                2: print "incorporated";
                3: if (vp == 3) { print "has incorporated"; } else { print "have incorporated"; }
                4: print "had incorporated";
                5: print "will incorporate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not incorporate"; } else { print "do not incorporate"; }
                2: print "did not incorporate";
                3: if (vp == 3) { print "has not incorporated"; } else { print "have not incorporated"; }
                4: print "had not incorporated";
                5: print "will not incorporate";
            }
    }
];
[ ConjugateVerb_10 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "enclose";
        2: print "enclosed";
        3: print "enclosing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_37;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "encloses"; } else { print "enclose"; }
                2: print "enclosed";
                3: if (vp == 3) { print "has enclosed"; } else { print "have enclosed"; }
                4: print "had enclosed";
                5: print "will enclose";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not enclose"; } else { print "do not enclose"; }
                2: print "did not enclose";
                3: if (vp == 3) { print "has not enclosed"; } else { print "have not enclosed"; }
                4: print "had not enclosed";
                5: print "will not enclose";
            }
    }
];
[ ConjugateVerb_11 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "carry";
        2: print "carried";
        3: print "carrying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_21;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "carries"; } else { print "carry"; }
                2: print "carried";
                3: if (vp == 3) { print "has carried"; } else { print "have carried"; }
                4: print "had carried";
                5: print "will carry";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not carry"; } else { print "do not carry"; }
                2: print "did not carry";
                3: if (vp == 3) { print "has not carried"; } else { print "have not carried"; }
                4: print "had not carried";
                5: print "will not carry";
            }
    }
];
[ ConjugateVerb_12 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hold";
        2: print "held";
        3: print "holding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_23;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "holds"; } else { print "hold"; }
                2: print "held";
                3: if (vp == 3) { print "has held"; } else { print "have held"; }
                4: print "had held";
                5: print "will hold";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hold"; } else { print "do not hold"; }
                2: print "did not hold";
                3: if (vp == 3) { print "has not held"; } else { print "have not held"; }
                4: print "had not held";
                5: print "will not hold";
            }
    }
];
[ ConjugateVerb_13 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wear";
        2: print "worn";
        3: print "wearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_25;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wears"; } else { print "wear"; }
                2: print "wore";
                3: if (vp == 3) { print "has worn"; } else { print "have worn"; }
                4: print "had worn";
                5: print "will wear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wear"; } else { print "do not wear"; }
                2: print "did not wear";
                3: if (vp == 3) { print "has not worn"; } else { print "have not worn"; }
                4: print "had not worn";
                5: print "will not wear";
            }
    }
];
[ ConjugateVerb_14 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to see";
        2: print "been able to see";
        3: print "being able to see";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_31;
        CV_POS:
            switch (t) {
                1: print "can see";
                2: print "could see";
                3: if (vp == 3) { print "has been able to see"; } else { print "have been able to see"; }
                4: print "had been able to see";
                5: print "will be able to see";
                6: print "see";
                7: print "see";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot see";
                2: print "could not see";
                3: if (vp == 3) { print "has not been able to see"; } else { print "have not been able to see"; }
                4: print "had not been able to see";
                5: print "will not be able to see";
                6: print "see";
                7: print "see";
            }
    }
];
[ ConjugateVerb_15 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to";
        2: print "been able to";
        3: print "being able to";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    2: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    3: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    4: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    5: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    6: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_16 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "see";
        2: print "seen";
        3: print "seeing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sees"; } else { print "see"; }
                2: print "saw";
                3: if (vp == 3) { print "has seen"; } else { print "have seen"; }
                4: print "had seen";
                5: print "will see";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not see"; } else { print "do not see"; }
                2: print "did not see";
                3: if (vp == 3) { print "has not seen"; } else { print "have not seen"; }
                4: print "had not seen";
                5: print "will not see";
            }
    }
];
[ ConjugateVerb_17 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to touch";
        2: print "been able to touch";
        3: print "being able to touch";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_33;
        CV_POS:
            switch (t) {
                1: print "can touch";
                2: print "could touch";
                3: if (vp == 3) { print "has been able to touch"; } else { print "have been able to touch"; }
                4: print "had been able to touch";
                5: print "will be able to touch";
                6: print "touch";
                7: print "touch";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot touch";
                2: print "could not touch";
                3: if (vp == 3) { print "has not been able to touch"; } else { print "have not been able to touch"; }
                4: print "had not been able to touch";
                5: print "will not be able to touch";
                6: print "touch";
                7: print "touch";
            }
    }
];
[ ConjugateVerb_18 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "touch";
        2: print "touched";
        3: print "touching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "touches"; } else { print "touch"; }
                2: print "touched";
                3: if (vp == 3) { print "has touched"; } else { print "have touched"; }
                4: print "had touched";
                5: print "will touch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not touch"; } else { print "do not touch"; }
                2: print "did not touch";
                3: if (vp == 3) { print "has not touched"; } else { print "have not touched"; }
                4: print "had not touched";
                5: print "will not touch";
            }
    }
];
[ ConjugateVerb_19 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "conceal";
        2: print "concealed";
        3: print "concealing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_35;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "conceals"; } else { print "conceal"; }
                2: print "concealed";
                3: if (vp == 3) { print "has concealed"; } else { print "have concealed"; }
                4: print "had concealed";
                5: print "will conceal";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not conceal"; } else { print "do not conceal"; }
                2: print "did not conceal";
                3: if (vp == 3) { print "has not concealed"; } else { print "have not concealed"; }
                4: print "had not concealed";
                5: print "will not conceal";
            }
    }
];
[ ConjugateVerb_20 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "unlock";
        2: print "unlocked";
        3: print "unlocking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_69;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "unlocks"; } else { print "unlock"; }
                2: print "unlocked";
                3: if (vp == 3) { print "has unlocked"; } else { print "have unlocked"; }
                4: print "had unlocked";
                5: print "will unlock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not unlock"; } else { print "do not unlock"; }
                2: print "did not unlock";
                3: if (vp == 3) { print "has not unlocked"; } else { print "have not unlocked"; }
                4: print "had not unlocked";
                5: print "will not unlock";
            }
    }
];
[ ConjugateVerb_21 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "achieve";
        2: print "achieved";
        3: print "achieving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "achieves"; } else { print "achieve"; }
                2: print "achieved";
                3: if (vp == 3) { print "has achieved"; } else { print "have achieved"; }
                4: print "had achieved";
                5: print "will achieve";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not achieve"; } else { print "do not achieve"; }
                2: print "did not achieve";
                3: if (vp == 3) { print "has not achieved"; } else { print "have not achieved"; }
                4: print "had not achieved";
                5: print "will not achieve";
            }
    }
];
[ ConjugateVerb_22 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "appreciate";
        2: print "appreciated";
        3: print "appreciating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "appreciates"; } else { print "appreciate"; }
                2: print "appreciated";
                3: if (vp == 3) { print "has appreciated"; } else { print "have appreciated"; }
                4: print "had appreciated";
                5: print "will appreciate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not appreciate"; } else { print "do not appreciate"; }
                2: print "did not appreciate";
                3: if (vp == 3) { print "has not appreciated"; } else { print "have not appreciated"; }
                4: print "had not appreciated";
                5: print "will not appreciate";
            }
    }
];
[ ConjugateVerb_23 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "arrive";
        2: print "arrived";
        3: print "arriving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "arrives"; } else { print "arrive"; }
                2: print "arrived";
                3: if (vp == 3) { print "has arrived"; } else { print "have arrived"; }
                4: print "had arrived";
                5: print "will arrive";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not arrive"; } else { print "do not arrive"; }
                2: print "did not arrive";
                3: if (vp == 3) { print "has not arrived"; } else { print "have not arrived"; }
                4: print "had not arrived";
                5: print "will not arrive";
            }
    }
];
[ ConjugateVerb_24 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "care";
        2: print "cared";
        3: print "caring";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "cares"; } else { print "care"; }
                2: print "cared";
                3: if (vp == 3) { print "has cared"; } else { print "have cared"; }
                4: print "had cared";
                5: print "will care";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not care"; } else { print "do not care"; }
                2: print "did not care";
                3: if (vp == 3) { print "has not cared"; } else { print "have not cared"; }
                4: print "had not cared";
                5: print "will not care";
            }
    }
];
[ ConjugateVerb_25 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "close";
        2: print "closed";
        3: print "closing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "closes"; } else { print "close"; }
                2: print "closed";
                3: if (vp == 3) { print "has closed"; } else { print "have closed"; }
                4: print "had closed";
                5: print "will close";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not close"; } else { print "do not close"; }
                2: print "did not close";
                3: if (vp == 3) { print "has not closed"; } else { print "have not closed"; }
                4: print "had not closed";
                5: print "will not close";
            }
    }
];
[ ConjugateVerb_26 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "die";
        2: print "died";
        3: print "dying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "dies"; } else { print "die"; }
                2: print "died";
                3: if (vp == 3) { print "has died"; } else { print "have died"; }
                4: print "had died";
                5: print "will die";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not die"; } else { print "do not die"; }
                2: print "did not die";
                3: if (vp == 3) { print "has not died"; } else { print "have not died"; }
                4: print "had not died";
                5: print "will not die";
            }
    }
];
[ ConjugateVerb_27 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "discover";
        2: print "discovered";
        3: print "discovering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "discovers"; } else { print "discover"; }
                2: print "discovered";
                3: if (vp == 3) { print "has discovered"; } else { print "have discovered"; }
                4: print "had discovered";
                5: print "will discover";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not discover"; } else { print "do not discover"; }
                2: print "did not discover";
                3: if (vp == 3) { print "has not discovered"; } else { print "have not discovered"; }
                4: print "had not discovered";
                5: print "will not discover";
            }
    }
];
[ ConjugateVerb_28 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "drop";
        2: print "dropped";
        3: print "dropping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "drops"; } else { print "drop"; }
                2: print "dropped";
                3: if (vp == 3) { print "has dropped"; } else { print "have dropped"; }
                4: print "had dropped";
                5: print "will drop";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not drop"; } else { print "do not drop"; }
                2: print "did not drop";
                3: if (vp == 3) { print "has not dropped"; } else { print "have not dropped"; }
                4: print "had not dropped";
                5: print "will not drop";
            }
    }
];
[ ConjugateVerb_29 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "eat";
        2: print "eaten";
        3: print "eating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "eats"; } else { print "eat"; }
                2: print "ate";
                3: if (vp == 3) { print "has eaten"; } else { print "have eaten"; }
                4: print "had eaten";
                5: print "will eat";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not eat"; } else { print "do not eat"; }
                2: print "did not eat";
                3: if (vp == 3) { print "has not eaten"; } else { print "have not eaten"; }
                4: print "had not eaten";
                5: print "will not eat";
            }
    }
];
[ ConjugateVerb_30 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "feel";
        2: print "felt";
        3: print "feeling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "feels"; } else { print "feel"; }
                2: print "felt";
                3: if (vp == 3) { print "has felt"; } else { print "have felt"; }
                4: print "had felt";
                5: print "will feel";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not feel"; } else { print "do not feel"; }
                2: print "did not feel";
                3: if (vp == 3) { print "has not felt"; } else { print "have not felt"; }
                4: print "had not felt";
                5: print "will not feel";
            }
    }
];
[ ConjugateVerb_31 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "find";
        2: print "found";
        3: print "finding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "finds"; } else { print "find"; }
                2: print "found";
                3: if (vp == 3) { print "has found"; } else { print "have found"; }
                4: print "had found";
                5: print "will find";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not find"; } else { print "do not find"; }
                2: print "did not find";
                3: if (vp == 3) { print "has not found"; } else { print "have not found"; }
                4: print "had not found";
                5: print "will not find";
            }
    }
];
[ ConjugateVerb_32 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "get";
        2: print "got";
        3: print "getting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gets"; } else { print "get"; }
                2: print "got";
                3: if (vp == 3) { print "has got"; } else { print "have got"; }
                4: print "had got";
                5: print "will get";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not get"; } else { print "do not get"; }
                2: print "did not get";
                3: if (vp == 3) { print "has not got"; } else { print "have not got"; }
                4: print "had not got";
                5: print "will not get";
            }
    }
];
[ ConjugateVerb_33 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "give";
        2: print "given";
        3: print "giving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gives"; } else { print "give"; }
                2: print "gave";
                3: if (vp == 3) { print "has given"; } else { print "have given"; }
                4: print "had given";
                5: print "will give";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not give"; } else { print "do not give"; }
                2: print "did not give";
                3: if (vp == 3) { print "has not given"; } else { print "have not given"; }
                4: print "had not given";
                5: print "will not give";
            }
    }
];
[ ConjugateVerb_34 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "go";
        2: print "gone";
        3: print "going";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "goes"; } else { print "go"; }
                2: print "went";
                3: if (vp == 3) { print "has gone"; } else { print "have gone"; }
                4: print "had gone";
                5: print "will go";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not go"; } else { print "do not go"; }
                2: print "did not go";
                3: if (vp == 3) { print "has not gone"; } else { print "have not gone"; }
                4: print "had not gone";
                5: print "will not go";
            }
    }
];
[ ConjugateVerb_35 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "happen";
        2: print "happened";
        3: print "happening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "happens"; } else { print "happen"; }
                2: print "happened";
                3: if (vp == 3) { print "has happened"; } else { print "have happened"; }
                4: print "had happened";
                5: print "will happen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not happen"; } else { print "do not happen"; }
                2: print "did not happen";
                3: if (vp == 3) { print "has not happened"; } else { print "have not happened"; }
                4: print "had not happened";
                5: print "will not happen";
            }
    }
];
[ ConjugateVerb_36 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hear";
        2: print "heard";
        3: print "hearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "hears"; } else { print "hear"; }
                2: print "heard";
                3: if (vp == 3) { print "has heard"; } else { print "have heard"; }
                4: print "had heard";
                5: print "will hear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hear"; } else { print "do not hear"; }
                2: print "did not hear";
                3: if (vp == 3) { print "has not heard"; } else { print "have not heard"; }
                4: print "had not heard";
                5: print "will not hear";
            }
    }
];
[ ConjugateVerb_37 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "jump";
        2: print "jumped";
        3: print "jumping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "jumps"; } else { print "jump"; }
                2: print "jumped";
                3: if (vp == 3) { print "has jumped"; } else { print "have jumped"; }
                4: print "had jumped";
                5: print "will jump";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not jump"; } else { print "do not jump"; }
                2: print "did not jump";
                3: if (vp == 3) { print "has not jumped"; } else { print "have not jumped"; }
                4: print "had not jumped";
                5: print "will not jump";
            }
    }
];
[ ConjugateVerb_38 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lack";
        2: print "lacked";
        3: print "lacking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "lacks"; } else { print "lack"; }
                2: print "lacked";
                3: if (vp == 3) { print "has lacked"; } else { print "have lacked"; }
                4: print "had lacked";
                5: print "will lack";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lack"; } else { print "do not lack"; }
                2: print "did not lack";
                3: if (vp == 3) { print "has not lacked"; } else { print "have not lacked"; }
                4: print "had not lacked";
                5: print "will not lack";
            }
    }
];
[ ConjugateVerb_39 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lead";
        2: print "led";
        3: print "leading";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "leads"; } else { print "lead"; }
                2: print "led";
                3: if (vp == 3) { print "has led"; } else { print "have led"; }
                4: print "had led";
                5: print "will lead";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lead"; } else { print "do not lead"; }
                2: print "did not lead";
                3: if (vp == 3) { print "has not led"; } else { print "have not led"; }
                4: print "had not led";
                5: print "will not lead";
            }
    }
];
[ ConjugateVerb_40 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "like";
        2: print "liked";
        3: print "liking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "likes"; } else { print "like"; }
                2: print "liked";
                3: if (vp == 3) { print "has liked"; } else { print "have liked"; }
                4: print "had liked";
                5: print "will like";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not like"; } else { print "do not like"; }
                2: print "did not like";
                3: if (vp == 3) { print "has not liked"; } else { print "have not liked"; }
                4: print "had not liked";
                5: print "will not like";
            }
    }
];
[ ConjugateVerb_41 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "listen";
        2: print "listened";
        3: print "listening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "listens"; } else { print "listen"; }
                2: print "listened";
                3: if (vp == 3) { print "has listened"; } else { print "have listened"; }
                4: print "had listened";
                5: print "will listen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not listen"; } else { print "do not listen"; }
                2: print "did not listen";
                3: if (vp == 3) { print "has not listened"; } else { print "have not listened"; }
                4: print "had not listened";
                5: print "will not listen";
            }
    }
];
[ ConjugateVerb_42 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lock";
        2: print "locked";
        3: print "locking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "locks"; } else { print "lock"; }
                2: print "locked";
                3: if (vp == 3) { print "has locked"; } else { print "have locked"; }
                4: print "had locked";
                5: print "will lock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lock"; } else { print "do not lock"; }
                2: print "did not lock";
                3: if (vp == 3) { print "has not locked"; } else { print "have not locked"; }
                4: print "had not locked";
                5: print "will not lock";
            }
    }
];
[ ConjugateVerb_43 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "look";
        2: print "looked";
        3: print "looking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "looks"; } else { print "look"; }
                2: print "looked";
                3: if (vp == 3) { print "has looked"; } else { print "have looked"; }
                4: print "had looked";
                5: print "will look";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not look"; } else { print "do not look"; }
                2: print "did not look";
                3: if (vp == 3) { print "has not looked"; } else { print "have not looked"; }
                4: print "had not looked";
                5: print "will not look";
            }
    }
];
[ ConjugateVerb_44 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "need";
        2: print "needed";
        3: print "needing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "needs"; } else { print "need"; }
                2: print "needed";
                3: if (vp == 3) { print "has needed"; } else { print "have needed"; }
                4: print "had needed";
                5: print "will need";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not need"; } else { print "do not need"; }
                2: print "did not need";
                3: if (vp == 3) { print "has not needed"; } else { print "have not needed"; }
                4: print "had not needed";
                5: print "will not need";
            }
    }
];
[ ConjugateVerb_45 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "open";
        2: print "opened";
        3: print "opening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "opens"; } else { print "open"; }
                2: print "opened";
                3: if (vp == 3) { print "has opened"; } else { print "have opened"; }
                4: print "had opened";
                5: print "will open";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not open"; } else { print "do not open"; }
                2: print "did not open";
                3: if (vp == 3) { print "has not opened"; } else { print "have not opened"; }
                4: print "had not opened";
                5: print "will not open";
            }
    }
];
[ ConjugateVerb_46 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pass";
        2: print "passed";
        3: print "passing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "passes"; } else { print "pass"; }
                2: print "passed";
                3: if (vp == 3) { print "has passed"; } else { print "have passed"; }
                4: print "had passed";
                5: print "will pass";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pass"; } else { print "do not pass"; }
                2: print "did not pass";
                3: if (vp == 3) { print "has not passed"; } else { print "have not passed"; }
                4: print "had not passed";
                5: print "will not pass";
            }
    }
];
[ ConjugateVerb_47 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pick";
        2: print "picked";
        3: print "picking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "picks"; } else { print "pick"; }
                2: print "picked";
                3: if (vp == 3) { print "has picked"; } else { print "have picked"; }
                4: print "had picked";
                5: print "will pick";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pick"; } else { print "do not pick"; }
                2: print "did not pick";
                3: if (vp == 3) { print "has not picked"; } else { print "have not picked"; }
                4: print "had not picked";
                5: print "will not pick";
            }
    }
];
[ ConjugateVerb_48 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provoke";
        2: print "provoked";
        3: print "provoking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provokes"; } else { print "provoke"; }
                2: print "provoked";
                3: if (vp == 3) { print "has provoked"; } else { print "have provoked"; }
                4: print "had provoked";
                5: print "will provoke";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provoke"; } else { print "do not provoke"; }
                2: print "did not provoke";
                3: if (vp == 3) { print "has not provoked"; } else { print "have not provoked"; }
                4: print "had not provoked";
                5: print "will not provoke";
            }
    }
];
[ ConjugateVerb_49 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pull";
        2: print "pulled";
        3: print "pulling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pulls"; } else { print "pull"; }
                2: print "pulled";
                3: if (vp == 3) { print "has pulled"; } else { print "have pulled"; }
                4: print "had pulled";
                5: print "will pull";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pull"; } else { print "do not pull"; }
                2: print "did not pull";
                3: if (vp == 3) { print "has not pulled"; } else { print "have not pulled"; }
                4: print "had not pulled";
                5: print "will not pull";
            }
    }
];
[ ConjugateVerb_50 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "push";
        2: print "pushed";
        3: print "pushing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pushes"; } else { print "push"; }
                2: print "pushed";
                3: if (vp == 3) { print "has pushed"; } else { print "have pushed"; }
                4: print "had pushed";
                5: print "will push";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not push"; } else { print "do not push"; }
                2: print "did not push";
                3: if (vp == 3) { print "has not pushed"; } else { print "have not pushed"; }
                4: print "had not pushed";
                5: print "will not push";
            }
    }
];
[ ConjugateVerb_51 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "put";
        2: print "put";
        3: print "putting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "puts"; } else { print "put"; }
                2: print "put";
                3: if (vp == 3) { print "has put"; } else { print "have put"; }
                4: print "had put";
                5: print "will put";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not put"; } else { print "do not put"; }
                2: print "did not put";
                3: if (vp == 3) { print "has not put"; } else { print "have not put"; }
                4: print "had not put";
                5: print "will not put";
            }
    }
];
[ ConjugateVerb_52 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "rub";
        2: print "rubbed";
        3: print "rubbing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "rubs"; } else { print "rub"; }
                2: print "rubbed";
                3: if (vp == 3) { print "has rubbed"; } else { print "have rubbed"; }
                4: print "had rubbed";
                5: print "will rub";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not rub"; } else { print "do not rub"; }
                2: print "did not rub";
                3: if (vp == 3) { print "has not rubbed"; } else { print "have not rubbed"; }
                4: print "had not rubbed";
                5: print "will not rub";
            }
    }
];
[ ConjugateVerb_53 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "say";
        2: print "said";
        3: print "saying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "says"; } else { print "say"; }
                2: print "said";
                3: if (vp == 3) { print "has said"; } else { print "have said"; }
                4: print "had said";
                5: print "will say";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not say"; } else { print "do not say"; }
                2: print "did not say";
                3: if (vp == 3) { print "has not said"; } else { print "have not said"; }
                4: print "had not said";
                5: print "will not say";
            }
    }
];
[ ConjugateVerb_54 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "search";
        2: print "searched";
        3: print "searching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "searches"; } else { print "search"; }
                2: print "searched";
                3: if (vp == 3) { print "has searched"; } else { print "have searched"; }
                4: print "had searched";
                5: print "will search";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not search"; } else { print "do not search"; }
                2: print "did not search";
                3: if (vp == 3) { print "has not searched"; } else { print "have not searched"; }
                4: print "had not searched";
                5: print "will not search";
            }
    }
];
[ ConjugateVerb_55 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "seem";
        2: print "seemed";
        3: print "seeming";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "seems"; } else { print "seem"; }
                2: print "seemed";
                3: if (vp == 3) { print "has seemed"; } else { print "have seemed"; }
                4: print "had seemed";
                5: print "will seem";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not seem"; } else { print "do not seem"; }
                2: print "did not seem";
                3: if (vp == 3) { print "has not seemed"; } else { print "have not seemed"; }
                4: print "had not seemed";
                5: print "will not seem";
            }
    }
];
[ ConjugateVerb_56 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "set";
        2: print "set";
        3: print "setting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sets"; } else { print "set"; }
                2: print "set";
                3: if (vp == 3) { print "has set"; } else { print "have set"; }
                4: print "had set";
                5: print "will set";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not set"; } else { print "do not set"; }
                2: print "did not set";
                3: if (vp == 3) { print "has not set"; } else { print "have not set"; }
                4: print "had not set";
                5: print "will not set";
            }
    }
];
[ ConjugateVerb_57 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "smell";
        2: print "smelled";
        3: print "smelling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "smells"; } else { print "smell"; }
                2: print "smelled";
                3: if (vp == 3) { print "has smelled"; } else { print "have smelled"; }
                4: print "had smelled";
                5: print "will smell";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not smell"; } else { print "do not smell"; }
                2: print "did not smell";
                3: if (vp == 3) { print "has not smelled"; } else { print "have not smelled"; }
                4: print "had not smelled";
                5: print "will not smell";
            }
    }
];
[ ConjugateVerb_58 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "sniff";
        2: print "sniffed";
        3: print "sniffing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sniffs"; } else { print "sniff"; }
                2: print "sniffed";
                3: if (vp == 3) { print "has sniffed"; } else { print "have sniffed"; }
                4: print "had sniffed";
                5: print "will sniff";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not sniff"; } else { print "do not sniff"; }
                2: print "did not sniff";
                3: if (vp == 3) { print "has not sniffed"; } else { print "have not sniffed"; }
                4: print "had not sniffed";
                5: print "will not sniff";
            }
    }
];
[ ConjugateVerb_59 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "squeeze";
        2: print "squeezed";
        3: print "squeezing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "squeezes"; } else { print "squeeze"; }
                2: print "squeezed";
                3: if (vp == 3) { print "has squeezed"; } else { print "have squeezed"; }
                4: print "had squeezed";
                5: print "will squeeze";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not squeeze"; } else { print "do not squeeze"; }
                2: print "did not squeeze";
                3: if (vp == 3) { print "has not squeezed"; } else { print "have not squeezed"; }
                4: print "had not squeezed";
                5: print "will not squeeze";
            }
    }
];
[ ConjugateVerb_60 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "switch";
        2: print "switched";
        3: print "switching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "switches"; } else { print "switch"; }
                2: print "switched";
                3: if (vp == 3) { print "has switched"; } else { print "have switched"; }
                4: print "had switched";
                5: print "will switch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not switch"; } else { print "do not switch"; }
                2: print "did not switch";
                3: if (vp == 3) { print "has not switched"; } else { print "have not switched"; }
                4: print "had not switched";
                5: print "will not switch";
            }
    }
];
[ ConjugateVerb_61 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "take";
        2: print "taken";
        3: print "taking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "takes"; } else { print "take"; }
                2: print "took";
                3: if (vp == 3) { print "has taken"; } else { print "have taken"; }
                4: print "had taken";
                5: print "will take";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not take"; } else { print "do not take"; }
                2: print "did not take";
                3: if (vp == 3) { print "has not taken"; } else { print "have not taken"; }
                4: print "had not taken";
                5: print "will not take";
            }
    }
];
[ ConjugateVerb_62 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "talk";
        2: print "talked";
        3: print "talking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "talks"; } else { print "talk"; }
                2: print "talked";
                3: if (vp == 3) { print "has talked"; } else { print "have talked"; }
                4: print "had talked";
                5: print "will talk";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not talk"; } else { print "do not talk"; }
                2: print "did not talk";
                3: if (vp == 3) { print "has not talked"; } else { print "have not talked"; }
                4: print "had not talked";
                5: print "will not talk";
            }
    }
];
[ ConjugateVerb_63 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "taste";
        2: print "tasted";
        3: print "tasting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "tastes"; } else { print "taste"; }
                2: print "tasted";
                3: if (vp == 3) { print "has tasted"; } else { print "have tasted"; }
                4: print "had tasted";
                5: print "will taste";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not taste"; } else { print "do not taste"; }
                2: print "did not taste";
                3: if (vp == 3) { print "has not tasted"; } else { print "have not tasted"; }
                4: print "had not tasted";
                5: print "will not taste";
            }
    }
];
[ ConjugateVerb_64 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "turn";
        2: print "turned";
        3: print "turning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "turns"; } else { print "turn"; }
                2: print "turned";
                3: if (vp == 3) { print "has turned"; } else { print "have turned"; }
                4: print "had turned";
                5: print "will turn";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not turn"; } else { print "do not turn"; }
                2: print "did not turn";
                3: if (vp == 3) { print "has not turned"; } else { print "have not turned"; }
                4: print "had not turned";
                5: print "will not turn";
            }
    }
];
[ ConjugateVerb_65 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wait";
        2: print "waited";
        3: print "waiting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waits"; } else { print "wait"; }
                2: print "waited";
                3: if (vp == 3) { print "has waited"; } else { print "have waited"; }
                4: print "had waited";
                5: print "will wait";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wait"; } else { print "do not wait"; }
                2: print "did not wait";
                3: if (vp == 3) { print "has not waited"; } else { print "have not waited"; }
                4: print "had not waited";
                5: print "will not wait";
            }
    }
];
[ ConjugateVerb_66 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wave";
        2: print "waved";
        3: print "waving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waves"; } else { print "wave"; }
                2: print "waved";
                3: if (vp == 3) { print "has waved"; } else { print "have waved"; }
                4: print "had waved";
                5: print "will wave";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wave"; } else { print "do not wave"; }
                2: print "did not wave";
                3: if (vp == 3) { print "has not waved"; } else { print "have not waved"; }
                4: print "had not waved";
                5: print "will not wave";
            }
    }
];
[ ConjugateVerb_67 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "win";
        2: print "won";
        3: print "winning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wins"; } else { print "win"; }
                2: print "won";
                3: if (vp == 3) { print "has won"; } else { print "have won"; }
                4: print "had won";
                5: print "will win";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not win"; } else { print "do not win"; }
                2: print "did not win";
                3: if (vp == 3) { print "has not won"; } else { print "have not won"; }
                4: print "had not won";
                5: print "will not win";
            }
    }
];
[ ConjugateVerb_68 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "could";
        2: print "coulded";
        3: print "coulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_69 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "may";
        2: print "mayed";
        3: print "maying";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_70 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "might";
        2: print "mighted";
        3: print "mighting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_71 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "must";
        2: print "musted";
        3: print "musting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_72 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "should";
        2: print "shoulded";
        3: print "shoulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_73 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "would";
        2: print "woulded";
        3: print "woulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_74 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'re";
        2: print " been";
        3: print " being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "'m";
                    2: print "'re";
                    3: print "'s";
                    4: print "'re";
                    5: print "'re";
                    6: print "'re";
                }
                2: switch (vp) {
                    1: print " was";
                    2: print " were";
                    3: print " was";
                    4: print " were";
                    5: print " were";
                    6: print " were";
                }
                3: if (vp == 3) { print "'s been"; } else { print "'ve been"; }
                4: print "'d been";
                5: print "'ll be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "'m not";
                    2: print "'re not";
                    3: print "'s not";
                    4: print "'re not";
                    5: print "'re not";
                    6: print "'re not";
                }
                2: switch (vp) {
                    1: print " wasn't";
                    2: print " weren't";
                    3: print " wasn't";
                    4: print " weren't";
                    5: print " weren't";
                    6: print " weren't";
                }
                3: if (vp == 3) { print "'s not been"; } else { print "'ve not been"; }
                4: print "'d not been";
                5: print "'ll not be";
            }
    }
];
[ ConjugateVerb_75 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'ve";
        2: print " had";
        3: print " having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "'s"; } else { print "'ve"; }
                2: print " had";
                3: if (vp == 3) { print "'s had"; } else { print "'ve had"; }
                4: print "'d had";
                5: print "'ll have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "'s not"; } else { print "'ve not"; }
                2: print " hadn't";
                3: if (vp == 3) { print "'s not had"; } else { print "'ve not had"; }
                4: print "'d not had";
                5: print "'ll not have";
            }
    }
];
[ ConjugateVerb_76 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "aren't";
        2: print "aren'ted";
        3: print "aren'ting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "aren't";
                    3: print "isn't";
                    4: print "aren't";
                    5: print "aren't";
                    6: print "aren't";
                }
                2: switch (vp) {
                    1: print "wasn't";
                    2: print "weren't";
                    3: print "wasn't";
                    4: print "weren't";
                    5: print "weren't";
                    6: print "weren't";
                }
                3: if (vp == 3) { print "hasn't been"; } else { print "haven't been"; }
                4: print "hadn't been";
                5: print "won't be";
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_77 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "can't";
        2: print "can'ted";
        3: print "can'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_78 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "haven't";
        2: print "haven'ted";
        3: print "haven'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_79 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "don't";
        2: print "don'ted";
        3: print "don'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "doesn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "don't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_80 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mustn't";
        2: print "mustn'ted";
        3: print "mustn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_81 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mightn't";
        2: print "mightn'ted";
        3: print "mightn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_82 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mayn't";
        2: print "mayn'ted";
        3: print "mayn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_83 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wouldn't";
        2: print "wouldn'ted";
        3: print "wouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_84 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "couldn't";
        2: print "couldn'ted";
        3: print "couldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_85 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "shouldn't";
        2: print "shouldn'ted";
        3: print "shouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_86 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "won't";
        2: print "won'ted";
        3: print "won'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_87 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "spawn";
        2: print "spawned";
        3: print "spawning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_15;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "spawns"; } else { print "spawn"; }
                2: print "spawned";
                3: if (vp == 3) { print "has spawned"; } else { print "have spawned"; }
                4: print "had spawned";
                5: print "will spawn";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not spawn"; } else { print "do not spawn"; }
                2: print "did not spawn";
                3: if (vp == 3) { print "has not spawned"; } else { print "have not spawned"; }
                4: print "had not spawned";
                5: print "will not spawn";
            }
    }
];
Array TableOfVerbs --> ConjugateVerb_0 ConjugateVerb_2 ConjugateVerb_3 ConjugateVerb_4 ConjugateVerb_5 ConjugateVerb_6 ConjugateVerb_7 ConjugateVerb_8 ConjugateVerb_9 ConjugateVerb_10 ConjugateVerb_11 ConjugateVerb_12 ConjugateVerb_13 ConjugateVerb_14 ConjugateVerb_15 ConjugateVerb_16 ConjugateVerb_17 ConjugateVerb_18 ConjugateVerb_19 ConjugateVerb_20 ConjugateVerb_21 ConjugateVerb_22 ConjugateVerb_23 ConjugateVerb_24 ConjugateVerb_25 ConjugateVerb_26 ConjugateVerb_27 ConjugateVerb_28 ConjugateVerb_29 ConjugateVerb_30 ConjugateVerb_31 ConjugateVerb_32 ConjugateVerb_33 ConjugateVerb_34 ConjugateVerb_35 ConjugateVerb_36 ConjugateVerb_37 ConjugateVerb_38 ConjugateVerb_39 ConjugateVerb_40 ConjugateVerb_41 ConjugateVerb_42 ConjugateVerb_43 ConjugateVerb_44 ConjugateVerb_45 ConjugateVerb_46 ConjugateVerb_47 ConjugateVerb_48 ConjugateVerb_49 ConjugateVerb_50 ConjugateVerb_51 ConjugateVerb_52 ConjugateVerb_53 ConjugateVerb_54 ConjugateVerb_55 ConjugateVerb_56 ConjugateVerb_57 ConjugateVerb_58 ConjugateVerb_59 ConjugateVerb_60 ConjugateVerb_61 ConjugateVerb_62 ConjugateVerb_63 ConjugateVerb_64 ConjugateVerb_65 ConjugateVerb_66 ConjugateVerb_67 ConjugateVerb_68 ConjugateVerb_69 ConjugateVerb_70 ConjugateVerb_71 ConjugateVerb_72 ConjugateVerb_73 ConjugateVerb_87 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Testing commands
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF DEBUG;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Abstract Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if (obj <= InformLibrary) "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent) "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Actions Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Gonear Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GonearSub;
	PlayerTo(LocationOf(noun));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Purloin Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Random Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Relations Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
	if ((RlnGetF(rel, RR_PERMISSIONS)) & (RELS_SHOW)) {
		(RlnGetF(rel, RR_HANDLER))(rel, RELS_SHOW);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Responses Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global suppress_text_substitution = false;
[ ShowResponsesSub a i j reg wd set_mode;
	if (NO_RESPONSES == 0) "There are no lettered responses.";
	wn = 2;
	if (NextWordStopped() == 'now') set_mode = 1; else wn--;
	if (NextWordStopped() == 'set') set_mode = 2; else wn--;
	wd = NextWordStopped(); wn--;
	if (wd == 'all') reg = 0;
	else {
		reg = -1;
		if (wd ~= -1) reg = TryNumber(wn);
		if (reg < 0) {
			say__p = 1;
   			print ">--> The following sets of responses are available:^";
			print "    RESPONSES ALL^";
		}
	}
	for (a=0, i=1, j=0: ResponseDivisions-->a: a=a+3, i++) {
		if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) j++;
		if ((reg == 0) || (reg == j)) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				if (set_mode) {
					print "[", (string) ResponseDivisions-->a, "]^";
				} else {
					print (string) ResponseDivisions-->a, ":^";
				}
			}
			ShowResponsesRange(ResponseDivisions-->(a+1), ResponseDivisions-->(a+2), set_mode);
		}
		if (reg < 0) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				print "    RESPONSES ", j, ": ", (string) ResponseDivisions-->a, "^";
			}
		}
	}
];

[ ShowResponsesRange from to set_mode i;
	say__p = 1;
	for (i=from: i<=to: i++) {
		switch (set_mode) {
			1: print "now ";
			2: ;
			0: print "    ";
		}
		print (PrintResponse) i;
		switch (set_mode) {
			1: print " is ";
			2: print " is ";
			0: print ": ";
		}
		suppress_text_substitution = true;
		CarryOutActivity(PRINTING_RESPONSE_ACT, i);
		suppress_text_substitution = false;
		switch (set_mode) {
			1: print ";";
			2: print ".";
		}
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Rules Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scenes Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scope Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showheap Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowHeapSub;
	HeapDebug();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: ShowMe Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowMeSub t_0 na;
	t_0 = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (t_0 ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (t_0) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(pluralname)) && (t_0  has pluralname)) { if (na++ > 0) print ", "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (t_0  hasnt pluralname)) { if (na++ > 0) print ", "; print "singular-named"; }
    if ((AllowInShowme(proper)) && (t_0  has proper)) { if (na++ > 0) print ", "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (t_0  hasnt proper)) { if (na++ > 0) print ", "; print "improper-named"; }
    if ((AllowInShowme(ambigpluralname)) && (t_0  has ambigpluralname)) { if (na++ > 0) print ", "; print "ambiguously plural"; }
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lighted"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "dark"; }
    if ((AllowInShowme(visited)) && (t_0  has visited)) { if (na++ > 0) print ", "; print "visited"; }
    if ((AllowInShowme(visited)) && (t_0  hasnt visited)) { if (na++ > 0) print ", "; print "unvisited"; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lit"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "unlit"; }
    if ((AllowInShowme(edible)) && (t_0  has edible)) { if (na++ > 0) print ", "; print "edible"; }
    if ((AllowInShowme(edible)) && (t_0  hasnt edible)) { if (na++ > 0) print ", "; print "inedible"; }
    if ((AllowInShowme(static)) && (t_0  has static)) { if (na++ > 0) print ", "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (t_0  hasnt static)) { if (na++ > 0) print ", "; print "portable"; }
    if ((AllowInShowme(scenery)) && (t_0  has scenery)) { if (na++ > 0) print ", "; print "scenery"; }
    if ((AllowInShowme(clothing)) && (t_0  has clothing)) { if (na++ > 0) print ", "; print "wearable"; }
    if ((AllowInShowme(pushable)) && (t_0  has pushable)) { if (na++ > 0) print ", "; print "pushable between rooms"; }
    if ((AllowInShowme(moved)) && (t_0  has moved)) { if (na++ > 0) print ", "; print "handled"; }
    if ((AllowInShowme(concealed)) && (t_0  hasnt concealed)) { if (na++ > 0) print ", "; print "described"; }
    if ((AllowInShowme(concealed)) && (t_0  has concealed)) { if (na++ > 0) print ", "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (t_0  has mentioned)) { if (na++ > 0) print ", "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (t_0  hasnt mentioned)) { if (na++ > 0) print ", "; print "unmentioned"; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
    if ((AllowInShowme(transparent)) && (t_0  hasnt transparent)) { if (na++ > 0) print ", "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (t_0  has transparent)) { if (na++ > 0) print ", "; print "transparent"; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 ofclass K13_device) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(on)) && (t_0  has on)) { if (na++ > 0) print ", "; print "switched on"; }
    if ((AllowInShowme(on)) && (t_0  hasnt on)) { if (na++ > 0) print ", "; print "switched off"; }
}
if (t_0 ofclass K16_g_window) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p74_g_required)) && (t_0  has p74_g_required)) { if (na++ > 0) print ", "; print "g-required"; }
    if ((AllowInShowme(p74_g_required)) && (t_0  hasnt p74_g_required)) { if (na++ > 0) print ", "; print "g-unrequired"; }
    if ((AllowInShowme(p76_g_present)) && (t_0  has p76_g_present)) { if (na++ > 0) print ", "; print "g-present"; }
    if ((AllowInShowme(p76_g_present)) && (t_0  hasnt p76_g_present)) { if (na++ > 0) print ", "; print "g-unpresent"; }
    if ((AllowInShowme(p78_currently_being_processe)) && (t_0  has p78_currently_being_processe)) { if (na++ > 0) print ", "; print "currently being processed"; }
}
if (t_0 == I51_north) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I52_northeast) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I53_northwest) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I54_south) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I55_southeast) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I56_southwest) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I57_east) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I58_west) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I59_up) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I60_down) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == in_obj) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == out_obj) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 == I200_main_window) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I201_status_window) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I202_quote_window) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I220_musa) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p79_complacida)) && (t_0  has p79_complacida)) { if (na++ > 0) print ", "; print "complacida"; }
    if ((AllowInShowme(p79_complacida)) && (t_0  hasnt p79_complacida)) { if (na++ > 0) print ", "; print "espectante"; }
}
if (t_0 == I223_abismo) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I231_presencia) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I270_mercader) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p81_vivo)) && (t_0  has p81_vivo)) { if (na++ > 0) print ", "; print "vivo"; }
    if ((AllowInShowme(p81_vivo)) && (t_0  hasnt p81_vivo)) { if (na++ > 0) print ", "; print "muerto"; }
}
if (t_0) {if (na > 0) { na = 0; print "^"; }
    print "list grouping key: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, list_together), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, list_together), "~", "^";
    print "printed name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, short_name), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, short_name), "~", "^";
    print "printed plural name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, plural), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, plural), "~", "^";
    print "indefinite article: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, article), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, article), "~", "^";
    print "grammatical gender: "; print (E66) GProperty(OBJECT_TY, t_0, p72_grammatical_gender), "^";
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, map_region)) { print "map region: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, map_region), "^";
    }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    print "initial appearance: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, initial), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, initial), "~", "^";
    if (GProperty(OBJECT_TY, t_0, with_key)) { print "matching key: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, with_key), "^";
    }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p10_opposite)) { print "opposite: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p10_opposite), "^";
    }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, door_to)) { print "other side: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, door_to), "^";
    }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    print "default ask quip: "; print (E71) GProperty(OBJECT_TY, t_0, p15_default_ask_quip), "^";
    print "default tell quip: "; print (E71) GProperty(OBJECT_TY, t_0, p16_default_tell_quip), "^";
    print "greeting: "; print (E71) GProperty(OBJECT_TY, t_0, p17_greeting), "^";
    print "litany: "; print (PrintTableName) GProperty(OBJECT_TY, t_0, p18_litany), "^";
}
if (t_0 ofclass K16_g_window) {if (na > 0) { na = 0; print "^"; }
    print "type: "; print (E74) GProperty(OBJECT_TY, t_0, p19_type), "^";
    print "position: "; print (E78) GProperty(OBJECT_TY, t_0, p20_position), "^";
    print "scale method: "; print (E79) GProperty(OBJECT_TY, t_0, p21_scale_method), "^";
    print "measurement: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p22_measurement), "^";
    print "minimum size: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p23_minimum_size), "^";
    print "rock number: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p24_rock_number), "^";
    print "ref number: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p25_ref_number), "^";
    print "border hint: "; print (DA_TruthState) GProperty(OBJECT_TY, t_0, p26_border_hint), "^";
    print "background color: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p27_background_color), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p27_background_color), "~", "^";
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides KD_Count) {
		k = KindHierarchy-->((obj.KD_Count)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showverb Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) print "has no grammar lines.^";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Test Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (0 > 0);

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Trace Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Tree Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides KD_Count))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'responses'

	*                                           -> ShowResponses
	* special                                   -> ShowResponses
	* 'now' special                             -> ShowResponses
	* 'set' special                             -> ShowResponses;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'on'                                      -> RulesOn
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'on'                                      -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases ;
    ];

#ENDIF; ! DEBUG


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: I6 Inclusions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 25 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];

! Objetos VerboIrregular, necesarios para el parseo de verbos irregulares en espanol (Added by SL)
VerboIrregular "abandonar el juego" with imperativo 'q//' 'quit' 'terminar' 'fin' 'acabar' 'abandonar';
VerboIrregular "abrir" with imperativo 'abre';
VerboIrregular "activar la transcripcin a disco" with imperativo 'script' 'transcripcion';
VerboIrregular "adquirir" with imperativo 'adquiere';
VerboIrregular "ajustar" with imperativo 'set';
VerboIrregular "apretar" with imperativo 'aprieta';
VerboIrregular "atravesar" with imperativo 'atraviesa';
VerboIrregular "bajar" with imperativo 'bajate' 'bajarse' 'irte';
VerboIrregular "balancear" with imperativo 'balanceate' 'meneate' 'balancearse' 'menearse' 'balancearse' 'menearse';
VerboIrregular "cambiar a modo LARGO" with imperativo 'verbose' 'largo';
VerboIrregular "cambiar a modo NORMAL" with imperativo 'breve' 'normal';
VerboIrregular "cambiar a modo SUPERBREVE" with imperativo 'superbreve' 'corto';
VerboIrregular "cambiar el dialecto del juego" with imperativo 'dialecto';
VerboIrregular "cambiar el estado de la NOTIFICACION de PUNTOS" with imperativo 'notificar' 'notify';
VerboIrregular "cargar un juego previamente guardado en disco" with imperativo 'cargar' 'recuperar' 'load' 'restaurar' 'restore';
VerboIrregular "cerrar" with imperativo 'cierra';
VerboIrregular "columpiar" with imperativo 'columpiate' 'columpiarse' 'columpiarse';
VerboIrregular "comer" with imperativo 'comete' 'comerse' 'comerte';
VerboIrregular "ingerir" with imperativo 'ingiere';
VerboIrregular "conocer el número de VERSION del juego" with imperativo 'version';
VerboIrregular "conocer la puntuación" with imperativo 'score' 'puntos' 'puntuacion';
VerboIrregular "conocer la puntuación detallada" with imperativo 'total' 'pt';
VerboIrregular "contar" with imperativo 'cuenta';
VerboIrregular "cubrir" with imperativo 'cubre';
VerboIrregular "darle" with imperativo 'dale' 'dase' 'darse';
VerboIrregular "decir" with imperativo 'di' 'dile';
VerboIrregular "desactivar la transcripción a disco" with imperativo 'unscript' 'noscript' 'notranscripcion';
VerboIrregular "descubrir" with imperativo 'descubre';
VerboIrregular "despertar" with imperativo 'despierta' 'espabilate' 'espabilarse' 'espabilarte';
VerboIrregular "destruir" with imperativo 'destruye';
VerboIrregular "disculparte" with imperativo 'sorry' 'perdon';
VerboIrregular "dormir" with imperativo 'duerme';
VerboIrregular "echar" with imperativo 'echate' 'echarse';
VerboIrregular "encender" with imperativo 'enciende';
VerboIrregular "esperar" with imperativo 'z//';
VerboIrregular "examinar" with imperativo 'x//' 'describe' 'ex';
VerboIrregular "fregar" with imperativo 'friega';
VerboIrregular "guardar en disco el estado del juego" with imperativo 'save' 'guardar' 'salvar';
VerboIrregular "ir" with imperativo 've' 'vete';
VerboIrregular "volver" with imperativo 'vuelve';
VerboIrregular "levantar" with imperativo 'levantate' 'levantarse' 'levantarte';
VerboIrregular "listar los lugares visitados" with imperativo 'places' 'lugares';
VerboIrregular "listar los objetos que se han tenido" with imperativo 'objects' 'objetos';
VerboIrregular "meter" with imperativo 'metete' 'meterse' 'meterte' 'meterme' 'meteme';
VerboIrregular "mirar" with imperativo 'l//' 'look' 'm//';
VerboIrregular "mostrar" with imperativo 'muestra';
VerboIrregular "mostrar inventario" with imperativo 'i//' 'inv' 'inventario';
VerboIrregular "mover" with imperativo 'mueve';
VerboIrregular "oir" with imperativo 'oye';
VerboIrregular "oler" with imperativo 'huele';
VerboIrregular "pedir" with imperativo 'pide' 'pidele';
VerboIrregular "pensar" with imperativo 'piensa';
VerboIrregular "poner" with imperativo 'pon' 'ponte' 'viste' 'vistete' 'ponerse' 'vestirse' 'ponerte' 'vestirte' 'ponerme' 'vestirme' 'ponme' 'visteme';
VerboIrregular "probar" with imperativo 'prueba';
VerboIrregular "pulir" with imperativo 'pule';
VerboIrregular "quitar" with imperativo 'sacate' 'quitate' 'sacarse' 'quitarse' 'quitarte' 'sacarte' 'sacarme' 'quitarme' 'quitame' 'sacame';
VerboIrregular "quitarle" with imperativo 'quitale';
VerboIrregular "reiniciar el juego" with imperativo 'reiniciar';
VerboIrregular "responder ~no~" with imperativo 'nx';
VerboIrregular "responder ~sí~" with imperativo 'si' 'y//';
VerboIrregular "sacudir" with imperativo 'sacude';
VerboIrregular "salir" with imperativo 'sal' 'fuera' 'afuera' 'salte' 'salirse' 'salirte';
VerboIrregular "sentar" with imperativo 'sienta' 'sientate' 'sentarse' 'echarte' 'sentarte';
VerboIrregular "soltar" with imperativo 'suelta';
VerboIrregular "subir" with imperativo 'sube' 'subete' 'subirse' 'subirte';
VerboIrregular "torcer" with imperativo 'tuerce';
VerboIrregular "retorcer" with imperativo 'retuerce';
VerboIrregular "transferir" with imperativo 'transfiere';
VerboIrregular "unir" with imperativo 'une';
VerboIrregular "ver el estado de los pronombres" with imperativo 'pronombres';
VerboIrregular "verificar la corrección del juego" with imperativo 'verificar';
VerboIrregular "mostrar las salidas" with imperativo 'salidas'; ! Urba touch
#ifdef DEBUG;
VerboIrregular "purloin" with imperativo 'purloin';
VerboIrregular "hacer con abstract" with imperativo 'abstract' 'xmueve';
VerboIrregular "hacer con gonear (indica lugar)" with imperativo 'gonear' 'xmueve';
#endif;

! Cuando el usuario teclea un comando incompleto, es necesario que
! el parser genere un mensaje preguntando por lo que falta,
! pero la forma de preguntarlo depende del verbo. Por ej.:
!
! > coge
! ¿Qué quieres coger?
!
! > mete llave
! ¿Dónde quieres meter la llave?
!
! > orco, saca la botella
! ¿De dónde tiene que sacar el orco la botella?
!
! Cuando el parser tiene que imprimir una respuesta de estas,
! simplemente llama a MLIdioma con el número de mensaje Misc, 48 o
! 49. En esta versión de la librería (6/7) es responsabilidad de
! LanguageLM generar el mensaje completo.
!
! En nuestro caso hemos implementado estos mensajes de forma que
! llaman a IniciarPregunta para que escriba una partícula interrogativa
! como "Donde" "De donde", etc. Si no escribe nada, MLIdioma pone
! "Qué" o "A quién" según el tipo de error, a continuación se escribe
! "quieres" o "tiene que" según quién sea el actor. Se llama a
! LanguageVerb para que escriba el verbo, y finalmente se añade el
! name del objeto directo si lo había, para terminar la pregunta
! cerrando la interrogación.
!
! IniciarPregunta, lo que hace es: 
!
! 1) busca preposiciones en el patrón que ha encajado, si las
! encuentra, la pregunta debe comenzar por alguna partícula
! interrogativa. Por ejemplo, si la línea de gramática hallada era
! "saca" noun "de" noun, se hallará la preposición "de" que nos indica
! que la pregunta ha de comenzar con "¿De dónde ...".
!
! 2) Llama a la función "IdiomaPreguntarPrep" que recibe como
! parámetros la preposición y la acción en curso, para que imprima la
! partícula interrogativa adecuada. Esta función tan sólo debe
! escribir esa partícula.
!
! IdiomaPreguntarPrep llama a su vez a PreguntarPreposicion por si el
! programador añade verbos raros con preposiciones raras que no son
! correctamente manejados por esta rutina. Si PreguntarPreposicion
! existe y retorna distinto de cero, IdiomaPreguntarPrep asumirá
! que la partícula interrogativa ya ha sido escrita por
! PreguntarPreposicion y no hará nada más.
!
[ IdiomaPreguntarPrep prepos action;

    if (PreguntarPreposicion(prepos, action)) return;
    !print "^IPPrep: action: ", (DebugAction)action, "  Prepos: ",(address)prepos,"^"; ! infsp debug 
    switch (prepos)
    {
     'de':			print "De dónde";
     'en', 'dentro', 'encima': 	print "Dónde";
     'bajo','debajo':			print "Debajo de qué";
     'sobre', 'acerca':		print "Sobre qué";
     'contra':	print "Contra qué";
     'hacia':		print "Hacia dónde";
     'con':if (action==##Tell or ##Attack)  print "Con quién";
              else print "Con qué";
     'por':if (action==##Ask) 	print "Por qué";
              else print "Por dónde";
     'una', 'un' :				print "A quién";
     'a//':  switch(action){
           ##Go:			print "Hacia dónde";
           ##Climb:		print "Dónde";
           ##ThrowAt, ##Give, ##Show, ##Answer, ##Tell, ##Ask:	print "A quién";
           ##Search:	print "A través de qué";
           ##Tie:			print "A qué"; 
           ##Enter:		print "A dónde";
           default:		print "A quién";
       };
    }
];


! A partir del patrón que ha construido el parser, se determina cuál
! es la primera preposición usada detrás del verbo.
! Esto será usado por la función IniciarPregunta y por LanguageIsVerb
! [INFSP] Recoding para un mejor comportamiento en caso de lineas de gramaticas complejas
! Ej: 'pon' noun 'en/sobre' noun . Antes usando 'sobre' (segundo token) no andaba.
! (devolvia NULL)

[ AveriguarPreposicion 
    i k p ;

!		pattern: array que contiene las palabras reconocidas
!		pcount: contador dentro de pattern
!    print " ",pattern-->(pcount-1)," ^"; ![infsp] debug
!    print "pcount:",pcount," ^"; ![infsp] debug

    p = NULL;
    ! recorrido hacia atrás; apartir de pcount, posicion reconocida
    for (k=pcount:k>=1:k=k-1){ !infsp tunnig, para evitar el menos menos que quiebra la sintaxis de Include
       i=pattern-->k;
!        print "^AP: k:",k," i:",i," (i):",(address)VM_NumberToDictionaryAddress(i-REPARSE_CODE),"^"; ! infsp debug 
       if ( i == PATTERN_NULL) continue;
       if ( i >= REPARSE_CODE)
           p=VM_NumberToDictionaryAddress(i-REPARSE_CODE);!asignar particula, será la conectada a tipo de pregunta segun contexto
    }
    return p;

];


[ AveriguarPrimeraPreposicion
    i k p found;
    p=NULL;
    for (k=pcount:k>=1:k=k-1) ! infsp tunnig, para evitar el menos menos que quiebra la sintaxis de Include
    { 
!     print "^AP: k:",k; ! infsp debug
     i=pattern-->k;
!    print "^ i:",i; ! infsp debug 
   if (pattern-->k == PATTERN_NULL) continue;
!    i=pattern-->k;
        if (i>=REPARSE_CODE)
        {
        i=VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        p=i;    ! nos quedamos con la primera
        found=k;
        }
    }
!    print "APP: Primera prep: ",(address) p; ! infsp debug
!    print " / found :",found; ! infsp debug
!    print " / pcount :",pcount,"^"; ! infsp debug
    
    if (found==(pcount -1)) return NULL;
    else return p;
];


! Averigua si es necesaria una partícula interrogativa. Llama a
! IdiomaPreguntarPrep para que la imprima.
!
! Retorna 1 si ha sido impresa la partícula interrogativa, y 0 en caso
! contrario, (y entonces la función que la llamó "LanguageLM", sabe
! que es necesario escribir "Qué" o "A quién" ya que en este caso lo
! que faltaba era el objeto directo en lugar del complemento.
!
[ IniciarPregunta
    p;

    print "¿";
    p=AveriguarPreposicion();
    if (p~=NULL) {
      IdiomaPreguntarPrep(p, action_to_be);
      return 1;
    }
    return 0;
    
];

!|PrintCommand| reconstructs the command as it presently reads, from the
!pattern which has been built up.

!If |from| is 0, it starts with the verb: then it goes through the pattern.

!The other parameter is |emptyf| -- a flag: if 0, it goes up to |pcount|:
!if 1, it goes up to |pcount|-1.

!Note that verbs and prepositions are printed out of the dictionary:
!and that since the dictionary may only preserve the first six characters
!of a word (in a V3 game), we have to hand-code the longer words needed.
!At present, I7 doesn't do this, but it probably should.

!(Recall that pattern entries are 0 for "multiple object", 1 for "special
!word", 2 to |REPARSE_CODE-1| are object numbers and |REPARSE_CODE+n| means
!the preposition |n|.)

!IdiomaImprimirComando: hackeo spanish de PrintCommand(Parser.i6t)
!												adicion inteligente de preposiciones en la deduccion impresa

[ PrintCommand from i k spacing_flag prep;

    if (from == 0) {
        i = verb_word;
        LanguageVerb(i); !check si uso abreviatura de comando ("i, z, l") e imprime verbo completo
        from++; spacing_flag = true;
    }
  
! print "^Valor de from: ",from,"^"; ! infsp debug
! print "Valor de pcount: ",pcount,"^"; ! infsp debug
  
  for (k=from:k<pcount:k++){
     i=pattern-->k;
     !print "^IIC: i: ",  i, "^"; ! infsp debug
      if (i == PATTERN_NULL) continue;
      if (spacing_flag) print (char) ' ';
      if (i == 0) { PARSER_CLARIF_INTERNAL_RM('F'); jump TokenPrinted; }!viejo THOSET__TX
      if (i == 1) { PARSER_CLARIF_INTERNAL_RM('G'); jump TokenPrinted; }!viejo THAT__TX
      if (i >= REPARSE_CODE) continue;
      else {
            if (i in compass && LanguageVerbLikesAdverb(verb_word))
                LanguageDirection (i.door_dir); ! the direction name as adverb
            if (i==player) print "te";
            else  {
               prep=AveriguarPrimeraPreposicion();
               switch(prep){
                 'a//': print (al) i;
                 'de': print (del) i;
                 NULL: print (the) i;
                 default: !print " ", (address) prep;
                           print (the) i;
               }
            }
      continue;
      }
      .TokenPrinted;
      spacing_flag = true;
  } ! for
];



! ---------------------------------------------------------------------------
! Otras rutinas de soporte para el AUTOR de Aventuras 

[ TextoLlamativo txt;
    ! Imprime un texto rodeado de asteriscos y en negrita. 
    ! Puedes cambiarlo si quieres que aparezcan en otros formatos.
     VM_Style(ALERT_VMSTY);
!     print "***", (string) txt, "***"; ! [010508] Corregido bug (string)
     print (string) txt; ! infsp fix, los asteriscos ya se ponian en parserm.h
     VM_Style(NORMAL_VMSTY);
];


Constant LIBRARY_SPANISH;       ! for dependency checking.

[ GTE_SetStylehint wintype style hint N i;
	if ( style == I126_all_styles )
	{
		for ( i = 0: i < style_NUMSTYLES : i++ )
		{
			glk_stylehint_set( wintype, i, hint, N );
		}
	}
	else
	{
		glk_stylehint_set( wintype, style - 2, hint, N );
	}
];

[ GTE_ConvertColour txt p1 cp1 dsize i ch progress;
	! Transmute the text
	cp1 = txt-->0;
	p1 = TEXT_TY_Temporarily_Transmute( txt );
	dsize = BlkValueLBCapacity( txt );
	for ( i = 0 : i < dsize : i++ )
	{
		! Decode the hex characters
		ch = BlkValueRead( txt, i );
		if ( ch == 0 )
		{
			break;
		}
		else if ( ch > 47 && ch < 58 )
		{
			progress = progress * 16 + ch - 48;
		}
		else if ( ch > 64 && ch < 71 )
		{
			progress = progress * 16 + ch - 55;
		}
		else if ( ch > 96 && ch < 103 )
		{
			progress = progress * 16 + ch - 87;
		}
	}
	! Clean up and return
	TEXT_TY_Untransmute( txt, p1, cp1 );
	return progress;
];


! Wait for a safe non navigating key. The user might press Down/PgDn or use the mouse scroll wheel to scroll a page of text, so we will stop those key codes from continuing.
[ KeyPause key; 
	while ( 1 )
	{
		key = VM_KeyChar();
		#Ifdef TARGET_ZCODE;
		if ( key == 63 or 129 or 130 or 132 )
		{
			continue;
		}
		#Ifnot; ! TARGET_GLULX
		if ( key == -4 or -5 or -10 or -11 or -12 or -13 )
		{
			continue;
		}
		#Endif; ! TARGET_
		rfalse;
	}
];

[ SPACEPause i;
	while (i ~= 13 or 31 or 32)
	{
		i = VM_KeyChar();	
	}
];

! No longer used but included just in case
[ GetKey;
	return VM_KeyChar(); 
];



[ CenterPrint str depth i j len;
	font off;
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	VM_MoveCursorInStatusLine(depth, j);
	print (I7_string) str; 
	font on;
];

[ CenterPrintComplex str i j len;
	font off;
	print "^"; 
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	spaces j;
	print (I7_string) str; 
	font on;
];



[ I7ScreenHeight i screen_height;
	i = 0->32;
	if (screen_height == 0 or 255) screen_height = 18;
	screen_height = screen_height - 7;
	return screen_height;
];

 

[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    screen_width = VM_ScreenWidth();
    #ifdef TARGET_GLULX;
        VM_ClearScreen(1);
    #ifnot;
        style reverse;
        for (i=1:i<depth+1:i++)
        {
             @set_cursor i 1;
             spaces(screen_width);
        } 
    #endif;
]; 

[ I7VM_MoveCursorInStatusLine depth;
	VM_MoveCursorInStatusLine(depth, 1);
];

[ RightAlign depth screen_width o n;
	screen_width = VM_ScreenWidth(); 
	n = (Global_Vars-->11);
	o = screen_width - n;
	VM_MoveCursorInStatusLine(depth, o);
];


[ ASR_CheckForGlk res;
	@gestalt 4 2 res;
	if (res == 0) quit;
	rfalse;
];

[ ASR_GGRecoverObjects;
	! We must call GGRecoverObjects() indirectly like this because it returns true which will abort the before rules
	GGRecoverObjects();
	rfalse;
];

[ ASR_SoundChannelInitialisation;
	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}
	rfalse;
];

[ ASR_OpenBuiltInWindows res sty;
	res = InitGlkWindow(0);
	if (res ~= 0) return;

	! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

	if (gg_mainwin == 0) {
		! Open the story window.
		res = InitGlkWindow(GG_MAINWIN_ROCK);
		if (res == 0) {
			! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
			gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
		if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
	} else {
		! There was already a story window. We should erase it.
		glk_window_clear(gg_mainwin);
	}

	if (gg_statuswin == 0) {
		res = InitGlkWindow(GG_STATUSWIN_ROCK);
		if (res == 0) {
			statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
			gg_statuswin =
				glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
					statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
		}
	}
	! It's possible that the status window couldn't be opened, in which case
	! gg_statuswin is now zero. We must allow for that later on.

	glk_set_window(gg_mainwin);

	InitGlkWindow(1);
	rfalse;
];


[ GD_GlulxGestalt sel arg res;
	@gestalt sel arg res;
	return res;
];

[ GOR_zeroing;
	gg_mainwin = 0;
	gg_statuswin = 0;
	gg_quotewin = 0;
	gg_scriptfref = 0;
	gg_scriptstr = 0;
	gg_savestr = 0;
	statuswin_cursize = 0;
	gg_foregroundchan = 0;
	gg_backgroundchan = 0;
	gg_commandstr = 0;
	gg_command_reading = false;
	rfalse;
];

[ GOR_indentify_windows;
	switch ( (Global_Vars-->27) )
	{
		GG_MAINWIN_ROCK:
			gg_mainwin = (Global_Vars-->28);
		GG_STATUSWIN_ROCK:
			gg_statuswin = (Global_Vars-->28);
		GG_QUOTEWIN_ROCK:
			gg_quotewin = (Global_Vars-->28);
	}
	rfalse;
];

[ GOR_indentify_streams;
	switch ( (Global_Vars-->27) )
	{
		GG_SAVESTR_ROCK:
			gg_savestr = (Global_Vars-->28);
		GG_SCRIPTSTR_ROCK:
			gg_scriptstr = (Global_Vars-->28);
		GG_COMMANDWSTR_ROCK:
			gg_commandstr = (Global_Vars-->28);
			gg_command_reading = false;
		GG_COMMANDRSTR_ROCK:
			gg_commandstr = (Global_Vars-->28);
			gg_command_reading = true;
	}
	rfalse;
];

[ GOR_indentify_filerefs;
	switch ( (Global_Vars-->27) )
	{
		GG_SCRIPTFREF_ROCK:
			gg_scriptfref = (Global_Vars-->28);
	}
	rfalse;
];

[ GOR_indentify_schannels;
	switch ( (Global_Vars-->27) )
	{
		GG_FOREGROUNDCHAN_ROCK:
			gg_foregroundchan = (Global_Vars-->28);
		GG_BACKGROUNDCHAN_ROCK:
			gg_backgroundchan = (Global_Vars-->28);
	}
	if ( gg_foregroundchan ~= 0 )
	{
		glk_schannel_stop( gg_foregroundchan );
	}
	if ( gg_backgroundchan ~= 0 )
	{
		glk_schannel_stop( gg_backgroundchan );
	}
	rfalse;
];

[ FW_glk_window_close _vararg_count;
  ! glk_window_close(window, &{uint, uint})
  @glk 36 _vararg_count 0;
  return 0;
];

[ FW_ConstructGWindow win parentwin method size type rock;
	win = parameter_value;
	! Fill in parentwin, method and size only if the window is not the main window
	if ( win ~= I200_main_window )
	{
		parentwin = parent( win ).p25_ref_number;
		if ( win.p21_scale_method == I194_g_proportional )
		{
			method = winmethod_Proportional;
		}
		else
		{
			method = winmethod_Fixed;
		}
		method = method + win.p20_position - 2;
		if ( win.p21_scale_method == I196_g_using_minimum )
		{
			size = win.p23_minimum_size;
		}
		else
		{
			size = win.p22_measurement;
		}
		if ( ~~win.p26_border_hint ) method = method | winmethod_NoBorder;
	}
	type = win.p19_type + 2;
	rock = win.p24_rock_number;
	win.p25_ref_number = FW_glk_window_open( parentwin, method, size, type, rock );
	rfalse;
];

[ FW_glk_window_open _vararg_count ret;
  ! glk_window_open(window, uint, uint, uint, uint) => window
  @glk 35 _vararg_count ret;
  return ret;
];
  
[ FW_WindowSize win index;
	! if win is g-present:
	if ( GetEitherOrProperty( win, p76_g_present ) )
	{
		glk_window_get_size( win.p25_ref_number, gg_arguments, gg_arguments + WORDSIZE );
		return gg_arguments-->index;
	}
	return 0;
];

[ FW_PositionFromNum method;
	switch ( method & winmethod_DirMask )
	{
		winmethod_Left: return I189_g_placeleft;
		winmethod_Right: return I190_g_placeright;
		winmethod_Above: return I191_g_placeabove;
		winmethod_Below: return I192_g_placebelow;
	}
];

[ FW_ScaleMethodFromNum method;
	switch ( method & winmethod_DivisionMask )
	{
		winmethod_Fixed: return I195_g_fixed_size;
		winmethod_Proportional: return I194_g_proportional;
	}
];

[ FW_TypeFromNum type;
	switch ( type )
	{
		wintype_TextBuffer: return I181_g_text_buffer;
		wintype_TextGrid: return I182_g_text_grid;
		wintype_Graphics: return I183_g_graphics;
	}
];

[ FW_ClearStylehint wintype style hint i;
	if ( style == I126_all_styles )
	{
		for ( i = 0: i < style_NUMSTYLES : i++ )
		{
			glk_stylehint_clear( wintype, i, hint );
		}
	}
	else
	{
		glk_stylehint_clear( wintype, style - 2, hint );
	}
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Entries in constant lists
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====





! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: To Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! From "Flexible Windows" by Jon Ingold
! Request 0: phrase (number, number, number, number, number) -> number
! To decide which number is the result from handling an unscheduled construction from ( parent - a number ) with method ( method - a number ) and size ( size - a number ) and type ( type - a number ) and rock ( rock - a number ) ( this is handling an unscheduled construction ):
[ PHR_1071_r0  
    t_0 ! Call parameter 'parent': number
    t_1 ! Call parameter 'method': number
    t_2 ! Call parameter 'size': number
    t_3 ! Call parameter 'type': number
    t_4 ! Call parameter 'rock': number
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_12(t_0, t_1, t_2, t_3, t_4);
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! number
];
[ KERNEL_12 
    t_0 ! Call parameter 'parent': number
    t_1 ! Call parameter 'method': number
    t_2 ! Call parameter 'size': number
    t_3 ! Call parameter 'type': number
    t_4 ! Call parameter 'rock': number
    tmp_0 ! Let/loop value, e.g., 'parent win': thing
    tmp_1 ! Let/loop value, e.g., 'win': thing
    ;
    ! [2: let parent win be the window with ref parent]

    		tmp_0 = (PHR_1038_r119 (t_0));
    ! [3: let win be the window with rock rock]

    		tmp_1 = (PHR_1039_r18 (t_4));
    ! [4: if parent win is the invalid window or win is the invalid window]
    if ((((tmp_0 == ( nothing )))) || (((tmp_1 == ( nothing )))))
    {! [5: decide on 0]
        return 0;
        }
    ! [6: now win is spawned by parent win]
    MoveObject(tmp_1,tmp_0);
    ! [7: now the position of win is the position from method]
    WriteGProperty(10, tmp_1,p20_position,FW_PositionFromNum( t_1 ));
    ! [8: now the scale method of win is the scale method from method]
    WriteGProperty(10, tmp_1,p21_scale_method,FW_ScaleMethodFromNum( t_1 ));
    ! [9: now the measurement of win is the size]
    WriteGProperty(10, tmp_1,p22_measurement,t_2);
    ! [10: now the type of win is the type from type]
    WriteGProperty(10, tmp_1,p19_type,FW_TypeFromNum( t_3 ));
    ! [11: open win]

    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = tmp_1;
        if (((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window))))) { (PHR_1040_r10 (formal_par0)); }
        else ArgumentTypeFailed(573, 8);

    ! Resolution complete

    ! [12: decide on the ref number of win]
    return GProperty(10, tmp_1,p25_ref_number);
    return 0;
];
! From "Flexible Windows" by Jon Ingold
! Request 1: phrase number -> nothing
! To handle an unscheduled deconstruction from ( ref - a number ) ( this is handling an unscheduled deconstruction ):
[ PHR_1072_r1  
    t_0 ! Call parameter 'ref': number
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_13(t_0);
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_13 
    t_0 ! Call parameter 'ref': number
    tmp_0 ! Let/loop value, e.g., 'win': thing
    ;
    ! [2: let win be the window with ref ref]

    		tmp_0 = (PHR_1038_r119 (t_0));
    ! [3: if win is the invalid window]
    if (((tmp_0 == ( nothing ))))
    {! [4: call fw_glk_window_close for ref]
        FW_glk_window_close( t_0, 0 );
        } else {
        ! [5: close win]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_0;
            if (((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window))))) { (PHR_1041_r12 (formal_par0)); }
            else ArgumentTypeFailed(581, 8);

        ! Resolution complete

        }
        rfalse;
];
! From "Reactable Quips SP" by Michael Martin
! Request 2: phrase nothing -> truth state
! To decide whether RQ is active:
[ PHR_926_r2  ;
    ! [2: if the pertinent quip is quip_null]
    if ((((Global_Vars-->18) == I152_quip_null)))
    {! [3: no]
        rfalse;
        }
    ! [4: yes]
    rtrue;
    return false;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 3: phrase nothing -> nothing
! To clue talking:
[ PHR_941_r3  ;
    ! [2: say ~[QBC talking cue][paragraph break]~]
    say__p=1;! [3: qbc talking cue]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->24);! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say496; .L_SayX488;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 4: phrase nothing -> nothing
! To terminate the conversation:
[ PHR_957_r4  ;
    ! [2: now the qbc_litany is the table of no conversation]
    (Global_Vars-->25) = T21_no_conversation;
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 5: phrase quip -> nothing
! To disable the ( q - a quip ) quip:
[ PHR_954_r5  
    t_0 ! Call parameter 'q': quip
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the qbc_litany]
    @push ct_0; @push ct_1;
    		for (tmp_0=(Global_Vars-->25), tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the response entry is q]
        if (((TableLookUpEntry(ct_0,136,ct_1) == t_0)))
        {! [4: now the enabled entry is 0]
            TableLookUpEntry(ct_0,137,ct_1,1,0);
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 6: phrase quip -> nothing
! To enable the ( q - a quip ) quip:
[ PHR_953_r6  
    t_0 ! Call parameter 'q': quip
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the qbc_litany]
    @push ct_0; @push ct_1;
    		for (tmp_0=(Global_Vars-->25), tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the response entry is q]
        if (((TableLookUpEntry(ct_0,136,ct_1) == t_0)))
        {! [4: now the enabled entry is 1]
            TableLookUpEntry(ct_0,137,ct_1,1,1);
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 7: phrase nothing -> nothing
! To display the QBC options:
[ PHR_947_r7  
    tmp_0 ! Let/loop value, e.g., 'qbc_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if the story has ended]
    if (((deadflag~=0)))
    {! [3: stop]
        rtrue;
        }
    ! [4: if rq is active]
    if (((PHR_926_r2 ())))
    {! [5: stop]
        rtrue;
        }
    ! [6: let qbc_index be 0]

    		tmp_0 = 0;
    ! [7: repeat through qbc_litany]
    @push ct_0; @push ct_1;
    		for (tmp_1=(Global_Vars-->25), tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [8: if the enabled entry is 1]
        if (((TableLookUpEntry(ct_0,137,ct_1) == 1)))
        {! [9: increase qbc_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [10: say ~[bracket][qbc_index][close bracket] [prompt entry][line break]~]
            say__p=1;! [11: bracket]
            ParaContent(); print "[";! [12: qbc_index]
            ParaContent(); print (say__n=tmp_0);! [13: close bracket]
            ParaContent(); print "]";! [14: ~ ~]
            ParaContent(); print " ";! [15: prompt entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,135,ct_1);! [16: line break]
            ParaContent(); new_line; .L_Say497; .L_SayX489;}
            }
            @pull ct_1; @pull ct_0;! [17: if qbc_index is not 0]
    if (((~~((tmp_0 == 0)))))
    {! [18: now the number understood is 0]
        parsed_number = 0;
        } else {
        ! [19: terminate the conversation]
        (PHR_957_r4 ());
        }
        rfalse;
];
! From "Basic Screen Effects" by Emily Short
! Request 8: phrase table name -> nothing
! To fill the/-- status bar/line with ( selected table - a table-name ):
[ PHR_891_r8  
    t_0 ! Call parameter 'selected table': table name
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_14(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_14 
    t_0 ! Call parameter 'selected table': table name
    tmp_0 ! Let/loop value, e.g., '__n': number
    tmp_1 ! Let/loop value, e.g., '__index': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __n be the number of rows in the selected table]

    		tmp_0 = TableRows(t_0);
    ! [3: deepen status line to __n rows]
    DeepStatus(tmp_0);
    ! [4: let __index be 1]

    		tmp_1 = 1;
    ! [5: repeat through selected table]
    @push ct_0; @push ct_1;
    		for (tmp_2=t_0, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [6: move cursor to __index]
        I7VM_MoveCursorInStatusLine(tmp_1);
        ! [7: if there is left entry]
        if (((ExistsTableLookUpEntry(ct_0,119,ct_1))))
        {! [8: say ~[left entry]~]
            say__p=1;! [9: left entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,119,ct_1); .L_Say498; .L_SayX490;}
        ! [10: if there is central entry]
        if (((ExistsTableLookUpEntry(ct_0,120,ct_1))))
        {! [11: center central entry at row __index]
            CenterPrint(BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,120,ct_1)), tmp_1);
            }
        ! [12: if there is right entry]
        if (((ExistsTableLookUpEntry(ct_0,121,ct_1))))
        {! [13: right align cursor to __index]
            RightAlign(tmp_1);
            ! [14: say ~[right entry]~]
            say__p=1;! [15: right entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,121,ct_1); .L_Say499; .L_SayX491;}
        ! [16: increase __index by 1]
        tmp_1 = tmp_1 + 1;;
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 9: phrase nothing -> truth state
! To decide whether QBC is active:
[ PHR_942_r9  ;
    ! [2: if the number of filled rows in the qbc_litany is not zero and not rq is active]
    if ((((~~((TableFilledRows((Global_Vars-->25)) == 0))))) && ((~~((((PHR_926_r2 ())))))))
    {! [3: yes]
        rtrue;
        }
    ! [4: no]
    rfalse;
    return false;
];
! From "Flexible Windows" by Jon Ingold
! Request 10: phrase g-window -> nothing
! To open up/-- ( win - a g-window ) , as the acting main window:
[ PHR_1040_r10  
    t_0 ! Call parameter 'win': g-window
    phrase_options ! Implied call parameter
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_15(t_0, phrase_options);
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_15 
    t_0 ! Call parameter 'win': g-window
    phrase_options ! Implied call parameter
    ;
    ! [2: if win is g-unpresent and ( win is the main window or the main window is ancestral to win )]
    if (((((Adj_103_t1_v10(t_0))))) && ((((t_0 == I200_main_window))) || (((IndirectlyContains(I200_main_window,t_0))))))
    {! [3: now win is g-required]
        (Adj_100_t2_v10(t_0));
        ! [4: now every g-window ancestral to win is g-required]
        Prop_39(t_0);
        ! [5: calibrate windows]
        (PHR_1044_r19 ());
        ! [6: if as the acting main window]
        if (phrase_options & 1)
        {! [7: set win as the acting main window]

            ! Resolution of run-time phrase ambiguity (to phrase):
                formal_par0 = t_0;
                if (((((formal_par0 ofclass K16_g_window) && (formal_par0 ofclass K16_g_window) && ((Adj_102_t1_v10(formal_par0))) && ((~~Adj_44_t1_v10(formal_par0))))))) { (PHR_1059_r25 (formal_par0)); }
                else ArgumentTypeFailed(232, 8);

            ! Resolution complete

            }
            }
            rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 11: phrase g-window -> nothing
! To clear ( win - a g-window ):
[ PHR_1048_r11  
    t_0 ! Call parameter 'win': g-window
    ;
    ! [2: if win is g-present]
    if ((((Adj_102_t1_v10(t_0)))))
    {! [3: if the type of win is g-graphics and the background color of win is not empty]
        if ((((GProperty(10, t_0,p19_type) == I183_g_graphics))) && (((~~(((Adj_17_t1_v14(GProperty(10, t_0,p27_background_color)))))))))
        {! [4: set the background color of win to the background color of win]
            glk_window_set_background_color( t_0.p25_ref_number, GTE_ConvertColour( GProperty(10, t_0,p27_background_color) ) );
            }
        ! [5: call glk_window_clear for win]
        glk_window_clear( t_0.p25_ref_number );
        }
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 12: phrase g-window -> nothing
! To close ( win - a g-window ):
[ PHR_1041_r12  
    t_0 ! Call parameter 'win': g-window
    ;
    ! [2: if win is g-present]
    if ((((Adj_102_t1_v10(t_0)))))
    {! [3: now win is g-unrequired]
        (Adj_101_t2_v10(t_0));
        ! [4: now every g-window descended from win is g-unrequired]
        Prop_40(t_0);
        ! [5: calibrate windows]
        (PHR_1044_r19 ());
        }
        rfalse;
];
! From the Standard Rules
! Request 13: phrase (object, number) -> nothing
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_82_r13  
    t_0 ! Call parameter 'O': object
    t_1 ! Call parameter 'N': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if o is a thing]
    if (((t_0 ofclass K2_thing)))
    {! [3: if n <= 0]
        if (((t_1 <= 0)))
        {! [4: now o is mentioned]
            (Adj_78_t2_v10(t_0));
            }
        ! [5: if there is a notable-object of o in the table of locale priorities]
        if (((ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0))))
        {! [6: choose row with a notable-object of o in the table of locale priorities]
            ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0);
            ! [7: if n <= 0]
            if (((t_1 <= 0)))
            {! [8: blank out the whole row]
                TableBlankOutRow(ct_0, ct_1);
                } else {
                ! [9: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1);
                }
                } else {
            ! [10: if n is greater than 0]
            if (((t_1 > 0)))
            {! [11: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0);
                ! [12: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0);
                ! [13: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1);
                }
                }
                }
                rfalse;
];
! From the Standard Rules
! Request 14: phrase object -> nothing
! To describe locale for ( O - object ):
[ PHR_81_r14  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: carry out the printing the locale description activity with o]
    CarryOutActivity(V30_printing_the_locale_desc, t_0);
    rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 15: phrase text -> nothing
! To johan mode ( T - text ):
[ PHR_800_r15  
    t_0 ! Call parameter 'T': text
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_16(t_0);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_16 
    t_0 ! Call parameter 'T': text
    tmp_0 ! Let/loop value, e.g., 'X': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let x be the number of words in t]

    		tmp_0 = TEXT_TY_BlobAccess(t_0, WORD_BLOB);
    ! [3: say word number 1 in t in sentence case]
    say__p=1;! [4: word number 1 in t in sentence case]
    ParaContent(); print (TEXT_TY_Say) TEXT_TY_GetBlob(I7SFRAME, TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*2), t_0, 3), 1, WORD_BLOB); .L_Say500; .L_SayX492;! [5: repeat with counter running from 2 to x]
    for (tmp_1=2: tmp_1<=tmp_0: tmp_1++)
    {! [6: say ~ [word number counter in T]~]
        say__p=1;! [7: ~ ~]
        ParaContent(); print " ";! [8: word number counter in t]
        ParaContent(); print (TEXT_TY_Say) TEXT_TY_GetBlob((I7SFRAME+WORDSIZE*4), t_0, tmp_1, WORD_BLOB); .L_Say501; .L_SayX493;}
        rfalse;
];
! From "Reactable Quips SP" by Michael Martin
! Request 16: phrase quip -> nothing
! To deliver the ( q - quip ) quip:
[ PHR_924_r16  
    t_0 ! Call parameter 'q': quip
    tmp_0 ! Let/loop value, e.g., 'rq_index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: now the current quip is q]
    (Global_Vars-->17) = t_0;
    ! [3: carry out the quipping activity]
    CarryOutActivity(V36_quipping);
    ! [4: let rq_index be 0]

    		tmp_0 = 0;
    ! [5: repeat through table of quip followups]
    @push ct_0; @push ct_1;
    		for (tmp_1=T18_quip_followups, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [6: if the current quip is the quip entry]
        if ((((Global_Vars-->17) == TableLookUpEntry(ct_0,130,ct_1))))
        {! [7: increase rq_index by 1]
            tmp_0 = tmp_0 + 1;;
            ! [8: say ~[bracket][rq_index][close bracket] [option entry][line break]~]
            say__p=1;! [9: bracket]
            ParaContent(); print "[";! [10: rq_index]
            ParaContent(); print (say__n=tmp_0);! [11: close bracket]
            ParaContent(); print "]";! [12: ~ ~]
            ParaContent(); print " ";! [13: option entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,132,ct_1);! [14: line break]
            ParaContent(); new_line; .L_Say502; .L_SayX494;}
            }
            @pull ct_1; @pull ct_0;! [15: if rq_index is not 0]
    if (((~~((tmp_0 == 0)))))
    {! [16: now the pertinent quip is the current quip]
        (Global_Vars-->18) = (Global_Vars-->17);
        ! [17: now the number understood is 0]
        parsed_number = 0;
        } else {
        ! [18: now the pertinent quip is quip_null]
        (Global_Vars-->18) = I152_quip_null;
        }
        rfalse;
];
! From "Menus" by Emily Short
! Request 17: phrase nothing -> nothing
! To show menu contents:
[ PHR_908_r17  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_17();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_17 
    tmp_0 ! Let/loop value, e.g., 'temporary depth': number
    tmp_1 ! Let/loop value, e.g., 'temporary menu': table name
    tmp_2 ! Let/loop value, e.g., 'temporary title': text
    tmp_3 ! Let/loop value, e.g., '__x': number
    tmp_4 ! Let/loop value, e.g., '__index': number
    tmp_5 ! Let/loop value (deallocated by end of phrase)
    tmp_6 ! Let/loop value (deallocated by end of phrase)
    tmp_7 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: increase the menu depth by 1]
    (Global_Vars-->12) = (Global_Vars-->12) + 1;;
    ! [3: let temporary depth be the menu depth]

    		tmp_0 = (Global_Vars-->12);
    ! [4: let temporary menu be the current menu]

    		tmp_1 = (Global_Vars-->15);
    ! [5: let temporary title be the current menu title]
    tmp_2 = I7SFRAME; 
    		BlkValueCopy(tmp_2, (Global_Vars-->14));
    ! [6: let __x be 0]

    		tmp_3 = 0;
    ! [7: let __index be 0]

    		tmp_4 = 0;
    ! [8: while __index is not 1]
    while (((~~((tmp_4 == 1)))))
    {! [9: now the current menu is the temporary menu]
        (Global_Vars-->15) = tmp_1;
        ! [10: let __n be 0]

        		tmp_5 = 0;
        ! [11: repeat through current menu]
        @push ct_0; @push ct_1;
        		for (tmp_6=(Global_Vars-->15), tmp_7=1, ct_0=tmp_6, ct_1=tmp_7:
        			tmp_7<=TableRows(tmp_6):
        			tmp_7++, ct_0=tmp_6, ct_1=tmp_7)
        			if (TableRowIsBlank(ct_0, ct_1)==false)
        {! [12: increase __n by 1]
            tmp_5 = tmp_5 + 1;;
            ! [13: if title entry is current menu title]
            if ((( BlkValueCompare(TableLookUpEntry(ct_0,122,ct_1), (Global_Vars-->14)) == 0)))
            {! [14: now current menu selection is __n]
                (Global_Vars-->16) = tmp_5;
                }
                }
                @pull ct_1; @pull ct_0;! [15: now the current menu title is the temporary title]
        BlkValueCopy((Global_Vars-->14), tmp_2);
        ! [16: reprint current menu]
        (PHR_907_r26 ((Global_Vars-->15)));
        ! [17: let __x be the chosen letter]
        tmp_3 = VM_KeyChar();
        ! [18: if __x is a number listed in the table of menu commands]
        if (((true) && ((ct_1=ExistsTableRowCorr(ct_0=T7_menu_commands,126,tmp_3)))))
        {! [19: follow the effect entry]
            FollowRulebook(TableLookUpEntry(ct_0,127,ct_1));
            ! [20: if temporary depth > menu depth]
            if (((tmp_0 > (Global_Vars-->12))))
            {! [21: now __index is 1]
                tmp_4 = 1;
                }
                }
                }
                rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 18: phrase number -> g-window
! To decide which g-window is the window with rock ( rock - a number ):
[ PHR_1039_r18  
    t_0 ! Call parameter 'rock': number
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if rock is not 0]
    if (((~~((t_0 == 0)))))
    {! [3: repeat with win running through g-windows]
        for (tmp_0=Prop_41(0), tmp_1=Prop_41(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_41(tmp_1))
        {! [4: if the rock number of win is rock]
            if (((GProperty(10, tmp_0,p24_rock_number) == t_0)))
            {! [5: decide on win]
                return tmp_0;
                }
                }
                }
    ! [6: decide on the invalid window]
    return ( nothing );
    return I197_all_windows;
];
! From "Flexible Windows" by Jon Ingold
! Request 19: phrase nothing -> nothing
! To calibrate windows:
[ PHR_1044_r19  
    tmp_0 ! Let/loop value, e.g., 'win': g-window
    ;
    ! [2: while there is a not currently being processed g-unrequired g-present childless g-window ( called win )]
    while ((((Prop_42() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: now win is currently being processed]
        (Adj_104_t2_v10(tmp_0));
        ! [4: safely carry out the deconstructing activity with win]
        @push say__p; @push say__pc; CarryOutActivity( V38_deconstructing, tmp_0 ); @pull say__pc; @pull say__p;
        ! [5: now win is not currently being processed]
        (Adj_104_t3_v10(tmp_0));
        }
    ! [6: while there is a not currently being processed g-required g-unpresent next-step g-window ( called win )]
    while ((((Prop_43() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [7: now win is currently being processed]
        (Adj_104_t2_v10(tmp_0));
        ! [8: safely carry out the constructing activity with win]
        @push say__p; @push say__pc; CarryOutActivity( V37_constructing, tmp_0 ); @pull say__pc; @pull say__p;
        ! [9: now win is not currently being processed]
        (Adj_104_t3_v10(tmp_0));
        }
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 20: phrase g-window -> nothing
! To focus ( win - a g-window ):
[ PHR_1058_r20  
    t_0 ! Call parameter 'win': g-window
    ;
    ! [2: if win is g-present]
    if ((((Adj_102_t1_v10(t_0)))))
    {! [3: now the current focus window is win]
        (Global_Vars-->31) = t_0;
        ! [4: call glk_set_window for win]
        glk_set_window( t_0.p25_ref_number );
        }
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 21: phrase nothing -> nothing
! To refresh all/-- windows:
[ PHR_1050_r21  
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: repeat with win running through g-present non-buffering g-windows]
    for (tmp_0=Prop_44(0), tmp_1=Prop_44(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_44(tmp_1))
    {! [3: refresh win]
        (PHR_1049_r22 (tmp_0));
        }
        rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 22: phrase g-window -> nothing
! To refresh ( win - a g-window ):
[ PHR_1049_r22  
    t_0 ! Call parameter 'win': g-window
    ;
    ! [2: safely carry out the refreshing activity with win]
    @push say__p; @push say__pc; CarryOutActivity( V39_refreshing, t_0 ); @pull say__pc; @pull say__p;
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 23: phrase g-window -> g-window
! To decide which g-window is the parent of ( win - a g-window ):
[ PHR_1037_r23  
    t_0 ! Call parameter 'win': g-window
    ;
    ! [2: if the holder of win is a g-window]
    if ((((HolderOf(t_0)) ofclass K16_g_window)))
    {! [3: decide on the holder of win]
        return CheckKindReturned((HolderOf(t_0)), K16_g_window);
        }
    ! [4: decide on the invalid window]
    return ( nothing );
    return I197_all_windows;
];
! From "Flexible Windows" by Jon Ingold
! Request 24: phrase text -> nothing
! To set the Gargoyle window padding to ( T - a text ):
[ PHR_1103_r24  
    t_0 ! Call parameter 'T': text
    ;
    ! [2: set the background color of wintype 3 for normal-style to t]
    GTE_SetStylehint( 3, I127_normal_style, stylehint_BackColor, GTE_ConvertColour( t_0 ) );
    rfalse;
];
! From "Flexible Windows" by Jon Ingold
! Request 25: phrase g-window -> nothing
! To set ( win - a g-present textual g-window ) as the acting main window:
[ PHR_1059_r25  
    t_0 ! Call parameter 'win': g-window
    tmp_0 ! Let/loop value, e.g., 'status window state': truth state
    ;
    ! [2: now the acting main window is win]
    (Global_Vars-->32) = t_0;
    ! [3: now gg_mainwin is the ref number of win]
    gg_mainwin = GProperty(10, t_0,p25_ref_number);
    ! [4: focus win]
    (PHR_1058_r20 (t_0));
    ! [5: let the status window state be whether or not the status window is g-present]

    		tmp_0 = (((((Adj_102_t1_v10(I201_status_window))))));
    ! [6: close the status window]
    (PHR_1041_r12 (I201_status_window));
    ! [7: now the status window is spawned by win]
    MoveObject(I201_status_window,t_0);
    ! [8: close the quote window]
    (PHR_1041_r12 (I202_quote_window));
    ! [9: now the quote window is spawned by win]
    MoveObject(I202_quote_window,t_0);
    ! [10: if the status window state is true]
    if ((((tmp_0 && true) == (1 && true))))
    {! [11: open the status window]
        (PHR_1040_r10 (I201_status_window));
        }
        rfalse;
];
! From "Menus" by Emily Short
! Request 26: phrase table name -> nothing
! To reprint ( selected menu - a table name ):
[ PHR_907_r26  
    t_0 ! Call parameter 'selected menu': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: redraw status line]
    DrawStatusLine();
    ! [3: say fixed letter spacing]
    say__p=1;! [4: fixed letter spacing]
    ParaContent(); font off; .L_Say503; .L_SayX495;! [5: let __index be 1]

    		tmp_0 = 1;
    ! [6: clear only the main screen]
    VM_ClearScreen(2);
    ! [7: repeat through selected menu]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [8: if __index is current menu selection]
        if (((tmp_0 == (Global_Vars-->16))))
        {! [9: say ~ >~]
            say__p=1;! [10: ~ >~]
            ParaContent(); print " >"; .L_Say504; .L_SayX496;} else {
            ! [11: say ~  ~]
            say__p=1;! [12: ~  ~]
            ParaContent(); print "  "; .L_Say505; .L_SayX497;}
        ! [13: say ~ [title entry][line break]~]
        say__p=1;! [14: ~ ~]
        ParaContent(); print " ";! [15: title entry]
        ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,122,ct_1);! [16: line break]
        ParaContent(); new_line; .L_Say506; .L_SayX498;! [17: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        }
        @pull ct_1; @pull ct_0;! [18: say variable letter spacing]
    say__p=1;! [19: variable letter spacing]
    ParaContent(); font on; .L_Say507; .L_SayX499;rfalse;
];
! From "Basic Screen Effects" by Emily Short
! Request 27: phrase nothing -> nothing
! To pause the/-- game:
[ PHR_879_r27  ;
    ! [2: carry out the pausing the game activity]
    CarryOutActivity(V34_pausing_the_game);
    rfalse;
];
! From "Menus SP" by Emily Short
! Request 28: phrase table name -> nothing
! To say known hints from ( hint booklet - table name ):
[ PHR_915_r28  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __index be 0]

    		tmp_0 = 0;
    ! [3: clear only the main screen]
    VM_ClearScreen(2);
    ! [4: repeat through hint booklet]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [6: if there is a used entry]
        if (((ExistsTableLookUpEntry(ct_0,129,ct_1))))
        {! [7: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
            say__p=1;! [8: __index]
            ParaContent(); print (say__n=tmp_0);! [9: ~/~]
            ParaContent(); print "/";! [10: number of rows in hint booklet]
            ParaContent(); print (say__n=TableRows(t_0));! [11: ~: ~]
            ParaContent(); print ": ";! [12: hint entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [13: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say508; .L_SayX500;} else {
            ! [14: if __index is 1]
            if (((tmp_0 == 1)))
            {! [15: now used entry is turn count]
                TableLookUpEntry(ct_0,129,ct_1,1,turns);
                ! [16: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
                say__p=1;! [17: __index]
                ParaContent(); print (say__n=tmp_0);! [18: ~/~]
                ParaContent(); print "/";! [19: number of rows in hint booklet]
                ParaContent(); print (say__n=TableRows(t_0));! [20: ~: ~]
                ParaContent(); print ": ";! [21: hint entry]
                ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [22: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say509; .L_SayX501;}
                }
                }
                @pull ct_1; @pull ct_0;! [23: say ~Pulsa la tecla espaciadora para retornar al menú o H para enseñar otra pista.~]
    say__p=1;! [24: ~Pulsa la tecla espaciadora para retornar al menú o H para enseñar otra pista.~]
    ParaContent(); print "Pulsa la tecla espaciadora para retornar al menú o H para enseñar otra pista."; new_line; .L_Say510; .L_SayX502;rfalse;
];
! From "Menus SP" by Emily Short
! Request 29: phrase table name -> nothing
! To say hints from ( hint booklet - table name ):
[ PHR_916_r29  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __index be 0]

    		tmp_0 = 0;
    ! [3: clear only the main screen]
    VM_ClearScreen(2);
    ! [4: repeat through hint booklet]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [6: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
        say__p=1;! [7: __index]
        ParaContent(); print (say__n=tmp_0);! [8: ~/~]
        ParaContent(); print "/";! [9: number of rows in hint booklet]
        ParaContent(); print (say__n=TableRows(t_0));! [10: ~: ~]
        ParaContent(); print ": ";! [11: hint entry]
        ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [12: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say511; .L_SayX503;! [13: if there is a used entry]
        if (((ExistsTableLookUpEntry(ct_0,129,ct_1))))
        {! [14: do nothing]
            ;
            } else {
            ! [15: now used entry is turn count]
            TableLookUpEntry(ct_0,129,ct_1,1,turns);
            ! [16: say ~Pulsa la tecla espaciadora para retornar al menú[if __index < number of rows in hint booklet] o H para desvelar otra pista[end if].~]
            say__p=1;! [17: ~Pulsa la tecla espaciadora para retornar al menú~]
            ParaContent(); print "Pulsa la tecla espaciadora para retornar al menú";! [18: if __index < number of rows in hint booklet]
            ParaContent(); 
            	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say512;! [19: ~ o H para desvelar otra pista~]
            ParaContent(); print " o H para desvelar otra pista";! [20: end if]

            	.L_Say512; .L_SayX504;! [21: ~.~]
            ParaContent(); print "."; new_line; .L_Say513; .L_SayX505;! [22: make no decision]
            rfalse;
            }
            }
            @pull ct_1; @pull ct_0;! [23: say ~Pulsa la tecla espaciadora para retornar al menú[if __index < number of rows in hint booklet]  o H para desvelar otra pista[end if].~]
    say__p=1;! [24: ~Pulsa la tecla espaciadora para retornar al menú~]
    ParaContent(); print "Pulsa la tecla espaciadora para retornar al menú";! [25: if __index < number of rows in hint booklet]
    ParaContent(); 
    	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say514;! [26: ~  o H para desvelar otra pista~]
    ParaContent(); print "  o H para desvelar otra pista";! [27: end if]

    	.L_Say514; .L_SayX506;! [28: ~.~]
    ParaContent(); print "."; new_line; .L_Say515; .L_SayX507;rfalse;
];
! From "Basic Help Menu SP" by Emily Short
! Request 30: phrase nothing -> verbosity
! To decide what verbosity is the current verbosity mode:
[ PHR_920_r30  
    tmp_0 ! Let/loop value, e.g., 'n': number
    ;
    ! [2: let n be the current lookmode number]

    		tmp_0 = lookmode;
    ! [3: if n is 1]
    if (((tmp_0 == 1)))
    {! [4: decide on brief]
        return I148_brief;
        }
    ! [5: if n is 2]
    if (((tmp_0 == 2)))
    {! [6: decide on verbose]
        return I149_verbose;
        }
    ! [7: if n is 3]
    if (((tmp_0 == 3)))
    {! [8: decide on superbrief]
        return I150_superbrief;
        }
        return I148_brief;
];
! From the Standard Rules
! Request 31: phrase nothing -> nothing
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_350_r31  ;
    ! [2: do nothing]
    ;
    rfalse;
];
! From the Standard Rules
! Request 32: phrase response -> nothing
! To say text of ( R - response ) ( documented at phs_response ):
[ PHR_390_r32  
    t_0 ! Call parameter 'R': response
    ;
    ! [2: carry out the issuing the response text activity with r]
    CarryOutActivity(V33_issuing_the_response_tex, t_0);
    rfalse;
];
! From the Standard Rules
! Request 33: phrase real number -> real number
! To decide which real number is the real square of ( R - a real number ) ( this is the rsqr function inverse to root ):
[ PHR_424_r33  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = r@@94@{32} where x is a real number]

    		! Solving Q0_english for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 34: phrase real number -> real number
! To decide which real number is the hyperbolic arcsine of ( R - a real number ) ( documented at ph_hyperbolicarcsine ) ( this is the arcsinh function inverse to sinh ):
[ PHR_442_r34  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = log ( r + root ( r@@94@{32} + 1 ) ) where x is a real number]

    		! Solving Q1_english for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 35: phrase real number -> real number
! To decide which real number is the hyperbolic arccosine of ( R - a real number ) ( documented at ph_hyperbolicarccosine ) ( this is the arccosh function inverse to cosh ):
[ PHR_443_r35  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = log ( r + root ( r@@94@{32} - 1 ) ) where x is a real number]

    		! Solving Q2_english for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 36: phrase real number -> real number
! To decide which real number is the hyperbolic arctangent of ( R - a real number ) ( documented at ph_hyperbolicarctangent ) ( this is the arctanh function inverse to tanh ):
[ PHR_444_r36  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = 0.5* ( log ( 1+r ) - log ( 1-r ) ) where x is a real number]

    		! Solving Q3_english for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Times(1056964608, (REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))), (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 37: phrase nothing -> nothing
! To say here ( documented at phs_here ):
[ PHR_527_r37  ;
    ! [2: say ~[if story tense is present tense]here[otherwise]there~]
    say__p=1;! [3: if story tense is present tense]

    	if (~~((((story_tense == I106_present_tense))))) jump L_Say516;! [4: ~here~]
    ParaContent(); print "here";! [5: otherwise]

    	jump L_SayX508; .L_Say516;! [6: ~there~]
    ParaContent(); print "there"; .L_Say517; .L_SayX508;rfalse;
];
! From the Standard Rules
! Request 38: phrase nothing -> nothing
! To say now ( documented at phs_now ):
[ PHR_528_r38  ;
    ! [2: say ~[if story tense is present tense]now[otherwise]then~]
    say__p=1;! [3: if story tense is present tense]

    	if (~~((((story_tense == I106_present_tense))))) jump L_Say518;! [4: ~now~]
    ParaContent(); print "now";! [5: otherwise]

    	jump L_SayX509; .L_Say518;! [6: ~then~]
    ParaContent(); print "then"; .L_Say519; .L_SayX509;rfalse;
];
! From "English Language" by Graham Nelson
! Request 39: phrase nothing -> nothing
! To say we:
[ PHR_763_r39  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~I~]
        say__p=1;! [5: ~I~]
        ParaContent(); print "I"; .L_Say520; .L_SayX510;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~you~]
        say__p=1;! [8: ~you~]
        ParaContent(); print "you"; .L_Say521; .L_SayX511;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~he~]
            say__p=1;! [12: ~he~]
            ParaContent(); print "he"; .L_Say522; .L_SayX512;} else {
            ! [13: say ~she~]
            say__p=1;! [14: ~she~]
            ParaContent(); print "she"; .L_Say523; .L_SayX513;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~we~]
        say__p=1;! [17: ~we~]
        ParaContent(); print "we"; .L_Say524; .L_SayX514;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~you~]
        say__p=1;! [20: ~you~]
        ParaContent(); print "you"; .L_Say525; .L_SayX515;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~they~]
        say__p=1;! [23: ~they~]
        ParaContent(); print "they"; .L_Say526; .L_SayX516;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 40: phrase nothing -> nothing
! To say us:
[ PHR_764_r40  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~me~]
        say__p=1;! [5: ~me~]
        ParaContent(); print "me"; .L_Say527; .L_SayX517;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~you~]
        say__p=1;! [8: ~you~]
        ParaContent(); print "you"; .L_Say528; .L_SayX518;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~him~]
            say__p=1;! [12: ~him~]
            ParaContent(); print "him"; .L_Say529; .L_SayX519;} else {
            ! [13: say ~her~]
            say__p=1;! [14: ~her~]
            ParaContent(); print "her"; .L_Say530; .L_SayX520;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~us~]
        say__p=1;! [17: ~us~]
        ParaContent(); print "us"; .L_Say531; .L_SayX521;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~you~]
        say__p=1;! [20: ~you~]
        ParaContent(); print "you"; .L_Say532; .L_SayX522;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~them~]
        say__p=1;! [23: ~them~]
        ParaContent(); print "them"; .L_Say533; .L_SayX523;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 41: phrase nothing -> nothing
! To say ours:
[ PHR_765_r41  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~mine~]
        say__p=1;! [5: ~mine~]
        ParaContent(); print "mine"; .L_Say534; .L_SayX524;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~yours~]
        say__p=1;! [8: ~yours~]
        ParaContent(); print "yours"; .L_Say535; .L_SayX525;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~his~]
            say__p=1;! [12: ~his~]
            ParaContent(); print "his"; .L_Say536; .L_SayX526;} else {
            ! [13: say ~hers~]
            say__p=1;! [14: ~hers~]
            ParaContent(); print "hers"; .L_Say537; .L_SayX527;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~ours~]
        say__p=1;! [17: ~ours~]
        ParaContent(); print "ours"; .L_Say538; .L_SayX528;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~yours~]
        say__p=1;! [20: ~yours~]
        ParaContent(); print "yours"; .L_Say539; .L_SayX529;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~theirs~]
        say__p=1;! [23: ~theirs~]
        ParaContent(); print "theirs"; .L_Say540; .L_SayX530;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 42: phrase nothing -> nothing
! To say ourselves:
[ PHR_766_r42  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~myself~]
        say__p=1;! [5: ~myself~]
        ParaContent(); print "myself"; .L_Say541; .L_SayX531;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~yourself~]
        say__p=1;! [8: ~yourself~]
        ParaContent(); print "yourself"; .L_Say542; .L_SayX532;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~himself~]
            say__p=1;! [12: ~himself~]
            ParaContent(); print "himself"; .L_Say543; .L_SayX533;} else {
            ! [13: say ~herself~]
            say__p=1;! [14: ~herself~]
            ParaContent(); print "herself"; .L_Say544; .L_SayX534;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~ourselves~]
        say__p=1;! [17: ~ourselves~]
        ParaContent(); print "ourselves"; .L_Say545; .L_SayX535;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~yourselves~]
        say__p=1;! [20: ~yourselves~]
        ParaContent(); print "yourselves"; .L_Say546; .L_SayX536;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~themselves~]
        say__p=1;! [23: ~themselves~]
        ParaContent(); print "themselves"; .L_Say547; .L_SayX537;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 43: phrase nothing -> nothing
! To say our:
[ PHR_767_r43  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~my~]
        say__p=1;! [5: ~my~]
        ParaContent(); print "my"; .L_Say548; .L_SayX538;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~your~]
        say__p=1;! [8: ~your~]
        ParaContent(); print "your"; .L_Say549; .L_SayX539;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~his~]
            say__p=1;! [12: ~his~]
            ParaContent(); print "his"; .L_Say550; .L_SayX540;} else {
            ! [13: say ~her~]
            say__p=1;! [14: ~her~]
            ParaContent(); print "her"; .L_Say551; .L_SayX541;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~our~]
        say__p=1;! [17: ~our~]
        ParaContent(); print "our"; .L_Say552; .L_SayX542;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~your~]
        say__p=1;! [20: ~your~]
        ParaContent(); print "your"; .L_Say553; .L_SayX543;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~their~]
        say__p=1;! [23: ~their~]
        ParaContent(); print "their"; .L_Say554; .L_SayX544;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 44: phrase nothing -> nothing
! To say We:
[ PHR_768_r44  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~I~]
        say__p=1;! [5: ~I~]
        ParaContent(); print "I"; .L_Say555; .L_SayX545;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~You~]
        say__p=1;! [8: ~You~]
        ParaContent(); print "You"; .L_Say556; .L_SayX546;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~He~]
            say__p=1;! [12: ~He~]
            ParaContent(); print "He"; .L_Say557; .L_SayX547;} else {
            ! [13: say ~She~]
            say__p=1;! [14: ~She~]
            ParaContent(); print "She"; .L_Say558; .L_SayX548;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~We~]
        say__p=1;! [17: ~We~]
        ParaContent(); print "We"; .L_Say559; .L_SayX549;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~You~]
        say__p=1;! [20: ~You~]
        ParaContent(); print "You"; .L_Say560; .L_SayX550;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~They~]
        say__p=1;! [23: ~They~]
        ParaContent(); print "They"; .L_Say561; .L_SayX551;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 45: phrase nothing -> nothing
! To say Us:
[ PHR_769_r45  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~Me~]
        say__p=1;! [5: ~Me~]
        ParaContent(); print "Me"; .L_Say562; .L_SayX552;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~You~]
        say__p=1;! [8: ~You~]
        ParaContent(); print "You"; .L_Say563; .L_SayX553;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~Him~]
            say__p=1;! [12: ~Him~]
            ParaContent(); print "Him"; .L_Say564; .L_SayX554;} else {
            ! [13: say ~Her~]
            say__p=1;! [14: ~Her~]
            ParaContent(); print "Her"; .L_Say565; .L_SayX555;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~Us~]
        say__p=1;! [17: ~Us~]
        ParaContent(); print "Us"; .L_Say566; .L_SayX556;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~You~]
        say__p=1;! [20: ~You~]
        ParaContent(); print "You"; .L_Say567; .L_SayX557;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~Them~]
        say__p=1;! [23: ~Them~]
        ParaContent(); print "Them"; .L_Say568; .L_SayX558;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 46: phrase nothing -> nothing
! To say Ours:
[ PHR_770_r46  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~Mine~]
        say__p=1;! [5: ~Mine~]
        ParaContent(); print "Mine"; .L_Say569; .L_SayX559;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~Yours~]
        say__p=1;! [8: ~Yours~]
        ParaContent(); print "Yours"; .L_Say570; .L_SayX560;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~His~]
            say__p=1;! [12: ~His~]
            ParaContent(); print "His"; .L_Say571; .L_SayX561;} else {
            ! [13: say ~Hers~]
            say__p=1;! [14: ~Hers~]
            ParaContent(); print "Hers"; .L_Say572; .L_SayX562;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~Ours~]
        say__p=1;! [17: ~Ours~]
        ParaContent(); print "Ours"; .L_Say573; .L_SayX563;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~Yours~]
        say__p=1;! [20: ~Yours~]
        ParaContent(); print "Yours"; .L_Say574; .L_SayX564;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~Theirs~]
        say__p=1;! [23: ~Theirs~]
        ParaContent(); print "Theirs"; .L_Say575; .L_SayX565;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 47: phrase nothing -> nothing
! To say Ourselves:
[ PHR_771_r47  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~Myself~]
        say__p=1;! [5: ~Myself~]
        ParaContent(); print "Myself"; .L_Say576; .L_SayX566;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~Yourself~]
        say__p=1;! [8: ~Yourself~]
        ParaContent(); print "Yourself"; .L_Say577; .L_SayX567;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~Himself~]
            say__p=1;! [12: ~Himself~]
            ParaContent(); print "Himself"; .L_Say578; .L_SayX568;} else {
            ! [13: say ~Herself~]
            say__p=1;! [14: ~Herself~]
            ParaContent(); print "Herself"; .L_Say579; .L_SayX569;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~Ourselves~]
        say__p=1;! [17: ~Ourselves~]
        ParaContent(); print "Ourselves"; .L_Say580; .L_SayX570;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~Yourselves~]
        say__p=1;! [20: ~Yourselves~]
        ParaContent(); print "Yourselves"; .L_Say581; .L_SayX571;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~Themselves~]
        say__p=1;! [23: ~Themselves~]
        ParaContent(); print "Themselves"; .L_Say582; .L_SayX572;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 48: phrase nothing -> nothing
! To say Our:
[ PHR_772_r48  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~My~]
        say__p=1;! [5: ~My~]
        ParaContent(); print "My"; .L_Say583; .L_SayX573;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~Your~]
        say__p=1;! [8: ~Your~]
        ParaContent(); print "Your"; .L_Say584; .L_SayX574;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~His~]
            say__p=1;! [12: ~His~]
            ParaContent(); print "His"; .L_Say585; .L_SayX575;} else {
            ! [13: say ~Her~]
            say__p=1;! [14: ~Her~]
            ParaContent(); print "Her"; .L_Say586; .L_SayX576;}
            }
    ! [15: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [16: say ~Our~]
        say__p=1;! [17: ~Our~]
        ParaContent(); print "Our"; .L_Say587; .L_SayX577;}
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~Your~]
        say__p=1;! [20: ~Your~]
        ParaContent(); print "Your"; .L_Say588; .L_SayX578;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~Their~]
        say__p=1;! [23: ~Their~]
        ParaContent(); print "Their"; .L_Say589; .L_SayX579;}
        rfalse;
];
! From "English Language" by Graham Nelson
! Request 49: phrase nothing -> nothing
! To say those:
[ PHR_773_r49  ;
    ! [2: say those in the accusative]
    say__p=1;! [3: those in the accusative]
    ParaContent(); (PHR_775_r51 (I120_accusative)); .L_Say590; .L_SayX580;rfalse;
];
! From "English Language" by Graham Nelson
! Request 50: phrase nothing -> nothing
! To say Those:
[ PHR_774_r50  ;
    ! [2: say those in the nominative]
    say__p=1;! [3: those in the nominative]
    ParaContent(); (PHR_776_r52 (I119_nominative)); .L_Say591; .L_SayX581;rfalse;
];
! From "English Language" by Graham Nelson
! Request 51: phrase grammatical case -> nothing
! To say those in ( case - grammatical case ):
[ PHR_775_r51  
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if the case is nominative]
    if (((t_0 == I119_nominative)))
    {! [3: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [4: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [5: say ~those~]
            say__p=1;! [6: ~those~]
            ParaContent(); print "those"; .L_Say592; .L_SayX582;} else {
            ! [7: if the item is the player]
            if (((tmp_0 == player)))
            {! [8: say ~[we]~]
                say__p=1;! [9: we]
                ParaContent(); (PHR_763_r39 ()); .L_Say593; .L_SayX583;} else {
                ! [10: if the item is a male person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [11: say ~he~]
                    say__p=1;! [12: ~he~]
                    ParaContent(); print "he"; .L_Say594; .L_SayX584;} else {
                    ! [13: if the item is a female person and item is not neuter]
                    if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                    {! [14: say ~she~]
                        say__p=1;! [15: ~she~]
                        ParaContent(); print "she"; .L_Say595; .L_SayX585;} else {
                        ! [16: say ~that~]
                        say__p=1;! [17: ~that~]
                        ParaContent(); print "that"; .L_Say596; .L_SayX586;}
                        }
                        }
                        }
                        } else {
        ! [18: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [19: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [20: say ~those~]
            say__p=1;! [21: ~those~]
            ParaContent(); print "those"; .L_Say597; .L_SayX587;} else {
            ! [22: if the item is the player]
            if (((tmp_0 == player)))
            {! [23: say ~[we]~]
                say__p=1;! [24: we]
                ParaContent(); (PHR_763_r39 ()); .L_Say598; .L_SayX588;} else {
                ! [25: if the item is a male person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [26: say ~him~]
                    say__p=1;! [27: ~him~]
                    ParaContent(); print "him"; .L_Say599; .L_SayX589;} else {
                    ! [28: if the item is a female person and item is not neuter]
                    if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                    {! [29: say ~her~]
                        say__p=1;! [30: ~her~]
                        ParaContent(); print "her"; .L_Say600; .L_SayX590;} else {
                        ! [31: say ~that~]
                        say__p=1;! [32: ~that~]
                        ParaContent(); print "that"; .L_Say601; .L_SayX591;}
                        }
                        }
                        }
                        }
                        rfalse;
];
! From "English Language" by Graham Nelson
! Request 52: phrase grammatical case -> nothing
! To say Those in ( case - grammatical case ):
[ PHR_776_r52  
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if the case is nominative]
    if (((t_0 == I119_nominative)))
    {! [3: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [4: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [5: say ~Those~]
            say__p=1;! [6: ~Those~]
            ParaContent(); print "Those"; .L_Say602; .L_SayX592;} else {
            ! [7: if the item is the player]
            if (((tmp_0 == player)))
            {! [8: say ~[We]~]
                say__p=1;! [9: we]
                ParaContent(); (PHR_768_r44 ()); .L_Say603; .L_SayX593;} else {
                ! [10: if the item is a male person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [11: say ~He~]
                    say__p=1;! [12: ~He~]
                    ParaContent(); print "He"; .L_Say604; .L_SayX594;} else {
                    ! [13: if the item is a female person and item is not neuter]
                    if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                    {! [14: say ~She~]
                        say__p=1;! [15: ~She~]
                        ParaContent(); print "She"; .L_Say605; .L_SayX595;} else {
                        ! [16: say ~That~]
                        say__p=1;! [17: ~That~]
                        ParaContent(); print "That"; .L_Say606; .L_SayX596;}
                        }
                        }
                        }
                        } else {
        ! [18: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [19: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [20: say ~Those~]
            say__p=1;! [21: ~Those~]
            ParaContent(); print "Those"; .L_Say607; .L_SayX597;} else {
            ! [22: if the item is the player]
            if (((tmp_0 == player)))
            {! [23: say ~[We]~]
                say__p=1;! [24: we]
                ParaContent(); (PHR_768_r44 ()); .L_Say608; .L_SayX598;} else {
                ! [25: if the item is a male person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [26: say ~Him~]
                    say__p=1;! [27: ~Him~]
                    ParaContent(); print "Him"; .L_Say609; .L_SayX599;} else {
                    ! [28: if the item is a female person and item is not neuter]
                    if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                    {! [29: say ~Her~]
                        say__p=1;! [30: ~Her~]
                        ParaContent(); print "Her"; .L_Say610; .L_SayX600;} else {
                        ! [31: say ~That~]
                        say__p=1;! [32: ~That~]
                        ParaContent(); print "That"; .L_Say611; .L_SayX601;}
                        }
                        }
                        }
                        }
                        rfalse;
];
! From "English Language" by Graham Nelson
! Request 53: phrase nothing -> nothing
! To say they:
[ PHR_777_r53  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~they~]
        say__p=1;! [5: ~they~]
        ParaContent(); print "they"; .L_Say612; .L_SayX602;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[we]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_763_r39 ()); .L_Say613; .L_SayX603;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~he~]
                say__p=1;! [11: ~he~]
                ParaContent(); print "he"; .L_Say614; .L_SayX604;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~she~]
                    say__p=1;! [14: ~she~]
                    ParaContent(); print "she"; .L_Say615; .L_SayX605;} else {
                    ! [15: say ~it~]
                    say__p=1;! [16: ~it~]
                    ParaContent(); print "it"; .L_Say616; .L_SayX606;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 54: phrase nothing -> nothing
! To say They:
[ PHR_778_r54  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~They~]
        say__p=1;! [5: ~They~]
        ParaContent(); print "They"; .L_Say617; .L_SayX607;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[We]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_768_r44 ()); .L_Say618; .L_SayX608;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~He~]
                say__p=1;! [11: ~He~]
                ParaContent(); print "He"; .L_Say619; .L_SayX609;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~She~]
                    say__p=1;! [14: ~She~]
                    ParaContent(); print "She"; .L_Say620; .L_SayX610;} else {
                    ! [15: say ~It~]
                    say__p=1;! [16: ~It~]
                    ParaContent(); print "It"; .L_Say621; .L_SayX611;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 55: phrase nothing -> nothing
! To say their:
[ PHR_779_r55  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~their~]
        say__p=1;! [5: ~their~]
        ParaContent(); print "their"; .L_Say622; .L_SayX612;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[our]~]
            say__p=1;! [8: our]
            ParaContent(); (PHR_767_r43 ()); .L_Say623; .L_SayX613;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~his~]
                say__p=1;! [11: ~his~]
                ParaContent(); print "his"; .L_Say624; .L_SayX614;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~her~]
                    say__p=1;! [14: ~her~]
                    ParaContent(); print "her"; .L_Say625; .L_SayX615;} else {
                    ! [15: say ~its~]
                    say__p=1;! [16: ~its~]
                    ParaContent(); print "its"; .L_Say626; .L_SayX616;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 56: phrase nothing -> nothing
! To say Their:
[ PHR_780_r56  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Their~]
        say__p=1;! [5: ~Their~]
        ParaContent(); print "Their"; .L_Say627; .L_SayX617;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Our]~]
            say__p=1;! [8: our]
            ParaContent(); (PHR_772_r48 ()); .L_Say628; .L_SayX618;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~His~]
                say__p=1;! [11: ~His~]
                ParaContent(); print "His"; .L_Say629; .L_SayX619;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~Her~]
                    say__p=1;! [14: ~Her~]
                    ParaContent(); print "Her"; .L_Say630; .L_SayX620;} else {
                    ! [15: say ~Its~]
                    say__p=1;! [16: ~Its~]
                    ParaContent(); print "Its"; .L_Say631; .L_SayX621;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 57: phrase nothing -> nothing
! To say them:
[ PHR_781_r57  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~them~]
        say__p=1;! [5: ~them~]
        ParaContent(); print "them"; .L_Say632; .L_SayX622;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[us]~]
            say__p=1;! [8: us]
            ParaContent(); (PHR_764_r40 ()); .L_Say633; .L_SayX623;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~him~]
                say__p=1;! [11: ~him~]
                ParaContent(); print "him"; .L_Say634; .L_SayX624;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~her~]
                    say__p=1;! [14: ~her~]
                    ParaContent(); print "her"; .L_Say635; .L_SayX625;} else {
                    ! [15: say ~it~]
                    say__p=1;! [16: ~it~]
                    ParaContent(); print "it"; .L_Say636; .L_SayX626;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 58: phrase nothing -> nothing
! To say Them:
[ PHR_782_r58  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Them~]
        say__p=1;! [5: ~Them~]
        ParaContent(); print "Them"; .L_Say637; .L_SayX627;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Us]~]
            say__p=1;! [8: us]
            ParaContent(); (PHR_769_r45 ()); .L_Say638; .L_SayX628;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~Him~]
                say__p=1;! [11: ~Him~]
                ParaContent(); print "Him"; .L_Say639; .L_SayX629;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~Her~]
                    say__p=1;! [14: ~Her~]
                    ParaContent(); print "Her"; .L_Say640; .L_SayX630;} else {
                    ! [15: say ~It~]
                    say__p=1;! [16: ~It~]
                    ParaContent(); print "It"; .L_Say641; .L_SayX631;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 59: phrase nothing -> nothing
! To say theirs:
[ PHR_783_r59  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~theirs~]
        say__p=1;! [5: ~theirs~]
        ParaContent(); print "theirs"; .L_Say642; .L_SayX632;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[ours]~]
            say__p=1;! [8: ours]
            ParaContent(); (PHR_765_r41 ()); .L_Say643; .L_SayX633;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~his~]
                say__p=1;! [11: ~his~]
                ParaContent(); print "his"; .L_Say644; .L_SayX634;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~hers~]
                    say__p=1;! [14: ~hers~]
                    ParaContent(); print "hers"; .L_Say645; .L_SayX635;} else {
                    ! [15: say ~its~]
                    say__p=1;! [16: ~its~]
                    ParaContent(); print "its"; .L_Say646; .L_SayX636;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 60: phrase nothing -> nothing
! To say Theirs:
[ PHR_784_r60  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Theirs~]
        say__p=1;! [5: ~Theirs~]
        ParaContent(); print "Theirs"; .L_Say647; .L_SayX637;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Ours]~]
            say__p=1;! [8: ours]
            ParaContent(); (PHR_770_r46 ()); .L_Say648; .L_SayX638;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~His~]
                say__p=1;! [11: ~His~]
                ParaContent(); print "His"; .L_Say649; .L_SayX639;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~Hers~]
                    say__p=1;! [14: ~Hers~]
                    ParaContent(); print "Hers"; .L_Say650; .L_SayX640;} else {
                    ! [15: say ~Its~]
                    say__p=1;! [16: ~Its~]
                    ParaContent(); print "Its"; .L_Say651; .L_SayX641;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 61: phrase nothing -> nothing
! To say themselves:
[ PHR_785_r61  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~themselves~]
        say__p=1;! [5: ~themselves~]
        ParaContent(); print "themselves"; .L_Say652; .L_SayX642;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[ourselves]~]
            say__p=1;! [8: ourselves]
            ParaContent(); (PHR_815_r89 ()); .L_Say653; .L_SayX643;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~himself~]
                say__p=1;! [11: ~himself~]
                ParaContent(); print "himself"; .L_Say654; .L_SayX644;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~herself~]
                    say__p=1;! [14: ~herself~]
                    ParaContent(); print "herself"; .L_Say655; .L_SayX645;} else {
                    ! [15: say ~itself~]
                    say__p=1;! [16: ~itself~]
                    ParaContent(); print "itself"; .L_Say656; .L_SayX646;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 62: phrase nothing -> nothing
! To say Themselves:
[ PHR_786_r62  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Themselves~]
        say__p=1;! [5: ~Themselves~]
        ParaContent(); print "Themselves"; .L_Say657; .L_SayX647;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Ourselves]~]
            say__p=1;! [8: ourselves]
            ParaContent(); (PHR_771_r47 ()); .L_Say658; .L_SayX648;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~Himself~]
                say__p=1;! [11: ~Himself~]
                ParaContent(); print "Himself"; .L_Say659; .L_SayX649;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~Herself~]
                    say__p=1;! [14: ~Herself~]
                    ParaContent(); print "Herself"; .L_Say660; .L_SayX650;} else {
                    ! [15: say ~Itself~]
                    say__p=1;! [16: ~Itself~]
                    ParaContent(); print "Itself"; .L_Say661; .L_SayX651;}
                    }
                    }
                    }
                    rfalse;
];
! From "English Language" by Graham Nelson
! Request 63: phrase nothing -> nothing
! To say they're:
[ PHR_787_r63  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~they~]
        say__p=1;! [5: ~they~]
        ParaContent(); print "they"; .L_Say662; .L_SayX652;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[we]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_763_r39 ()); .L_Say663; .L_SayX653;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~he~]
                say__p=1;! [11: ~he~]
                ParaContent(); print "he"; .L_Say664; .L_SayX654;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~she~]
                    say__p=1;! [14: ~she~]
                    ParaContent(); print "she"; .L_Say665; .L_SayX655;} else {
                    ! [15: say ~that~]
                    say__p=1;! [16: ~that~]
                    ParaContent(); print "that"; .L_Say666; .L_SayX656;}
                    }
                    }
                    }
    ! [17: say ~['re]~]
    say__p=1;! [18: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say667; .L_SayX657;rfalse;
];
! From "English Language" by Graham Nelson
! Request 64: phrase nothing -> nothing
! To say They're:
[ PHR_788_r64  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~They~]
        say__p=1;! [5: ~They~]
        ParaContent(); print "They"; .L_Say668; .L_SayX658;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[We]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_768_r44 ()); .L_Say669; .L_SayX659;} else {
            ! [9: if the item is a male person and item is not neuter]
            if ((((tmp_0 ofclass K8_person) && ((Adj_91_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
            {! [10: say ~He~]
                say__p=1;! [11: ~He~]
                ParaContent(); print "He"; .L_Say670; .L_SayX660;} else {
                ! [12: if the item is a female person and item is not neuter]
                if ((((tmp_0 ofclass K8_person) && ((Adj_90_t1_v10(tmp_0))))) && (((~~(((Adj_92_t1_v10(tmp_0))))))))
                {! [13: say ~She~]
                    say__p=1;! [14: ~She~]
                    ParaContent(); print "She"; .L_Say671; .L_SayX661;} else {
                    ! [15: say ~That~]
                    say__p=1;! [16: ~That~]
                    ParaContent(); print "That"; .L_Say672; .L_SayX662;}
                    }
                    }
                    }
    ! [17: say ~['re]~]
    say__p=1;! [18: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say673; .L_SayX663;rfalse;
];
! From "English Language" by Graham Nelson
! Request 65: phrase nothing -> nothing
! To say It:
[ PHR_789_r65  ;
    ! [2: say ~[regarding nothing]It~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~It~]
    ParaContent(); print "It"; .L_Say674; .L_SayX664;rfalse;
];
! From "English Language" by Graham Nelson
! Request 66: phrase nothing -> nothing
! To say There:
[ PHR_790_r66  ;
    ! [2: say ~[regarding nothing]There~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~There~]
    ParaContent(); print "There"; .L_Say675; .L_SayX665;rfalse;
];
! From "English Language" by Graham Nelson
! Request 67: phrase nothing -> nothing
! To say it:
[ PHR_791_r67  ;
    ! [2: say ~[regarding nothing]it~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~it~]
    ParaContent(); print "it"; .L_Say676; .L_SayX666;rfalse;
];
! From "English Language" by Graham Nelson
! Request 68: phrase nothing -> nothing
! To say there:
[ PHR_792_r68  ;
    ! [2: say ~[regarding nothing]there~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~there~]
    ParaContent(); print "there"; .L_Say677; .L_SayX667;rfalse;
];
! From "English Language" by Graham Nelson
! Request 69: phrase nothing -> nothing
! To say It's:
[ PHR_793_r69  ;
    ! [2: say ~[regarding nothing]It['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~It~]
    ParaContent(); print "It";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say678; .L_SayX668;rfalse;
];
! From "English Language" by Graham Nelson
! Request 70: phrase nothing -> nothing
! To say There's:
[ PHR_794_r70  ;
    ! [2: say ~[regarding nothing]There['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~There~]
    ParaContent(); print "There";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say679; .L_SayX669;rfalse;
];
! From "English Language" by Graham Nelson
! Request 71: phrase nothing -> nothing
! To say it's:
[ PHR_795_r71  ;
    ! [2: say ~[regarding nothing]it['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~it~]
    ParaContent(); print "it";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say680; .L_SayX670;rfalse;
];
! From "English Language" by Graham Nelson
! Request 72: phrase nothing -> nothing
! To say there's:
[ PHR_796_r72  ;
    ! [2: say ~[regarding nothing]there['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~there~]
    ParaContent(); print "there";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say681; .L_SayX671;rfalse;
];
! From "English Language" by Graham Nelson
! Request 73: phrase nothing -> nothing
! To say possessive:
[ PHR_797_r73  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[our]~]
        say__p=1;! [5: our]
        ParaContent(); (PHR_767_r43 ()); .L_Say682; .L_SayX672;} else {
        ! [6: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [7: say ~[the item][apostrophe]~]
            say__p=1;! [8: the item]
            ParaContent(); print (the) tmp_0;! [9: apostrophe]
            ParaContent(); print "'"; .L_Say683; .L_SayX673;} else {
            ! [10: say ~[the item][apostrophe]s~]
            say__p=1;! [11: the item]
            ParaContent(); print (the) tmp_0;! [12: apostrophe]
            ParaContent(); print "'";! [13: ~s~]
            ParaContent(); print "s"; .L_Say684; .L_SayX674;}
            }
            rfalse;
];
! From "English Language" by Graham Nelson
! Request 74: phrase nothing -> nothing
! To say Possessive:
[ PHR_798_r74  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[Our]~]
        say__p=1;! [5: our]
        ParaContent(); (PHR_772_r48 ()); .L_Say685; .L_SayX675;} else {
        ! [6: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [7: say ~[The item][apostrophe]~]
            say__p=1;! [8: the item]
            ParaContent(); print (The) tmp_0;! [9: apostrophe]
            ParaContent(); print "'"; .L_Say686; .L_SayX676;} else {
            ! [10: say ~[The item][apostrophe]s~]
            say__p=1;! [11: the item]
            ParaContent(); print (The) tmp_0;! [12: apostrophe]
            ParaContent(); print "'";! [13: ~s~]
            ParaContent(); print "s"; .L_Say687; .L_SayX677;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 75: phrase object -> nothing
! To say el ( O - object ):
[ PHR_801_r75  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: say ~[the O]~]
    say__p=1;! [3: the o]
    ParaContent(); print (the) t_0; .L_Say688; .L_SayX678;rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 76: phrase object -> nothing
! To say un ( O - object ):
[ PHR_802_r76  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: say ~[a O]~]
    say__p=1;! [3: a o]
    ParaContent(); print (a) t_0; .L_Say689; .L_SayX679;rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 77: phrase object -> nothing
! To say El ( O - object ):
[ PHR_803_r77  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: say ~[The O]~]
    say__p=1;! [3: the o]
    ParaContent(); print (The) t_0; .L_Say690; .L_SayX680;rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 78: phrase object -> nothing
! To say Un ( O - object ):
[ PHR_804_r78  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: say ~[A O]~]
    say__p=1;! [3: a o]
    ParaContent(); CIndefArt(t_0); .L_Say691; .L_SayX681;rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 79: phrase nothing -> nothing
! to say plm:
[ PHR_805_r79  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_18();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_18 ;
    ! [2: stop capturing text]
    EndCapture();
    ! [3: say ~[captured text]~ in sentence case]
    say__p=1;! [4: ~[captured text]~ in sentence case]
    ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, (TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_458)), 3); .L_Say692; .L_SayX682;rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 80: phrase nothing -> nothing
! To say tu:
[ PHR_806_r80  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [4: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [5: say ~ él~]
            say__p=1;! [6: ~ él~]
            ParaContent(); print " él"; .L_Say693; .L_SayX683;} else {
            ! [7: say ~ ella~]
            say__p=1;! [8: ~ ella~]
            ParaContent(); print " ella"; .L_Say694; .L_SayX684;}
            }
    ! [9: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~ ellos~]
            say__p=1;! [12: ~ ellos~]
            ParaContent(); print " ellos"; .L_Say695; .L_SayX685;} else {
            ! [13: say ~ ellas~]
            say__p=1;! [14: ~ ellas~]
            ParaContent(); print " ellas"; .L_Say696; .L_SayX686;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 81: phrase nothing -> nothing
! To say Tu:
[ PHR_807_r81  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: start capturing text]
        StartCapture();
        }
    ! [5: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [6: start capturing text]
        StartCapture();
        }
    ! [7: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [8: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [9: say ~Él~]
            say__p=1;! [10: ~Él~]
            ParaContent(); print "Él"; .L_Say697; .L_SayX687;} else {
            ! [11: say ~Ella~]
            say__p=1;! [12: ~Ella~]
            ParaContent(); print "Ella"; .L_Say698; .L_SayX688;}
            }
    ! [13: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [14: start capturing text]
        StartCapture();
        }
    ! [15: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [16: start capturing text]
        StartCapture();
        }
    ! [17: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [18: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [19: say ~Ellos~]
            say__p=1;! [20: ~Ellos~]
            ParaContent(); print "Ellos"; .L_Say699; .L_SayX689;} else {
            ! [21: say ~Ellas~]
            say__p=1;! [22: ~Ellas~]
            ParaContent(); print "Ellas"; .L_Say700; .L_SayX690;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 82: phrase nothing -> nothing
! To say él:
[ PHR_808_r82  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [4: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [5: say ~ él~]
            say__p=1;! [6: ~ él~]
            ParaContent(); print " él"; .L_Say701; .L_SayX691;} else {
            ! [7: say ~ ella~]
            say__p=1;! [8: ~ ella~]
            ParaContent(); print " ella"; .L_Say702; .L_SayX692;}
            }
    ! [9: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~ ellos~]
            say__p=1;! [12: ~ ellos~]
            ParaContent(); print " ellos"; .L_Say703; .L_SayX693;} else {
            ! [13: say ~ ellas~]
            say__p=1;! [14: ~ ellas~]
            ParaContent(); print " ellas"; .L_Say704; .L_SayX694;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 83: phrase nothing -> nothing
! To say Él:
[ PHR_809_r83  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: start capturing text]
        StartCapture();
        }
    ! [5: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [6: start capturing text]
        StartCapture();
        }
    ! [7: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [8: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [9: say ~Él~]
            say__p=1;! [10: ~Él~]
            ParaContent(); print "Él"; .L_Say705; .L_SayX695;} else {
            ! [11: say ~Ella~]
            say__p=1;! [12: ~Ella~]
            ParaContent(); print "Ella"; .L_Say706; .L_SayX696;}
            }
    ! [13: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [14: start capturing text]
        StartCapture();
        }
    ! [15: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [16: start capturing text]
        StartCapture();
        }
    ! [17: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [18: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [19: say ~Ellos~]
            say__p=1;! [20: ~Ellos~]
            ParaContent(); print "Ellos"; .L_Say707; .L_SayX697;} else {
            ! [21: say ~Ellas~]
            say__p=1;! [22: ~Ellas~]
            ParaContent(); print "Ellas"; .L_Say708; .L_SayX698;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 84: phrase nothing -> nothing
! To say sí:
[ PHR_810_r84  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: say ~mí~]
        say__p=1;! [5: ~mí~]
        ParaContent(); print "mí"; .L_Say709; .L_SayX699;}
    ! [6: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [7: say ~ti~]
        say__p=1;! [8: ~ti~]
        ParaContent(); print "ti"; .L_Say710; .L_SayX700;}
    ! [9: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [10: say ~sí~]
        say__p=1;! [11: ~sí~]
        ParaContent(); print "sí"; .L_Say711; .L_SayX701;}
    ! [12: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [13: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [14: say ~nosotros~]
            say__p=1;! [15: ~nosotros~]
            ParaContent(); print "nosotros"; .L_Say712; .L_SayX702;} else {
            ! [16: say ~nosotras~]
            say__p=1;! [17: ~nosotras~]
            ParaContent(); print "nosotras"; .L_Say713; .L_SayX703;}
            }
    ! [18: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [19: say ~vosotros~]
        say__p=1;! [20: ~vosotros~]
        ParaContent(); print "vosotros"; .L_Say714; .L_SayX704;}
    ! [21: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [22: say ~sí~]
        say__p=1;! [23: ~sí~]
        ParaContent(); print "sí"; .L_Say715; .L_SayX705;}
        rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 85: phrase nothing -> nothing
! To say su:
[ PHR_811_r85  ;
    ! [2: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [3: say ~su~]
        say__p=1;! [4: ~su~]
        ParaContent(); print "su"; .L_Say716; .L_SayX706;} else {
        ! [5: if the story viewpoint is third person plural]
        if (((story_viewpoint == I117_third_person_plural)))
        {! [6: say ~su~]
            say__p=1;! [7: ~su~]
            ParaContent(); print "su"; .L_Say717; .L_SayX707;} else {
            ! [8: if the story viewpoint is second person singular]
            if (((story_viewpoint == I113_second_person_singular)))
            {! [9: say ~tu~]
                say__p=1;! [10: ~tu~]
                ParaContent(); print "tu"; .L_Say718; .L_SayX708;} else {
                ! [11: if the story viewpoint is second person plural]
                if (((story_viewpoint == I116_second_person_plural)))
                {! [12: say ~vuestro~]
                    say__p=1;! [13: ~vuestro~]
                    ParaContent(); print "vuestro"; .L_Say719; .L_SayX709;} else {
                    ! [14: if the story viewpoint is first person singular]
                    if (((story_viewpoint == I112_first_person_singular)))
                    {! [15: say ~mi~]
                        say__p=1;! [16: ~mi~]
                        ParaContent(); print "mi"; .L_Say720; .L_SayX710;} else {
                        ! [17: if the story viewpoint is first person plural]
                        if (((story_viewpoint == I115_first_person_plural)))
                        {! [18: if prior named object is male]
                            if ((((Adj_91_t1_v10(prior_named_noun)))))
                            {! [19: say ~nuestro~]
                                say__p=1;! [20: ~nuestro~]
                                ParaContent(); print "nuestro"; .L_Say721; .L_SayX711;} else {
                                ! [21: say ~nuestra~]
                                say__p=1;! [22: ~nuestra~]
                                ParaContent(); print "nuestra"; .L_Say722; .L_SayX712;}
                                }
                                }
                                }
                                }
                                }
                                }
                                rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 86: phrase nothing -> nothing
! To say tuyo:
[ PHR_812_r86  ;
    ! [2: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [3: if the prior named object is male]
        if ((((Adj_91_t1_v10(prior_named_noun)))))
        {! [4: say ~suyo~]
            say__p=1;! [5: ~suyo~]
            ParaContent(); print "suyo"; .L_Say723; .L_SayX713;} else {
            ! [6: say ~suya~]
            say__p=1;! [7: ~suya~]
            ParaContent(); print "suya"; .L_Say724; .L_SayX714;}
            } else {
        ! [8: if the story viewpoint is third person plural]
        if (((story_viewpoint == I117_third_person_plural)))
        {! [9: if the prior named object is male]
            if ((((Adj_91_t1_v10(prior_named_noun)))))
            {! [10: say ~suyos~]
                say__p=1;! [11: ~suyos~]
                ParaContent(); print "suyos"; .L_Say725; .L_SayX715;} else {
                ! [12: say ~suyas~]
                say__p=1;! [13: ~suyas~]
                ParaContent(); print "suyas"; .L_Say726; .L_SayX716;}
                } else {
            ! [14: if the story viewpoint is second person singular]
            if (((story_viewpoint == I113_second_person_singular)))
            {! [15: if the prior named object is male]
                if ((((Adj_91_t1_v10(prior_named_noun)))))
                {! [16: say ~tuyo~]
                    say__p=1;! [17: ~tuyo~]
                    ParaContent(); print "tuyo"; .L_Say727; .L_SayX717;} else {
                    ! [18: say ~tuya~]
                    say__p=1;! [19: ~tuya~]
                    ParaContent(); print "tuya"; .L_Say728; .L_SayX718;}
                    } else {
                ! [20: if the story viewpoint is second person plural]
                if (((story_viewpoint == I116_second_person_plural)))
                {! [21: if the prior named object is male]
                    if ((((Adj_91_t1_v10(prior_named_noun)))))
                    {! [22: say ~vuestro~]
                        say__p=1;! [23: ~vuestro~]
                        ParaContent(); print "vuestro"; .L_Say729; .L_SayX719;} else {
                        ! [24: say ~tuyas~]
                        say__p=1;! [25: ~tuyas~]
                        ParaContent(); print "tuyas"; .L_Say730; .L_SayX720;}
                        } else {
                    ! [26: if the story viewpoint is first person singular]
                    if (((story_viewpoint == I112_first_person_singular)))
                    {! [27: if the prior named object is male]
                        if ((((Adj_91_t1_v10(prior_named_noun)))))
                        {! [28: say ~mío~]
                            say__p=1;! [29: ~mío~]
                            ParaContent(); print "mío"; .L_Say731; .L_SayX721;} else {
                            ! [30: say ~mía~]
                            say__p=1;! [31: ~mía~]
                            ParaContent(); print "mía"; .L_Say732; .L_SayX722;}
                            } else {
                        ! [32: if the story viewpoint is first person plural]
                        if (((story_viewpoint == I115_first_person_plural)))
                        {! [33: if the prior named object is male]
                            if ((((Adj_91_t1_v10(prior_named_noun)))))
                            {! [34: say ~míos~]
                                say__p=1;! [35: ~míos~]
                                ParaContent(); print "míos"; .L_Say733; .L_SayX723;} else {
                                ! [36: say ~mías~]
                                say__p=1;! [37: ~mías~]
                                ParaContent(); print "mías"; .L_Say734; .L_SayX724;}
                                }
                                }
                                }
                                }
                                }
                                }
                                rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 87: phrase nothing -> nothing
! To say se:
[ PHR_813_r87  ;
    ! [2: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [3: say ~se~]
        say__p=1;! [4: ~se~]
        ParaContent(); print "se"; .L_Say735; .L_SayX725;} else {
        ! [5: if the story viewpoint is third person plural]
        if (((story_viewpoint == I117_third_person_plural)))
        {! [6: say ~se~]
            say__p=1;! [7: ~se~]
            ParaContent(); print "se"; .L_Say736; .L_SayX726;} else {
            ! [8: if the story viewpoint is second person singular]
            if (((story_viewpoint == I113_second_person_singular)))
            {! [9: say ~te~]
                say__p=1;! [10: ~te~]
                ParaContent(); print "te"; .L_Say737; .L_SayX727;} else {
                ! [11: if the story viewpoint is second person plural]
                if (((story_viewpoint == I116_second_person_plural)))
                {! [12: say ~se~]
                    say__p=1;! [13: ~se~]
                    ParaContent(); print "se"; .L_Say738; .L_SayX728;} else {
                    ! [14: if the story viewpoint is first person singular]
                    if (((story_viewpoint == I112_first_person_singular)))
                    {! [15: say ~me~]
                        say__p=1;! [16: ~me~]
                        ParaContent(); print "me"; .L_Say739; .L_SayX729;} else {
                        ! [17: if the story viewpoint is first person plural]
                        if (((story_viewpoint == I115_first_person_plural)))
                        {! [18: say ~nos~]
                            say__p=1;! [19: ~nos~]
                            ParaContent(); print "nos"; .L_Say740; .L_SayX730;}
                            }
                            }
                            }
                            }
                            }
                            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 88: phrase nothing -> nothing
! To say te:
[ PHR_814_r88  ;
    ! [2: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [3: say ~le~]
        say__p=1;! [4: ~le~]
        ParaContent(); print "le"; .L_Say741; .L_SayX731;} else {
        ! [5: if the story viewpoint is third person plural]
        if (((story_viewpoint == I117_third_person_plural)))
        {! [6: say ~les~]
            say__p=1;! [7: ~les~]
            ParaContent(); print "les"; .L_Say742; .L_SayX732;} else {
            ! [8: if the story viewpoint is second person singular]
            if (((story_viewpoint == I113_second_person_singular)))
            {! [9: say ~te~]
                say__p=1;! [10: ~te~]
                ParaContent(); print "te"; .L_Say743; .L_SayX733;} else {
                ! [11: if the story viewpoint is second person plural]
                if (((story_viewpoint == I116_second_person_plural)))
                {! [12: say ~se~]
                    say__p=1;! [13: ~se~]
                    ParaContent(); print "se"; .L_Say744; .L_SayX734;} else {
                    ! [14: if the story viewpoint is first person singular]
                    if (((story_viewpoint == I112_first_person_singular)))
                    {! [15: say ~me~]
                        say__p=1;! [16: ~me~]
                        ParaContent(); print "me"; .L_Say745; .L_SayX735;} else {
                        ! [17: if the story viewpoint is first person plural]
                        if (((story_viewpoint == I115_first_person_plural)))
                        {! [18: say ~nos~]
                            say__p=1;! [19: ~nos~]
                            ParaContent(); print "nos"; .L_Say746; .L_SayX736;}
                            }
                            }
                            }
                            }
                            }
                            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 89: phrase nothing -> nothing
! To say ourselves:
[ PHR_815_r89  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is first person singular]
    if (((story_viewpoint == I112_first_person_singular)))
    {! [4: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [5: say ~mi mismo~]
            say__p=1;! [6: ~mi mismo~]
            ParaContent(); print "mi mismo"; .L_Say747; .L_SayX737;} else {
            ! [7: say ~mi misma~]
            say__p=1;! [8: ~mi misma~]
            ParaContent(); print "mi misma"; .L_Say748; .L_SayX738;}
            }
    ! [9: if the story viewpoint is second person singular]
    if (((story_viewpoint == I113_second_person_singular)))
    {! [10: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [11: say ~ti mismo~]
            say__p=1;! [12: ~ti mismo~]
            ParaContent(); print "ti mismo"; .L_Say749; .L_SayX739;} else {
            ! [13: say ~ti misma~]
            say__p=1;! [14: ~ti misma~]
            ParaContent(); print "ti misma"; .L_Say750; .L_SayX740;}
            }
    ! [15: if the story viewpoint is third person singular]
    if (((story_viewpoint == I114_third_person_singular)))
    {! [16: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [17: say ~si mismo~]
            say__p=1;! [18: ~si mismo~]
            ParaContent(); print "si mismo"; .L_Say751; .L_SayX741;} else {
            ! [19: say ~si misma~]
            say__p=1;! [20: ~si misma~]
            ParaContent(); print "si misma"; .L_Say752; .L_SayX742;}
            }
    ! [21: if the story viewpoint is first person plural]
    if (((story_viewpoint == I115_first_person_plural)))
    {! [22: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [23: say ~nosotros mismos~]
            say__p=1;! [24: ~nosotros mismos~]
            ParaContent(); print "nosotros mismos"; .L_Say753; .L_SayX743;} else {
            ! [25: say ~nosotras mismas~]
            say__p=1;! [26: ~nosotras mismas~]
            ParaContent(); print "nosotras mismas"; .L_Say754; .L_SayX744;}
            }
    ! [27: if the story viewpoint is second person plural]
    if (((story_viewpoint == I116_second_person_plural)))
    {! [28: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [29: say ~ustedes mismos~]
            say__p=1;! [30: ~ustedes mismos~]
            ParaContent(); print "ustedes mismos"; .L_Say755; .L_SayX745;} else {
            ! [31: say ~ustedes mismas~]
            say__p=1;! [32: ~ustedes mismas~]
            ParaContent(); print "ustedes mismas"; .L_Say756; .L_SayX746;}
            }
    ! [33: if the story viewpoint is third person plural]
    if (((story_viewpoint == I117_third_person_plural)))
    {! [34: if the player is male]
        if ((((Adj_91_t1_v10(player)))))
        {! [35: say ~ellos mismos~]
            say__p=1;! [36: ~ellos mismos~]
            ParaContent(); print "ellos mismos"; .L_Say757; .L_SayX747;} else {
            ! [37: say ~ellas mismas~]
            say__p=1;! [38: ~ellas mismas~]
            ParaContent(); print "ellas mismas"; .L_Say758; .L_SayX748;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 90: phrase nothing -> nothing
! To say eso:
[ PHR_816_r90  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[tu]~]
        say__p=1;! [5: tu]
        ParaContent(); (PHR_806_r80 ()); .L_Say759; .L_SayX749;} else {
        ! [6: if the item is plural-named]
        if ((((Adj_53_t1_v10(tmp_0)))))
        {! [7: if the item is male]
            if ((((Adj_91_t1_v10(tmp_0)))))
            {! [8: say ~esos~]
                say__p=1;! [9: ~esos~]
                ParaContent(); print "esos"; .L_Say760; .L_SayX750;} else {
                ! [10: say ~esas~]
                say__p=1;! [11: ~esas~]
                ParaContent(); print "esas"; .L_Say761; .L_SayX751;}
                } else {
            ! [12: if the item is male]
            if ((((Adj_91_t1_v10(tmp_0)))))
            {! [13: say ~eso~]
                say__p=1;! [14: ~eso~]
                ParaContent(); print "eso"; .L_Say762; .L_SayX752;} else {
                ! [15: say ~esa~]
                say__p=1;! [16: ~esa~]
                ParaContent(); print "esa"; .L_Say763; .L_SayX753;}
                }
                }
                rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 91: phrase nothing -> nothing
! To say Eso:
[ PHR_817_r91  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[Tu]~]
        say__p=1;! [5: tu]
        ParaContent(); (PHR_807_r81 ()); .L_Say764; .L_SayX754;} else {
        ! [6: if the item is plural-named]
        if ((((Adj_53_t1_v10(tmp_0)))))
        {! [7: if the item is male]
            if ((((Adj_91_t1_v10(tmp_0)))))
            {! [8: say ~Esos~]
                say__p=1;! [9: ~Esos~]
                ParaContent(); print "Esos"; .L_Say765; .L_SayX755;} else {
                ! [10: say ~Esas~]
                say__p=1;! [11: ~Esas~]
                ParaContent(); print "Esas"; .L_Say766; .L_SayX756;}
                } else {
            ! [12: if the item is male]
            if ((((Adj_91_t1_v10(tmp_0)))))
            {! [13: say ~Eso~]
                say__p=1;! [14: ~Eso~]
                ParaContent(); print "Eso"; .L_Say767; .L_SayX757;} else {
                ! [15: say ~Esa~]
                say__p=1;! [16: ~Esa~]
                ParaContent(); print "Esa"; .L_Say768; .L_SayX758;}
                }
                }
                rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 92: phrase nothing -> nothing
! To say o:
[ PHR_818_r92  ;
    ! [2: say ~[regarding the noun]~]
    say__p=1;! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun); .L_Say769; .L_SayX759;! [4: if prior named object is plural-named or the player is plural-named]
    if (((((Adj_53_t1_v10(prior_named_noun))))) || ((((Adj_53_t1_v10(player))))))
    {! [5: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [6: say ~as~]
            say__p=1;! [7: ~as~]
            ParaContent(); print "as"; .L_Say770; .L_SayX760;} else {
            ! [8: say ~os~]
            say__p=1;! [9: ~os~]
            ParaContent(); print "os"; .L_Say771; .L_SayX761;}
            } else {
        ! [10: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [11: say ~a~]
            say__p=1;! [12: ~a~]
            ParaContent(); print "a"; .L_Say772; .L_SayX762;} else {
            ! [13: say ~o~]
            say__p=1;! [14: ~o~]
            ParaContent(); print "o"; .L_Say773; .L_SayX763;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 93: phrase nothing -> nothing
! To say o_jugador:
[ PHR_819_r93  ;
    ! [2: say ~[regarding the player]~]
    say__p=1;! [3: regarding the player]
    ParaContent(); RegardingSingleObject(player); .L_Say774; .L_SayX764;! [4: if prior named object is plural-named or the player is plural-named]
    if (((((Adj_53_t1_v10(prior_named_noun))))) || ((((Adj_53_t1_v10(player))))))
    {! [5: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [6: say ~as~]
            say__p=1;! [7: ~as~]
            ParaContent(); print "as"; .L_Say775; .L_SayX765;} else {
            ! [8: say ~os~]
            say__p=1;! [9: ~os~]
            ParaContent(); print "os"; .L_Say776; .L_SayX766;}
            } else {
        ! [10: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [11: say ~a~]
            say__p=1;! [12: ~a~]
            ParaContent(); print "a"; .L_Say777; .L_SayX767;} else {
            ! [13: say ~o~]
            say__p=1;! [14: ~o~]
            ParaContent(); print "o"; .L_Say778; .L_SayX768;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 94: phrase nothing -> nothing
! To say lo:
[ PHR_820_r94  ;
    ! [2: say ~[regarding the noun]~]
    say__p=1;! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun); .L_Say779; .L_SayX769;! [4: if prior named object is plural-named or the player is plural-named]
    if (((((Adj_53_t1_v10(prior_named_noun))))) || ((((Adj_53_t1_v10(player))))))
    {! [5: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [6: say ~las~]
            say__p=1;! [7: ~las~]
            ParaContent(); print "las"; .L_Say780; .L_SayX770;} else {
            ! [8: say ~los~]
            say__p=1;! [9: ~los~]
            ParaContent(); print "los"; .L_Say781; .L_SayX771;}
            } else {
        ! [10: if prior named object is female]
        if ((((Adj_90_t1_v10(prior_named_noun)))))
        {! [11: say ~la~]
            say__p=1;! [12: ~la~]
            ParaContent(); print "la"; .L_Say782; .L_SayX772;} else {
            ! [13: say ~lo~]
            say__p=1;! [14: ~lo~]
            ParaContent(); print "lo"; .L_Say783; .L_SayX773;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 95: phrase nothing -> nothing
! To say n:
[ PHR_821_r95  ;
    ! [2: say ~[regarding the noun]~]
    say__p=1;! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun); .L_Say784; .L_SayX774;! [4: if prior named object is the player]
    if (((prior_named_noun == player)))
    {! [5: if the story viewpoint is first person singular or the story viewpoint is third person singular]
        if ((((story_viewpoint == I112_first_person_singular))) || (((story_viewpoint == I114_third_person_singular))))
        {! [6: say nothing]
            say__p=1;! [7: nothing]
            ParaContent(); PrintShortName(nothing); .L_Say785; .L_SayX775;}
        ! [8: if the story viewpoint is second person singular]
        if (((story_viewpoint == I113_second_person_singular)))
        {! [9: say ~s~]
            say__p=1;! [10: ~s~]
            ParaContent(); print "s"; .L_Say786; .L_SayX776;}
        ! [11: if the story viewpoint is first person plural]
        if (((story_viewpoint == I115_first_person_plural)))
        {! [12: say ~mos~]
            say__p=1;! [13: ~mos~]
            ParaContent(); print "mos"; .L_Say787; .L_SayX777;}
        ! [14: if the story viewpoint is second person plural or the story viewpoint is third person plural]
        if ((((story_viewpoint == I116_second_person_plural))) || (((story_viewpoint == I117_third_person_plural))))
        {! [15: say ~n~]
            say__p=1;! [16: ~n~]
            ParaContent(); print "n"; .L_Say788; .L_SayX778;}
            } else {
        ! [17: if prior named object is plural-named]
        if ((((Adj_53_t1_v10(prior_named_noun)))))
        {! [18: say ~n~]
            say__p=1;! [19: ~n~]
            ParaContent(); print "n"; .L_Say789; .L_SayX779;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 96: phrase nothing -> nothing
! To say s:
[ PHR_822_r96  ;
    ! [2: say ~[regarding the noun]~]
    say__p=1;! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun); .L_Say790; .L_SayX780;! [4: if prior named object is the player]
    if (((prior_named_noun == player)))
    {! [5: if the story viewpoint is first person singular or the story viewpoint is third person singular]
        if ((((story_viewpoint == I112_first_person_singular))) || (((story_viewpoint == I114_third_person_singular))))
        {! [6: say nothing]
            say__p=1;! [7: nothing]
            ParaContent(); PrintShortName(nothing); .L_Say791; .L_SayX781;}
        ! [8: if the story viewpoint is second person singular]
        if (((story_viewpoint == I113_second_person_singular)))
        {! [9: say ~s~]
            say__p=1;! [10: ~s~]
            ParaContent(); print "s"; .L_Say792; .L_SayX782;}
        ! [11: if the story viewpoint is first person plural]
        if (((story_viewpoint == I115_first_person_plural)))
        {! [12: say ~mos~]
            say__p=1;! [13: ~mos~]
            ParaContent(); print "mos"; .L_Say793; .L_SayX783;}
        ! [14: if the story viewpoint is second person plural or the story viewpoint is third person plural]
        if ((((story_viewpoint == I116_second_person_plural))) || (((story_viewpoint == I117_third_person_plural))))
        {! [15: say ~n~]
            say__p=1;! [16: ~n~]
            ParaContent(); print "n"; .L_Say794; .L_SayX784;}
            } else {
        ! [17: if prior named object is plural-named]
        if ((((Adj_53_t1_v10(prior_named_noun)))))
        {! [18: say ~s~]
            say__p=1;! [19: ~s~]
            ParaContent(); print "s"; .L_Say795; .L_SayX785;}
            }
            rfalse;
];
! From "Spanish Language" by Sebastian Arg
! Request 97: phrase nothing -> nothing
! To say es-ves:
[ PHR_827_r97  ;
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: say ~[regarding list writer internals]eres~]
        say__p=1;! [4: regarding list writer internals]
        ParaContent(); RegardingLWI();! [5: ~eres~]
        ParaContent(); print "eres"; .L_Say796; .L_SayX786;} else {
        ! [6: say ~ves~]
        say__p=1;! [7: ~ves~]
        ParaContent(); print "ves"; .L_Say797; .L_SayX787;}
        rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 98: phrase nothing -> nothing
! To limpiar la/-- pantalla:
[ PHR_892_r98  ;
    ! [2: clear the screen]
    VM_ClearScreen(0);
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 99: phrase nothing -> nothing
! To limpiar solo la/-- pantalla principal:
[ PHR_893_r99  ;
    ! [2: clear only the main screen]
    VM_ClearScreen(2);
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 100: phrase nothing -> nothing
! To limpiar solo la/-- linea de estado:
[ PHR_894_r100  ;
    ! [2: clear only the status line]
    VM_ClearScreen(1);
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 101: phrase nothing -> nothing
! To esperar pulsacion de tecla:
[ PHR_895_r101  ;
    ! [2: wait for any key]
    KeyPause();
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 102: phrase nothing -> nothing
! To esperar pulsacion de ESPACIO:
[ PHR_896_r102  ;
    ! [2: wait for the space key]
    SPACEPause();
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 103: phrase nothing -> nothing
! To pausar el/-- juego:
[ PHR_897_r103  ;
    ! [2: pause the game]
    (PHR_879_r27 ());
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 104: phrase text -> nothing
! To centrar ( quote - text ):
[ PHR_898_r104  
    t_0 ! Call parameter 'quote': text
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_19(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_19 
    t_0 ! Call parameter 'quote': text
    ;
    ! [2: center quote]
    CenterPrintComplex(BlkValueCopy(I7SFRAME, t_0));
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 105: phrase (text, number) -> nothing
! To centrar ( quote - text ) en columna ( depth - a number ):
[ PHR_899_r105  
    t_0 ! Call parameter 'quote': text
    t_1 ! Call parameter 'depth': number
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_20(t_0, t_1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_20 
    t_0 ! Call parameter 'quote': text
    t_1 ! Call parameter 'depth': number
    ;
    ! [2: center quote at the row depth]
    CenterPrint(BlkValueCopy(I7SFRAME, t_0), t_1);
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 106: phrase nothing -> nothing
! To salir abruptamente:
[ PHR_900_r106  ;
    ! [2: stop the game abruptly]
    quit;
    rfalse;
];
! From "Basic Screen Effects Sp" by Emily Short
! Request 107: phrase nothing -> nothing
! To mostrar el/-- mensaje actual:
[ PHR_901_r107  ;
    ! [2: show the current quotation]
    ClearBoxedText();
    rfalse;
];
! From "Menus" by Emily Short
! Request 108: phrase table name -> nothing
! To say known hints from ( hint booklet - table name ):
[ PHR_911_r108  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __index be 0]

    		tmp_0 = 0;
    ! [3: clear only the main screen]
    VM_ClearScreen(2);
    ! [4: repeat through hint booklet]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [6: if there is a used entry]
        if (((ExistsTableLookUpEntry(ct_0,129,ct_1))))
        {! [7: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
            say__p=1;! [8: __index]
            ParaContent(); print (say__n=tmp_0);! [9: ~/~]
            ParaContent(); print "/";! [10: number of rows in hint booklet]
            ParaContent(); print (say__n=TableRows(t_0));! [11: ~: ~]
            ParaContent(); print ": ";! [12: hint entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [13: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say798; .L_SayX788;} else {
            ! [14: if __index is 1]
            if (((tmp_0 == 1)))
            {! [15: now used entry is turn count]
                TableLookUpEntry(ct_0,129,ct_1,1,turns);
                ! [16: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
                say__p=1;! [17: __index]
                ParaContent(); print (say__n=tmp_0);! [18: ~/~]
                ParaContent(); print "/";! [19: number of rows in hint booklet]
                ParaContent(); print (say__n=TableRows(t_0));! [20: ~: ~]
                ParaContent(); print ": ";! [21: hint entry]
                ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [22: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say799; .L_SayX789;}
                }
                }
                @pull ct_1; @pull ct_0;! [23: say ~Press SPACE to return to the menu or H to reveal another hint.~]
    say__p=1;! [24: ~Press SPACE to return to the menu or H to reveal another hint.~]
    ParaContent(); print "Press SPACE to return to the menu or H to reveal another hint."; new_line; .L_Say800; .L_SayX790;rfalse;
];
! From "Menus" by Emily Short
! Request 109: phrase table name -> nothing
! To say hints from ( hint booklet - table name ):
[ PHR_912_r109  
    t_0 ! Call parameter 'hint booklet': table name
    tmp_0 ! Let/loop value, e.g., '__index': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __index be 0]

    		tmp_0 = 0;
    ! [3: clear only the main screen]
    VM_ClearScreen(2);
    ! [4: repeat through hint booklet]
    @push ct_0; @push ct_1;
    		for (tmp_1=t_0, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: increase __index by 1]
        tmp_0 = tmp_0 + 1;;
        ! [6: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
        say__p=1;! [7: __index]
        ParaContent(); print (say__n=tmp_0);! [8: ~/~]
        ParaContent(); print "/";! [9: number of rows in hint booklet]
        ParaContent(); print (say__n=TableRows(t_0));! [10: ~: ~]
        ParaContent(); print ": ";! [11: hint entry]
        ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,128,ct_1);! [12: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say801; .L_SayX791;! [13: if there is a used entry]
        if (((ExistsTableLookUpEntry(ct_0,129,ct_1))))
        {! [14: do nothing]
            ;
            } else {
            ! [15: now used entry is turn count]
            TableLookUpEntry(ct_0,129,ct_1,1,turns);
            ! [16: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
            say__p=1;! [17: ~Press SPACE to return to the menu~]
            ParaContent(); print "Press SPACE to return to the menu";! [18: if __index < number of rows in hint booklet]
            ParaContent(); 
            	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say802;! [19: ~ or H to reveal another hint~]
            ParaContent(); print " or H to reveal another hint";! [20: end if]

            	.L_Say802; .L_SayX792;! [21: ~.~]
            ParaContent(); print "."; new_line; .L_Say803; .L_SayX793;! [22: make no decision]
            rfalse;
            }
            }
            @pull ct_1; @pull ct_0;! [23: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
    say__p=1;! [24: ~Press SPACE to return to the menu~]
    ParaContent(); print "Press SPACE to return to the menu";! [25: if __index < number of rows in hint booklet]
    ParaContent(); 
    	if (~~((((tmp_0 < TableRows(t_0)))))) jump L_Say804;! [26: ~ or H to reveal another hint~]
    ParaContent(); print " or H to reveal another hint";! [27: end if]

    	.L_Say804; .L_SayX794;! [28: ~.~]
    ParaContent(); print "."; new_line; .L_Say805; .L_SayX795;rfalse;
];
! From "Reactable Quips SP" by Michael Martin
! Request 110: phrase quip -> nothing
! To nest the ( q - quip ) quip:
[ PHR_925_r110  
    t_0 ! Call parameter 'q': quip
    tmp_0 ! Let/loop value, e.g., 'x': quip
    ;
    ! [2: let x be the current quip]

    		tmp_0 = (Global_Vars-->17);
    ! [3: now the current quip is q]
    (Global_Vars-->17) = t_0;
    ! [4: carry out the quipping activity]
    CarryOutActivity(V36_quipping);
    ! [5: now the current quip is x]
    (Global_Vars-->17) = tmp_0;
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 111: phrase (quip, thing) -> nothing
! To enable the ( q - a quip ) quip for ( o - a thing ):
[ PHR_951_r111  
    t_0 ! Call parameter 'q': quip
    t_1 ! Call parameter 'o': thing
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the litany of o]
    @push ct_0; @push ct_1;
    		for (tmp_0=GProperty(10, t_1,p18_litany), tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the response entry is q]
        if (((TableLookUpEntry(ct_0,136,ct_1) == t_0)))
        {! [4: now the enabled entry is 1]
            TableLookUpEntry(ct_0,137,ct_1,1,1);
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 112: phrase (quip, thing) -> nothing
! To disable the ( q - a quip ) quip for ( o - a thing ):
[ PHR_952_r112  
    t_0 ! Call parameter 'q': quip
    t_1 ! Call parameter 'o': thing
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the litany of o]
    @push ct_0; @push ct_1;
    		for (tmp_0=GProperty(10, t_1,p18_litany), tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the response entry is q]
        if (((TableLookUpEntry(ct_0,136,ct_1) == t_0)))
        {! [4: now the enabled entry is 0]
            TableLookUpEntry(ct_0,137,ct_1,1,0);
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 113: phrase table name -> nothing
! To shift the conversation to ( t - a table-name ):
[ PHR_955_r113  
    t_0 ! Call parameter 't': table name
    ;
    ! [2: now the qbc_litany is t]
    (Global_Vars-->25) = t_0;
    rfalse;
];
! From "Quip-Based Conversation Sp" by Michael Martin
! Request 114: phrase table name -> nothing
! To run a conversation on ( t - a table-name ):
[ PHR_956_r114  
    t_0 ! Call parameter 't': table name
    ;
    ! [2: shift the conversation to t]
    (PHR_955_r113 (t_0));
    ! [3: display the qbc options]
    (PHR_947_r7 ());
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! Request 115: phrase nothing -> g-event
! To decide which g-event is the current glk event ( deprecated ):
[ PHR_1001_r115  ;
    ! [2: decide on gep internal current glk event]
    return GE_Event_Struct_type;
    return I170_timer_event;
];
! From "Glulx Entry Points" by Emily Short
! Request 116: phrase nothing -> number
! To decide what number is input replacement ( deprecated ):
[ PHR_1004_r116  ;
    ! [2: decide on gep internal input replacement]
    return 2;
    return 0;
];
! From "Glulx Entry Points" by Emily Short
! Request 117: phrase nothing -> number
! To decide what number is input continuation ( deprecated ):
[ PHR_1005_r117  ;
    ! [2: decide on gep internal input continuation]
    return 1;
    return 0;
];
! From "Glulx Entry Points" by Emily Short
! Request 118: phrase nothing -> number
! To decide what number is the value returned by glk event handling ( this is the handle glk event rule ):
[ PHR_1009_r118  ;
    ! [2: now glulx replacement command is ~~]
    BlkValueCopy((Global_Vars-->29), EMPTY_TEXT_VALUE);
    ! [3: follow the glulx input handling rules for the gep internal current glk event]
    FollowRulebook(405, GE_Event_Struct_type, true);
    ! [4: if the outcome of the rulebook is the replace player input outcome]
    if ((((ResultOfRule()) == RBNO_13)))
    {! [5: decide on gep internal input replacement]
        return 2;
        }
    ! [6: if the outcome of the rulebook is the require input to continue outcome]
    if ((((ResultOfRule()) == RBNO_14)))
    {! [7: decide on gep internal input continuation]
        return 1;
        }
    ! [8: follow the command-counting rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(414));
    ! [9: if the rule succeeded]
    if (((RulebookSucceeded())))
    {! [10: follow the input-cancelling rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(415));
        ! [11: follow the command-showing rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(416));
        ! [12: follow the command-pasting rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(417));
        ! [13: if the rule succeeded]
        if (((RulebookSucceeded())))
        {! [14: decide on gep internal input replacement]
            return 2;
            }
            }
            return 0;
];
! From "Flexible Windows" by Jon Ingold
! Request 119: phrase number -> g-window
! To decide which g-window is the window with ref ( ref - a number ):
[ PHR_1038_r119  
    t_0 ! Call parameter 'ref': number
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if ref is not 0]
    if (((~~((t_0 == 0)))))
    {! [3: repeat with win running through g-windows]
        for (tmp_0=Prop_45(0), tmp_1=Prop_45(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_45(tmp_1))
        {! [4: if the ref number of win is ref]
            if (((GProperty(10, tmp_0,p25_ref_number) == t_0)))
            {! [5: decide on win]
                return tmp_0;
                }
                }
                }
    ! [6: decide on the invalid window]
    return ( nothing );
    return I197_all_windows;
];
! From "Flexible Windows" by Jon Ingold
! Request 120: phrase text -> nothing
! To set the Gargoyle background color to the color ( T - a text ) ( deprecated ):
[ PHR_1104_r120  
    t_0 ! Call parameter 'T': text
    ;
    ! [2: set the background color of wintype 3 for normal-style to t]
    GTE_SetStylehint( 3, I127_normal_style, stylehint_BackColor, GTE_ConvertColour( t_0 ) );
    rfalse;
];
Array TX_R_0 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_0_R;
[ TX_R_0_R ;
    ResponseViaActivity(R_359_RESP_A);
];
[ ADJUST_LIGHT_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_0;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_1 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_1_R;
[ TX_R_1_R ;
    ResponseViaActivity(R_361_RESP_A);
];
[ GENERATE_ACTION_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_1;
        'B': str = TX_R_2;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_2 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_2_R;
[ TX_R_2_R ;
    ResponseViaActivity(R_361_RESP_B);
];
Array TX_R_3 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_3_R;
[ TX_R_3_R ;
    ResponseViaActivity(R_368_RESP_A);
];
[ BASIC_ACCESSIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_3;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_4 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_4_R;
[ TX_R_4_R ;
    ResponseViaActivity(R_369_RESP_A);
];
[ BASIC_VISIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_4;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_5 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_5_R;
[ TX_R_5_R ;
    ResponseViaActivity(R_371_RESP_A);
];
[ REQUESTED_ACTIONS_REQUIRE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_5;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_6 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_6_R;
[ TX_R_6_R ;
    ResponseViaActivity(R_372_RESP_A);
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_6;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_7 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_7_R;
[ TX_R_7_R ;
    ResponseViaActivity(R_375_RESP_A);
];
[ ACCESS_THROUGH_BARRIERS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_7;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_8 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_8_R;
[ TX_R_8_R ;
    ResponseViaActivity(R_376_RESP_A);
];
[ CANT_REACH_INSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_8;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_9 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_9_R;
[ TX_R_9_R ;
    ResponseViaActivity(R_377_RESP_A);
];
[ CANT_REACH_INSIDE_ROOMS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_9;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_10 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_10_R;
[ TX_R_10_R ;
    ResponseViaActivity(R_378_RESP_A);
];
[ CANT_REACH_OUTSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_10;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_11 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_11_R;
[ TX_R_11_R ;
    ResponseViaActivity(R_379_RESP_A);
];
[ LIST_WRITER_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_11;
        'B': str = TX_R_12;
        'C': str = TX_R_13;
        'D': str = TX_R_14;
        'E': str = TX_R_15;
        'F': str = TX_R_16;
        'G': str = TX_R_17;
        'H': str = TX_R_18;
        'I': str = TX_R_19;
        'J': str = TX_R_20;
        'K': str = TX_R_21;
        'L': str = TX_R_22;
        'M': str = TX_R_23;
        'N': str = TX_R_24;
        'O': str = TX_R_25;
        'P': str = TX_R_26;
        'Q': str = TX_R_27;
        'R': str = TX_R_28;
        'S': str = TX_R_29;
        'T': str = TX_R_30;
        'U': str = TX_R_31;
        'V': str = TX_R_32;
        'W': str = TX_R_33;
        'X': str = TX_R_34;
        'Y': str = TX_R_35;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_12 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_12_R;
[ TX_R_12_R ;
    ResponseViaActivity(R_379_RESP_B);
];
Array TX_R_13 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_13_R;
[ TX_R_13_R ;
    ResponseViaActivity(R_379_RESP_C);
];
Array TX_R_14 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_14_R;
[ TX_R_14_R ;
    ResponseViaActivity(R_379_RESP_D);
];
Array TX_R_15 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_15_R;
[ TX_R_15_R ;
    ResponseViaActivity(R_379_RESP_E);
];
Array TX_R_16 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_16_R;
[ TX_R_16_R ;
    ResponseViaActivity(R_379_RESP_F);
];
Array TX_R_17 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_17_R;
[ TX_R_17_R ;
    ResponseViaActivity(R_379_RESP_G);
];
Array TX_R_18 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_18_R;
[ TX_R_18_R ;
    ResponseViaActivity(R_379_RESP_H);
];
Array TX_R_19 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_19_R;
[ TX_R_19_R ;
    ResponseViaActivity(R_379_RESP_I);
];
Array TX_R_20 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_20_R;
[ TX_R_20_R ;
    ResponseViaActivity(R_379_RESP_J);
];
Array TX_R_21 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_21_R;
[ TX_R_21_R ;
    ResponseViaActivity(R_379_RESP_K);
];
Array TX_R_22 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_22_R;
[ TX_R_22_R ;
    ResponseViaActivity(R_379_RESP_L);
];
Array TX_R_23 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_23_R;
[ TX_R_23_R ;
    ResponseViaActivity(R_379_RESP_M);
];
Array TX_R_24 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_24_R;
[ TX_R_24_R ;
    ResponseViaActivity(R_379_RESP_N);
];
Array TX_R_25 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_25_R;
[ TX_R_25_R ;
    ResponseViaActivity(R_379_RESP_O);
];
Array TX_R_26 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_26_R;
[ TX_R_26_R ;
    ResponseViaActivity(R_379_RESP_P);
];
Array TX_R_27 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_27_R;
[ TX_R_27_R ;
    ResponseViaActivity(R_379_RESP_Q);
];
Array TX_R_28 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_28_R;
[ TX_R_28_R ;
    ResponseViaActivity(R_379_RESP_R);
];
Array TX_R_29 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_29_R;
[ TX_R_29_R ;
    ResponseViaActivity(R_379_RESP_S);
];
Array TX_R_30 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_30_R;
[ TX_R_30_R ;
    ResponseViaActivity(R_379_RESP_T);
];
Array TX_R_31 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_31_R;
[ TX_R_31_R ;
    ResponseViaActivity(R_379_RESP_U);
];
Array TX_R_32 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_32_R;
[ TX_R_32_R ;
    ResponseViaActivity(R_379_RESP_V);
];
Array TX_R_33 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_33_R;
[ TX_R_33_R ;
    ResponseViaActivity(R_379_RESP_W);
];
Array TX_R_34 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_34_R;
[ TX_R_34_R ;
    ResponseViaActivity(R_379_RESP_X);
];
Array TX_R_35 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_35_R;
[ TX_R_35_R ;
    ResponseViaActivity(R_379_RESP_Y);
];
Array TX_R_36 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_36_R;
[ TX_R_36_R ;
    ResponseViaActivity(R_380_RESP_A);
];
[ ACTION_PROCESSING_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_36;
        'B': str = TX_R_37;
        'C': str = TX_R_38;
        'D': str = TX_R_39;
        'E': str = TX_R_40;
        'F': str = TX_R_41;
        'G': str = TX_R_42;
        'H': str = TX_R_43;
        'I': str = TX_R_44;
        'J': str = TX_R_45;
        'K': str = TX_R_46;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_37 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_37_R;
[ TX_R_37_R ;
    ResponseViaActivity(R_380_RESP_B);
];
Array TX_R_38 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_38_R;
[ TX_R_38_R ;
    ResponseViaActivity(R_380_RESP_C);
];
Array TX_R_39 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_39_R;
[ TX_R_39_R ;
    ResponseViaActivity(R_380_RESP_D);
];
Array TX_R_40 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_40_R;
[ TX_R_40_R ;
    ResponseViaActivity(R_380_RESP_E);
];
Array TX_R_41 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_41_R;
[ TX_R_41_R ;
    ResponseViaActivity(R_380_RESP_F);
];
Array TX_R_42 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_42_R;
[ TX_R_42_R ;
    ResponseViaActivity(R_380_RESP_G);
];
Array TX_R_43 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_43_R;
[ TX_R_43_R ;
    ResponseViaActivity(R_380_RESP_H);
];
Array TX_R_44 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_44_R;
[ TX_R_44_R ;
    ResponseViaActivity(R_380_RESP_I);
];
Array TX_R_45 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_45_R;
[ TX_R_45_R ;
    ResponseViaActivity(R_380_RESP_J);
];
Array TX_R_46 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_46_R;
[ TX_R_46_R ;
    ResponseViaActivity(R_380_RESP_K);
];
Array TX_R_47 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_47_R;
[ TX_R_47_R ;
    ResponseViaActivity(R_381_RESP_A);
];
[ PARSER_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_47;
        'B': str = TX_R_48;
        'C': str = TX_R_49;
        'D': str = TX_R_50;
        'E': str = TX_R_51;
        'F': str = TX_R_52;
        'G': str = TX_R_53;
        'H': str = TX_R_54;
        'I': str = TX_R_55;
        'J': str = TX_R_56;
        'K': str = TX_R_57;
        'L': str = TX_R_58;
        'M': str = TX_R_59;
        'N': str = TX_R_60;
        'O': str = TX_R_61;
        'P': str = TX_R_62;
        'Q': str = TX_R_63;
        'R': str = TX_R_64;
        'S': str = TX_R_65;
        'T': str = TX_R_66;
        'U': str = TX_R_67;
        'V': str = TX_R_68;
        'W': str = TX_R_69;
        'X': str = TX_R_70;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_48 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_48_R;
[ TX_R_48_R ;
    ResponseViaActivity(R_381_RESP_B);
];
Array TX_R_49 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_49_R;
[ TX_R_49_R ;
    ResponseViaActivity(R_381_RESP_C);
];
Array TX_R_50 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_50_R;
[ TX_R_50_R ;
    ResponseViaActivity(R_381_RESP_D);
];
Array TX_R_51 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_51_R;
[ TX_R_51_R ;
    ResponseViaActivity(R_381_RESP_E);
];
Array TX_R_52 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_52_R;
[ TX_R_52_R ;
    ResponseViaActivity(R_381_RESP_F);
];
Array TX_R_53 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_53_R;
[ TX_R_53_R ;
    ResponseViaActivity(R_381_RESP_G);
];
Array TX_R_54 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_54_R;
[ TX_R_54_R ;
    ResponseViaActivity(R_381_RESP_H);
];
Array TX_R_55 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_55_R;
[ TX_R_55_R ;
    ResponseViaActivity(R_381_RESP_I);
];
Array TX_R_56 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_56_R;
[ TX_R_56_R ;
    ResponseViaActivity(R_381_RESP_J);
];
Array TX_R_57 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_57_R;
[ TX_R_57_R ;
    ResponseViaActivity(R_381_RESP_K);
];
Array TX_R_58 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_58_R;
[ TX_R_58_R ;
    ResponseViaActivity(R_381_RESP_L);
];
Array TX_R_59 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_59_R;
[ TX_R_59_R ;
    ResponseViaActivity(R_381_RESP_M);
];
Array TX_R_60 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_60_R;
[ TX_R_60_R ;
    ResponseViaActivity(R_381_RESP_N);
];
Array TX_R_61 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_61_R;
[ TX_R_61_R ;
    ResponseViaActivity(R_381_RESP_O);
];
Array TX_R_62 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_62_R;
[ TX_R_62_R ;
    ResponseViaActivity(R_381_RESP_P);
];
Array TX_R_63 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_63_R;
[ TX_R_63_R ;
    ResponseViaActivity(R_381_RESP_Q);
];
Array TX_R_64 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_64_R;
[ TX_R_64_R ;
    ResponseViaActivity(R_381_RESP_R);
];
Array TX_R_65 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_65_R;
[ TX_R_65_R ;
    ResponseViaActivity(R_381_RESP_S);
];
Array TX_R_66 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_66_R;
[ TX_R_66_R ;
    ResponseViaActivity(R_381_RESP_T);
];
Array TX_R_67 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_67_R;
[ TX_R_67_R ;
    ResponseViaActivity(R_381_RESP_U);
];
Array TX_R_68 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_68_R;
[ TX_R_68_R ;
    ResponseViaActivity(R_381_RESP_V);
];
Array TX_R_69 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_69_R;
[ TX_R_69_R ;
    ResponseViaActivity(R_381_RESP_W);
];
Array TX_R_70 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_70_R;
[ TX_R_70_R ;
    ResponseViaActivity(R_381_RESP_X);
];
Array TX_R_71 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_71_R;
[ TX_R_71_R ;
    ResponseViaActivity(R_382_RESP_A);
];
[ PARSER_N_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_71;
        'B': str = TX_R_72;
        'C': str = TX_R_73;
        'D': str = TX_R_74;
        'E': str = TX_R_75;
        'F': str = TX_R_76;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_72 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_72_R;
[ TX_R_72_R ;
    ResponseViaActivity(R_382_RESP_B);
];
Array TX_R_73 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_73_R;
[ TX_R_73_R ;
    ResponseViaActivity(R_382_RESP_C);
];
Array TX_R_74 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_74_R;
[ TX_R_74_R ;
    ResponseViaActivity(R_382_RESP_D);
];
Array TX_R_75 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_75_R;
[ TX_R_75_R ;
    ResponseViaActivity(R_382_RESP_E);
];
Array TX_R_76 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_76_R;
[ TX_R_76_R ;
    ResponseViaActivity(R_382_RESP_F);
];
Array TX_R_77 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_77_R;
[ TX_R_77_R ;
    ResponseViaActivity(R_383_RESP_A);
];
[ DARKNESS_NAME_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_77;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_78 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_78_R;
[ TX_R_78_R ;
    ResponseViaActivity(R_384_RESP_A);
];
[ PARSER_COMMAND_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_78;
        'B': str = TX_R_79;
        'C': str = TX_R_80;
        'D': str = TX_R_81;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_79 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_79_R;
[ TX_R_79_R ;
    ResponseViaActivity(R_384_RESP_B);
];
Array TX_R_80 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_80_R;
[ TX_R_80_R ;
    ResponseViaActivity(R_384_RESP_C);
];
Array TX_R_81 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_81_R;
[ TX_R_81_R ;
    ResponseViaActivity(R_384_RESP_D);
];
Array TX_R_82 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_82_R;
[ TX_R_82_R ;
    ResponseViaActivity(R_385_RESP_A);
];
[ PARSER_CLARIF_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_82;
        'B': str = TX_R_83;
        'C': str = TX_R_84;
        'D': str = TX_R_85;
        'E': str = TX_R_86;
        'F': str = TX_R_87;
        'G': str = TX_R_88;
        'H': str = TX_R_89;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_83 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_83_R;
[ TX_R_83_R ;
    ResponseViaActivity(R_385_RESP_B);
];
Array TX_R_84 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_84_R;
[ TX_R_84_R ;
    ResponseViaActivity(R_385_RESP_C);
];
Array TX_R_85 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_85_R;
[ TX_R_85_R ;
    ResponseViaActivity(R_385_RESP_D);
];
Array TX_R_86 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_86_R;
[ TX_R_86_R ;
    ResponseViaActivity(R_385_RESP_E);
];
Array TX_R_87 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_87_R;
[ TX_R_87_R ;
    ResponseViaActivity(R_385_RESP_F);
];
Array TX_R_88 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_88_R;
[ TX_R_88_R ;
    ResponseViaActivity(R_385_RESP_G);
];
Array TX_R_89 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_89_R;
[ TX_R_89_R ;
    ResponseViaActivity(R_385_RESP_H);
];
Array TX_R_90 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_90_R;
[ TX_R_90_R ;
    ResponseViaActivity(R_386_RESP_A);
];
[ YES_OR_NO_QUESTION_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_90;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_91 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_91_R;
[ TX_R_91_R ;
    ResponseViaActivity(R_387_RESP_A);
];
[ PRINT_PROTAGONIST_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_91;
        'B': str = TX_R_92;
        'C': str = TX_R_93;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_92 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_92_R;
[ TX_R_92_R ;
    ResponseViaActivity(R_387_RESP_B);
];
Array TX_R_93 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_93_R;
[ TX_R_93_R ;
    ResponseViaActivity(R_387_RESP_C);
];
Array TX_R_94 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_94_R;
[ TX_R_94_R ;
    ResponseViaActivity(R_390_RESP_A);
];
[ STANDARD_IMPLICIT_TAKING_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_94;
        'B': str = TX_R_95;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_95 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_95_R;
[ TX_R_95_R ;
    ResponseViaActivity(R_390_RESP_B);
];
Array TX_R_96 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_96_R;
[ TX_R_96_R ;
    ResponseViaActivity(R_392_RESP_A);
];
[ PRINT_OBITUARY_HEADLINE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_96;
        'B': str = TX_R_97;
        'C': str = TX_R_98;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_97 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_97_R;
[ TX_R_97_R ;
    ResponseViaActivity(R_392_RESP_B);
];
Array TX_R_98 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_98_R;
[ TX_R_98_R ;
    ResponseViaActivity(R_392_RESP_C);
];
Array TX_R_99 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_99_R;
[ TX_R_99_R ;
    ResponseViaActivity(R_398_RESP_A);
];
[ IMMEDIATELY_UNDO_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_99;
        'B': str = TX_R_100;
        'C': str = TX_R_101;
        'D': str = TX_R_102;
        'E': str = TX_R_103;
        'F': str = TX_R_104;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_100 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_100_R;
[ TX_R_100_R ;
    ResponseViaActivity(R_398_RESP_B);
];
Array TX_R_101 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_101_R;
[ TX_R_101_R ;
    ResponseViaActivity(R_398_RESP_C);
];
Array TX_R_102 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_102_R;
[ TX_R_102_R ;
    ResponseViaActivity(R_398_RESP_D);
];
Array TX_R_103 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_103_R;
[ TX_R_103_R ;
    ResponseViaActivity(R_398_RESP_E);
];
Array TX_R_104 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_104_R;
[ TX_R_104_R ;
    ResponseViaActivity(R_398_RESP_F);
];
Array TX_R_105 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_105_R;
[ TX_R_105_R ;
    ResponseViaActivity(R_401_RESP_A);
];
[ QUIT_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_105;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_106 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_106_R;
[ TX_R_106_R ;
    ResponseViaActivity(R_402_RESP_A);
];
[ SAVE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_106;
        'B': str = TX_R_107;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_107 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_107_R;
[ TX_R_107_R ;
    ResponseViaActivity(R_402_RESP_B);
];
Array TX_R_108 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_108_R;
[ TX_R_108_R ;
    ResponseViaActivity(R_403_RESP_A);
];
[ RESTORE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_108;
        'B': str = TX_R_109;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_109 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_109_R;
[ TX_R_109_R ;
    ResponseViaActivity(R_403_RESP_B);
];
Array TX_R_110 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_110_R;
[ TX_R_110_R ;
    ResponseViaActivity(R_404_RESP_A);
];
[ RESTART_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_110;
        'B': str = TX_R_111;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_111 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_111_R;
[ TX_R_111_R ;
    ResponseViaActivity(R_404_RESP_B);
];
Array TX_R_112 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_112_R;
[ TX_R_112_R ;
    ResponseViaActivity(R_405_RESP_A);
];
[ VERIFY_THE_STORY_FILE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_112;
        'B': str = TX_R_113;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_113 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_113_R;
[ TX_R_113_R ;
    ResponseViaActivity(R_405_RESP_B);
];
Array TX_R_114 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_114_R;
[ TX_R_114_R ;
    ResponseViaActivity(R_406_RESP_A);
];
[ SWITCH_TRANSCRIPT_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_114;
        'B': str = TX_R_115;
        'C': str = TX_R_116;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_115 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_115_R;
[ TX_R_115_R ;
    ResponseViaActivity(R_406_RESP_B);
];
Array TX_R_116 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_116_R;
[ TX_R_116_R ;
    ResponseViaActivity(R_406_RESP_C);
];
Array TX_R_117 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_117_R;
[ TX_R_117_R ;
    ResponseViaActivity(R_407_RESP_A);
];
[ SWITCH_TRANSCRIPT_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_117;
        'B': str = TX_R_118;
        'C': str = TX_R_119;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_118 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_118_R;
[ TX_R_118_R ;
    ResponseViaActivity(R_407_RESP_B);
];
Array TX_R_119 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_119_R;
[ TX_R_119_R ;
    ResponseViaActivity(R_407_RESP_C);
];
Array TX_R_120 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_120_R;
[ TX_R_120_R ;
    ResponseViaActivity(R_409_RESP_A);
];
[ ANNOUNCE_SCORE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_120;
        'B': str = TX_R_121;
        'C': str = TX_R_122;
        'D': str = TX_R_123;
        'E': str = TX_R_124;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_121 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_121_R;
[ TX_R_121_R ;
    ResponseViaActivity(R_409_RESP_B);
];
Array TX_R_122 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_122_R;
[ TX_R_122_R ;
    ResponseViaActivity(R_409_RESP_C);
];
Array TX_R_123 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_123_R;
[ TX_R_123_R ;
    ResponseViaActivity(R_409_RESP_D);
];
Array TX_R_124 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_124_R;
[ TX_R_124_R ;
    ResponseViaActivity(R_409_RESP_E);
];
Array TX_R_125 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_125_R;
[ TX_R_125_R ;
    ResponseViaActivity(R_411_RESP_A);
];
[ REP_PREFER_ABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_125;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_126 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_126_R;
[ TX_R_126_R ;
    ResponseViaActivity(R_413_RESP_A);
];
[ REP_PREFER_UNABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_126;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_127 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_127_R;
[ TX_R_127_R ;
    ResponseViaActivity(R_415_RESP_A);
];
[ REP_PREFER_SOMETIMES_ABBR_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_127;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_128 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_128_R;
[ TX_R_128_R ;
    ResponseViaActivity(R_417_RESP_A);
];
[ REP_SWITCH_NOTIFY_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_128;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_129 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_129_R;
[ TX_R_129_R ;
    ResponseViaActivity(R_419_RESP_A);
];
[ REP_SWITCH_NOTIFY_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_129;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_130 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_130_R;
[ TX_R_130_R ;
    ResponseViaActivity(R_420_RESP_A);
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_130;
        'B': str = TX_R_131;
        'C': str = TX_R_132;
        'D': str = TX_R_133;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_131 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_131_R;
[ TX_R_131_R ;
    ResponseViaActivity(R_420_RESP_B);
];
Array TX_R_132 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_132_R;
[ TX_R_132_R ;
    ResponseViaActivity(R_420_RESP_C);
];
Array TX_R_133 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_133_R;
[ TX_R_133_R ;
    ResponseViaActivity(R_420_RESP_D);
];
Array TX_R_134 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_134_R;
[ TX_R_134_R ;
    ResponseViaActivity(R_11_RESP_A);
];
Array TX_R_135 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_135_R;
[ TX_R_135_R ;
    ResponseViaActivity(R_39_RESP_A);
];
Array TX_R_136 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_136_R;
[ TX_R_136_R ;
    ResponseViaActivity(R_41_RESP_A);
];
Array TX_R_137 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_137_R;
[ TX_R_137_R ;
    ResponseViaActivity(R_41_RESP_B);
];
Array TX_R_138 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_138_R;
[ TX_R_138_R ;
    ResponseViaActivity(R_40_RESP_A);
];
Array TX_R_139 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_139_R;
[ TX_R_139_R ;
    ResponseViaActivity(R_42_RESP_A);
];
Array TX_R_140 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_140_R;
[ TX_R_140_R ;
    ResponseViaActivity(R_46_RESP_A);
];
Array TX_R_141 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_141_R;
[ TX_R_141_R ;
    ResponseViaActivity(R_46_RESP_B);
];
Array TX_R_142 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_142_R;
[ TX_R_142_R ;
    ResponseViaActivity(R_46_RESP_C);
];
Array TX_R_143 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_143_R;
[ TX_R_143_R ;
    ResponseViaActivity(R_46_RESP_D);
];
Array TX_R_144 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_144_R;
[ TX_R_144_R ;
    ResponseViaActivity(R_46_RESP_E);
];
Array TX_R_145 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_145_R;
[ TX_R_145_R ;
    ResponseViaActivity(R_46_RESP_F);
];
Array TX_R_146 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_146_R;
[ TX_R_146_R ;
    ResponseViaActivity(R_53_RESP_A);
];
Array TX_R_147 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_147_R;
[ TX_R_147_R ;
    ResponseViaActivity(R_55_RESP_A);
];
Array TX_R_148 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_148_R;
[ TX_R_148_R ;
    ResponseViaActivity(R_56_RESP_A);
];
Array TX_R_149 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_149_R;
[ TX_R_149_R ;
    ResponseViaActivity(R_57_RESP_A);
];
Array TX_R_150 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_150_R;
[ TX_R_150_R ;
    ResponseViaActivity(R_58_RESP_A);
];
Array TX_R_151 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_151_R;
[ TX_R_151_R ;
    ResponseViaActivity(R_59_RESP_A);
];
Array TX_R_152 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_152_R;
[ TX_R_152_R ;
    ResponseViaActivity(R_60_RESP_A);
];
Array TX_R_153 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_153_R;
[ TX_R_153_R ;
    ResponseViaActivity(R_61_RESP_A);
];
Array TX_R_154 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_154_R;
[ TX_R_154_R ;
    ResponseViaActivity(R_62_RESP_A);
];
Array TX_R_155 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_155_R;
[ TX_R_155_R ;
    ResponseViaActivity(R_63_RESP_A);
];
Array TX_R_156 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_156_R;
[ TX_R_156_R ;
    ResponseViaActivity(R_64_RESP_A);
];
Array TX_R_157 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_157_R;
[ TX_R_157_R ;
    ResponseViaActivity(R_65_RESP_A);
];
Array TX_R_158 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_158_R;
[ TX_R_158_R ;
    ResponseViaActivity(R_66_RESP_A);
];
Array TX_R_159 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_159_R;
[ TX_R_159_R ;
    ResponseViaActivity(R_67_RESP_A);
];
Array TX_R_160 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_160_R;
[ TX_R_160_R ;
    ResponseViaActivity(R_68_RESP_A);
];
Array TX_R_161 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_161_R;
[ TX_R_161_R ;
    ResponseViaActivity(R_69_RESP_A);
];
Array TX_R_162 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_162_R;
[ TX_R_162_R ;
    ResponseViaActivity(R_70_RESP_A);
];
Array TX_R_163 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_163_R;
[ TX_R_163_R ;
    ResponseViaActivity(R_71_RESP_A);
];
Array TX_R_164 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_164_R;
[ TX_R_164_R ;
    ResponseViaActivity(R_73_RESP_A);
];
Array TX_R_165 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_165_R;
[ TX_R_165_R ;
    ResponseViaActivity(R_73_RESP_B);
];
Array TX_R_166 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_166_R;
[ TX_R_166_R ;
    ResponseViaActivity(R_74_RESP_A);
];
Array TX_R_167 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_167_R;
[ TX_R_167_R ;
    ResponseViaActivity(R_75_RESP_A);
];
Array TX_R_168 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_168_R;
[ TX_R_168_R ;
    ResponseViaActivity(R_78_RESP_A);
];
Array TX_R_169 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_169_R;
[ TX_R_169_R ;
    ResponseViaActivity(R_77_RESP_A);
];
Array TX_R_170 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_170_R;
[ TX_R_170_R ;
    ResponseViaActivity(R_79_RESP_A);
];
Array TX_R_171 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_171_R;
[ TX_R_171_R ;
    ResponseViaActivity(R_80_RESP_A);
];
Array TX_R_172 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_172_R;
[ TX_R_172_R ;
    ResponseViaActivity(R_81_RESP_A);
];
Array TX_R_173 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_173_R;
[ TX_R_173_R ;
    ResponseViaActivity(R_82_RESP_A);
];
Array TX_R_174 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_174_R;
[ TX_R_174_R ;
    ResponseViaActivity(R_82_RESP_B);
];
Array TX_R_175 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_175_R;
[ TX_R_175_R ;
    ResponseViaActivity(R_84_RESP_A);
];
Array TX_R_176 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_176_R;
[ TX_R_176_R ;
    ResponseViaActivity(R_84_RESP_B);
];
Array TX_R_177 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_177_R;
[ TX_R_177_R ;
    ResponseViaActivity(R_87_RESP_A);
];
Array TX_R_178 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_178_R;
[ TX_R_178_R ;
    ResponseViaActivity(R_88_RESP_A);
];
Array TX_R_179 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_179_R;
[ TX_R_179_R ;
    ResponseViaActivity(R_89_RESP_A);
];
Array TX_R_180 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_180_R;
[ TX_R_180_R ;
    ResponseViaActivity(R_90_RESP_A);
];
Array TX_R_181 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_181_R;
[ TX_R_181_R ;
    ResponseViaActivity(R_92_RESP_A);
];
Array TX_R_182 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_182_R;
[ TX_R_182_R ;
    ResponseViaActivity(R_93_RESP_A);
];
Array TX_R_183 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_183_R;
[ TX_R_183_R ;
    ResponseViaActivity(R_96_RESP_A);
];
Array TX_R_184 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_184_R;
[ TX_R_184_R ;
    ResponseViaActivity(R_97_RESP_A);
];
Array TX_R_185 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_185_R;
[ TX_R_185_R ;
    ResponseViaActivity(R_98_RESP_A);
];
Array TX_R_186 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_186_R;
[ TX_R_186_R ;
    ResponseViaActivity(R_99_RESP_A);
];
Array TX_R_187 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_187_R;
[ TX_R_187_R ;
    ResponseViaActivity(R_100_RESP_A);
];
Array TX_R_188 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_188_R;
[ TX_R_188_R ;
    ResponseViaActivity(R_102_RESP_A);
];
Array TX_R_189 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_189_R;
[ TX_R_189_R ;
    ResponseViaActivity(R_103_RESP_A);
];
Array TX_R_190 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_190_R;
[ TX_R_190_R ;
    ResponseViaActivity(R_104_RESP_A);
];
Array TX_R_191 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_191_R;
[ TX_R_191_R ;
    ResponseViaActivity(R_105_RESP_A);
];
Array TX_R_192 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_192_R;
[ TX_R_192_R ;
    ResponseViaActivity(R_106_RESP_A);
];
Array TX_R_193 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_193_R;
[ TX_R_193_R ;
    ResponseViaActivity(R_109_RESP_A);
];
Array TX_R_194 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_194_R;
[ TX_R_194_R ;
    ResponseViaActivity(R_109_RESP_B);
];
Array TX_R_195 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_195_R;
[ TX_R_195_R ;
    ResponseViaActivity(R_111_RESP_A);
];
Array TX_R_196 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_196_R;
[ TX_R_196_R ;
    ResponseViaActivity(R_112_RESP_A);
];
Array TX_R_197 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_197_R;
[ TX_R_197_R ;
    ResponseViaActivity(R_112_RESP_B);
];
Array TX_R_198 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_198_R;
[ TX_R_198_R ;
    ResponseViaActivity(R_113_RESP_A);
];
Array TX_R_199 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_199_R;
[ TX_R_199_R ;
    ResponseViaActivity(R_114_RESP_A);
];
Array TX_R_200 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_200_R;
[ TX_R_200_R ;
    ResponseViaActivity(R_116_RESP_A);
];
Array TX_R_201 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_201_R;
[ TX_R_201_R ;
    ResponseViaActivity(R_116_RESP_B);
];
Array TX_R_202 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_202_R;
[ TX_R_202_R ;
    ResponseViaActivity(R_120_RESP_A);
];
Array TX_R_203 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_203_R;
[ TX_R_203_R ;
    ResponseViaActivity(R_120_RESP_B);
];
Array TX_R_204 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_204_R;
[ TX_R_204_R ;
    ResponseViaActivity(R_120_RESP_C);
];
Array TX_R_205 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_205_R;
[ TX_R_205_R ;
    ResponseViaActivity(R_120_RESP_D);
];
Array TX_R_206 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_206_R;
[ TX_R_206_R ;
    ResponseViaActivity(R_120_RESP_E);
];
Array TX_R_207 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_207_R;
[ TX_R_207_R ;
    ResponseViaActivity(R_120_RESP_F);
];
Array TX_R_208 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_208_R;
[ TX_R_208_R ;
    ResponseViaActivity(R_120_RESP_G);
];
Array TX_R_209 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_209_R;
[ TX_R_209_R ;
    ResponseViaActivity(R_120_RESP_H);
];
Array TX_R_210 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_210_R;
[ TX_R_210_R ;
    ResponseViaActivity(R_120_RESP_I);
];
Array TX_R_211 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_211_R;
[ TX_R_211_R ;
    ResponseViaActivity(R_120_RESP_J);
];
Array TX_R_212 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_212_R;
[ TX_R_212_R ;
    ResponseViaActivity(R_120_RESP_K);
];
Array TX_R_213 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_213_R;
[ TX_R_213_R ;
    ResponseViaActivity(R_120_RESP_L);
];
Array TX_R_214 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_214_R;
[ TX_R_214_R ;
    ResponseViaActivity(R_120_RESP_M);
];
Array TX_R_215 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_215_R;
[ TX_R_215_R ;
    ResponseViaActivity(R_120_RESP_N);
];
Array TX_R_216 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_216_R;
[ TX_R_216_R ;
    ResponseViaActivity(R_120_RESP_O);
];
Array TX_R_217 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_217_R;
[ TX_R_217_R ;
    ResponseViaActivity(R_120_RESP_P);
];
Array TX_R_218 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_218_R;
[ TX_R_218_R ;
    ResponseViaActivity(R_120_RESP_Q);
];
Array TX_R_219 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_219_R;
[ TX_R_219_R ;
    ResponseViaActivity(R_120_RESP_R);
];
Array TX_R_220 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_220_R;
[ TX_R_220_R ;
    ResponseViaActivity(R_120_RESP_S);
];
Array TX_R_221 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_221_R;
[ TX_R_221_R ;
    ResponseViaActivity(R_124_RESP_A);
];
Array TX_R_222 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_222_R;
[ TX_R_222_R ;
    ResponseViaActivity(R_124_RESP_B);
];
Array TX_R_223 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_223_R;
[ TX_R_223_R ;
    ResponseViaActivity(R_125_RESP_A);
];
Array TX_R_224 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_224_R;
[ TX_R_224_R ;
    ResponseViaActivity(R_125_RESP_B);
];
Array TX_R_225 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_225_R;
[ TX_R_225_R ;
    ResponseViaActivity(R_125_RESP_C);
];
Array TX_R_226 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_226_R;
[ TX_R_226_R ;
    ResponseViaActivity(R_125_RESP_D);
];
Array TX_R_227 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_227_R;
[ TX_R_227_R ;
    ResponseViaActivity(R_126_RESP_A);
];
Array TX_R_228 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_228_R;
[ TX_R_228_R ;
    ResponseViaActivity(R_127_RESP_A);
];
Array TX_R_229 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_229_R;
[ TX_R_229_R ;
    ResponseViaActivity(R_127_RESP_B);
];
Array TX_R_230 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_230_R;
[ TX_R_230_R ;
    ResponseViaActivity(R_128_RESP_A);
];
Array TX_R_231 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_231_R;
[ TX_R_231_R ;
    ResponseViaActivity(R_129_RESP_A);
];
Array TX_R_232 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_232_R;
[ TX_R_232_R ;
    ResponseViaActivity(R_129_RESP_B);
];
Array TX_R_233 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_233_R;
[ TX_R_233_R ;
    ResponseViaActivity(R_129_RESP_C);
];
Array TX_R_234 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_234_R;
[ TX_R_234_R ;
    ResponseViaActivity(R_129_RESP_D);
];
Array TX_R_235 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_235_R;
[ TX_R_235_R ;
    ResponseViaActivity(R_129_RESP_E);
];
Array TX_R_236 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_236_R;
[ TX_R_236_R ;
    ResponseViaActivity(R_131_RESP_A);
];
Array TX_R_237 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_237_R;
[ TX_R_237_R ;
    ResponseViaActivity(R_131_RESP_B);
];
Array TX_R_238 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_238_R;
[ TX_R_238_R ;
    ResponseViaActivity(R_131_RESP_C);
];
Array TX_R_239 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_239_R;
[ TX_R_239_R ;
    ResponseViaActivity(R_131_RESP_D);
];
Array TX_R_240 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_240_R;
[ TX_R_240_R ;
    ResponseViaActivity(R_134_RESP_A);
];
Array TX_R_241 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_241_R;
[ TX_R_241_R ;
    ResponseViaActivity(R_135_RESP_A);
];
Array TX_R_242 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_242_R;
[ TX_R_242_R ;
    ResponseViaActivity(R_138_RESP_A);
];
Array TX_R_243 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_243_R;
[ TX_R_243_R ;
    ResponseViaActivity(R_138_RESP_B);
];
Array TX_R_244 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_244_R;
[ TX_R_244_R ;
    ResponseViaActivity(R_138_RESP_C);
];
Array TX_R_245 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_245_R;
[ TX_R_245_R ;
    ResponseViaActivity(R_140_RESP_A);
];
Array TX_R_246 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_246_R;
[ TX_R_246_R ;
    ResponseViaActivity(R_142_RESP_A);
];
Array TX_R_247 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_247_R;
[ TX_R_247_R ;
    ResponseViaActivity(R_275_RESP_A);
];
Array TX_R_248 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_248_R;
[ TX_R_248_R ;
    ResponseViaActivity(R_275_RESP_B);
];
Array TX_R_249 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_249_R;
[ TX_R_249_R ;
    ResponseViaActivity(R_275_RESP_C);
];
Array TX_R_250 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_250_R;
[ TX_R_250_R ;
    ResponseViaActivity(R_147_RESP_A);
];
Array TX_R_251 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_251_R;
[ TX_R_251_R ;
    ResponseViaActivity(R_150_RESP_A);
];
Array TX_R_252 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_252_R;
[ TX_R_252_R ;
    ResponseViaActivity(R_152_RESP_A);
];
Array TX_R_253 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_253_R;
[ TX_R_253_R ;
    ResponseViaActivity(R_153_RESP_A);
];
Array TX_R_254 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_254_R;
[ TX_R_254_R ;
    ResponseViaActivity(R_153_RESP_B);
];
Array TX_R_255 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_255_R;
[ TX_R_255_R ;
    ResponseViaActivity(R_154_RESP_A);
];
Array TX_R_256 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_256_R;
[ TX_R_256_R ;
    ResponseViaActivity(R_155_RESP_A);
];
Array TX_R_257 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_257_R;
[ TX_R_257_R ;
    ResponseViaActivity(R_156_RESP_A);
];
Array TX_R_258 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_258_R;
[ TX_R_258_R ;
    ResponseViaActivity(R_157_RESP_A);
];
Array TX_R_259 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_259_R;
[ TX_R_259_R ;
    ResponseViaActivity(R_158_RESP_A);
];
Array TX_R_260 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_260_R;
[ TX_R_260_R ;
    ResponseViaActivity(R_159_RESP_A);
];
Array TX_R_261 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_261_R;
[ TX_R_261_R ;
    ResponseViaActivity(R_160_RESP_A);
];
Array TX_R_262 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_262_R;
[ TX_R_262_R ;
    ResponseViaActivity(R_161_RESP_A);
];
Array TX_R_263 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_263_R;
[ TX_R_263_R ;
    ResponseViaActivity(R_162_RESP_A);
];
Array TX_R_264 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_264_R;
[ TX_R_264_R ;
    ResponseViaActivity(R_162_RESP_B);
];
Array TX_R_265 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_265_R;
[ TX_R_265_R ;
    ResponseViaActivity(R_163_RESP_A);
];
Array TX_R_266 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_266_R;
[ TX_R_266_R ;
    ResponseViaActivity(R_163_RESP_B);
];
Array TX_R_267 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_267_R;
[ TX_R_267_R ;
    ResponseViaActivity(R_164_RESP_A);
];
Array TX_R_268 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_268_R;
[ TX_R_268_R ;
    ResponseViaActivity(R_165_RESP_A);
];
Array TX_R_269 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_269_R;
[ TX_R_269_R ;
    ResponseViaActivity(R_165_RESP_B);
];
Array TX_R_270 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_270_R;
[ TX_R_270_R ;
    ResponseViaActivity(R_166_RESP_A);
];
Array TX_R_271 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_271_R;
[ TX_R_271_R ;
    ResponseViaActivity(R_167_RESP_A);
];
Array TX_R_272 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_272_R;
[ TX_R_272_R ;
    ResponseViaActivity(R_168_RESP_A);
];
Array TX_R_273 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_273_R;
[ TX_R_273_R ;
    ResponseViaActivity(R_169_RESP_A);
];
Array TX_R_274 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_274_R;
[ TX_R_274_R ;
    ResponseViaActivity(R_171_RESP_A);
];
Array TX_R_275 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_275_R;
[ TX_R_275_R ;
    ResponseViaActivity(R_171_RESP_B);
];
Array TX_R_276 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_276_R;
[ TX_R_276_R ;
    ResponseViaActivity(R_172_RESP_A);
];
Array TX_R_277 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_277_R;
[ TX_R_277_R ;
    ResponseViaActivity(R_173_RESP_A);
];
Array TX_R_278 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_278_R;
[ TX_R_278_R ;
    ResponseViaActivity(R_174_RESP_A);
];
Array TX_R_279 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_279_R;
[ TX_R_279_R ;
    ResponseViaActivity(R_176_RESP_A);
];
Array TX_R_280 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_280_R;
[ TX_R_280_R ;
    ResponseViaActivity(R_176_RESP_B);
];
Array TX_R_281 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_281_R;
[ TX_R_281_R ;
    ResponseViaActivity(R_177_RESP_A);
];
Array TX_R_282 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_282_R;
[ TX_R_282_R ;
    ResponseViaActivity(R_178_RESP_A);
];
Array TX_R_283 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_283_R;
[ TX_R_283_R ;
    ResponseViaActivity(R_180_RESP_A);
];
Array TX_R_284 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_284_R;
[ TX_R_284_R ;
    ResponseViaActivity(R_181_RESP_A);
];
Array TX_R_285 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_285_R;
[ TX_R_285_R ;
    ResponseViaActivity(R_182_RESP_A);
];
Array TX_R_286 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_286_R;
[ TX_R_286_R ;
    ResponseViaActivity(R_184_RESP_A);
];
Array TX_R_287 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_287_R;
[ TX_R_287_R ;
    ResponseViaActivity(R_185_RESP_A);
];
Array TX_R_288 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_288_R;
[ TX_R_288_R ;
    ResponseViaActivity(R_186_RESP_A);
];
Array TX_R_289 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_289_R;
[ TX_R_289_R ;
    ResponseViaActivity(R_187_RESP_A);
];
Array TX_R_290 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_290_R;
[ TX_R_290_R ;
    ResponseViaActivity(R_189_RESP_A);
];
Array TX_R_291 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_291_R;
[ TX_R_291_R ;
    ResponseViaActivity(R_190_RESP_A);
];
Array TX_R_292 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_292_R;
[ TX_R_292_R ;
    ResponseViaActivity(R_190_RESP_B);
];
Array TX_R_293 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_293_R;
[ TX_R_293_R ;
    ResponseViaActivity(R_190_RESP_C);
];
Array TX_R_294 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_294_R;
[ TX_R_294_R ;
    ResponseViaActivity(R_191_RESP_A);
];
Array TX_R_295 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_295_R;
[ TX_R_295_R ;
    ResponseViaActivity(R_192_RESP_A);
];
Array TX_R_296 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_296_R;
[ TX_R_296_R ;
    ResponseViaActivity(R_194_RESP_A);
];
Array TX_R_297 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_297_R;
[ TX_R_297_R ;
    ResponseViaActivity(R_194_RESP_B);
];
Array TX_R_298 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_298_R;
[ TX_R_298_R ;
    ResponseViaActivity(R_194_RESP_C);
];
Array TX_R_299 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_299_R;
[ TX_R_299_R ;
    ResponseViaActivity(R_195_RESP_A);
];
Array TX_R_300 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_300_R;
[ TX_R_300_R ;
    ResponseViaActivity(R_196_RESP_A);
];
Array TX_R_301 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_301_R;
[ TX_R_301_R ;
    ResponseViaActivity(R_197_RESP_A);
];
Array TX_R_302 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_302_R;
[ TX_R_302_R ;
    ResponseViaActivity(R_199_RESP_A);
];
Array TX_R_303 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_303_R;
[ TX_R_303_R ;
    ResponseViaActivity(R_199_RESP_B);
];
Array TX_R_304 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_304_R;
[ TX_R_304_R ;
    ResponseViaActivity(R_200_RESP_A);
];
Array TX_R_305 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_305_R;
[ TX_R_305_R ;
    ResponseViaActivity(R_201_RESP_A);
];
Array TX_R_306 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_306_R;
[ TX_R_306_R ;
    ResponseViaActivity(R_203_RESP_A);
];
Array TX_R_307 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_307_R;
[ TX_R_307_R ;
    ResponseViaActivity(R_203_RESP_B);
];
Array TX_R_308 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_308_R;
[ TX_R_308_R ;
    ResponseViaActivity(R_204_RESP_A);
];
Array TX_R_309 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_309_R;
[ TX_R_309_R ;
    ResponseViaActivity(R_205_RESP_A);
];
Array TX_R_310 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_310_R;
[ TX_R_310_R ;
    ResponseViaActivity(R_206_RESP_A);
];
Array TX_R_311 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_311_R;
[ TX_R_311_R ;
    ResponseViaActivity(R_207_RESP_A);
];
Array TX_R_312 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_312_R;
[ TX_R_312_R ;
    ResponseViaActivity(R_208_RESP_A);
];
Array TX_R_313 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_313_R;
[ TX_R_313_R ;
    ResponseViaActivity(R_209_RESP_A);
];
Array TX_R_314 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_314_R;
[ TX_R_314_R ;
    ResponseViaActivity(R_211_RESP_A);
];
Array TX_R_315 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_315_R;
[ TX_R_315_R ;
    ResponseViaActivity(R_211_RESP_B);
];
Array TX_R_316 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_316_R;
[ TX_R_316_R ;
    ResponseViaActivity(R_211_RESP_C);
];
Array TX_R_317 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_317_R;
[ TX_R_317_R ;
    ResponseViaActivity(R_212_RESP_A);
];
Array TX_R_318 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_318_R;
[ TX_R_318_R ;
    ResponseViaActivity(R_214_RESP_A);
];
Array TX_R_319 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_319_R;
[ TX_R_319_R ;
    ResponseViaActivity(R_215_RESP_A);
];
Array TX_R_320 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_320_R;
[ TX_R_320_R ;
    ResponseViaActivity(R_216_RESP_A);
];
Array TX_R_321 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_321_R;
[ TX_R_321_R ;
    ResponseViaActivity(R_217_RESP_A);
];
Array TX_R_322 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_322_R;
[ TX_R_322_R ;
    ResponseViaActivity(R_218_RESP_A);
];
Array TX_R_323 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_323_R;
[ TX_R_323_R ;
    ResponseViaActivity(R_219_RESP_A);
];
Array TX_R_324 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_324_R;
[ TX_R_324_R ;
    ResponseViaActivity(R_220_RESP_A);
];
Array TX_R_325 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_325_R;
[ TX_R_325_R ;
    ResponseViaActivity(R_221_RESP_A);
];
Array TX_R_326 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_326_R;
[ TX_R_326_R ;
    ResponseViaActivity(R_223_RESP_A);
];
Array TX_R_327 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_327_R;
[ TX_R_327_R ;
    ResponseViaActivity(R_228_RESP_A);
];
Array TX_R_328 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_328_R;
[ TX_R_328_R ;
    ResponseViaActivity(R_228_RESP_B);
];
Array TX_R_329 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_329_R;
[ TX_R_329_R ;
    ResponseViaActivity(R_229_RESP_A);
];
Array TX_R_330 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_330_R;
[ TX_R_330_R ;
    ResponseViaActivity(R_229_RESP_B);
];
Array TX_R_331 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_331_R;
[ TX_R_331_R ;
    ResponseViaActivity(R_230_RESP_A);
];
Array TX_R_332 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_332_R;
[ TX_R_332_R ;
    ResponseViaActivity(R_230_RESP_B);
];
Array TX_R_333 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_333_R;
[ TX_R_333_R ;
    ResponseViaActivity(R_230_RESP_C);
];
Array TX_R_334 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_334_R;
[ TX_R_334_R ;
    ResponseViaActivity(R_231_RESP_A);
];
Array TX_R_335 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_335_R;
[ TX_R_335_R ;
    ResponseViaActivity(R_231_RESP_B);
];
Array TX_R_336 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_336_R;
[ TX_R_336_R ;
    ResponseViaActivity(R_232_RESP_A);
];
Array TX_R_337 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_337_R;
[ TX_R_337_R ;
    ResponseViaActivity(R_233_RESP_A);
];
Array TX_R_338 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_338_R;
[ TX_R_338_R ;
    ResponseViaActivity(R_233_RESP_B);
];
Array TX_R_339 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_339_R;
[ TX_R_339_R ;
    ResponseViaActivity(R_234_RESP_A);
];
Array TX_R_340 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_340_R;
[ TX_R_340_R ;
    ResponseViaActivity(R_235_RESP_A);
];
Array TX_R_341 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_341_R;
[ TX_R_341_R ;
    ResponseViaActivity(R_236_RESP_A);
];
Array TX_R_342 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_342_R;
[ TX_R_342_R ;
    ResponseViaActivity(R_237_RESP_A);
];
Array TX_R_343 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_343_R;
[ TX_R_343_R ;
    ResponseViaActivity(R_237_RESP_B);
];
Array TX_R_344 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_344_R;
[ TX_R_344_R ;
    ResponseViaActivity(R_238_RESP_A);
];
Array TX_R_345 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_345_R;
[ TX_R_345_R ;
    ResponseViaActivity(R_239_RESP_A);
];
Array TX_R_346 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_346_R;
[ TX_R_346_R ;
    ResponseViaActivity(R_240_RESP_A);
];
Array TX_R_347 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_347_R;
[ TX_R_347_R ;
    ResponseViaActivity(R_241_RESP_A);
];
Array TX_R_348 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_348_R;
[ TX_R_348_R ;
    ResponseViaActivity(R_241_RESP_B);
];
Array TX_R_349 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_349_R;
[ TX_R_349_R ;
    ResponseViaActivity(R_242_RESP_A);
];
Array TX_R_350 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_350_R;
[ TX_R_350_R ;
    ResponseViaActivity(R_243_RESP_A);
];
Array TX_R_351 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_351_R;
[ TX_R_351_R ;
    ResponseViaActivity(R_244_RESP_A);
];
Array TX_R_352 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_352_R;
[ TX_R_352_R ;
    ResponseViaActivity(R_245_RESP_A);
];
Array TX_R_353 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_353_R;
[ TX_R_353_R ;
    ResponseViaActivity(R_245_RESP_B);
];
Array TX_R_354 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_354_R;
[ TX_R_354_R ;
    ResponseViaActivity(R_246_RESP_A);
];
Array TX_R_355 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_355_R;
[ TX_R_355_R ;
    ResponseViaActivity(R_247_RESP_A);
];
Array TX_R_356 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_356_R;
[ TX_R_356_R ;
    ResponseViaActivity(R_248_RESP_A);
];
Array TX_R_357 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_357_R;
[ TX_R_357_R ;
    ResponseViaActivity(R_249_RESP_A);
];
Array TX_R_358 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_358_R;
[ TX_R_358_R ;
    ResponseViaActivity(R_251_RESP_A);
];
Array TX_R_359 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_359_R;
[ TX_R_359_R ;
    ResponseViaActivity(R_252_RESP_A);
];
Array TX_R_360 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_360_R;
[ TX_R_360_R ;
    ResponseViaActivity(R_253_RESP_A);
];
Array TX_R_361 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_361_R;
[ TX_R_361_R ;
    ResponseViaActivity(R_253_RESP_B);
];
Array TX_R_362 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_362_R;
[ TX_R_362_R ;
    ResponseViaActivity(R_254_RESP_A);
];
Array TX_R_363 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_363_R;
[ TX_R_363_R ;
    ResponseViaActivity(R_255_RESP_A);
];
Array TX_R_364 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_364_R;
[ TX_R_364_R ;
    ResponseViaActivity(R_256_RESP_A);
];
Array TX_R_365 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_365_R;
[ TX_R_365_R ;
    ResponseViaActivity(R_257_RESP_A);
];
Array TX_R_366 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_366_R;
[ TX_R_366_R ;
    ResponseViaActivity(R_258_RESP_A);
];
Array TX_R_367 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_367_R;
[ TX_R_367_R ;
    ResponseViaActivity(R_259_RESP_A);
];
Array TX_R_368 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_368_R;
[ TX_R_368_R ;
    ResponseViaActivity(R_259_RESP_B);
];
Array TX_R_369 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_369_R;
[ TX_R_369_R ;
    ResponseViaActivity(R_260_RESP_A);
];
Array TX_R_370 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_370_R;
[ TX_R_370_R ;
    ResponseViaActivity(R_260_RESP_B);
];
Array TX_R_371 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_371_R;
[ TX_R_371_R ;
    ResponseViaActivity(R_261_RESP_A);
];
Array TX_R_372 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_372_R;
[ TX_R_372_R ;
    ResponseViaActivity(R_261_RESP_B);
];
Array TX_R_373 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_373_R;
[ TX_R_373_R ;
    ResponseViaActivity(R_262_RESP_A);
];
Array TX_R_374 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_374_R;
[ TX_R_374_R ;
    ResponseViaActivity(R_263_RESP_A);
];
Array TX_R_375 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_375_R;
[ TX_R_375_R ;
    ResponseViaActivity(R_263_RESP_B);
];
Array TX_R_376 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_376_R;
[ TX_R_376_R ;
    ResponseViaActivity(R_264_RESP_A);
];
Array TX_R_377 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_377_R;
[ TX_R_377_R ;
    ResponseViaActivity(R_265_RESP_A);
];
Array TX_R_378 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_378_R;
[ TX_R_378_R ;
    ResponseViaActivity(R_266_RESP_A);
];
Array TX_R_379 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_379_R;
[ TX_R_379_R ;
    ResponseViaActivity(R_267_RESP_A);
];
Array TX_R_380 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_380_R;
[ TX_R_380_R ;
    ResponseViaActivity(R_268_RESP_A);
];
Array TX_R_381 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_381_R;
[ TX_R_381_R ;
    ResponseViaActivity(R_269_RESP_A);
];
Array TX_R_382 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_382_R;
[ TX_R_382_R ;
    ResponseViaActivity(R_269_RESP_B);
];
Array TX_R_383 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_383_R;
[ TX_R_383_R ;
    ResponseViaActivity(R_270_RESP_A);
];
Array TX_R_384 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_384_R;
[ TX_R_384_R ;
    ResponseViaActivity(R_271_RESP_A);
];
Array TX_R_385 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_385_R;
[ TX_R_385_R ;
    ResponseViaActivity(R_271_RESP_B);
];
Array TX_R_386 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_386_R;
[ TX_R_386_R ;
    ResponseViaActivity(R_272_RESP_A);
];
Array TX_R_387 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_387_R;
[ TX_R_387_R ;
    ResponseViaActivity(R_273_RESP_A);
];
Array TX_R_388 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_388_R;
[ TX_R_388_R ;
    ResponseViaActivity(R_274_RESP_A);
];
Array TX_R_389 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_389_R;
[ TX_R_389_R ;
    ResponseViaActivity(R_279_RESP_A);
];
Array TX_R_390 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_390_R;
[ TX_R_390_R ;
    ResponseViaActivity(R_146_RESP_A);
];
Array TX_R_391 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_391_R;
[ TX_R_391_R ;
    ResponseViaActivity(R_146_RESP_B);
];
Array TX_R_392 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_392_R;
[ TX_R_392_R ;
    ResponseViaActivity(R_146_RESP_C);
];
Array TX_R_393 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_393_R;
[ TX_R_393_R ;
    ResponseViaActivity(R_222_RESP_A);
];
Array TX_R_394 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_394_R;
[ TX_R_394_R ;
    ResponseViaActivity(R_224_RESP_A);
];
Array TX_R_395 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_395_R;
[ TX_R_395_R ;
    ResponseViaActivity(R_225_RESP_A);
];
[ R_TX_S_134 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]Tan bella como oscura, irradia una rojiza luz maléfica que envuelve tu ser y tu libro, impregnando las páginas con sangre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break]Tan bella como oscura, irradia una rojiza luz maléfica que envuelve tu ser y tu libro, impregnando las páginas con sangre.~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: ~Tan bella como oscura, irradia una rojiza luz maléfica que envuelve tu ser y tu libro, impregnando las páginas con sangre.~]
    ParaContent(); print "Tan bella como oscura, irradia una rojiza luz maléfica que envuelve tu ser y tu libro, impregnando las páginas con sangre."; .L_Say806; .L_SayX796;rtrue;
];
[ R_TX_S_135 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if espectante][line break]La musa espera que escribas en el libro del destino.[otherwise]No puedes dejar de mirar a tu musa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if espectante][line break]La musa espera que escribas en el libro del destino.[otherwise]No puedes dejar de mirar a tu musa.~]
    say__p=1;! [2: if espectante]

    	if (~~(((((Adj_106_t1_v10(self))))))) jump L_Say807;! [3: line break]
    ParaContent(); new_line;! [4: ~La musa espera que escribas en el libro del destino.~]
    ParaContent(); print "La musa espera que escribas en el libro del destino.";! [5: otherwise]

    	jump L_SayX797; .L_Say807;! [6: ~No puedes dejar de mirar a tu musa.~]
    ParaContent(); print "No puedes dejar de mirar a tu musa."; .L_Say808; .L_SayX797;rtrue;
];
[ R_TX_S_136 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Apareces de entre la bruma en un campo verde y puro. Estás cansado y te tumbas en la fresca hierba contemplando un imposible atardecer. El paisaje bucólico se ve aderezado por la aparición de un rebaño de ovejas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Apareces de entre la bruma en un campo verde y puro. Estás cansado y te tumbas en la fresca hierba contemplando un imposible atardecer. El paisaje bucólico se ve aderezado por la aparición de un rebaño de ovejas.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say809;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say809; .L_SayX798;! [6: ~Apareces de entre la bruma en un campo verde y puro. Estás cansado y te tumbas en la fresca hierba contemplando un imposible atardecer. El paisaje bucólico se ve aderezado por la aparición de un rebaño de ovejas.~]
    ParaContent(); print "Apareces de entre la bruma en un campo verde y puro. Estás cansado y te tumbas en la fresca hierba contemplando un imposible atardecer. El paisaje bucólico se ve aderezado por la aparición de un rebaño de ovejas."; .L_Say810; .L_SayX799;rtrue;
];
[ R_TX_S_137 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás en lo alto de un castillo, desde donde puedes ver toda la sierra. Tu arrogante figura proyecta unas sombras sobre lo que parece ser un banquete improvisado, dispuesto sobre unas bandejas en el centro del torreón. A un lado puedes ver encadenado a un pobre hombre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás en lo alto de un castillo, desde donde puedes ver toda la sierra. Tu arrogante figura proyecta unas sombras sobre lo que parece ser un banquete improvisado, dispuesto sobre unas bandejas en el centro del torreón. A un lado puedes ver encadenado a un pobre hombre.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say811;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say811; .L_SayX800;! [6: ~Estás en lo alto de un castillo, desde donde puedes ver toda la sierra. Tu arrogante figura proyecta unas sombras sobre lo que parece ser un banquete improvisado, dispuesto sobre unas bandejas en el centro del torreón. A un lado puedes ver encadenado a un pobre hombre.~]
    ParaContent(); print "Estás en lo alto de un castillo, desde donde puedes ver toda la sierra. Tu arrogante figura proyecta unas sombras sobre lo que parece ser un banquete improvisado, dispuesto sobre unas bandejas en el centro del torreón. A un lado puedes ver encadenado a un pobre hombre."; .L_Say812; .L_SayX801;rtrue;
];
[ R_TX_S_138 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás en el campo de batalla, feroces guerreros te rodean armados con espadas y artilugios de dar muerte. Ante ti hay un soldado moribundo que implora salvar su mísera vida.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás en el campo de batalla, feroces guerreros te rodean armados con espadas y artilugios de dar muerte. Ante ti hay un soldado moribundo que implora salvar su mísera vida.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say813;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say813; .L_SayX802;! [6: ~Estás en el campo de batalla, feroces guerreros te rodean armados con espadas y artilugios de dar muerte. Ante ti hay un soldado moribundo que implora salvar su mísera vida.~]
    ParaContent(); print "Estás en el campo de batalla, feroces guerreros te rodean armados con espadas y artilugios de dar muerte. Ante ti hay un soldado moribundo que implora salvar su mísera vida."; .L_Say814; .L_SayX803;rtrue;
];
[ R_TX_S_139 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Tus pasos te conducen hacia una habitación amplia, decorada con motivos femeninos, donde una hermosa doncella peina su larga cabellera, ante un espejo, sentada desnuda sobre una butaca.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Tus pasos te conducen hacia una habitación amplia, decorada con motivos femeninos, donde una hermosa doncella peina su larga cabellera, ante un espejo, sentada desnuda sobre una butaca.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say815;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say815; .L_SayX804;! [6: ~Tus pasos te conducen hacia una habitación amplia, decorada con motivos femeninos, donde una hermosa doncella peina su larga cabellera, ante un espejo, sentada desnuda sobre una butaca.~]
    ParaContent(); print "Tus pasos te conducen hacia una habitación amplia, decorada con motivos femeninos, donde una hermosa doncella peina su larga cabellera, ante un espejo, sentada desnuda sobre una butaca."; .L_Say816; .L_SayX805;rtrue;
];
[ R_TX_S_140 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Qué importa la butaca? No puedes hacer otra cosa que mirar la deslumbrante desnudez de la doncella. [paragraph break]Un calor incesante se apodera de tu cuerpo, que lucha en vano por superar el instinto primario...~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Qué importa la butaca? No puedes hacer otra cosa que mirar la deslumbrante desnudez de la doncella. [paragraph break]Un calor incesante se apodera de tu cuerpo, que lucha en vano por superar el instinto primario...~]
    say__p=1;! [2: ~¿Qué importa la butaca? No puedes hacer otra cosa que mirar la deslumbrante desnudez de la doncella. ~]
    ParaContent(); print "¿Qué importa la butaca? No puedes hacer otra cosa que mirar la deslumbrante desnudez de la doncella. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Un calor incesante se apodera de tu cuerpo, que lucha en vano por superar el instinto primario...~]
    ParaContent(); print "Un calor incesante se apodera de tu cuerpo, que lucha en vano por superar el instinto primario..."; .L_Say817; .L_SayX806;rtrue;
];
[ R_TX_S_141 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Su bello rostro mantiene una mirada lánguida en el espejo, [if cepillo is in location]esperando lo inevitable. [otherwise]cepillándose enérgicamente el pelo para eliminar sus enredos. [end if]Su semblante es triste y parece que está llorando.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Su bello rostro mantiene una mirada lánguida en el espejo, [if cepillo is in location]esperando lo inevitable. [otherwise]cepillándose enérgicamente el pelo para eliminar sus enredos. [end if]Su semblante es triste y parece que está llorando.~]
    say__p=1;! [2: ~Su bello rostro mantiene una mirada lánguida en el espejo, ~]
    ParaContent(); print "Su bello rostro mantiene una mirada lánguida en el espejo, ";! [3: if cepillo is in location]
    ParaContent(); 
    	if (~~((((real_location == ContainerOf(I263_cepillo)))))) jump L_Say818;! [4: ~esperando lo inevitable. ~]
    ParaContent(); print "esperando lo inevitable. ";! [5: otherwise]

    	jump L_SayX807; .L_Say818;! [6: ~cepillándose enérgicamente el pelo para eliminar sus enredos. ~]
    ParaContent(); print "cepillándose enérgicamente el pelo para eliminar sus enredos. ";! [7: end if]

    	.L_Say819; .L_SayX807;! [8: ~Su semblante es triste y parece que está llorando.~]
    ParaContent(); print "Su semblante es triste y parece que está llorando."; .L_Say820; .L_SayX808;rtrue;
];
[ R_TX_S_142 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Puedes vislumbrar el lugar donde te parece estar, una extraña sala octogonal recubierta de pinturas obscenas. En el centro, entre almohadas y finas telas, [if mercader is vivo]descansa dormido un rico mercader[else if mercader is muerto]está el cuerpo sin vida del mercader[end if], sosteniendo entre sus manos un gran diamante tallado con la forma de una flor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Puedes vislumbrar el lugar donde te parece estar, una extraña sala octogonal recubierta de pinturas obscenas. En el centro, entre almohadas y finas telas, [if mercader is vivo]descansa dormido un rico mercader[else if mercader is muerto]está el cuerpo sin vida del mercader[end if], sosteniendo entre sus manos un gran diamante tallado con la forma de una flor.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say821;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say821; .L_SayX809;! [6: ~Puedes vislumbrar el lugar donde te parece estar, una extraña sala octogonal recubierta de pinturas obscenas. En el centro, entre almohadas y finas telas, ~]
    ParaContent(); print "Puedes vislumbrar el lugar donde te parece estar, una extraña sala octogonal recubierta de pinturas obscenas. En el centro, entre almohadas y finas telas, ";! [7: if mercader is vivo]

    	if (~~(((((Adj_107_t1_v10(I270_mercader))))))) jump L_Say822;! [8: ~descansa dormido un rico mercader~]
    ParaContent(); print "descansa dormido un rico mercader";! [9: else if mercader is muerto]
    ParaContent(); 
    	jump L_SayX810; .L_Say822; if (~~(((((Adj_108_t1_v10(I270_mercader))))))) jump L_Say823;! [10: ~está el cuerpo sin vida del mercader~]
    ParaContent(); print "está el cuerpo sin vida del mercader";! [11: end if]

    	.L_Say823; .L_SayX810;! [12: ~, sosteniendo entre sus manos un gran diamante tallado con la forma de una flor.~]
    ParaContent(); print ", sosteniendo entre sus manos un gran diamante tallado con la forma de una flor."; .L_Say824; .L_SayX811;rtrue;
];
[ R_TX_S_143 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El diamante más maravilloso que existe, sin duda. Es tal su belleza... es tanto su valor... [paragraph break][italic type]'Cógelo, es tuyo'[roman type], dice la musa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El diamante más maravilloso que existe, sin duda. Es tal su belleza... es tanto su valor... [paragraph break][italic type]'Cógelo, es tuyo'[roman type], dice la musa.~]
    say__p=1;! [2: ~El diamante más maravilloso que existe, sin duda. Es tal su belleza... es tanto su valor... ~]
    ParaContent(); print "El diamante más maravilloso que existe, sin duda. Es tal su belleza... es tanto su valor... ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: italic type]
    ParaContent(); style underline;! [5: ~'Cógelo, es tuyo'~]
    ParaContent(); print "~Cógelo, es tuyo~";! [6: roman type]
    ParaContent(); style roman;! [7: ~, dice la musa.~]
    ParaContent(); print ", dice la musa."; .L_Say825; .L_SayX812;rtrue;
];
[ R_TX_S_144 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if vivo]Un orondo mercader, vestido con ricas telas, tumbado sobre almohadas y cojines, cuyos ronquidos retruenan en la sala y enturbian la cegadora belleza del diamante que sostiene en sus manos.[else if muerto]El mercader ahora está sumido en un sueño más profundo.[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if vivo]Un orondo mercader, vestido con ricas telas, tumbado sobre almohadas y cojines, cuyos ronquidos retruenan en la sala y enturbian la cegadora belleza del diamante que sostiene en sus manos.[else if muerto]El mercader ahora está sumido en un sueño más profundo.[end if]~]
    say__p=1;! [2: if vivo]

    	if (~~(((((Adj_107_t1_v10(self))))))) jump L_Say826;! [3: ~Un orondo mercader, vestido con ricas telas, tumbado sobre almohadas y cojines, cuyos ronquidos retruenan en la sala y enturbian la cegadora belleza del diamante que sostiene en sus manos.~]
    ParaContent(); print "Un orondo mercader, vestido con ricas telas, tumbado sobre almohadas y cojines, cuyos ronquidos retruenan en la sala y enturbian la cegadora belleza del diamante que sostiene en sus manos.";! [4: else if muerto]
    ParaContent(); 
    	jump L_SayX813; .L_Say826; if (~~(((((Adj_108_t1_v10(self))))))) jump L_Say827;! [5: ~El mercader ahora está sumido en un sueño más profundo.~]
    ParaContent(); print "El mercader ahora está sumido en un sueño más profundo.";! [6: end if]

    	.L_Say827; .L_SayX813; .L_Say828; .L_SayX814;rtrue;
];
[ R_TX_S_145 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Te encuentras ante una multitud de fieles que te aclaman como su señor, sus cánticos resuenan en la oscura noche. Eres el gran maestre. Un poco más allá puedes ver una pequeña hoguera. [if the player is in the altar][paragraph break]Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado.[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Te encuentras ante una multitud de fieles que te aclaman como su señor, sus cánticos resuenan en la oscura noche. Eres el gran maestre. Un poco más allá puedes ver una pequeña hoguera. [if the player is in the altar][paragraph break]Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado.[end if]~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say829;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say829; .L_SayX815;! [6: ~Te encuentras ante una multitud de fieles que te aclaman como su señor, sus cánticos resuenan en la oscura noche. Eres el gran maestre. Un poco más allá puedes ver una pequeña hoguera. ~]
    ParaContent(); print "Te encuentras ante una multitud de fieles que te aclaman como su señor, sus cánticos resuenan en la oscura noche. Eres el gran maestre. Un poco más allá puedes ver una pequeña hoguera. ";! [7: if the player is in the altar]
    ParaContent(); 
    	if (~~((((I274_altar == ContainerOf(player)))))) jump L_Say830;! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [9: ~Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado.~]
    ParaContent(); print "Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado.";! [10: end if]

    	.L_Say830; .L_SayX816; .L_Say831; .L_SayX817;rtrue;
];
[ R_TX_S_146 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Es un altar de piedra, [if the player is in the altar]los fieles estan espectantes y sus cánticos se aceleran.[otherwise]los fieles esperan a que subas para empezar el ritual.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Es un altar de piedra, [if the player is in the altar]los fieles estan espectantes y sus cánticos se aceleran.[otherwise]los fieles esperan a que subas para empezar el ritual.~]
    say__p=1;! [2: ~Es un altar de piedra, ~]
    ParaContent(); print "Es un altar de piedra, ";! [3: if the player is in the altar]
    ParaContent(); 
    	if (~~((((I274_altar == ContainerOf(player)))))) jump L_Say832;! [4: ~los fieles estan espectantes y sus cánticos se aceleran.~]
    ParaContent(); print "los fieles estan espectantes y sus cánticos se aceleran.";! [5: otherwise]

    	jump L_SayX818; .L_Say832;! [6: ~los fieles esperan a que subas para empezar el ritual.~]
    ParaContent(); print "los fieles esperan a que subas para empezar el ritual."; .L_Say833; .L_SayX818;rtrue;
];
[ R_TX_S_147 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the player is in the altar]Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado. [otherwise]Estás frente a un improvisado altar hecho con piedras, encima de las cuales hay un ternero degollado.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the player is in the altar]Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado. [otherwise]Estás frente a un improvisado altar hecho con piedras, encima de las cuales hay un ternero degollado.~]
    say__p=1;! [2: if the player is in the altar]
    ParaContent(); 
    	if (~~((((I274_altar == ContainerOf(player)))))) jump L_Say834;! [3: ~Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado. ~]
    ParaContent(); print "Estás en el altar de piedra, abajo están los fieles, esperando a la culminación del ritual. Frente a ti hay un ternero degollado. ";! [4: otherwise]

    	jump L_SayX819; .L_Say834;! [5: ~Estás frente a un improvisado altar hecho con piedras, encima de las cuales hay un ternero degollado.~]
    ParaContent(); print "Estás frente a un improvisado altar hecho con piedras, encima de las cuales hay un ternero degollado."; .L_Say835; .L_SayX819;rtrue;
];
[ R_TX_S_148 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás caminando descalzo sobre tierra húmeda, recién labrada. Alzas la vista, parece que se avecina tormenta. [if the player carries the piedra]Tienes una piedra en tu mano. [end if]No recuerdas por qué sonríes satisfecho y temeroso a la vez.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if unvisited]Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.[paragraph break][end if]Estás caminando descalzo sobre tierra húmeda, recién labrada. Alzas la vista, parece que se avecina tormenta. [if the player carries the piedra]Tienes una piedra en tu mano. [end if]No recuerdas por qué sonríes satisfecho y temeroso a la vez.~]
    say__p=1;! [2: if unvisited]

    	if (~~(((((Adj_63_t1_v10(self))))))) jump L_Say836;! [3: ~Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.~]
    ParaContent(); print "Tu mente nublada se recupera del estallido de sensaciones contradictorias que te ha producido la sola visión de tu musa.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say836; .L_SayX820;! [6: ~Estás caminando descalzo sobre tierra húmeda, recién labrada. Alzas la vista, parece que se avecina tormenta. ~]
    ParaContent(); print "Estás caminando descalzo sobre tierra húmeda, recién labrada. Alzas la vista, parece que se avecina tormenta. ";! [7: if the player carries the piedra]

    	if (~~((((player == CarrierOf(I276_piedra)))))) jump L_Say837;! [8: ~Tienes una piedra en tu mano. ~]
    ParaContent(); print "Tienes una piedra en tu mano. ";! [9: end if]

    	.L_Say837; .L_SayX821;! [10: ~No recuerdas por qué sonríes satisfecho y temeroso a la vez.~]
    ParaContent(); print "No recuerdas por qué sonríes satisfecho y temeroso a la vez."; .L_Say838; .L_SayX822;rtrue;
];
[ R_TX_S_149 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~La mitad de la mano derecha del soldado está tirada en el suelo, [if the player carries the espada]en un charco de sangre.[otherwise]al lado de una ensangrentada espada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~La mitad de la mano derecha del soldado está tirada en el suelo, [if the player carries the espada]en un charco de sangre.[otherwise]al lado de una ensangrentada espada.~]
    say__p=1;! [2: ~La mitad de la mano derecha del soldado está tirada en el suelo, ~]
    ParaContent(); print "La mitad de la mano derecha del soldado está tirada en el suelo, ";! [3: if the player carries the espada]

    	if (~~((((player == CarrierOf(I252_espada)))))) jump L_Say839;! [4: ~en un charco de sangre.~]
    ParaContent(); print "en un charco de sangre.";! [5: otherwise]

    	jump L_SayX823; .L_Say839;! [6: ~al lado de una ensangrentada espada.~]
    ParaContent(); print "al lado de una ensangrentada espada."; .L_Say840; .L_SayX823;rtrue;
];
[ R_TX_S_150 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if almohada is handled]Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.[otherwise]El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if almohada is handled]Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.[otherwise]El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~]
    say__p=1;! [2: if almohada is handled]

    	if (~~(((((Adj_73_t1_v10(I268_almohada))))))) jump L_Say841;! [3: ~Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.~]
    ParaContent(); print "Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.";! [4: otherwise]

    	jump L_SayX824; .L_Say841;! [5: ~El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~]
    ParaContent(); print "El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti."; .L_Say842; .L_SayX824;rtrue;
];
[ R_TX_S_151 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if almohada is handled]Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.[otherwise]El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if almohada is handled]Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.[otherwise]El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~]
    say__p=1;! [2: if almohada is handled]

    	if (~~(((((Adj_73_t1_v10(I268_almohada))))))) jump L_Say843;! [3: ~Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.~]
    ParaContent(); print "Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.";! [4: otherwise]

    	jump L_SayX825; .L_Say843;! [5: ~El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti.~]
    ParaContent(); print "El mercader reposa sobre un lecho de cojines y almohadas, una de las cuales está muy cerca de ti."; .L_Say844; .L_SayX825;rtrue;
];
[ R_TX_S_152 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Una almohada ricamente adornada.[paragraph break][italic type]'Mata al mercader... y el diamante será tuyo... ¡mátalo!'[roman type], te sisea la musa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Una almohada ricamente adornada.[paragraph break][italic type]'Mata al mercader... y el diamante será tuyo... ¡mátalo!'[roman type], te sisea la musa.~]
    say__p=1;! [2: ~Una almohada ricamente adornada.~]
    ParaContent(); print "Una almohada ricamente adornada.";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: italic type]
    ParaContent(); style underline;! [5: ~'Mata al mercader... y el diamante será tuyo... ¡mátalo!'~]
    ParaContent(); print "~Mata al mercader... y el diamante será tuyo... ¡mátalo!~";! [6: roman type]
    ParaContent(); style roman;! [7: ~, te sisea la musa.~]
    ParaContent(); print ", te sisea la musa."; .L_Say845; .L_SayX826;rtrue;
];
[ R_TX_S_153 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Un ternero degollado, forma parte del ritual. [if the player is in the altar]Los fieles estan espectantes y sus cánticos se aceleran.[otherwise]Los fieles esperan a que empieces el ritual.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Un ternero degollado, forma parte del ritual. [if the player is in the altar]Los fieles estan espectantes y sus cánticos se aceleran.[otherwise]Los fieles esperan a que empieces el ritual.~]
    say__p=1;! [2: ~Un ternero degollado, forma parte del ritual. ~]
    ParaContent(); print "Un ternero degollado, forma parte del ritual. ";! [3: if the player is in the altar]
    ParaContent(); 
    	if (~~((((I274_altar == ContainerOf(player)))))) jump L_Say846;! [4: ~Los fieles estan espectantes y sus cánticos se aceleran.~]
    ParaContent(); print "Los fieles estan espectantes y sus cánticos se aceleran.";! [5: otherwise]

    	jump L_SayX827; .L_Say846;! [6: ~Los fieles esperan a que empieces el ritual.~]
    ParaContent(); print "Los fieles esperan a que empieces el ritual."; .L_Say847; .L_SayX827;rtrue;
];
[ R_TX_S_154 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Necesito que sigas el hilo de la conversación para avanzar. Ingresa un número o el comando MOSTRAR para volver a ver tus opciones.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Necesito que sigas el hilo de la conversación para avanzar. Ingresa un número o el comando MOSTRAR para volver a ver tus opciones.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Necesito que sigas el hilo de la conversación para avanzar. Ingresa un número o el comando MOSTRAR para volver a ver tus opciones.~]
    ParaContent(); print "Necesito que sigas el hilo de la conversación para avanzar. Ingresa un número o el comando MOSTRAR para volver a ver tus opciones.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say848; .L_SayX828;rtrue;
];
[ R_TX_S_155 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]No hay respuestas disponibles.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]No hay respuestas disponibles.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~No hay respuestas disponibles.~]
    ParaContent(); print "No hay respuestas disponibles.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say849; .L_SayX829;rtrue;
];
[ R_TX_S_156 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Utiliza HABLA CON para interactuar con los personajes.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Utiliza HABLA CON para interactuar con los personajes.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Utiliza HABLA CON para interactuar con los personajes.~]
    ParaContent(); print "Utiliza HABLA CON para interactuar con los personajes.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say850; .L_SayX830;rtrue;
];
[ R_TX_S_157 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Ahora mismo no estás conversando con nadie.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Ahora mismo no estás conversando con nadie.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Ahora mismo no estás conversando con nadie.~]
    ParaContent(); print "Ahora mismo no estás conversando con nadie.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say851; .L_SayX831;rtrue;
];
[ R_TX_S_158 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[location]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[location]~]
    say__p=1;! [2: location]
    ParaContent(); PrintShortName(real_location); .L_Say852; .L_SayX832;rtrue;
];
[ R_TX_S_159 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[score]/[turn count]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[score]/[turn count]~]
    say__p=1;! [2: score]
    ParaContent(); print (say__n=score);! [3: ~/~]
    ParaContent(); print "/";! [4: turn count]
    ParaContent(); print (say__n=turns); .L_Say853; .L_SayX833;rtrue;
];
[ R_TX_S_160 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current menu title]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current menu title]~]
    say__p=1;! [2: current menu title]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->14); .L_Say854; .L_SayX834;rtrue;
];
[ R_TX_S_161 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current menu title]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current menu title]~]
    say__p=1;! [2: current menu title]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->14); .L_Say855; .L_SayX835;rtrue;
];
[ R_TX_S_162 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Q = [if menu depth > 1]Last Menu[otherwise]Quit Menu[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Q = [if menu depth > 1]Last Menu[otherwise]Quit Menu[end if]~]
    say__p=1;! [2: ~Q = ~]
    ParaContent(); print "Q = ";! [3: if menu depth > 1]

    	if (~~(((((Global_Vars-->12) > 1))))) jump L_Say856;! [4: ~Last Menu~]
    ParaContent(); print "Last Menu";! [5: otherwise]

    	jump L_SayX836; .L_Say856;! [6: ~Quit Menu~]
    ParaContent(); print "Quit Menu";! [7: end if]

    	.L_Say857; .L_SayX836; .L_Say858; .L_SayX837;rtrue;
];
[ R_TX_S_163 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Introducción a [story title]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Introducción a [story title]~]
    say__p=1;! [2: ~Introducción a ~]
    ParaContent(); print "Introducción a ";! [3: story title]
    ParaContent(); print (TEXT_TY_Say) TX_L_2; .L_Say859; .L_SayX838;rtrue;
];
[ R_TX_S_164 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Esto es una simple demo de un juego de género [story genre].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Esto es una simple demo de un juego de género [story genre].~]
    say__p=1;! [2: ~Esto es una simple demo de un juego de género ~]
    ParaContent(); print "Esto es una simple demo de un juego de género ";! [3: story genre]
    ParaContent(); print (TEXT_TY_Say) TX_L_153;! [4: ~.~]
    ParaContent(); print "."; .L_Say860; .L_SayX839;rtrue;
];
[ R_TX_S_165 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]Además de los verbos básicos, tienes las siguientes opciones:[paragraph break][bold type]REINICIAR[roman type] - Para volver a comenzar la partida.[line break][bold type]GUARDAR[roman type] - Para grabar tu posición.[line break][bold type]CARGAR[roman type] - Para recuperar una posición guardada.[line break][bold type]INVENTARIO[roman type] - Para mostrar los objetos que llevas.[line break][bold type]PUNTOS[roman type] - Para mostrar tu actual puntuación.[line break][bold type]TRANSCRIPT[roman type] - Para transcribir el juego en un archivo de texto.[line break][bold type]DIALECTO SUDAMERICANO[roman type] - Para adecuar verbos al español de América.[line break][bold type]DIALECTO CASTELLANO[roman type] - Para adecuar verbos al español de España.[line break][bold type]FIN[roman type] - Para terminar la partida.[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break]Además de los verbos básicos, tienes las siguientes opciones:[paragraph break][bold type]REINICIAR[roman type] - Para volver a comenzar la partida.[line break][bold type]GUARDAR[roman type] - Para grabar tu posición.[line break][bold type]CARGAR[roman type] - Para recuperar una posición guardada.[line break][bold type]INVENTARIO[roman type] - Para mostrar los objetos que llevas.[line break][bold type]PUNTOS[roman type] - Para mostrar tu actual puntuación.[line break][bold type]TRANSCRIPT[roman type] - Para transcribir el juego en un archivo de texto.[line break][bold type]DIALECTO SUDAMERICANO[roman type] - Para adecuar verbos al español de América.[line break][bold type]DIALECTO CASTELLANO[roman type] - Para adecuar verbos al español de España.[line break][bold type]FIN[roman type] - Para terminar la partida.[line break]~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: ~Además de los verbos básicos, tienes las siguientes opciones:~]
    ParaContent(); print "Además de los verbos básicos, tienes las siguientes opciones:";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: bold type]
    ParaContent(); style bold;! [6: ~REINICIAR~]
    ParaContent(); print "REINICIAR";! [7: roman type]
    ParaContent(); style roman;! [8: ~ - Para volver a comenzar la partida.~]
    ParaContent(); print " - Para volver a comenzar la partida.";! [9: line break]
    ParaContent(); new_line;! [10: bold type]
    ParaContent(); style bold;! [11: ~GUARDAR~]
    ParaContent(); print "GUARDAR";! [12: roman type]
    ParaContent(); style roman;! [13: ~ - Para grabar tu posición.~]
    ParaContent(); print " - Para grabar tu posición.";! [14: line break]
    ParaContent(); new_line;! [15: bold type]
    ParaContent(); style bold;! [16: ~CARGAR~]
    ParaContent(); print "CARGAR";! [17: roman type]
    ParaContent(); style roman;! [18: ~ - Para recuperar una posición guardada.~]
    ParaContent(); print " - Para recuperar una posición guardada.";! [19: line break]
    ParaContent(); new_line;! [20: bold type]
    ParaContent(); style bold;! [21: ~INVENTARIO~]
    ParaContent(); print "INVENTARIO";! [22: roman type]
    ParaContent(); style roman;! [23: ~ - Para mostrar los objetos que llevas.~]
    ParaContent(); print " - Para mostrar los objetos que llevas.";! [24: line break]
    ParaContent(); new_line;! [25: bold type]
    ParaContent(); style bold;! [26: ~PUNTOS~]
    ParaContent(); print "PUNTOS";! [27: roman type]
    ParaContent(); style roman;! [28: ~ - Para mostrar tu actual puntuación.~]
    ParaContent(); print " - Para mostrar tu actual puntuación.";! [29: line break]
    ParaContent(); new_line;! [30: bold type]
    ParaContent(); style bold;! [31: ~TRANSCRIPT~]
    ParaContent(); print "TRANSCRIPT";! [32: roman type]
    ParaContent(); style roman;! [33: ~ - Para transcribir el juego en un archivo de texto.~]
    ParaContent(); print " - Para transcribir el juego en un archivo de texto.";! [34: line break]
    ParaContent(); new_line;! [35: bold type]
    ParaContent(); style bold;! [36: ~DIALECTO SUDAMERICANO~]
    ParaContent(); print "DIALECTO SUDAMERICANO";! [37: roman type]
    ParaContent(); style roman;! [38: ~ - Para adecuar verbos al español de América.~]
    ParaContent(); print " - Para adecuar verbos al español de América.";! [39: line break]
    ParaContent(); new_line;! [40: bold type]
    ParaContent(); style bold;! [41: ~DIALECTO CASTELLANO~]
    ParaContent(); print "DIALECTO CASTELLANO";! [42: roman type]
    ParaContent(); style roman;! [43: ~ - Para adecuar verbos al español de España.~]
    ParaContent(); print " - Para adecuar verbos al español de España.";! [44: line break]
    ParaContent(); new_line;! [45: bold type]
    ParaContent(); style bold;! [46: ~FIN~]
    ParaContent(); print "FIN";! [47: roman type]
    ParaContent(); style roman;! [48: ~ - Para terminar la partida.~]
    ParaContent(); print " - Para terminar la partida.";! [49: line break]
    ParaContent(); new_line; .L_Say861; .L_SayX840;rtrue;
];
[ R_TX_S_166 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break][italic type]Maldita seas musa escurridiza,[line break]me entregas tus caricias y tu beso[line break]y junto las palabras cual poseso,[line break]hundiéndome en tu arena movediza.[paragraph break]Te marchas convirtiéndome en ceniza[line break]y siento sobre el cuello un lazo grueso[line break]que asfixia deseando tu regreso,[line break]creciendo esta obsesión casi enfermiza.[paragraph break]Maldita por mostrarme las estrellas,[line break]las risas, el azul, el universo,[line break]la luz, el llanto y tantas cosas bellas.[paragraph break]Te marchas y me muestras el adverso[line break]dejándome en mi pecho mil querellas,[line break]incapaz de escribir un solo verso.[roman type][paragraph break][bold type]Roberto Menéndez[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break][italic type]Maldita seas musa escurridiza,[line break]me entregas tus caricias y tu beso[line break]y junto las palabras cual poseso,[line break]hundiéndome en tu arena movediza.[paragraph break]Te marchas convirtiéndome en ceniza[line break]y siento sobre el cuello un lazo grueso[line break]que asfixia deseando tu regreso,[line break]creciendo esta obsesión casi enfermiza.[paragraph break]Maldita por mostrarme las estrellas,[line break]las risas, el azul, el universo,[line break]la luz, el llanto y tantas cosas bellas.[paragraph break]Te marchas y me muestras el adverso[line break]dejándome en mi pecho mil querellas,[line break]incapaz de escribir un solo verso.[roman type][paragraph break][bold type]Roberto Menéndez[roman type]~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: italic type]
    ParaContent(); style underline;! [4: ~Maldita seas musa escurridiza,~]
    ParaContent(); print "Maldita seas musa escurridiza,";! [5: line break]
    ParaContent(); new_line;! [6: ~me entregas tus caricias y tu beso~]
    ParaContent(); print "me entregas tus caricias y tu beso";! [7: line break]
    ParaContent(); new_line;! [8: ~y junto las palabras cual poseso,~]
    ParaContent(); print "y junto las palabras cual poseso,";! [9: line break]
    ParaContent(); new_line;! [10: ~hundiéndome en tu arena movediza.~]
    ParaContent(); print "hundiéndome en tu arena movediza.";! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [12: ~Te marchas convirtiéndome en ceniza~]
    ParaContent(); print "Te marchas convirtiéndome en ceniza";! [13: line break]
    ParaContent(); new_line;! [14: ~y siento sobre el cuello un lazo grueso~]
    ParaContent(); print "y siento sobre el cuello un lazo grueso";! [15: line break]
    ParaContent(); new_line;! [16: ~que asfixia deseando tu regreso,~]
    ParaContent(); print "que asfixia deseando tu regreso,";! [17: line break]
    ParaContent(); new_line;! [18: ~creciendo esta obsesión casi enfermiza.~]
    ParaContent(); print "creciendo esta obsesión casi enfermiza.";! [19: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [20: ~Maldita por mostrarme las estrellas,~]
    ParaContent(); print "Maldita por mostrarme las estrellas,";! [21: line break]
    ParaContent(); new_line;! [22: ~las risas, el azul, el universo,~]
    ParaContent(); print "las risas, el azul, el universo,";! [23: line break]
    ParaContent(); new_line;! [24: ~la luz, el llanto y tantas cosas bellas.~]
    ParaContent(); print "la luz, el llanto y tantas cosas bellas.";! [25: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [26: ~Te marchas y me muestras el adverso~]
    ParaContent(); print "Te marchas y me muestras el adverso";! [27: line break]
    ParaContent(); new_line;! [28: ~dejándome en mi pecho mil querellas,~]
    ParaContent(); print "dejándome en mi pecho mil querellas,";! [29: line break]
    ParaContent(); new_line;! [30: ~incapaz de escribir un solo verso.~]
    ParaContent(); print "incapaz de escribir un solo verso.";! [31: roman type]
    ParaContent(); style roman;! [32: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [33: bold type]
    ParaContent(); style bold;! [34: ~Roberto Menéndez~]
    ParaContent(); print "Roberto Menéndez";! [35: roman type]
    ParaContent(); style roman; .L_Say862; .L_SayX841;rtrue;
];
[ R_TX_S_167 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Qué es este '[command prompt]'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Qué es este '[command prompt]'~]
    say__p=1;! [2: ~Qué es este '~]
    ParaContent(); print "Qué es este ~";! [3: command prompt]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->1);! [4: ~'~]
    ParaContent(); print "~"; .L_Say863; .L_SayX842;rtrue;
];
[ R_TX_S_168 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El texto [command prompt] expresa el mensaje:'Ok, ¿qué quieres hacer ahora?'  Puedes responder con una instrucción (generalmente un verbo en imperativo, seguido tal vez de preposiciones y objetos).  Por ejemplo, MIRA, MIRA EL PESCADO, TOMA EL PESCADO.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El texto [command prompt] expresa el mensaje:'Ok, ¿qué quieres hacer ahora?'  Puedes responder con una instrucción (generalmente un verbo en imperativo, seguido tal vez de preposiciones y objetos).  Por ejemplo, MIRA, MIRA EL PESCADO, TOMA EL PESCADO.~]
    say__p=1;! [2: ~El texto ~]
    ParaContent(); print "El texto ";! [3: command prompt]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->1);! [4: ~ expresa el mensaje:'Ok, ¿qué quieres hacer ahora?'  Puedes responder con una instrucción (generalmente un verbo en imperativo, seguido tal vez de preposiciones y objetos).  Por ejemplo, MIRA, MIRA EL PESCADO, TOMA EL PESCADO.~]
    ParaContent(); print " expresa el mensaje:~Ok, ¿qué quieres hacer ahora?~  Puedes responder con una instrucción (generalmente un verbo en imperativo, seguido tal vez de preposiciones y objetos).  Por ejemplo, MIRA, MIRA EL PESCADO, TOMA EL PESCADO."; .L_Say864; .L_SayX843;rtrue;
];
[ R_TX_S_169 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Lo primero que debes hacer es familiarizarte con lo que te rodea y tratar de dilucidar tu objetivo en el juego. Por eso, lee con cuidado el texto de intruducción del juego. Generalmente hay un par de pistas alli. También pégale una mirada a la habitación en donde estás, fijándote en las salidas que se listan y qué objetos se describen. Si algo de ello te interesa, puedes EXAMINAR alguno de ellos. [paragraph break]También puedes examinarte a ti mismo (EXAMINAME). El autor del juego tal vez ha dejado algunas pistas en la descripción de tu propio personaje. INVENTARIO te dirá lo que llevas.[paragraph break]Una vez que ya estés orientado, puedes empezar la exploración. Muevete de habitación en habitación, prestando atención a toda nueva salida en el mapa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Lo primero que debes hacer es familiarizarte con lo que te rodea y tratar de dilucidar tu objetivo en el juego. Por eso, lee con cuidado el texto de intruducción del juego. Generalmente hay un par de pistas alli. También pégale una mirada a la habitación en donde estás, fijándote en las salidas que se listan y qué objetos se describen. Si algo de ello te interesa, puedes EXAMINAR alguno de ellos. [paragraph break]También puedes examinarte a ti mismo (EXAMINAME). El autor del juego tal vez ha dejado algunas pistas en la descripción de tu propio personaje. INVENTARIO te dirá lo que llevas.[paragraph break]Una vez que ya estés orientado, puedes empezar la exploración. Muevete de habitación en habitación, prestando atención a toda nueva salida en el mapa.~]
    say__p=1;! [2: ~Lo primero que debes hacer es familiarizarte con lo que te rodea y tratar de dilucidar tu objetivo en el juego. Por eso, lee con cuidado el texto de intruducción del juego. Generalmente hay un par de pistas alli. También pégale una mirada a la habitación en donde estás, fijándote en las salidas que se listan y qué objetos se describen. Si algo de ello te interesa, puedes EXAMINAR alguno de ellos. ~]
    ParaContent(); print "Lo primero que debes hacer es familiarizarte con lo que te rodea y tratar de dilucidar tu objetivo en el juego. Por eso, lee con cuidado el texto de intruducción del juego. Generalmente hay un par de pistas alli. También pégale una mirada a la habitación en donde estás, fijándote en las salidas que se listan y qué objetos se describen. Si algo de ello te interesa, puedes EXAMINAR alguno de ellos. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~También puedes examinarte a ti mismo (EXAMINAME). El autor del juego tal vez ha dejado algunas pistas en la descripción de tu propio personaje. INVENTARIO te dirá lo que llevas.~]
    ParaContent(); print "También puedes examinarte a ti mismo (EXAMINAME). El autor del juego tal vez ha dejado algunas pistas en la descripción de tu propio personaje. INVENTARIO te dirá lo que llevas.";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~Una vez que ya estés orientado, puedes empezar la exploración. Muevete de habitación en habitación, prestando atención a toda nueva salida en el mapa.~]
    ParaContent(); print "Una vez que ya estés orientado, puedes empezar la exploración. Muevete de habitación en habitación, prestando atención a toda nueva salida en el mapa."; .L_Say865; .L_SayX844;rtrue;
];
[ R_TX_S_170 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~En todo momento del juego tu estás en una habitación (o localidad). Cuando llegas allí, el juego imprimirá una descripción de lo que puedes ver. Dicha descripción te dara información vital sobre dos cosas: cosas de la localidad con la que puedes interactuar y una lista de las salidas. Si algo de ello te interesa, puedes EXAMINAR algunos items. [paragraph break]Cuando quieras abandonar una habitación para ir a otro lugar, puedes decirlo usando las direcciones de una brújula: por ejemplo, IR AL NORTE. Para simplificar, puedes omitir el verbo IR, y usar solo las direcciones abreviadas. Puedes usar NORTE, SUR, ESTE, OESTE, NORESTE, SURESTE, NOROESTE, SUROESTE, ARRIBA, ABAJO o sus abreviaciones N, S, E, O, NE, SE, NO, SO, U(de UP) y D (de DOWN).[paragraph break]En algunas situaciones ENTRAR y SALIR también pueden serte útil.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En todo momento del juego tu estás en una habitación (o localidad). Cuando llegas allí, el juego imprimirá una descripción de lo que puedes ver. Dicha descripción te dara información vital sobre dos cosas: cosas de la localidad con la que puedes interactuar y una lista de las salidas. Si algo de ello te interesa, puedes EXAMINAR algunos items. [paragraph break]Cuando quieras abandonar una habitación para ir a otro lugar, puedes decirlo usando las direcciones de una brújula: por ejemplo, IR AL NORTE. Para simplificar, puedes omitir el verbo IR, y usar solo las direcciones abreviadas. Puedes usar NORTE, SUR, ESTE, OESTE, NORESTE, SURESTE, NOROESTE, SUROESTE, ARRIBA, ABAJO o sus abreviaciones N, S, E, O, NE, SE, NO, SO, U(de UP) y D (de DOWN).[paragraph break]En algunas situaciones ENTRAR y SALIR también pueden serte útil.~]
    say__p=1;! [2: ~En todo momento del juego tu estás en una habitación (o localidad). Cuando llegas allí, el juego imprimirá una descripción de lo que puedes ver. Dicha descripción te dara información vital sobre dos cosas: cosas de la localidad con la que puedes interactuar y una lista de las salidas. Si algo de ello te interesa, puedes EXAMINAR algunos items. ~]
    ParaContent(); print "En todo momento del juego tu estás en una habitación (o localidad). Cuando llegas allí, el juego imprimirá una descripción de lo que puedes ver. Dicha descripción te dara información vital sobre dos cosas: cosas de la localidad con la que puedes interactuar y una lista de las salidas. Si algo de ello te interesa, puedes EXAMINAR algunos items. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Cuando quieras abandonar una habitación para ir a otro lugar, puedes decirlo usando las direcciones de una brújula: por ejemplo, IR AL NORTE. Para simplificar, puedes omitir el verbo IR, y usar solo las direcciones abreviadas. Puedes usar NORTE, SUR, ESTE, OESTE, NORESTE, SURESTE, NOROESTE, SUROESTE, ARRIBA, ABAJO o sus abreviaciones N, S, E, O, NE, SE, NO, SO, U(de UP) y D (de DOWN).~]
    ParaContent(); print "Cuando quieras abandonar una habitación para ir a otro lugar, puedes decirlo usando las direcciones de una brújula: por ejemplo, IR AL NORTE. Para simplificar, puedes omitir el verbo IR, y usar solo las direcciones abreviadas. Puedes usar NORTE, SUR, ESTE, OESTE, NORESTE, SURESTE, NOROESTE, SUROESTE, ARRIBA, ABAJO o sus abreviaciones N, S, E, O, NE, SE, NO, SO, U(de UP) y D (de DOWN).";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~En algunas situaciones ENTRAR y SALIR también pueden serte útil.~]
    ParaContent(); print "En algunas situaciones ENTRAR y SALIR también pueden serte útil."; .L_Say866; .L_SayX845;rtrue;
];
[ R_TX_S_171 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A lo largo del juego te encontrarás con toda clase de objetos con los que interactuar y hacer cosas. Importante: puedes TOMAR o COGER items, y DEJARlos cuando te canses de ellos. INVENTARIO (abreviado I) mostrará una lista con los objetos que llevas contigo. [paragraph break]Hay varias cosas que puedes hacer con los objetos. Los más comunes son ABRIR, CERRAR, VESTIR, COMER, PONER O QUITAR CERROJO.[paragraph break]A veces el juego no reconocerá el nombre de un objeto aunque haya sido mencionado en la descripción de la localidad. En esa caso se trata de un escenario más bien que de un objeto. No lo necesitas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~A lo largo del juego te encontrarás con toda clase de objetos con los que interactuar y hacer cosas. Importante: puedes TOMAR o COGER items, y DEJARlos cuando te canses de ellos. INVENTARIO (abreviado I) mostrará una lista con los objetos que llevas contigo. [paragraph break]Hay varias cosas que puedes hacer con los objetos. Los más comunes son ABRIR, CERRAR, VESTIR, COMER, PONER O QUITAR CERROJO.[paragraph break]A veces el juego no reconocerá el nombre de un objeto aunque haya sido mencionado en la descripción de la localidad. En esa caso se trata de un escenario más bien que de un objeto. No lo necesitas.~]
    say__p=1;! [2: ~A lo largo del juego te encontrarás con toda clase de objetos con los que interactuar y hacer cosas. Importante: puedes TOMAR o COGER items, y DEJARlos cuando te canses de ellos. INVENTARIO (abreviado I) mostrará una lista con los objetos que llevas contigo. ~]
    ParaContent(); print "A lo largo del juego te encontrarás con toda clase de objetos con los que interactuar y hacer cosas. Importante: puedes TOMAR o COGER items, y DEJARlos cuando te canses de ellos. INVENTARIO (abreviado I) mostrará una lista con los objetos que llevas contigo. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Hay varias cosas que puedes hacer con los objetos. Los más comunes son ABRIR, CERRAR, VESTIR, COMER, PONER O QUITAR CERROJO.~]
    ParaContent(); print "Hay varias cosas que puedes hacer con los objetos. Los más comunes son ABRIR, CERRAR, VESTIR, COMER, PONER O QUITAR CERROJO.";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~A veces el juego no reconocerá el nombre de un objeto aunque haya sido mencionado en la descripción de la localidad. En esa caso se trata de un escenario más bien que de un objeto. No lo necesitas.~]
    ParaContent(); print "A veces el juego no reconocerá el nombre de un objeto aunque haya sido mencionado en la descripción de la localidad. En esa caso se trata de un escenario más bien que de un objeto. No lo necesitas."; .L_Say867; .L_SayX846;rtrue;
];
[ R_TX_S_172 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Existen un par de comandos para controlar el juego en sí. Estos son: [paragraph break]SALVAR graba la partida actual del juego. [line break]CARGAR carga una partida guardada. Puedes guardar tus partidas cuantas veces necesites. [line break]REINICIAR comienza el juego desde el principio. [line break]SALIR finaliza el juego.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Existen un par de comandos para controlar el juego en sí. Estos son: [paragraph break]SALVAR graba la partida actual del juego. [line break]CARGAR carga una partida guardada. Puedes guardar tus partidas cuantas veces necesites. [line break]REINICIAR comienza el juego desde el principio. [line break]SALIR finaliza el juego.~]
    say__p=1;! [2: ~Existen un par de comandos para controlar el juego en sí. Estos son: ~]
    ParaContent(); print "Existen un par de comandos para controlar el juego en sí. Estos son: ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~SALVAR graba la partida actual del juego. ~]
    ParaContent(); print "SALVAR graba la partida actual del juego. ";! [5: line break]
    ParaContent(); new_line;! [6: ~CARGAR carga una partida guardada. Puedes guardar tus partidas cuantas veces necesites. ~]
    ParaContent(); print "CARGAR carga una partida guardada. Puedes guardar tus partidas cuantas veces necesites. ";! [7: line break]
    ParaContent(); new_line;! [8: ~REINICIAR comienza el juego desde el principio. ~]
    ParaContent(); print "REINICIAR comienza el juego desde el principio. ";! [9: line break]
    ParaContent(); new_line;! [10: ~SALIR finaliza el juego.~]
    ParaContent(); print "SALIR finaliza el juego."; .L_Say868; .L_SayX847;rtrue;
];
[ R_TX_S_173 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Examina cada objeto del lugar y de tu inventario. Abre todas las puertas, ve por ellas. Mira dentro de todos los contenedores. Asegurate de agotar todas las opciones que tengas. [paragraph break]Prueba con todos tus sentidos. Si en el juego se mencionan texturas, olores y sonidos; intenta tocar, oler, escuchar o probar objetos.[paragraph break]No tengas escrúpulos. Si no se te ocurre nada más, prueba abriendo ventanas, mirando debajo de camas, etc. En ocasiones algunos objetos estan bien ocultos.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Examina cada objeto del lugar y de tu inventario. Abre todas las puertas, ve por ellas. Mira dentro de todos los contenedores. Asegurate de agotar todas las opciones que tengas. [paragraph break]Prueba con todos tus sentidos. Si en el juego se mencionan texturas, olores y sonidos; intenta tocar, oler, escuchar o probar objetos.[paragraph break]No tengas escrúpulos. Si no se te ocurre nada más, prueba abriendo ventanas, mirando debajo de camas, etc. En ocasiones algunos objetos estan bien ocultos.~]
    say__p=1;! [2: ~Examina cada objeto del lugar y de tu inventario. Abre todas las puertas, ve por ellas. Mira dentro de todos los contenedores. Asegurate de agotar todas las opciones que tengas. ~]
    ParaContent(); print "Examina cada objeto del lugar y de tu inventario. Abre todas las puertas, ve por ellas. Mira dentro de todos los contenedores. Asegurate de agotar todas las opciones que tengas. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Prueba con todos tus sentidos. Si en el juego se mencionan texturas, olores y sonidos; intenta tocar, oler, escuchar o probar objetos.~]
    ParaContent(); print "Prueba con todos tus sentidos. Si en el juego se mencionan texturas, olores y sonidos; intenta tocar, oler, escuchar o probar objetos.";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~No tengas escrúpulos. Si no se te ocurre nada más, prueba abriendo ventanas, mirando debajo de camas, etc. En ocasiones algunos objetos estan bien ocultos.~]
    ParaContent(); print "No tengas escrúpulos. Si no se te ocurre nada más, prueba abriendo ventanas, mirando debajo de camas, etc. En ocasiones algunos objetos estan bien ocultos."; .L_Say869; .L_SayX848;rtrue;
];
[ R_TX_S_174 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Lee y relee. Vuelve a mirar las cosas. A veces esto te prenderá la lamparita sobre algún detalle que estes omitiendo. [paragraph break]Trata de deducir pistas en los textos mismos del juego. Las cosas que se describen con alto detalle probablemente son más importantes que aquelllas que solo se mencionan. Interactua con dichos objetos. Si se describe una máquina y sus componentes, observa dichas partes, intenta jugar con ellas.  Toma nota de los verbos que el propio juego utiliza. Prueba usarlos también. Los juegos siempre incluyen verbos especiales (nombre de hechizos u otros comandos especiales). No está mal que quieras hacer algo si el juego lo menciona.[paragraph break]Escudriña toda la pantalla. ¿Existen ventanas extra?  ¿Qué sucede en ellas?  Observa la línea de estado, si existe. Normalmente te informa sobre el nombre de la habitación donde estás, tu puntuación, la hora en el juego, la salud del protagonista o algún otro dato importante.  Si ocurre algo alli, deberias prestarle atención.  ¿Cuando y dónde cambiaron los datos?  ¿Qué significa dicho cambio?  Si en la barra se describe tu salud, apuesta lo que sea a que en algún momento esta información será vital.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Lee y relee. Vuelve a mirar las cosas. A veces esto te prenderá la lamparita sobre algún detalle que estes omitiendo. [paragraph break]Trata de deducir pistas en los textos mismos del juego. Las cosas que se describen con alto detalle probablemente son más importantes que aquelllas que solo se mencionan. Interactua con dichos objetos. Si se describe una máquina y sus componentes, observa dichas partes, intenta jugar con ellas.  Toma nota de los verbos que el propio juego utiliza. Prueba usarlos también. Los juegos siempre incluyen verbos especiales (nombre de hechizos u otros comandos especiales). No está mal que quieras hacer algo si el juego lo menciona.[paragraph break]Escudriña toda la pantalla. ¿Existen ventanas extra?  ¿Qué sucede en ellas?  Observa la línea de estado, si existe. Normalmente te informa sobre el nombre de la habitación donde estás, tu puntuación, la hora en el juego, la salud del protagonista o algún otro dato importante.  Si ocurre algo alli, deberias prestarle atención.  ¿Cuando y dónde cambiaron los datos?  ¿Qué significa dicho cambio?  Si en la barra se describe tu salud, apuesta lo que sea a que en algún momento esta información será vital.~]
    say__p=1;! [2: ~Lee y relee. Vuelve a mirar las cosas. A veces esto te prenderá la lamparita sobre algún detalle que estes omitiendo. ~]
    ParaContent(); print "Lee y relee. Vuelve a mirar las cosas. A veces esto te prenderá la lamparita sobre algún detalle que estes omitiendo. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Trata de deducir pistas en los textos mismos del juego. Las cosas que se describen con alto detalle probablemente son más importantes que aquelllas que solo se mencionan. Interactua con dichos objetos. Si se describe una máquina y sus componentes, observa dichas partes, intenta jugar con ellas.  Toma nota de los verbos que el propio juego utiliza. Prueba usarlos también. Los juegos siempre incluyen verbos especiales (nombre de hechizos u otros comandos especiales). No está mal que quieras hacer algo si el juego lo menciona.~]
    ParaContent(); print "Trata de deducir pistas en los textos mismos del juego. Las cosas que se describen con alto detalle probablemente son más importantes que aquelllas que solo se mencionan. Interactua con dichos objetos. Si se describe una máquina y sus componentes, observa dichas partes, intenta jugar con ellas.  Toma nota de los verbos que el propio juego utiliza. Prueba usarlos también. Los juegos siempre incluyen verbos especiales (nombre de hechizos u otros comandos especiales). No está mal que quieras hacer algo si el juego lo menciona.";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~Escudriña toda la pantalla. ¿Existen ventanas extra?  ¿Qué sucede en ellas?  Observa la línea de estado, si existe. Normalmente te informa sobre el nombre de la habitación donde estás, tu puntuación, la hora en el juego, la salud del protagonista o algún otro dato importante.  Si ocurre algo alli, deberias prestarle atención.  ¿Cuando y dónde cambiaron los datos?  ¿Qué significa dicho cambio?  Si en la barra se describe tu salud, apuesta lo que sea a que en algún momento esta información será vital.~]
    ParaContent(); print "Escudriña toda la pantalla. ¿Existen ventanas extra?  ¿Qué sucede en ellas?  Observa la línea de estado, si existe. Normalmente te informa sobre el nombre de la habitación donde estás, tu puntuación, la hora en el juego, la salud del protagonista o algún otro dato importante.  Si ocurre algo alli, deberias prestarle atención.  ¿Cuando y dónde cambiaron los datos?  ¿Qué significa dicho cambio?  Si en la barra se describe tu salud, apuesta lo que sea a que en algún momento esta información será vital."; .L_Say870; .L_SayX849;rtrue;
];
[ R_TX_S_175 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Reescribe los comandos. Si hay algo que quieres hacer pero el juego no entiende, prueba expresarlo en otras palabras. [paragraph break] A veces una acción no funciona, aunque produce algo de resultado. Esto te da la pista de que vas por buen camino, a pesar de no conocer aun qué debes hacer exactamente. Con pulsar el botón rojo tal vez consigas un chirriante ruido dentro de la pared, por lo que pulsando primero el botón azul sea la clave para abrir una puerta secreta.[paragraph break]Toma en cuenta el género del juego. Misterio, romance y terror tienen sus propios perfiles de acción y motivación. ¿Qué estas intentando hacer y qué se supone que haga un personaje según el género del juego? ¿Cómo debe comportarse un detective o un espía?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Reescribe los comandos. Si hay algo que quieres hacer pero el juego no entiende, prueba expresarlo en otras palabras. [paragraph break] A veces una acción no funciona, aunque produce algo de resultado. Esto te da la pista de que vas por buen camino, a pesar de no conocer aun qué debes hacer exactamente. Con pulsar el botón rojo tal vez consigas un chirriante ruido dentro de la pared, por lo que pulsando primero el botón azul sea la clave para abrir una puerta secreta.[paragraph break]Toma en cuenta el género del juego. Misterio, romance y terror tienen sus propios perfiles de acción y motivación. ¿Qué estas intentando hacer y qué se supone que haga un personaje según el género del juego? ¿Cómo debe comportarse un detective o un espía?~]
    say__p=1;! [2: ~Reescribe los comandos. Si hay algo que quieres hacer pero el juego no entiende, prueba expresarlo en otras palabras. ~]
    ParaContent(); print "Reescribe los comandos. Si hay algo que quieres hacer pero el juego no entiende, prueba expresarlo en otras palabras. ";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~ A veces una acción no funciona, aunque produce algo de resultado. Esto te da la pista de que vas por buen camino, a pesar de no conocer aun qué debes hacer exactamente. Con pulsar el botón rojo tal vez consigas un chirriante ruido dentro de la pared, por lo que pulsando primero el botón azul sea la clave para abrir una puerta secreta.~]
    ParaContent(); print " A veces una acción no funciona, aunque produce algo de resultado. Esto te da la pista de que vas por buen camino, a pesar de no conocer aun qué debes hacer exactamente. Con pulsar el botón rojo tal vez consigas un chirriante ruido dentro de la pared, por lo que pulsando primero el botón azul sea la clave para abrir una puerta secreta.";! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [6: ~Toma en cuenta el género del juego. Misterio, romance y terror tienen sus propios perfiles de acción y motivación. ¿Qué estas intentando hacer y qué se supone que haga un personaje según el género del juego? ¿Cómo debe comportarse un detective o un espía?~]
    ParaContent(); print "Toma en cuenta el género del juego. Misterio, romance y terror tienen sus propios perfiles de acción y motivación. ¿Qué estas intentando hacer y qué se supone que haga un personaje según el género del juego? ¿Cómo debe comportarse un detective o un espía?"; .L_Say871; .L_SayX850;rtrue;
];
[ R_TX_S_176 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the current verbosity mode is verbose]Verbose room descriptions[end if][if the current verbosity mode is brief]Brief room descriptions[end if][if the current verbosity mode is superbrief]Superbrief room descriptions[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the current verbosity mode is verbose]Verbose room descriptions[end if][if the current verbosity mode is brief]Brief room descriptions[end if][if the current verbosity mode is superbrief]Superbrief room descriptions[end if]~]
    say__p=1;! [2: if the current verbosity mode is verbose]

    	if (~~(((((PHR_920_r30 ()) == I149_verbose))))) jump L_Say872;! [3: ~Verbose room descriptions~]
    ParaContent(); print "Verbose room descriptions";! [4: end if]

    	.L_Say872; .L_SayX851;! [5: if the current verbosity mode is brief]

    	if (~~(((((PHR_920_r30 ()) == I148_brief))))) jump L_Say873;! [6: ~Brief room descriptions~]
    ParaContent(); print "Brief room descriptions";! [7: end if]

    	.L_Say873; .L_SayX852;! [8: if the current verbosity mode is superbrief]

    	if (~~(((((PHR_920_r30 ()) == I150_superbrief))))) jump L_Say874;! [9: ~Superbrief room descriptions~]
    ParaContent(); print "Superbrief room descriptions";! [10: end if]

    	.L_Say874; .L_SayX853; .L_Say875; .L_SayX854;rtrue;
];
[ R_TX_S_177 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if notify mode is on]Score notification on[otherwise]Score notification off[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if notify mode is on]Score notification on[otherwise]Score notification off[end if]~]
    say__p=1;! [2: if notify mode is on]

    	if (~~(((notify_mode)))) jump L_Say876;! [3: ~Score notification on~]
    ParaContent(); print "Score notification on";! [4: otherwise]

    	jump L_SayX855; .L_Say876;! [5: ~Score notification off~]
    ParaContent(); print "Score notification off";! [6: end if]

    	.L_Say877; .L_SayX855; .L_Say878; .L_SayX856;rtrue;
];
[ R_TX_S_178 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[generic ask quip]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[generic ask quip]~]
    say__p=1;! [2: generic ask quip]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->19); .L_Say879; .L_SayX857;rtrue;
];
[ R_TX_S_179 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[generic tell quip]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[generic tell quip]~]
    say__p=1;! [2: generic tell quip]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20); .L_Say880; .L_SayX858;rtrue;
];
[ R_TX_S_180 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'Déjalo, déjalo estar'[roman type], dice la musa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'Déjalo, déjalo estar'[roman type], dice la musa.~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'Déjalo, déjalo estar'~]
    ParaContent(); print "~Déjalo, déjalo estar~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, dice la musa.~]
    ParaContent(); print ", dice la musa."; .L_Say881; .L_SayX859;rtrue;
];
[ R_TX_S_181 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'No... déjalo, ya perdió su rebaño, ahora descansa'[roman type], dice la musa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'No... déjalo, ya perdió su rebaño, ahora descansa'[roman type], dice la musa.~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'No... déjalo, ya perdió su rebaño, ahora descansa'~]
    ParaContent(); print "~No... déjalo, ya perdió su rebaño, ahora descansa~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, dice la musa.~]
    ParaContent(); print ", dice la musa."; .L_Say882; .L_SayX860;rtrue;
];
[ R_TX_S_182 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El hombre apenas puede hablar. Uno de los verdugos se acerca y te susurra al oído. [italic type]Dicen que robó una gallina para poder alimentar a su familia...[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El hombre apenas puede hablar. Uno de los verdugos se acerca y te susurra al oído. [italic type]Dicen que robó una gallina para poder alimentar a su familia...[roman type]~]
    say__p=1;! [2: ~El hombre apenas puede hablar. Uno de los verdugos se acerca y te susurra al oído. ~]
    ParaContent(); print "El hombre apenas puede hablar. Uno de los verdugos se acerca y te susurra al oído. ";! [3: italic type]
    ParaContent(); style underline;! [4: ~Dicen que robó una gallina para poder alimentar a su familia...~]
    ParaContent(); print "Dicen que robó una gallina para poder alimentar a su familia...";! [5: roman type]
    ParaContent(); style roman; .L_Say883; .L_SayX861;rtrue;
];
[ R_TX_S_183 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'¡Déjame en paz, asesino!'[roman type], te grita el hombre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'¡Déjame en paz, asesino!'[roman type], te grita el hombre.~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'¡Déjame en paz, asesino!'~]
    ParaContent(); print "~¡Déjame en paz, asesino!~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, te grita el hombre.~]
    ParaContent(); print ", te grita el hombre."; .L_Say884; .L_SayX862;rtrue;
];
[ R_TX_S_184 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El hombre observa con pavor la espada.[paragraph break]Le dices:[italic type]'Hay cierta poesía en morir por la propia espada de uno, blandida por su enemigo, ¿no es así?'[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El hombre observa con pavor la espada.[paragraph break]Le dices:[italic type]'Hay cierta poesía en morir por la propia espada de uno, blandida por su enemigo, ¿no es así?'[roman type]~]
    say__p=1;! [2: ~El hombre observa con pavor la espada.~]
    ParaContent(); print "El hombre observa con pavor la espada.";! [3: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [4: ~Le dices:~]
    ParaContent(); print "Le dices:";! [5: italic type]
    ParaContent(); style underline;! [6: ~'Hay cierta poesía en morir por la propia espada de uno, blandida por su enemigo, ¿no es así?'~]
    ParaContent(); print "~Hay cierta poesía en morir por la propia espada de uno, blandida por su enemigo, ¿no es así?~";! [7: roman type]
    ParaContent(); style roman; .L_Say885; .L_SayX863;rtrue;
];
[ R_TX_S_185 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]¡No, por favor, no me mates! Déjame marchar![roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]¡No, por favor, no me mates! Déjame marchar![roman type]~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~¡No, por favor, no me mates! Déjame marchar!~]
    ParaContent(); print "¡No, por favor, no me mates! Déjame marchar!";! [4: roman type]
    ParaContent(); style roman; .L_Say886; .L_SayX864;rtrue;
];
[ R_TX_S_186 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'¡Piedad, por favor! ¿Qué locura es ésta? ¡Soy inocente!'[roman type], te implora el hombre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'¡Piedad, por favor! ¿Qué locura es ésta? ¡Soy inocente!'[roman type], te implora el hombre.~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'¡Piedad, por favor! ¿Qué locura es ésta? ¡Soy inocente!'~]
    ParaContent(); print "~¡Piedad, por favor! ¿Qué locura es ésta? ¡Soy inocente!~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, te implora el hombre.~]
    ParaContent(); print ", te implora el hombre."; .L_Say887; .L_SayX865;rtrue;
];
[ R_TX_S_187 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'Muchas gracias, mi señor...'[roman type], dice la doncella.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'Muchas gracias, mi señor...'[roman type], dice la doncella.~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'Muchas gracias, mi señor...'~]
    ParaContent(); print "~Muchas gracias, mi señor...~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, dice la doncella.~]
    ParaContent(); print ", dice la doncella."; .L_Say888; .L_SayX866;rtrue;
];
[ R_TX_S_188 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'Pero... ¿qué has hecho?'[roman type], pregunta tu hermano...~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'Pero... ¿qué has hecho?'[roman type], pregunta tu hermano...~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'Pero... ¿qué has hecho?'~]
    ParaContent(); print "~Pero... ¿qué has hecho?~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, pregunta tu hermano...~]
    ParaContent(); print ", pregunta tu hermano..."; .L_Say889; .L_SayX867;rtrue;
];
[ R_TX_S_189 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'¿Cómo lo sabes?'[roman type], pregunta tu hermano...~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'¿Cómo lo sabes?'[roman type], pregunta tu hermano...~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'¿Cómo lo sabes?'~]
    ParaContent(); print "~¿Cómo lo sabes?~";! [4: roman type]
    ParaContent(); style roman;! [5: ~, pregunta tu hermano...~]
    ParaContent(); print ", pregunta tu hermano..."; .L_Say890; .L_SayX868;rtrue;
];
[ R_TX_S_190 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]'Así es, hermano. Por favor... ayúdame a encontrar un ternero, ¡debe haberse escapado!'[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]'Así es, hermano. Por favor... ayúdame a encontrar un ternero, ¡debe haberse escapado!'[roman type]~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~'Así es, hermano. Por favor... ayúdame a encontrar un ternero, ¡debe haberse escapado!'~]
    ParaContent(); print "~Así es, hermano. Por favor... ayúdame a encontrar un ternero, ¡debe haberse escapado!~";! [4: roman type]
    ParaContent(); style roman; .L_Say891; .L_SayX869;rtrue;
];
[ R_TX_S_191 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Has probado a escribir algo? Por ejemplo [italic type]'ESCRIBE VERSO EN LIBRO'.[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Has probado a escribir algo? Por ejemplo [italic type]'ESCRIBE VERSO EN LIBRO'.[roman type]~]
    say__p=1;! [2: ~¿Has probado a escribir algo? Por ejemplo ~]
    ParaContent(); print "¿Has probado a escribir algo? Por ejemplo ";! [3: italic type]
    ParaContent(); style underline;! [4: ~'ESCRIBE VERSO EN LIBRO'.~]
    ParaContent(); print "~ESCRIBE VERSO EN LIBRO~.";! [5: roman type]
    ParaContent(); style roman; .L_Say892; .L_SayX870;rtrue;
];
[ R_TX_S_192 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Puedes escribir lo que quieras, pero básicamente el juego entenderá una palabra, por ejemplo [italic type]'ESCRIBE AYUDA'.[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Puedes escribir lo que quieras, pero básicamente el juego entenderá una palabra, por ejemplo [italic type]'ESCRIBE AYUDA'.[roman type]~]
    say__p=1;! [2: ~Puedes escribir lo que quieras, pero básicamente el juego entenderá una palabra, por ejemplo ~]
    ParaContent(); print "Puedes escribir lo que quieras, pero básicamente el juego entenderá una palabra, por ejemplo ";! [3: italic type]
    ParaContent(); style underline;! [4: ~'ESCRIBE AYUDA'.~]
    ParaContent(); print "~ESCRIBE AYUDA~.";! [5: roman type]
    ParaContent(); style roman; .L_Say893; .L_SayX871;rtrue;
];
[ R_TX_S_193 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~F = [if menu depth > 1]Ult. Menú[otherwise]Fin Menú[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~F = [if menu depth > 1]Ult. Menú[otherwise]Fin Menú[end if]~]
    say__p=1;! [2: ~F = ~]
    ParaContent(); print "F = ";! [3: if menu depth > 1]

    	if (~~(((((Global_Vars-->12) > 1))))) jump L_Say894;! [4: ~Ult. Menú~]
    ParaContent(); print "Ult. Menú";! [5: otherwise]

    	jump L_SayX872; .L_Say894;! [6: ~Fin Menú~]
    ParaContent(); print "Fin Menú";! [7: end if]

    	.L_Say895; .L_SayX872; .L_Say896; .L_SayX873;rtrue;
];
Array TX_S_193 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_193;
[ R_TX_S_194 
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]Bienvenido a [bold type]La musa[roman type], una ficción interactiva escrita por Xavier Carrascosa e ilustrada por Mónica Clavijo, remake de la original de 2005 presentada en la XComp 1. Se trata de una aventura conversacional experimental en siete actos que puede resolverse con una sola orden. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?[paragraph break][italic type]'El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa.'[roman type][paragraph break][bold type]Premios recibidos:[roman type][paragraph break][bold type]XComp 1:[roman type][line break][italic type]Premio a la Mejor Aventura[roman type][line break][bold type]Premios Hispanos 2005:[roman type][line break][italic type]Nominada en las categorías de calidad literaria, interactividad y originalidad.[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break]Bienvenido a [bold type]La musa[roman type], una ficción interactiva escrita por Xavier Carrascosa e ilustrada por Mónica Clavijo, remake de la original de 2005 presentada en la XComp 1. Se trata de una aventura conversacional experimental en siete actos que puede resolverse con una sola orden. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?[paragraph break][italic type]'El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa.'[roman type][paragraph break][bold type]Premios recibidos:[roman type][paragraph break][bold type]XComp 1:[roman type][line break][italic type]Premio a la Mejor Aventura[roman type][line break][bold type]Premios Hispanos 2005:[roman type][line break][italic type]Nominada en las categorías de calidad literaria, interactividad y originalidad.[roman type]~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: ~Bienvenido a ~]
    ParaContent(); print "Bienvenido a ";! [4: bold type]
    ParaContent(); style bold;! [5: ~La musa~]
    ParaContent(); print "La musa";! [6: roman type]
    ParaContent(); style roman;! [7: ~, una ficción interactiva escrita por Xavier Carrascosa e ilustrada por Mónica Clavijo, remake de la original de 2005 presentada en la XComp 1. Se trata de una aventura conversacional experimental en siete actos que puede resolverse con una sola orden. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?~]
    ParaContent(); print ", una ficción interactiva escrita por Xavier Carrascosa e ilustrada por Mónica Clavijo, remake de la original de 2005 presentada en la XComp 1. Se trata de una aventura conversacional experimental en siete actos que puede resolverse con una sola orden. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?";! [8: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [9: italic type]
    ParaContent(); style underline;! [10: ~'El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa.'~]
    ParaContent(); print "~El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa.~";! [11: roman type]
    ParaContent(); style roman;! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [13: bold type]
    ParaContent(); style bold;! [14: ~Premios recibidos:~]
    ParaContent(); print "Premios recibidos:";! [15: roman type]
    ParaContent(); style roman;! [16: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [17: bold type]
    ParaContent(); style bold;! [18: ~XComp 1:~]
    ParaContent(); print "XComp 1:";! [19: roman type]
    ParaContent(); style roman;! [20: line break]
    ParaContent(); new_line;! [21: italic type]
    ParaContent(); style underline;! [22: ~Premio a la Mejor Aventura~]
    ParaContent(); print "Premio a la Mejor Aventura";! [23: roman type]
    ParaContent(); style roman;! [24: line break]
    ParaContent(); new_line;! [25: bold type]
    ParaContent(); style bold;! [26: ~Premios Hispanos 2005:~]
    ParaContent(); print "Premios Hispanos 2005:";! [27: roman type]
    ParaContent(); style roman;! [28: line break]
    ParaContent(); new_line;! [29: italic type]
    ParaContent(); style underline;! [30: ~Nominada en las categorías de calidad literaria, interactividad y originalidad.~]
    ParaContent(); print "Nominada en las categorías de calidad literaria, interactividad y originalidad.";! [31: roman type]
    ParaContent(); style roman; .L_Say897; .L_SayX874;rtrue;
];
Array TX_S_194 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_194;
[ R_TX_S_309 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[visibility ceiling]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[visibility ceiling]~]
    say__p=1;! [2: visibility ceiling]
    ParaContent(); PrintShortName((MStack-->MstVO(20011,3))); .L_Say898; .L_SayX875;rtrue;
];
Array TX_S_309 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_309;
[ R_TX_S_458 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[captured text]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[captured text]~]
    say__p=1;! [2: captured text]
    ParaContent(); PrintCapture(); .L_Say899; .L_SayX876;rtrue;
];
Array TX_S_458 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_458;
! Find next x satisfying:
! [ thing(x) ]
[ Prop_0 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'enterable'(x) & called='box'(thing)(x) & is('the location', ContainerOf(x)) ]
[ Prop_1 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_80_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_2 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_3 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_4 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_76_t1_v10(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_5 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_76_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Abstraction for set of x such that:
! [ thing(x) & thing(x) & 'unmentioned'(x) ]
[ Prop_6 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if ((x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && (x ofclass K2_thing) && ((Adj_79_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Find next x satisfying:
! [ thing(x) & not-'handled'(x) & supporter(const_0) & provides(const_1, 'the property initial appearance') & is(const_2, SupporterOf(x)) ]
[ Prop_7 
    const_0 ! Implied call parameter
    const_1 ! Implied call parameter
    const_2 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_2) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && (~~((Adj_73_t1_v10(x)))) && (const_0 ofclass K6_supporter) && (WhetherProvides(const_1, false, initial))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_8 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_9 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_10 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_11 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_12 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_13 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_14 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(player's holdall)(x) & is('actor', HolderOf(x)) ]
[ Prop_15 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=nothing: false: ){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_16 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_17 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_18 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_19 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', SupporterOf(x)) ]
[ Prop_20 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', ContainerOf(x)) ]
[ Prop_21 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : person(x) & called='owner'(person)(x) & NOT[ is(x, 'the actor') NOT] & encloses(x, 'noun') ]
[ Prop_22 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == actor))){
            if ((IndirectlyContains(x,noun))){
                deferred_calling_list-->0 = x;
                rtrue;
            }
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ thing(x) & is('the noun', SupporterOf(x)) ]
[ Prop_23 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the noun', ContainerOf(x)) ]
[ Prop_24 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_25 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('the noun', ContainerOf(x)) ]
[ Prop_26 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_74_t1_v10(x)))){
            if (~~(((Adj_70_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'the player') NOT] & is('the noun', ContainerOf(x)) ]
[ Prop_27 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('the noun', SupporterOf(x)) ]
[ Prop_28 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_74_t1_v10(x)))){
            if (~~(((Adj_70_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'the player') NOT] & is('the noun', SupporterOf(x)) ]
[ Prop_29 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_30 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_74_t1_v10(x)))){
            if (~~(((Adj_70_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_31 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_74_t1_v10(x)))){
            if (~~(((Adj_70_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_32 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', CarrierOf(x)) ]
[ Prop_33 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ g-window(x) ]
[ Prop_34 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ g-window(x) ]
[ Prop_35 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ g-window(x) & 'g-present'(x) & 'graphical'(x) ]
[ Prop_36 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        if (((Adj_102_t1_v10(x))) && ((Adj_44_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : g-window(x) & 'g-present'(x) & is(const_0, ContainerOf(x)) ]
[ Prop_37 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K16_g_window) && ((Adj_102_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : g-window(x) & 'g-present'(x) & is(const_0, ContainerOf(x)) ]
[ Prop_38 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K16_g_window) && ((Adj_102_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Force this to be true via 'now':
! [ ForAll x IN[ g-window(x) & encloses(x, const_0) IN] : 'g-required'(x) ]
[ Prop_39 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK16_First: x: x=x.IK16_Link){
        if ((IndirectlyContains(x,const_0))){
            qcn_0++;
            (Adj_100_t2_v10(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ g-window(x) & encloses(const_0, x) IN] : 'g-unrequired'(x) ]
[ Prop_40 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK16_First: x: x=x.IK16_Link){
        if ((IndirectlyContains(const_0,x))){
            qcn_0++;
            (Adj_101_t2_v10(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ g-window(x) ]
[ Prop_41 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : g-window(x) & not-'currently being processed'(x) & 'g-unrequired'(x) & 'g-present'(x) & 'childless'(x) & called='win'(g-window)(x) ]
[ Prop_42 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK16_First: x: x=x.IK16_Link){
        if ((~~((Adj_104_t1_v10(x)))) && ((Adj_101_t1_v10(x))) && ((Adj_102_t1_v10(x))) && ((~~Adj_50_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : g-window(x) & not-'currently being processed'(x) & 'g-required'(x) & 'g-unpresent'(x) & 'a next-step'(x) & called='win'(g-window)(x) ]
[ Prop_43 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK16_First: x: x=x.IK16_Link){
        if ((~~((Adj_104_t1_v10(x)))) && ((Adj_100_t1_v10(x))) && ((Adj_103_t1_v10(x))) && ((Adj_52_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ g-window(x) & 'g-present'(x) & 'non-buffering'(x) ]
[ Prop_44 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        if (((Adj_102_t1_v10(x))) && ((~~Adj_46_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ g-window(x) ]
[ Prop_45 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK16_First: x: x=x.IK16_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

Constant R_11_RESP_A = 1;
Constant R_39_RESP_A = 2;
Constant R_40_RESP_A = 3;
Constant R_41_RESP_A = 4;
Constant R_41_RESP_B = 5;
Constant R_42_RESP_A = 6;
Constant R_46_RESP_A = 7;
Constant R_46_RESP_B = 8;
Constant R_46_RESP_C = 9;
Constant R_46_RESP_D = 10;
Constant R_46_RESP_E = 11;
Constant R_46_RESP_F = 12;
Constant R_53_RESP_A = 13;
Constant R_55_RESP_A = 14;
Constant R_56_RESP_A = 15;
Constant R_57_RESP_A = 16;
Constant R_58_RESP_A = 17;
Constant R_59_RESP_A = 18;
Constant R_60_RESP_A = 19;
Constant R_61_RESP_A = 20;
Constant R_62_RESP_A = 21;
Constant R_63_RESP_A = 22;
Constant R_64_RESP_A = 23;
Constant R_65_RESP_A = 24;
Constant R_66_RESP_A = 25;
Constant R_67_RESP_A = 26;
Constant R_68_RESP_A = 27;
Constant R_69_RESP_A = 28;
Constant R_70_RESP_A = 29;
Constant R_71_RESP_A = 30;
Constant R_73_RESP_A = 31;
Constant R_73_RESP_B = 32;
Constant R_74_RESP_A = 33;
Constant R_75_RESP_A = 34;
Constant R_77_RESP_A = 35;
Constant R_78_RESP_A = 36;
Constant R_79_RESP_A = 37;
Constant R_80_RESP_A = 38;
Constant R_81_RESP_A = 39;
Constant R_82_RESP_A = 40;
Constant R_82_RESP_B = 41;
Constant R_84_RESP_A = 42;
Constant R_84_RESP_B = 43;
Constant R_87_RESP_A = 44;
Constant R_88_RESP_A = 45;
Constant R_89_RESP_A = 46;
Constant R_90_RESP_A = 47;
Constant R_92_RESP_A = 48;
Constant R_93_RESP_A = 49;
Constant R_96_RESP_A = 50;
Constant R_97_RESP_A = 51;
Constant R_98_RESP_A = 52;
Constant R_99_RESP_A = 53;
Constant R_100_RESP_A = 54;
Constant R_102_RESP_A = 55;
Constant R_103_RESP_A = 56;
Constant R_104_RESP_A = 57;
Constant R_105_RESP_A = 58;
Constant R_106_RESP_A = 59;
Constant R_109_RESP_A = 60;
Constant R_109_RESP_B = 61;
Constant R_111_RESP_A = 62;
Constant R_112_RESP_A = 63;
Constant R_112_RESP_B = 64;
Constant R_113_RESP_A = 65;
Constant R_114_RESP_A = 66;
Constant R_116_RESP_A = 67;
Constant R_116_RESP_B = 68;
Constant R_120_RESP_A = 69;
Constant R_120_RESP_B = 70;
Constant R_120_RESP_C = 71;
Constant R_120_RESP_D = 72;
Constant R_120_RESP_E = 73;
Constant R_120_RESP_F = 74;
Constant R_120_RESP_G = 75;
Constant R_120_RESP_H = 76;
Constant R_120_RESP_I = 77;
Constant R_120_RESP_J = 78;
Constant R_120_RESP_K = 79;
Constant R_120_RESP_L = 80;
Constant R_120_RESP_M = 81;
Constant R_120_RESP_N = 82;
Constant R_120_RESP_O = 83;
Constant R_120_RESP_P = 84;
Constant R_120_RESP_Q = 85;
Constant R_120_RESP_R = 86;
Constant R_120_RESP_S = 87;
Constant R_124_RESP_A = 88;
Constant R_124_RESP_B = 89;
Constant R_125_RESP_A = 90;
Constant R_125_RESP_B = 91;
Constant R_125_RESP_C = 92;
Constant R_125_RESP_D = 93;
Constant R_126_RESP_A = 94;
Constant R_127_RESP_A = 95;
Constant R_127_RESP_B = 96;
Constant R_128_RESP_A = 97;
Constant R_129_RESP_A = 98;
Constant R_129_RESP_B = 99;
Constant R_129_RESP_C = 100;
Constant R_129_RESP_D = 101;
Constant R_129_RESP_E = 102;
Constant R_131_RESP_A = 103;
Constant R_131_RESP_B = 104;
Constant R_131_RESP_C = 105;
Constant R_131_RESP_D = 106;
Constant R_134_RESP_A = 107;
Constant R_135_RESP_A = 108;
Constant R_138_RESP_A = 109;
Constant R_138_RESP_B = 110;
Constant R_138_RESP_C = 111;
Constant R_140_RESP_A = 112;
Constant R_142_RESP_A = 113;
Constant R_146_RESP_A = 114;
Constant R_146_RESP_B = 115;
Constant R_146_RESP_C = 116;
Constant R_147_RESP_A = 117;
Constant R_150_RESP_A = 118;
Constant R_152_RESP_A = 119;
Constant R_153_RESP_A = 120;
Constant R_153_RESP_B = 121;
Constant R_154_RESP_A = 122;
Constant R_155_RESP_A = 123;
Constant R_156_RESP_A = 124;
Constant R_157_RESP_A = 125;
Constant R_158_RESP_A = 126;
Constant R_159_RESP_A = 127;
Constant R_160_RESP_A = 128;
Constant R_161_RESP_A = 129;
Constant R_162_RESP_A = 130;
Constant R_162_RESP_B = 131;
Constant R_163_RESP_A = 132;
Constant R_163_RESP_B = 133;
Constant R_164_RESP_A = 134;
Constant R_165_RESP_A = 135;
Constant R_165_RESP_B = 136;
Constant R_166_RESP_A = 137;
Constant R_167_RESP_A = 138;
Constant R_168_RESP_A = 139;
Constant R_169_RESP_A = 140;
Constant R_171_RESP_A = 141;
Constant R_171_RESP_B = 142;
Constant R_172_RESP_A = 143;
Constant R_173_RESP_A = 144;
Constant R_174_RESP_A = 145;
Constant R_176_RESP_A = 146;
Constant R_176_RESP_B = 147;
Constant R_177_RESP_A = 148;
Constant R_178_RESP_A = 149;
Constant R_180_RESP_A = 150;
Constant R_181_RESP_A = 151;
Constant R_182_RESP_A = 152;
Constant R_184_RESP_A = 153;
Constant R_185_RESP_A = 154;
Constant R_186_RESP_A = 155;
Constant R_187_RESP_A = 156;
Constant R_189_RESP_A = 157;
Constant R_190_RESP_A = 158;
Constant R_190_RESP_B = 159;
Constant R_190_RESP_C = 160;
Constant R_191_RESP_A = 161;
Constant R_192_RESP_A = 162;
Constant R_194_RESP_A = 163;
Constant R_194_RESP_B = 164;
Constant R_194_RESP_C = 165;
Constant R_195_RESP_A = 166;
Constant R_196_RESP_A = 167;
Constant R_197_RESP_A = 168;
Constant R_199_RESP_A = 169;
Constant R_199_RESP_B = 170;
Constant R_200_RESP_A = 171;
Constant R_201_RESP_A = 172;
Constant R_203_RESP_A = 173;
Constant R_203_RESP_B = 174;
Constant R_204_RESP_A = 175;
Constant R_205_RESP_A = 176;
Constant R_206_RESP_A = 177;
Constant R_207_RESP_A = 178;
Constant R_208_RESP_A = 179;
Constant R_209_RESP_A = 180;
Constant R_211_RESP_A = 181;
Constant R_211_RESP_B = 182;
Constant R_211_RESP_C = 183;
Constant R_212_RESP_A = 184;
Constant R_214_RESP_A = 185;
Constant R_215_RESP_A = 186;
Constant R_216_RESP_A = 187;
Constant R_217_RESP_A = 188;
Constant R_218_RESP_A = 189;
Constant R_219_RESP_A = 190;
Constant R_220_RESP_A = 191;
Constant R_221_RESP_A = 192;
Constant R_222_RESP_A = 193;
Constant R_223_RESP_A = 194;
Constant R_224_RESP_A = 195;
Constant R_225_RESP_A = 196;
Constant R_228_RESP_A = 197;
Constant R_228_RESP_B = 198;
Constant R_229_RESP_A = 199;
Constant R_229_RESP_B = 200;
Constant R_230_RESP_A = 201;
Constant R_230_RESP_B = 202;
Constant R_230_RESP_C = 203;
Constant R_231_RESP_A = 204;
Constant R_231_RESP_B = 205;
Constant R_232_RESP_A = 206;
Constant R_233_RESP_A = 207;
Constant R_233_RESP_B = 208;
Constant R_234_RESP_A = 209;
Constant R_235_RESP_A = 210;
Constant R_236_RESP_A = 211;
Constant R_237_RESP_A = 212;
Constant R_237_RESP_B = 213;
Constant R_238_RESP_A = 214;
Constant R_239_RESP_A = 215;
Constant R_240_RESP_A = 216;
Constant R_241_RESP_A = 217;
Constant R_241_RESP_B = 218;
Constant R_242_RESP_A = 219;
Constant R_243_RESP_A = 220;
Constant R_244_RESP_A = 221;
Constant R_245_RESP_A = 222;
Constant R_245_RESP_B = 223;
Constant R_246_RESP_A = 224;
Constant R_247_RESP_A = 225;
Constant R_248_RESP_A = 226;
Constant R_249_RESP_A = 227;
Constant R_251_RESP_A = 228;
Constant R_252_RESP_A = 229;
Constant R_253_RESP_A = 230;
Constant R_253_RESP_B = 231;
Constant R_254_RESP_A = 232;
Constant R_255_RESP_A = 233;
Constant R_256_RESP_A = 234;
Constant R_257_RESP_A = 235;
Constant R_258_RESP_A = 236;
Constant R_259_RESP_A = 237;
Constant R_259_RESP_B = 238;
Constant R_260_RESP_A = 239;
Constant R_260_RESP_B = 240;
Constant R_261_RESP_A = 241;
Constant R_261_RESP_B = 242;
Constant R_262_RESP_A = 243;
Constant R_263_RESP_A = 244;
Constant R_263_RESP_B = 245;
Constant R_264_RESP_A = 246;
Constant R_265_RESP_A = 247;
Constant R_266_RESP_A = 248;
Constant R_267_RESP_A = 249;
Constant R_268_RESP_A = 250;
Constant R_269_RESP_A = 251;
Constant R_269_RESP_B = 252;
Constant R_270_RESP_A = 253;
Constant R_271_RESP_A = 254;
Constant R_271_RESP_B = 255;
Constant R_272_RESP_A = 256;
Constant R_273_RESP_A = 257;
Constant R_274_RESP_A = 258;
Constant R_275_RESP_A = 259;
Constant R_275_RESP_B = 260;
Constant R_275_RESP_C = 261;
Constant R_279_RESP_A = 262;
Constant R_359_RESP_A = 263;
Constant R_361_RESP_A = 264;
Constant R_361_RESP_B = 265;
Constant R_368_RESP_A = 266;
Constant R_369_RESP_A = 267;
Constant R_371_RESP_A = 268;
Constant R_372_RESP_A = 269;
Constant R_375_RESP_A = 270;
Constant R_376_RESP_A = 271;
Constant R_377_RESP_A = 272;
Constant R_378_RESP_A = 273;
Constant R_379_RESP_A = 274;
Constant R_379_RESP_B = 275;
Constant R_379_RESP_C = 276;
Constant R_379_RESP_D = 277;
Constant R_379_RESP_E = 278;
Constant R_379_RESP_F = 279;
Constant R_379_RESP_G = 280;
Constant R_379_RESP_H = 281;
Constant R_379_RESP_I = 282;
Constant R_379_RESP_J = 283;
Constant R_379_RESP_K = 284;
Constant R_379_RESP_L = 285;
Constant R_379_RESP_M = 286;
Constant R_379_RESP_N = 287;
Constant R_379_RESP_O = 288;
Constant R_379_RESP_P = 289;
Constant R_379_RESP_Q = 290;
Constant R_379_RESP_R = 291;
Constant R_379_RESP_S = 292;
Constant R_379_RESP_T = 293;
Constant R_379_RESP_U = 294;
Constant R_379_RESP_V = 295;
Constant R_379_RESP_W = 296;
Constant R_379_RESP_X = 297;
Constant R_379_RESP_Y = 298;
Constant R_380_RESP_A = 299;
Constant R_380_RESP_B = 300;
Constant R_380_RESP_C = 301;
Constant R_380_RESP_D = 302;
Constant R_380_RESP_E = 303;
Constant R_380_RESP_F = 304;
Constant R_380_RESP_G = 305;
Constant R_380_RESP_H = 306;
Constant R_380_RESP_I = 307;
Constant R_380_RESP_J = 308;
Constant R_380_RESP_K = 309;
Constant R_381_RESP_A = 310;
Constant R_381_RESP_B = 311;
Constant R_381_RESP_C = 312;
Constant R_381_RESP_D = 313;
Constant R_381_RESP_E = 314;
Constant R_381_RESP_F = 315;
Constant R_381_RESP_G = 316;
Constant R_381_RESP_H = 317;
Constant R_381_RESP_I = 318;
Constant R_381_RESP_J = 319;
Constant R_381_RESP_K = 320;
Constant R_381_RESP_L = 321;
Constant R_381_RESP_M = 322;
Constant R_381_RESP_N = 323;
Constant R_381_RESP_O = 324;
Constant R_381_RESP_P = 325;
Constant R_381_RESP_Q = 326;
Constant R_381_RESP_R = 327;
Constant R_381_RESP_S = 328;
Constant R_381_RESP_T = 329;
Constant R_381_RESP_U = 330;
Constant R_381_RESP_V = 331;
Constant R_381_RESP_W = 332;
Constant R_381_RESP_X = 333;
Constant R_382_RESP_A = 334;
Constant R_382_RESP_B = 335;
Constant R_382_RESP_C = 336;
Constant R_382_RESP_D = 337;
Constant R_382_RESP_E = 338;
Constant R_382_RESP_F = 339;
Constant R_383_RESP_A = 340;
Constant R_384_RESP_A = 341;
Constant R_384_RESP_B = 342;
Constant R_384_RESP_C = 343;
Constant R_384_RESP_D = 344;
Constant R_385_RESP_A = 345;
Constant R_385_RESP_B = 346;
Constant R_385_RESP_C = 347;
Constant R_385_RESP_D = 348;
Constant R_385_RESP_E = 349;
Constant R_385_RESP_F = 350;
Constant R_385_RESP_G = 351;
Constant R_385_RESP_H = 352;
Constant R_386_RESP_A = 353;
Constant R_387_RESP_A = 354;
Constant R_387_RESP_B = 355;
Constant R_387_RESP_C = 356;
Constant R_390_RESP_A = 357;
Constant R_390_RESP_B = 358;
Constant R_392_RESP_A = 359;
Constant R_392_RESP_B = 360;
Constant R_392_RESP_C = 361;
Constant R_398_RESP_A = 362;
Constant R_398_RESP_B = 363;
Constant R_398_RESP_C = 364;
Constant R_398_RESP_D = 365;
Constant R_398_RESP_E = 366;
Constant R_398_RESP_F = 367;
Constant R_401_RESP_A = 368;
Constant R_402_RESP_A = 369;
Constant R_402_RESP_B = 370;
Constant R_403_RESP_A = 371;
Constant R_403_RESP_B = 372;
Constant R_404_RESP_A = 373;
Constant R_404_RESP_B = 374;
Constant R_405_RESP_A = 375;
Constant R_405_RESP_B = 376;
Constant R_406_RESP_A = 377;
Constant R_406_RESP_B = 378;
Constant R_406_RESP_C = 379;
Constant R_407_RESP_A = 380;
Constant R_407_RESP_B = 381;
Constant R_407_RESP_C = 382;
Constant R_409_RESP_A = 383;
Constant R_409_RESP_B = 384;
Constant R_409_RESP_C = 385;
Constant R_409_RESP_D = 386;
Constant R_409_RESP_E = 387;
Constant R_411_RESP_A = 388;
Constant R_413_RESP_A = 389;
Constant R_415_RESP_A = 390;
Constant R_417_RESP_A = 391;
Constant R_419_RESP_A = 392;
Constant R_420_RESP_A = 393;
Constant R_420_RESP_B = 394;
Constant R_420_RESP_C = 395;
Constant R_420_RESP_D = 396;
Constant NO_RESPONSES = 396;
Array ResponseTexts -->
    TX_S_195 TX_S_459 TX_S_199 TX_S_460 TX_S_461 TX_S_462 TX_S_463 TX_S_464 TX_S_465 TX_S_466 TX_S_467 TX_S_468 TX_S_469 TX_S_470 TX_S_209 TX_S_471 TX_S_472 TX_S_473 TX_S_474 TX_S_475 TX_S_476 TX_S_477 TX_S_478 TX_S_479 TX_S_480 TX_S_481 TX_S_482 TX_S_483 TX_S_484 TX_S_485 TX_S_486 TX_S_487 TX_S_488 TX_S_489 TX_S_490 TX_S_491 TX_S_492 TX_S_493 TX_S_494 TX_S_495 TX_S_496 TX_S_497 TX_S_498 TX_S_499 TX_S_500 TX_S_501 TX_S_502 TX_S_503 TX_S_504 TX_S_505 TX_S_506 TX_S_507 TX_S_508 TX_S_509 TX_S_510 TX_S_511 TX_S_512 TX_S_513 TX_S_514 TX_S_515 TX_S_516 TX_S_517 TX_S_518 TX_S_519 TX_S_520 TX_S_521 TX_S_522 TX_S_523 TX_S_524 TX_S_525 TX_S_526 TX_S_527 TX_S_528 TX_S_529 TX_S_530 TX_S_531 TX_S_532 TX_S_533 TX_S_534 TX_S_535 TX_S_536 TX_S_537 TX_S_538 TX_S_539 TX_S_540 TX_S_541 TX_S_542 TX_S_543 TX_S_544 TX_S_284 TX_S_285 TX_S_286 TX_S_545 TX_S_546 TX_S_289 TX_S_290 TX_S_547 TX_S_548 TX_S_549 TX_S_550 TX_S_551 TX_S_552 TX_S_553 TX_S_554 TX_S_555 TX_S_556 TX_S_557 TX_S_558 TX_S_559 TX_S_560 TX_S_561 TX_S_562 TX_S_563 TX_S_564 TX_S_565 TX_S_566 TX_S_567 TX_S_568 TX_S_569 TX_S_570 TX_S_571 TX_S_572 TX_S_573 TX_S_574 TX_S_575 TX_S_576 TX_S_577 TX_S_578 TX_S_579 TX_S_580 TX_S_581 TX_S_582 TX_S_583 TX_S_584 TX_S_585 TX_S_586 TX_S_587 TX_S_588 TX_S_589 TX_S_590 TX_S_591 TX_S_592 TX_S_593 TX_S_594 TX_S_595 TX_S_596 TX_S_597 TX_S_598 TX_S_599 TX_S_600 TX_S_601 TX_S_602 TX_S_603 TX_S_604 TX_S_605 TX_S_606 TX_S_607 TX_S_608 TX_S_609 TX_S_610 TX_S_611 TX_S_612 TX_S_613 TX_S_614 TX_S_615 TX_S_616 TX_S_617 TX_S_618 TX_S_619 TX_S_620 TX_S_621 TX_S_622 TX_S_623 TX_S_624 TX_S_625 TX_S_626 TX_S_627 TX_S_628 TX_S_629 TX_S_630 TX_S_631 TX_S_632 TX_S_633 TX_S_634 TX_S_635 TX_S_636 TX_S_637 TX_S_638 TX_S_639 TX_S_640 TX_S_641 TX_S_642 TX_S_643 TX_S_644 TX_S_645 TX_S_646 TX_S_647 TX_S_648 TX_S_649 TX_S_650 TX_S_651 TX_S_652 TX_S_653 TX_S_654 TX_S_655 TX_S_656 TX_S_657 TX_S_658 TX_S_659 TX_S_660 TX_S_661 TX_S_662 TX_S_663 TX_S_664 TX_S_665 TX_S_666 TX_S_667 TX_S_668 TX_S_669 TX_S_670 TX_S_671 TX_S_672 TX_S_673 TX_S_674 TX_S_675 TX_S_676 TX_S_677 TX_S_678 TX_S_679 TX_S_680 TX_S_681 TX_S_682 TX_S_683 TX_S_684 TX_S_685 TX_S_686 TX_S_687 TX_S_688 TX_S_689 TX_S_690 TX_S_691 TX_S_692 TX_S_693 TX_S_694 TX_S_695 TX_S_696 TX_S_697 TX_S_698 TX_S_699 TX_S_700 TX_S_701 TX_S_702 TX_S_703 TX_S_704 TX_S_705 TX_S_706 TX_S_707 TX_S_708 TX_S_308 TX_S_310 TX_S_311 TX_S_709 TX_S_710 TX_S_711 TX_S_712 TX_S_713 TX_S_714 TX_S_715 TX_S_716 TX_S_7 TX_S_717 TX_S_718 TX_S_719 TX_S_720 TX_S_721 TX_S_722 TX_S_723 TX_S_724 TX_S_725 TX_S_726 TX_S_727 TX_S_728 TX_S_729 TX_S_730 TX_S_731 TX_S_732 TX_S_733 TX_S_734 TX_S_735 TX_S_736 TX_S_737 TX_S_738 TX_S_739 TX_S_740 TX_S_741 TX_S_742 TX_S_743 TX_S_744 TX_S_745 TX_S_746 TX_S_747 TX_S_748 TX_S_749 TX_S_750 TX_S_751 TX_S_752 TX_S_753 TX_S_754 TX_S_755 TX_S_756 TX_S_757 TX_S_758 TX_S_759 TX_S_760 TX_S_761 TX_S_762 TX_S_763 TX_S_764 TX_S_765 TX_S_766 TX_S_767 TX_S_768 TX_S_769 TX_S_770 TX_S_771 TX_S_772 TX_S_773 TX_S_774 TX_S_775 TX_S_776 TX_S_777 TX_S_778 TX_S_779 TX_S_780 TX_S_781 TX_S_782 TX_S_783 TX_S_784 TX_S_785 TX_S_786 TX_S_787 TX_S_788 TX_S_789 TX_S_790 TX_S_791 TX_S_792 TX_S_793 TX_S_794 TX_S_795 TX_S_796 TX_S_797 TX_S_798 TX_S_799 TX_S_800 TX_S_801 TX_S_802 TX_S_803 TX_S_804 TX_S_805 TX_S_806 TX_S_807 TX_S_808 TX_S_809 TX_S_810 TX_S_811 TX_S_812 TX_S_813 TX_S_814 TX_S_815 TX_S_816 TX_S_817 TX_S_818 TX_S_819 TX_S_820 TX_S_821 TX_S_822 TX_S_114 TX_S_115 TX_S_116 TX_S_823 TX_S_824 TX_S_825 TX_S_826 TX_S_827 TX_S_828 TX_S_829 TX_S_830 TX_S_831 TX_S_832 TX_S_833 TX_S_834 TX_S_835 TX_S_836 TX_S_837 TX_S_838 TX_S_839 0 0;
[ PrintResponse 
    R ! Implied call parameter
    ;
    if (R == R_359_RESP_A) print (RulePrintingRule) ADJUST_LIGHT_R, " response (A)";
    if (R == R_361_RESP_A) print (RulePrintingRule) GENERATE_ACTION_R, " response (A)";
    if (R == R_361_RESP_B) print (RulePrintingRule) GENERATE_ACTION_R, " response (B)";
    if (R == R_368_RESP_A) print (RulePrintingRule) BASIC_ACCESSIBILITY_R, " response (A)";
    if (R == R_369_RESP_A) print (RulePrintingRule) BASIC_VISIBILITY_R, " response (A)";
    if (R == R_371_RESP_A) print (RulePrintingRule) REQUESTED_ACTIONS_REQUIRE_R, " response (A)";
    if (R == R_372_RESP_A) print (RulePrintingRule) CARRY_OUT_REQUESTED_ACTIONS_R, " response (A)";
    if (R == R_375_RESP_A) print (RulePrintingRule) ACCESS_THROUGH_BARRIERS_R, " response (A)";
    if (R == R_376_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_CLOSED_R, " response (A)";
    if (R == R_377_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_ROOMS_R, " response (A)";
    if (R == R_378_RESP_A) print (RulePrintingRule) CANT_REACH_OUTSIDE_CLOSED_R, " response (A)";
    if (R == R_379_RESP_A) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (A)";
    if (R == R_379_RESP_B) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (B)";
    if (R == R_379_RESP_C) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (C)";
    if (R == R_379_RESP_D) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (D)";
    if (R == R_379_RESP_E) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (E)";
    if (R == R_379_RESP_F) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (F)";
    if (R == R_379_RESP_G) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (G)";
    if (R == R_379_RESP_H) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (H)";
    if (R == R_379_RESP_I) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (I)";
    if (R == R_379_RESP_J) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (J)";
    if (R == R_379_RESP_K) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (K)";
    if (R == R_379_RESP_L) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (L)";
    if (R == R_379_RESP_M) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (M)";
    if (R == R_379_RESP_N) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (N)";
    if (R == R_379_RESP_O) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (O)";
    if (R == R_379_RESP_P) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (P)";
    if (R == R_379_RESP_Q) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Q)";
    if (R == R_379_RESP_R) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (R)";
    if (R == R_379_RESP_S) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (S)";
    if (R == R_379_RESP_T) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (T)";
    if (R == R_379_RESP_U) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (U)";
    if (R == R_379_RESP_V) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (V)";
    if (R == R_379_RESP_W) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (W)";
    if (R == R_379_RESP_X) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (X)";
    if (R == R_379_RESP_Y) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Y)";
    if (R == R_380_RESP_A) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (A)";
    if (R == R_380_RESP_B) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (B)";
    if (R == R_380_RESP_C) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (C)";
    if (R == R_380_RESP_D) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (D)";
    if (R == R_380_RESP_E) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (E)";
    if (R == R_380_RESP_F) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (F)";
    if (R == R_380_RESP_G) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (G)";
    if (R == R_380_RESP_H) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (H)";
    if (R == R_380_RESP_I) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (I)";
    if (R == R_380_RESP_J) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (J)";
    if (R == R_380_RESP_K) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (K)";
    if (R == R_381_RESP_A) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (A)";
    if (R == R_381_RESP_B) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (B)";
    if (R == R_381_RESP_C) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (C)";
    if (R == R_381_RESP_D) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (D)";
    if (R == R_381_RESP_E) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (E)";
    if (R == R_381_RESP_F) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (F)";
    if (R == R_381_RESP_G) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (G)";
    if (R == R_381_RESP_H) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (H)";
    if (R == R_381_RESP_I) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (I)";
    if (R == R_381_RESP_J) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (J)";
    if (R == R_381_RESP_K) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (K)";
    if (R == R_381_RESP_L) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (L)";
    if (R == R_381_RESP_M) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (M)";
    if (R == R_381_RESP_N) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (N)";
    if (R == R_381_RESP_O) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (O)";
    if (R == R_381_RESP_P) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (P)";
    if (R == R_381_RESP_Q) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (Q)";
    if (R == R_381_RESP_R) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (R)";
    if (R == R_381_RESP_S) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (S)";
    if (R == R_381_RESP_T) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (T)";
    if (R == R_381_RESP_U) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (U)";
    if (R == R_381_RESP_V) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (V)";
    if (R == R_381_RESP_W) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (W)";
    if (R == R_381_RESP_X) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (X)";
    if (R == R_382_RESP_A) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (A)";
    if (R == R_382_RESP_B) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (B)";
    if (R == R_382_RESP_C) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (C)";
    if (R == R_382_RESP_D) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (D)";
    if (R == R_382_RESP_E) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (E)";
    if (R == R_382_RESP_F) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (F)";
    if (R == R_383_RESP_A) print (RulePrintingRule) DARKNESS_NAME_INTERNAL_R, " response (A)";
    if (R == R_384_RESP_A) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (A)";
    if (R == R_384_RESP_B) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (B)";
    if (R == R_384_RESP_C) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (C)";
    if (R == R_384_RESP_D) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (D)";
    if (R == R_385_RESP_A) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (A)";
    if (R == R_385_RESP_B) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (B)";
    if (R == R_385_RESP_C) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (C)";
    if (R == R_385_RESP_D) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (D)";
    if (R == R_385_RESP_E) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (E)";
    if (R == R_385_RESP_F) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (F)";
    if (R == R_385_RESP_G) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (G)";
    if (R == R_385_RESP_H) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (H)";
    if (R == R_386_RESP_A) print (RulePrintingRule) YES_OR_NO_QUESTION_INTERNAL_R, " response (A)";
    if (R == R_387_RESP_A) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (A)";
    if (R == R_387_RESP_B) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (B)";
    if (R == R_387_RESP_C) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (C)";
    if (R == R_390_RESP_A) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (A)";
    if (R == R_390_RESP_B) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (B)";
    if (R == R_392_RESP_A) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (A)";
    if (R == R_392_RESP_B) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (B)";
    if (R == R_392_RESP_C) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (C)";
    if (R == R_398_RESP_A) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (A)";
    if (R == R_398_RESP_B) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (B)";
    if (R == R_398_RESP_C) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (C)";
    if (R == R_398_RESP_D) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (D)";
    if (R == R_398_RESP_E) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (E)";
    if (R == R_398_RESP_F) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (F)";
    if (R == R_401_RESP_A) print (RulePrintingRule) QUIT_THE_GAME_R, " response (A)";
    if (R == R_402_RESP_A) print (RulePrintingRule) SAVE_THE_GAME_R, " response (A)";
    if (R == R_402_RESP_B) print (RulePrintingRule) SAVE_THE_GAME_R, " response (B)";
    if (R == R_403_RESP_A) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (A)";
    if (R == R_403_RESP_B) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (B)";
    if (R == R_404_RESP_A) print (RulePrintingRule) RESTART_THE_GAME_R, " response (A)";
    if (R == R_404_RESP_B) print (RulePrintingRule) RESTART_THE_GAME_R, " response (B)";
    if (R == R_405_RESP_A) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (A)";
    if (R == R_405_RESP_B) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (B)";
    if (R == R_406_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (A)";
    if (R == R_406_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (B)";
    if (R == R_406_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (C)";
    if (R == R_407_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (A)";
    if (R == R_407_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (B)";
    if (R == R_407_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (C)";
    if (R == R_409_RESP_A) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (A)";
    if (R == R_409_RESP_B) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (B)";
    if (R == R_409_RESP_C) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (C)";
    if (R == R_409_RESP_D) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (D)";
    if (R == R_409_RESP_E) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (E)";
    if (R == R_411_RESP_A) print (RulePrintingRule) REP_PREFER_ABBREVIATED_R, " response (A)";
    if (R == R_413_RESP_A) print (RulePrintingRule) REP_PREFER_UNABBREVIATED_R, " response (A)";
    if (R == R_415_RESP_A) print (RulePrintingRule) REP_PREFER_SOMETIMES_ABBR_R, " response (A)";
    if (R == R_417_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_ON_R, " response (A)";
    if (R == R_419_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_OFF_R, " response (A)";
    if (R == R_420_RESP_A) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (A)";
    if (R == R_420_RESP_B) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (B)";
    if (R == R_420_RESP_C) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (C)";
    if (R == R_420_RESP_D) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (D)";
    if (R == R_11_RESP_A) print (RulePrintingRule) R_22, " response (A)";
    if (R == R_39_RESP_A) print (RulePrintingRule) R_77, " response (A)";
    if (R == R_41_RESP_A) print (RulePrintingRule) R_79, " response (A)";
    if (R == R_41_RESP_B) print (RulePrintingRule) R_79, " response (B)";
    if (R == R_40_RESP_A) print (RulePrintingRule) R_78, " response (A)";
    if (R == R_42_RESP_A) print (RulePrintingRule) R_80, " response (A)";
    if (R == R_46_RESP_A) print (RulePrintingRule) R_86, " response (A)";
    if (R == R_46_RESP_B) print (RulePrintingRule) R_86, " response (B)";
    if (R == R_46_RESP_C) print (RulePrintingRule) R_86, " response (C)";
    if (R == R_46_RESP_D) print (RulePrintingRule) R_86, " response (D)";
    if (R == R_46_RESP_E) print (RulePrintingRule) R_86, " response (E)";
    if (R == R_46_RESP_F) print (RulePrintingRule) R_86, " response (F)";
    if (R == R_53_RESP_A) print (RulePrintingRule) R_93, " response (A)";
    if (R == R_55_RESP_A) print (RulePrintingRule) R_96, " response (A)";
    if (R == R_56_RESP_A) print (RulePrintingRule) R_97, " response (A)";
    if (R == R_57_RESP_A) print (RulePrintingRule) R_98, " response (A)";
    if (R == R_58_RESP_A) print (RulePrintingRule) R_99, " response (A)";
    if (R == R_59_RESP_A) print (RulePrintingRule) R_100, " response (A)";
    if (R == R_60_RESP_A) print (RulePrintingRule) R_101, " response (A)";
    if (R == R_61_RESP_A) print (RulePrintingRule) R_102, " response (A)";
    if (R == R_62_RESP_A) print (RulePrintingRule) R_103, " response (A)";
    if (R == R_63_RESP_A) print (RulePrintingRule) R_104, " response (A)";
    if (R == R_64_RESP_A) print (RulePrintingRule) R_105, " response (A)";
    if (R == R_65_RESP_A) print (RulePrintingRule) R_106, " response (A)";
    if (R == R_66_RESP_A) print (RulePrintingRule) R_107, " response (A)";
    if (R == R_67_RESP_A) print (RulePrintingRule) R_108, " response (A)";
    if (R == R_68_RESP_A) print (RulePrintingRule) R_109, " response (A)";
    if (R == R_69_RESP_A) print (RulePrintingRule) R_110, " response (A)";
    if (R == R_70_RESP_A) print (RulePrintingRule) R_111, " response (A)";
    if (R == R_71_RESP_A) print (RulePrintingRule) R_112, " response (A)";
    if (R == R_73_RESP_A) print (RulePrintingRule) R_114, " response (A)";
    if (R == R_73_RESP_B) print (RulePrintingRule) R_114, " response (B)";
    if (R == R_74_RESP_A) print (RulePrintingRule) R_115, " response (A)";
    if (R == R_75_RESP_A) print (RulePrintingRule) R_116, " response (A)";
    if (R == R_78_RESP_A) print (RulePrintingRule) R_119, " response (A)";
    if (R == R_77_RESP_A) print (RulePrintingRule) R_118, " response (A)";
    if (R == R_79_RESP_A) print (RulePrintingRule) R_120, " response (A)";
    if (R == R_80_RESP_A) print (RulePrintingRule) R_121, " response (A)";
    if (R == R_81_RESP_A) print (RulePrintingRule) R_122, " response (A)";
    if (R == R_82_RESP_A) print (RulePrintingRule) R_123, " response (A)";
    if (R == R_82_RESP_B) print (RulePrintingRule) R_123, " response (B)";
    if (R == R_84_RESP_A) print (RulePrintingRule) R_125, " response (A)";
    if (R == R_84_RESP_B) print (RulePrintingRule) R_125, " response (B)";
    if (R == R_87_RESP_A) print (RulePrintingRule) R_128, " response (A)";
    if (R == R_88_RESP_A) print (RulePrintingRule) R_129, " response (A)";
    if (R == R_89_RESP_A) print (RulePrintingRule) R_130, " response (A)";
    if (R == R_90_RESP_A) print (RulePrintingRule) R_131, " response (A)";
    if (R == R_92_RESP_A) print (RulePrintingRule) R_133, " response (A)";
    if (R == R_93_RESP_A) print (RulePrintingRule) R_134, " response (A)";
    if (R == R_96_RESP_A) print (RulePrintingRule) R_137, " response (A)";
    if (R == R_97_RESP_A) print (RulePrintingRule) R_138, " response (A)";
    if (R == R_98_RESP_A) print (RulePrintingRule) R_139, " response (A)";
    if (R == R_99_RESP_A) print (RulePrintingRule) R_140, " response (A)";
    if (R == R_100_RESP_A) print (RulePrintingRule) R_141, " response (A)";
    if (R == R_102_RESP_A) print (RulePrintingRule) R_143, " response (A)";
    if (R == R_103_RESP_A) print (RulePrintingRule) R_144, " response (A)";
    if (R == R_104_RESP_A) print (RulePrintingRule) R_145, " response (A)";
    if (R == R_105_RESP_A) print (RulePrintingRule) R_146, " response (A)";
    if (R == R_106_RESP_A) print (RulePrintingRule) R_147, " response (A)";
    if (R == R_109_RESP_A) print (RulePrintingRule) R_150, " response (A)";
    if (R == R_109_RESP_B) print (RulePrintingRule) R_150, " response (B)";
    if (R == R_111_RESP_A) print (RulePrintingRule) R_152, " response (A)";
    if (R == R_112_RESP_A) print (RulePrintingRule) R_153, " response (A)";
    if (R == R_112_RESP_B) print (RulePrintingRule) R_153, " response (B)";
    if (R == R_113_RESP_A) print (RulePrintingRule) R_154, " response (A)";
    if (R == R_114_RESP_A) print (RulePrintingRule) R_155, " response (A)";
    if (R == R_116_RESP_A) print (RulePrintingRule) R_157, " response (A)";
    if (R == R_116_RESP_B) print (RulePrintingRule) R_157, " response (B)";
    if (R == R_120_RESP_A) print (RulePrintingRule) R_161, " response (A)";
    if (R == R_120_RESP_B) print (RulePrintingRule) R_161, " response (B)";
    if (R == R_120_RESP_C) print (RulePrintingRule) R_161, " response (C)";
    if (R == R_120_RESP_D) print (RulePrintingRule) R_161, " response (D)";
    if (R == R_120_RESP_E) print (RulePrintingRule) R_161, " response (E)";
    if (R == R_120_RESP_F) print (RulePrintingRule) R_161, " response (F)";
    if (R == R_120_RESP_G) print (RulePrintingRule) R_161, " response (G)";
    if (R == R_120_RESP_H) print (RulePrintingRule) R_161, " response (H)";
    if (R == R_120_RESP_I) print (RulePrintingRule) R_161, " response (I)";
    if (R == R_120_RESP_J) print (RulePrintingRule) R_161, " response (J)";
    if (R == R_120_RESP_K) print (RulePrintingRule) R_161, " response (K)";
    if (R == R_120_RESP_L) print (RulePrintingRule) R_161, " response (L)";
    if (R == R_120_RESP_M) print (RulePrintingRule) R_161, " response (M)";
    if (R == R_120_RESP_N) print (RulePrintingRule) R_161, " response (N)";
    if (R == R_120_RESP_O) print (RulePrintingRule) R_161, " response (O)";
    if (R == R_120_RESP_P) print (RulePrintingRule) R_161, " response (P)";
    if (R == R_120_RESP_Q) print (RulePrintingRule) R_161, " response (Q)";
    if (R == R_120_RESP_R) print (RulePrintingRule) R_161, " response (R)";
    if (R == R_120_RESP_S) print (RulePrintingRule) R_161, " response (S)";
    if (R == R_124_RESP_A) print (RulePrintingRule) R_165, " response (A)";
    if (R == R_124_RESP_B) print (RulePrintingRule) R_165, " response (B)";
    if (R == R_125_RESP_A) print (RulePrintingRule) R_166, " response (A)";
    if (R == R_125_RESP_B) print (RulePrintingRule) R_166, " response (B)";
    if (R == R_125_RESP_C) print (RulePrintingRule) R_166, " response (C)";
    if (R == R_125_RESP_D) print (RulePrintingRule) R_166, " response (D)";
    if (R == R_126_RESP_A) print (RulePrintingRule) R_167, " response (A)";
    if (R == R_127_RESP_A) print (RulePrintingRule) R_168, " response (A)";
    if (R == R_127_RESP_B) print (RulePrintingRule) R_168, " response (B)";
    if (R == R_128_RESP_A) print (RulePrintingRule) R_169, " response (A)";
    if (R == R_129_RESP_A) print (RulePrintingRule) R_170, " response (A)";
    if (R == R_129_RESP_B) print (RulePrintingRule) R_170, " response (B)";
    if (R == R_129_RESP_C) print (RulePrintingRule) R_170, " response (C)";
    if (R == R_129_RESP_D) print (RulePrintingRule) R_170, " response (D)";
    if (R == R_129_RESP_E) print (RulePrintingRule) R_170, " response (E)";
    if (R == R_131_RESP_A) print (RulePrintingRule) R_172, " response (A)";
    if (R == R_131_RESP_B) print (RulePrintingRule) R_172, " response (B)";
    if (R == R_131_RESP_C) print (RulePrintingRule) R_172, " response (C)";
    if (R == R_131_RESP_D) print (RulePrintingRule) R_172, " response (D)";
    if (R == R_134_RESP_A) print (RulePrintingRule) R_176, " response (A)";
    if (R == R_135_RESP_A) print (RulePrintingRule) R_177, " response (A)";
    if (R == R_138_RESP_A) print (RulePrintingRule) R_180, " response (A)";
    if (R == R_138_RESP_B) print (RulePrintingRule) R_180, " response (B)";
    if (R == R_138_RESP_C) print (RulePrintingRule) R_180, " response (C)";
    if (R == R_140_RESP_A) print (RulePrintingRule) R_182, " response (A)";
    if (R == R_142_RESP_A) print (RulePrintingRule) R_184, " response (A)";
    if (R == R_275_RESP_A) print (RulePrintingRule) R_799, " response (A)";
    if (R == R_275_RESP_B) print (RulePrintingRule) R_799, " response (B)";
    if (R == R_275_RESP_C) print (RulePrintingRule) R_799, " response (C)";
    if (R == R_147_RESP_A) print (RulePrintingRule) R_189, " response (A)";
    if (R == R_150_RESP_A) print (RulePrintingRule) R_192, " response (A)";
    if (R == R_152_RESP_A) print (RulePrintingRule) R_194, " response (A)";
    if (R == R_153_RESP_A) print (RulePrintingRule) R_195, " response (A)";
    if (R == R_153_RESP_B) print (RulePrintingRule) R_195, " response (B)";
    if (R == R_154_RESP_A) print (RulePrintingRule) R_196, " response (A)";
    if (R == R_155_RESP_A) print (RulePrintingRule) R_197, " response (A)";
    if (R == R_156_RESP_A) print (RulePrintingRule) R_198, " response (A)";
    if (R == R_157_RESP_A) print (RulePrintingRule) R_199, " response (A)";
    if (R == R_158_RESP_A) print (RulePrintingRule) R_200, " response (A)";
    if (R == R_159_RESP_A) print (RulePrintingRule) R_201, " response (A)";
    if (R == R_160_RESP_A) print (RulePrintingRule) R_202, " response (A)";
    if (R == R_161_RESP_A) print (RulePrintingRule) R_203, " response (A)";
    if (R == R_162_RESP_A) print (RulePrintingRule) R_204, " response (A)";
    if (R == R_162_RESP_B) print (RulePrintingRule) R_204, " response (B)";
    if (R == R_163_RESP_A) print (RulePrintingRule) R_205, " response (A)";
    if (R == R_163_RESP_B) print (RulePrintingRule) R_205, " response (B)";
    if (R == R_164_RESP_A) print (RulePrintingRule) R_206, " response (A)";
    if (R == R_165_RESP_A) print (RulePrintingRule) R_207, " response (A)";
    if (R == R_165_RESP_B) print (RulePrintingRule) R_207, " response (B)";
    if (R == R_166_RESP_A) print (RulePrintingRule) R_208, " response (A)";
    if (R == R_167_RESP_A) print (RulePrintingRule) R_209, " response (A)";
    if (R == R_168_RESP_A) print (RulePrintingRule) R_210, " response (A)";
    if (R == R_169_RESP_A) print (RulePrintingRule) R_211, " response (A)";
    if (R == R_171_RESP_A) print (RulePrintingRule) R_213, " response (A)";
    if (R == R_171_RESP_B) print (RulePrintingRule) R_213, " response (B)";
    if (R == R_172_RESP_A) print (RulePrintingRule) R_214, " response (A)";
    if (R == R_173_RESP_A) print (RulePrintingRule) R_215, " response (A)";
    if (R == R_174_RESP_A) print (RulePrintingRule) R_216, " response (A)";
    if (R == R_176_RESP_A) print (RulePrintingRule) R_218, " response (A)";
    if (R == R_176_RESP_B) print (RulePrintingRule) R_218, " response (B)";
    if (R == R_177_RESP_A) print (RulePrintingRule) R_219, " response (A)";
    if (R == R_178_RESP_A) print (RulePrintingRule) R_220, " response (A)";
    if (R == R_180_RESP_A) print (RulePrintingRule) R_222, " response (A)";
    if (R == R_181_RESP_A) print (RulePrintingRule) R_223, " response (A)";
    if (R == R_182_RESP_A) print (RulePrintingRule) R_224, " response (A)";
    if (R == R_184_RESP_A) print (RulePrintingRule) R_226, " response (A)";
    if (R == R_185_RESP_A) print (RulePrintingRule) R_227, " response (A)";
    if (R == R_186_RESP_A) print (RulePrintingRule) R_228, " response (A)";
    if (R == R_187_RESP_A) print (RulePrintingRule) R_229, " response (A)";
    if (R == R_189_RESP_A) print (RulePrintingRule) R_231, " response (A)";
    if (R == R_190_RESP_A) print (RulePrintingRule) R_232, " response (A)";
    if (R == R_190_RESP_B) print (RulePrintingRule) R_232, " response (B)";
    if (R == R_190_RESP_C) print (RulePrintingRule) R_232, " response (C)";
    if (R == R_191_RESP_A) print (RulePrintingRule) R_233, " response (A)";
    if (R == R_192_RESP_A) print (RulePrintingRule) R_234, " response (A)";
    if (R == R_194_RESP_A) print (RulePrintingRule) R_236, " response (A)";
    if (R == R_194_RESP_B) print (RulePrintingRule) R_236, " response (B)";
    if (R == R_194_RESP_C) print (RulePrintingRule) R_236, " response (C)";
    if (R == R_195_RESP_A) print (RulePrintingRule) R_237, " response (A)";
    if (R == R_196_RESP_A) print (RulePrintingRule) R_238, " response (A)";
    if (R == R_197_RESP_A) print (RulePrintingRule) R_239, " response (A)";
    if (R == R_199_RESP_A) print (RulePrintingRule) R_241, " response (A)";
    if (R == R_199_RESP_B) print (RulePrintingRule) R_241, " response (B)";
    if (R == R_200_RESP_A) print (RulePrintingRule) R_243, " response (A)";
    if (R == R_201_RESP_A) print (RulePrintingRule) R_244, " response (A)";
    if (R == R_203_RESP_A) print (RulePrintingRule) R_246, " response (A)";
    if (R == R_203_RESP_B) print (RulePrintingRule) R_246, " response (B)";
    if (R == R_204_RESP_A) print (RulePrintingRule) R_247, " response (A)";
    if (R == R_205_RESP_A) print (RulePrintingRule) R_248, " response (A)";
    if (R == R_206_RESP_A) print (RulePrintingRule) R_249, " response (A)";
    if (R == R_207_RESP_A) print (RulePrintingRule) R_250, " response (A)";
    if (R == R_208_RESP_A) print (RulePrintingRule) R_251, " response (A)";
    if (R == R_209_RESP_A) print (RulePrintingRule) R_252, " response (A)";
    if (R == R_211_RESP_A) print (RulePrintingRule) R_254, " response (A)";
    if (R == R_211_RESP_B) print (RulePrintingRule) R_254, " response (B)";
    if (R == R_211_RESP_C) print (RulePrintingRule) R_254, " response (C)";
    if (R == R_212_RESP_A) print (RulePrintingRule) R_255, " response (A)";
    if (R == R_214_RESP_A) print (RulePrintingRule) R_257, " response (A)";
    if (R == R_215_RESP_A) print (RulePrintingRule) R_258, " response (A)";
    if (R == R_216_RESP_A) print (RulePrintingRule) R_259, " response (A)";
    if (R == R_217_RESP_A) print (RulePrintingRule) R_260, " response (A)";
    if (R == R_218_RESP_A) print (RulePrintingRule) R_261, " response (A)";
    if (R == R_219_RESP_A) print (RulePrintingRule) R_262, " response (A)";
    if (R == R_220_RESP_A) print (RulePrintingRule) R_263, " response (A)";
    if (R == R_221_RESP_A) print (RulePrintingRule) R_264, " response (A)";
    if (R == R_223_RESP_A) print (RulePrintingRule) R_266, " response (A)";
    if (R == R_228_RESP_A) print (RulePrintingRule) R_271, " response (A)";
    if (R == R_228_RESP_B) print (RulePrintingRule) R_271, " response (B)";
    if (R == R_229_RESP_A) print (RulePrintingRule) R_272, " response (A)";
    if (R == R_229_RESP_B) print (RulePrintingRule) R_272, " response (B)";
    if (R == R_230_RESP_A) print (RulePrintingRule) R_273, " response (A)";
    if (R == R_230_RESP_B) print (RulePrintingRule) R_273, " response (B)";
    if (R == R_230_RESP_C) print (RulePrintingRule) R_273, " response (C)";
    if (R == R_231_RESP_A) print (RulePrintingRule) R_274, " response (A)";
    if (R == R_231_RESP_B) print (RulePrintingRule) R_274, " response (B)";
    if (R == R_232_RESP_A) print (RulePrintingRule) R_275, " response (A)";
    if (R == R_233_RESP_A) print (RulePrintingRule) R_276, " response (A)";
    if (R == R_233_RESP_B) print (RulePrintingRule) R_276, " response (B)";
    if (R == R_234_RESP_A) print (RulePrintingRule) R_277, " response (A)";
    if (R == R_235_RESP_A) print (RulePrintingRule) R_278, " response (A)";
    if (R == R_236_RESP_A) print (RulePrintingRule) R_279, " response (A)";
    if (R == R_237_RESP_A) print (RulePrintingRule) R_280, " response (A)";
    if (R == R_237_RESP_B) print (RulePrintingRule) R_280, " response (B)";
    if (R == R_238_RESP_A) print (RulePrintingRule) R_281, " response (A)";
    if (R == R_239_RESP_A) print (RulePrintingRule) R_282, " response (A)";
    if (R == R_240_RESP_A) print (RulePrintingRule) R_283, " response (A)";
    if (R == R_241_RESP_A) print (RulePrintingRule) R_284, " response (A)";
    if (R == R_241_RESP_B) print (RulePrintingRule) R_284, " response (B)";
    if (R == R_242_RESP_A) print (RulePrintingRule) R_285, " response (A)";
    if (R == R_243_RESP_A) print (RulePrintingRule) R_286, " response (A)";
    if (R == R_244_RESP_A) print (RulePrintingRule) R_287, " response (A)";
    if (R == R_245_RESP_A) print (RulePrintingRule) R_288, " response (A)";
    if (R == R_245_RESP_B) print (RulePrintingRule) R_288, " response (B)";
    if (R == R_246_RESP_A) print (RulePrintingRule) R_289, " response (A)";
    if (R == R_247_RESP_A) print (RulePrintingRule) R_290, " response (A)";
    if (R == R_248_RESP_A) print (RulePrintingRule) R_291, " response (A)";
    if (R == R_249_RESP_A) print (RulePrintingRule) R_292, " response (A)";
    if (R == R_251_RESP_A) print (RulePrintingRule) R_294, " response (A)";
    if (R == R_252_RESP_A) print (RulePrintingRule) R_295, " response (A)";
    if (R == R_253_RESP_A) print (RulePrintingRule) R_296, " response (A)";
    if (R == R_253_RESP_B) print (RulePrintingRule) R_296, " response (B)";
    if (R == R_254_RESP_A) print (RulePrintingRule) R_297, " response (A)";
    if (R == R_255_RESP_A) print (RulePrintingRule) R_298, " response (A)";
    if (R == R_256_RESP_A) print (RulePrintingRule) R_299, " response (A)";
    if (R == R_257_RESP_A) print (RulePrintingRule) R_300, " response (A)";
    if (R == R_258_RESP_A) print (RulePrintingRule) R_301, " response (A)";
    if (R == R_259_RESP_A) print (RulePrintingRule) R_302, " response (A)";
    if (R == R_259_RESP_B) print (RulePrintingRule) R_302, " response (B)";
    if (R == R_260_RESP_A) print (RulePrintingRule) R_303, " response (A)";
    if (R == R_260_RESP_B) print (RulePrintingRule) R_303, " response (B)";
    if (R == R_261_RESP_A) print (RulePrintingRule) R_304, " response (A)";
    if (R == R_261_RESP_B) print (RulePrintingRule) R_304, " response (B)";
    if (R == R_262_RESP_A) print (RulePrintingRule) R_305, " response (A)";
    if (R == R_263_RESP_A) print (RulePrintingRule) R_306, " response (A)";
    if (R == R_263_RESP_B) print (RulePrintingRule) R_306, " response (B)";
    if (R == R_264_RESP_A) print (RulePrintingRule) R_307, " response (A)";
    if (R == R_265_RESP_A) print (RulePrintingRule) R_308, " response (A)";
    if (R == R_266_RESP_A) print (RulePrintingRule) R_309, " response (A)";
    if (R == R_267_RESP_A) print (RulePrintingRule) R_310, " response (A)";
    if (R == R_268_RESP_A) print (RulePrintingRule) R_311, " response (A)";
    if (R == R_269_RESP_A) print (RulePrintingRule) R_312, " response (A)";
    if (R == R_269_RESP_B) print (RulePrintingRule) R_312, " response (B)";
    if (R == R_270_RESP_A) print (RulePrintingRule) R_313, " response (A)";
    if (R == R_271_RESP_A) print (RulePrintingRule) R_314, " response (A)";
    if (R == R_271_RESP_B) print (RulePrintingRule) R_314, " response (B)";
    if (R == R_272_RESP_A) print (RulePrintingRule) R_315, " response (A)";
    if (R == R_273_RESP_A) print (RulePrintingRule) R_316, " response (A)";
    if (R == R_274_RESP_A) print (RulePrintingRule) R_317, " response (A)";
    if (R == R_279_RESP_A) print (RulePrintingRule) R_880, " response (A)";
    if (R == R_146_RESP_A) print (RulePrintingRule) R_188, " response (A)";
    if (R == R_146_RESP_B) print (RulePrintingRule) R_188, " response (B)";
    if (R == R_146_RESP_C) print (RulePrintingRule) R_188, " response (C)";
    if (R == R_222_RESP_A) print (RulePrintingRule) R_265, " response (A)";
    if (R == R_224_RESP_A) print (RulePrintingRule) R_267, " response (A)";
    if (R == R_225_RESP_A) print (RulePrintingRule) R_268, " response (A)";
];
[ STANDARD_RESPONSE_ISSUING_R ;
    RegardingSingleObject(); TEXT_TY_Say(ResponseTexts-->(parameter_value-1));
];
Array ResponseDivisions -->
    "Standard Rules" 1 258
    EMPTY_TEXT_PACKED 263 395
    "Spanish Language by Sebastian Arg" 259 261
    "Basic Screen Effects by Emily Short" 262 262
    0 0 0;
[ R_TX_S_7 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [aren't] available.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [aren't] available.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_774_r50 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ available.~]
    ParaContent(); print " available."; .L_Say900; .L_SayX877;rtrue;
];
Array TX_S_7 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_7;
[ R_TX_S_114 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Transcripting is already on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Transcripting is already on.~]
    say__p=1;! [2: ~Transcripting is already on.~]
    ParaContent(); print "Transcripting is already on."; .L_Say901; .L_SayX878;rtrue;
];
Array TX_S_114 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_114;
[ R_TX_S_115 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Start of a transcript of~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Start of a transcript of~]
    say__p=1;! [2: ~Start of a transcript of~]
    ParaContent(); print "Start of a transcript of"; .L_Say902; .L_SayX879;rtrue;
];
Array TX_S_115 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_115;
[ R_TX_S_116 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Attempt to begin transcript failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Attempt to begin transcript failed.~]
    say__p=1;! [2: ~Attempt to begin transcript failed.~]
    ParaContent(); print "Attempt to begin transcript failed."; .L_Say903; .L_SayX880;rtrue;
];
Array TX_S_116 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_116;
[ R_TX_S_195 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current item from the multiple object list]: [run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current item from the multiple object list]: [run paragraph on]~]
    say__p=1;! [2: current item from the multiple object list]
    ParaContent(); PrintShortName(multiple_object_item);! [3: ~: ~]
    ParaContent(); print ": ";! [4: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say904; .L_SayX881;rtrue;
];
Array TX_S_195 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_195;
[ R_TX_S_199 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~> [run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~> [run paragraph on]~]
    say__p=1;! [2: ~> ~]
    ParaContent(); print "> ";! [3: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say905; .L_SayX882;rtrue;
];
Array TX_S_199 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_199;
[ R_TX_S_209 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the item] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say906; .L_SayX883;rtrue;
];
Array TX_S_209 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_209;
[ R_TX_S_284 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] stand on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] stand on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_788_r64 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_763_r39 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ stand on.~]
    ParaContent(); print " stand on."; .L_Say907; .L_SayX884;rtrue;
];
Array TX_S_284 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_284;
[ R_TX_S_285 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] sit down on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] sit down on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_788_r64 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_763_r39 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ sit down on.~]
    ParaContent(); print " sit down on."; .L_Say908; .L_SayX885;rtrue;
];
Array TX_S_285 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_285;
[ R_TX_S_286 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] lie down on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] lie down on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_788_r64 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_763_r39 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ lie down on.~]
    ParaContent(); print " lie down on."; .L_Say909; .L_SayX886;rtrue;
];
Array TX_S_286 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_286;
[ R_TX_S_289 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room on [the noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_790_r66 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room on ~]
    ParaContent(); print " no more room on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say910; .L_SayX887;rtrue;
];
Array TX_S_289 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_289;
[ R_TX_S_290 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room in [the noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_790_r66 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room in ~]
    ParaContent(); print " no more room in ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say911; .L_SayX888;rtrue;
];
Array TX_S_290 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_290;
[ R_TX_S_308 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oscuridad~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oscuridad~]
    say__p=1;! [2: ~Oscuridad~]
    ParaContent(); print "Oscuridad"; .L_Say912; .L_SayX889;rtrue;
];
Array TX_S_308 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_308;
[ R_TX_S_310 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (sobre [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (sobre [the intermediate level])~]
    say__p=1;! [2: ~ (sobre ~]
    ParaContent(); print " (sobre ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say913; .L_SayX890;rtrue;
];
Array TX_S_310 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_310;
[ R_TX_S_311 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (en [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (en [the intermediate level])~]
    say__p=1;! [2: ~ (en ~]
    ParaContent(); print " (en ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say914; .L_SayX891;rtrue;
];
Array TX_S_311 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_311;
[ R_TX_S_459 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes especificar en qué dirección ir.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes especificar en qué dirección ir.~]
    say__p=1;! [2: ~Debes especificar en qué dirección ir.~]
    ParaContent(); print "Debes especificar en qué dirección ir."; .L_Say915; .L_SayX892;rtrue;
];
Array TX_S_459 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_459;
[ R_TX_S_460 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value: object
    tmp_2 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Quieres ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Quieres ~]
    say__p=1;! [2: ~¿Quieres ~]
    ParaContent(); print "¿Quieres "; .L_Say916; .L_SayX893;rtrue;
];
Array TX_S_460 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_460;
[ R_TX_S_461 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value: object
    tmp_2 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ o ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ o ~]
    say__p=1;! [2: ~ o ~]
    ParaContent(); print " o "; .L_Say917; .L_SayX894;rtrue;
];
Array TX_S_461 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_461;
[ R_TX_S_462 
    tmp_0 ! Let/loop value: object
    tmp_1 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~por favor, responde a alguna de arriba.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~por favor, responde a alguna de arriba.~]
    say__p=1;! [2: ~por favor, responde a alguna de arriba.~]
    ParaContent(); print "por favor, responde a alguna de arriba."; .L_Say918; .L_SayX895;rtrue;
];
Array TX_S_462 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_462;
[ R_TX_S_463 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Puedes ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Puedes ~]
    say__p=1;! [2: ~Puedes ~]
    ParaContent(); print "Puedes "; .L_Say919; .L_SayX896;rtrue;
];
Array TX_S_463 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_463;
[ R_TX_S_464 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~Sobre [the domain] puedes ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sobre [the domain] puedes ~]
    say__p=1;! [2: ~Sobre ~]
    ParaContent(); print "Sobre ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ puedes ~]
    ParaContent(); print " puedes "; .L_Say920; .L_SayX897;rtrue;
];
Array TX_S_464 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_464;
[ R_TX_S_465 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~En [the domain] puedes ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En [the domain] puedes ~]
    say__p=1;! [2: ~En ~]
    ParaContent(); print "En ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ puedes ~]
    ParaContent(); print " puedes "; .L_Say921; .L_SayX898;rtrue;
];
Array TX_S_465 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_465;
[ R_TX_S_466 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ver también ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ver también ~]
    say__p=1;! [2: ~ver también ~]
    ParaContent(); print "ver también "; .L_Say922; .L_SayX899;rtrue;
];
Array TX_S_466 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_466;
[ R_TX_S_467 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ver ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ver ~]
    say__p=1;! [2: ~ver ~]
    ParaContent(); print "ver "; .L_Say923; .L_SayX900;rtrue;
];
Array TX_S_467 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_467;
[ R_TX_S_468 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., 'common holder': object
    tmp_3 ! Let/loop value, e.g., 'contents form of list': truth state
    tmp_4 ! Let/loop value: object
    tmp_5 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~~]
    say__p=1; .L_Say924; .L_SayX901;rtrue;
];
Array TX_S_468 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_468;
[ R_TX_S_469 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~Sobre [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sobre [the item] ~]
    say__p=1;! [2: ~Sobre ~]
    ParaContent(); print "Sobre ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say925; .L_SayX902;rtrue;
];
Array TX_S_469 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_469;
[ R_TX_S_470 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~Sobre [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sobre [the item] ~]
    say__p=1;! [2: ~Sobre ~]
    ParaContent(); print "Sobre ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say926; .L_SayX903;rtrue;
];
Array TX_S_470 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_470;
[ R_TX_S_471 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No llevas nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No llevas nada.~]
    say__p=1;! [2: ~No llevas nada.~]
    ParaContent(); print "No llevas nada."; .L_Say927; .L_SayX904;rtrue;
];
Array TX_S_471 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_471;
[ R_TX_S_472 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Tu] llevas[plm]:[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Tu] llevas[plm]:[line break]~]
    say__p=1;! [2: tu]
    ParaContent(); (PHR_807_r81 ());! [3: ~ llevas~]
    ParaContent(); print " llevas";! [4: plm]
    ParaContent(); (PHR_805_r79 ());! [5: ~:~]
    ParaContent(); print ":";! [6: line break]
    ParaContent(); new_line; .L_Say928; .L_SayX905;rtrue;
];
Array TX_S_472 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_472;
[ R_TX_S_473 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] consulta su inventario.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] consulta su inventario.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ consulta su inventario.~]
    ParaContent(); print " consulta su inventario."; .L_Say929; .L_SayX906;rtrue;
];
Array TX_S_473 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_473;
[ R_TX_S_474 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Siempre te tienes a ti mism[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Siempre te tienes a ti mism[o].~]
    say__p=1;! [2: ~Siempre te tienes a ti mism~]
    ParaContent(); print "Siempre te tienes a ti mism";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~.~]
    ParaContent(); print "."; .L_Say930; .L_SayX907;rtrue;
];
Array TX_S_474 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_474;
[ R_TX_S_475 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No creo que [al noun] le[s] gustara[n].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No creo que [al noun] le[s] gustara[n].~]
    say__p=1;! [2: ~No creo que ~]
    ParaContent(); print "No creo que ";! [3: al noun]
    ParaContent(); print (al) noun;! [4: ~ le~]
    ParaContent(); print " le";! [5: s]
    ParaContent(); (PHR_822_r96 ());! [6: ~ gustara~]
    ParaContent(); print " gustara";! [7: n]
    ParaContent(); (PHR_821_r95 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say931; .L_SayX908;rtrue;
];
Array TX_S_475 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_475;
[ R_TX_S_476 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Parece que es parte [del whole].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Parece que es parte [del whole].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Parece que es parte ~]
    ParaContent(); print "Parece que es parte ";! [4: del whole]
    ParaContent(); print (del) tmp_0;! [5: ~.~]
    ParaContent(); print "."; .L_Say932; .L_SayX909;rtrue;
];
Array TX_S_476 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_476;
[ R_TX_S_477 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Parece que pertenece [al owner].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Parece que pertenece [al owner].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Parece que pertenece ~]
    ParaContent(); print "Parece que pertenece ";! [4: al owner]
    ParaContent(); print (al) tmp_1;! [5: ~.~]
    ParaContent(); print "."; .L_Say933; .L_SayX910;rtrue;
];
Array TX_S_477 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_477;
[ R_TX_S_478 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]No está[n] disponible[s].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]No está[n] disponible[s].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~No está~]
    ParaContent(); print "No está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ disponible~]
    ParaContent(); print " disponible";! [6: s]
    ParaContent(); (PHR_822_r96 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say934; .L_SayX911;rtrue;
];
Array TX_S_478 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_478;
[ R_TX_S_479 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Tu] tienes que [if noun is a supporter]bajarte[otherwise]salirte[end if] primero.[plm]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Tu] tienes que [if noun is a supporter]bajarte[otherwise]salirte[end if] primero.[plm]~]
    say__p=1;! [2: tu]
    ParaContent(); (PHR_807_r81 ());! [3: ~ tienes que ~]
    ParaContent(); print " tienes que ";! [4: if noun is a supporter]

    	if (~~((((noun ofclass K6_supporter))))) jump L_Say935;! [5: ~bajarte~]
    ParaContent(); print "bajarte";! [6: otherwise]

    	jump L_SayX912; .L_Say935;! [7: ~salirte~]
    ParaContent(); print "salirte";! [8: end if]

    	.L_Say936; .L_SayX912;! [9: ~ primero.~]
    ParaContent(); print " primero.";! [10: plm]
    ParaContent(); (PHR_805_r79 ()); .L_Say937; .L_SayX913;rtrue;
];
Array TX_S_479 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_479;
[ R_TX_S_480 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya tienes [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya tienes [the noun].~]
    say__p=1;! [2: ~Ya tienes ~]
    ParaContent(); print "Ya tienes ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say938; .L_SayX914;rtrue;
];
Array TX_S_480 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_480;
[ R_TX_S_481 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Difícilmente puedes llevarte eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Difícilmente puedes llevarte eso.~]
    say__p=1;! [2: ~Difícilmente puedes llevarte eso.~]
    ParaContent(); print "Difícilmente puedes llevarte eso."; .L_Say939; .L_SayX915;rtrue;
];
Array TX_S_481 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_481;
[ R_TX_S_482 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes llevarte eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes llevarte eso.~]
    say__p=1;! [2: ~No puedes llevarte eso.~]
    ParaContent(); print "No puedes llevarte eso."; .L_Say940; .L_SayX916;rtrue;
];
Array TX_S_482 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_482;
[ R_TX_S_483 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está fij[o] en el sitio.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está fij[o] en el sitio.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está fij~]
    ParaContent(); print " está fij";! [4: o]
    ParaContent(); (PHR_818_r92 ());! [5: ~ en el sitio.~]
    ParaContent(); print " en el sitio."; .L_Say941; .L_SayX917;rtrue;
];
Array TX_S_483 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_483;
[ R_TX_S_484 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value, e.g., 'transferred item': object
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(colocas [the transferred item] en [the current working sack] para hacer sitio)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(colocas [the transferred item] en [the current working sack] para hacer sitio)[command clarification break]~]
    say__p=1;! [2: ~(colocas ~]
    ParaContent(); print "(colocas ";! [3: the transferred item]
    ParaContent(); print (the) tmp_1;! [4: ~ en ~]
    ParaContent(); print " en ";! [5: the current working sack]
    ParaContent(); print (the) tmp_0;! [6: ~ para hacer sitio)~]
    ParaContent(); print " para hacer sitio)";! [7: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say942; .L_SayX918;rtrue;
];
Array TX_S_484 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_484;
[ R_TX_S_485 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya llevas demasiadas cosas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya llevas demasiadas cosas.~]
    say__p=1;! [2: ~Ya llevas demasiadas cosas.~]
    ParaContent(); print "Ya llevas demasiadas cosas."; .L_Say943; .L_SayX919;rtrue;
];
Array TX_S_485 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_485;
[ R_TX_S_486 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][if dialecto sudamericano]Tomad[o].[otherwise]Cogid[o].[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][if dialecto sudamericano]Tomad[o].[otherwise]Cogid[o].[end if]~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: if dialecto sudamericano]

    	if (~~(((dialecto_sudamericano)))) jump L_Say944;! [4: ~Tomad~]
    ParaContent(); print "Tomad";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~.~]
    ParaContent(); print ".";! [7: otherwise]

    	jump L_SayX920; .L_Say944;! [8: ~Cogid~]
    ParaContent(); print "Cogid";! [9: o]
    ParaContent(); (PHR_818_r92 ());! [10: ~.~]
    ParaContent(); print ".";! [11: end if]

    	.L_Say945; .L_SayX920; .L_Say946; .L_SayX921;rtrue;
];
Array TX_S_486 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_486;
[ R_TX_S_487 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [if dialecto sudamericano]toma[otherwise]coge[end if] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [if dialecto sudamericano]toma[otherwise]coge[end if] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: if dialecto sudamericano]

    	if (~~(((dialecto_sudamericano)))) jump L_Say947;! [5: ~toma~]
    ParaContent(); print "toma";! [6: otherwise]

    	jump L_SayX922; .L_Say947;! [7: ~coge~]
    ParaContent(); print "coge";! [8: end if]

    	.L_Say948; .L_SayX922;! [9: ~ ~]
    ParaContent(); print " ";! [10: the noun]
    ParaContent(); print (the) noun;! [11: ~.~]
    ParaContent(); print "."; .L_Say949; .L_SayX923;rtrue;
];
Array TX_S_487 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_487;
[ R_TX_S_488 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]¡Pero si no está[n] ahí ahora!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]¡Pero si no está[n] ahí ahora!~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~¡Pero si no está~]
    ParaContent(); print "¡Pero si no está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ahí ahora!~]
    ParaContent(); print " ahí ahora!"; .L_Say950; .L_SayX924;rtrue;
];
Array TX_S_488 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_488;
[ R_TX_S_489 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Parece que pertenece [al owner].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Parece que pertenece [al owner].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Parece que pertenece ~]
    ParaContent(); print "Parece que pertenece ";! [4: al owner]
    ParaContent(); print (al) tmp_0;! [5: ~.~]
    ParaContent(); print "."; .L_Say951; .L_SayX925;rtrue;
];
Array TX_S_489 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_489;
[ R_TX_S_490 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes hacer algo así.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes hacer algo así.~]
    say__p=1;! [2: ~No puedes hacer algo así.~]
    ParaContent(); print "No puedes hacer algo así."; .L_Say952; .L_SayX926;rtrue;
];
Array TX_S_490 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_490;
[ R_TX_S_491 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes dejar una parte de ti.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes dejar una parte de ti.~]
    say__p=1;! [2: ~No puedes dejar una parte de ti.~]
    ParaContent(); print "No puedes dejar una parte de ti."; .L_Say953; .L_SayX927;rtrue;
];
Array TX_S_491 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_491;
[ R_TX_S_492 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] ya está[n] allí.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] ya está[n] allí.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ya está~]
    ParaContent(); print " ya está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ allí.~]
    ParaContent(); print " allí."; .L_Say954; .L_SayX928;rtrue;
];
Array TX_S_492 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_492;
[ R_TX_S_493 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Para dejarl[o] deberías tenerl[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Para dejarl[o] deberías tenerl[o].~]
    say__p=1;! [2: ~Para dejarl~]
    ParaContent(); print "Para dejarl";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ deberías tenerl~]
    ParaContent(); print " deberías tenerl";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~.~]
    ParaContent(); print "."; .L_Say955; .L_SayX929;rtrue;
];
Array TX_S_493 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_493;
[ R_TX_S_494 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te quitas [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te quitas [the noun])[command clarification break]~]
    say__p=1;! [2: ~(primero te quitas ~]
    ParaContent(); print "(primero te quitas ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say956; .L_SayX930;rtrue;
];
Array TX_S_494 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_494;
[ R_TX_S_495 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~No hay más lugar sobre [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay más lugar sobre [the receptacle].~]
    say__p=1;! [2: ~No hay más lugar sobre ~]
    ParaContent(); print "No hay más lugar sobre ";! [3: the receptacle]
    ParaContent(); print (the) tmp_0;! [4: ~.~]
    ParaContent(); print "."; .L_Say957; .L_SayX931;rtrue;
];
Array TX_S_495 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_495;
[ R_TX_S_496 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~No hay más lugar en [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay más lugar en [the receptacle].~]
    say__p=1;! [2: ~No hay más lugar en ~]
    ParaContent(); print "No hay más lugar en ";! [3: the receptacle]
    ParaContent(); print (the) tmp_0;! [4: ~.~]
    ParaContent(); print "."; .L_Say958; .L_SayX932;rtrue;
];
Array TX_S_496 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_496;
[ R_TX_S_497 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Dejad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Dejad[o].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Dejad~]
    ParaContent(); print "Dejad";! [4: o]
    ParaContent(); (PHR_818_r92 ());! [5: ~.~]
    ParaContent(); print "."; .L_Say959; .L_SayX933;rtrue;
];
Array TX_S_497 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_497;
[ R_TX_S_498 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] deja [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] deja [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ deja ~]
    ParaContent(); print " deja ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say960; .L_SayX934;rtrue;
];
Array TX_S_498 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_498;
[ R_TX_S_499 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes poner un objeto sobre sí mismo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes poner un objeto sobre sí mismo.~]
    say__p=1;! [2: ~No puedes poner un objeto sobre sí mismo.~]
    ParaContent(); print "No puedes poner un objeto sobre sí mismo."; .L_Say961; .L_SayX935;rtrue;
];
Array TX_S_499 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_499;
[ R_TX_S_500 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Poner cosas sobre [the second noun] no servirá de nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Poner cosas sobre [the second noun] no servirá de nada.~]
    say__p=1;! [2: ~Poner cosas sobre ~]
    ParaContent(); print "Poner cosas sobre ";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~ no servirá de nada.~]
    ParaContent(); print " no servirá de nada."; .L_Say962; .L_SayX936;rtrue;
];
Array TX_S_500 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_500;
[ R_TX_S_501 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te [lo] quitas)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te [lo] quitas)[command clarification break]~]
    say__p=1;! [2: ~(primero te ~]
    ParaContent(); print "(primero te ";! [3: lo]
    ParaContent(); (PHR_820_r94 ());! [4: ~ quitas)~]
    ParaContent(); print " quitas)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say963; .L_SayX937;rtrue;
];
Array TX_S_501 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_501;
[ R_TX_S_502 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No queda sitio en [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No queda sitio en [the second noun].~]
    say__p=1;! [2: ~No queda sitio en ~]
    ParaContent(); print "No queda sitio en ";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~.~]
    ParaContent(); print "."; .L_Say964; .L_SayX938;rtrue;
];
Array TX_S_502 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_502;
[ R_TX_S_503 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Hecho.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Hecho.~]
    say__p=1;! [2: ~Hecho.~]
    ParaContent(); print "Hecho."; .L_Say965; .L_SayX939;rtrue;
];
Array TX_S_503 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_503;
[ R_TX_S_504 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Pones[otherwise][The actor] pone[end if] [the noun] sobre [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Pones[otherwise][The actor] pone[end if] [the noun] sobre [the second noun].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say966;! [3: ~Pones~]
    ParaContent(); print "Pones";! [4: otherwise]

    	jump L_SayX940; .L_Say966;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ pone~]
    ParaContent(); print " pone";! [7: end if]

    	.L_Say967; .L_SayX940;! [8: ~ ~]
    ParaContent(); print " ";! [9: the noun]
    ParaContent(); print (the) noun;! [10: ~ sobre ~]
    ParaContent(); print " sobre ";! [11: the second noun]
    ParaContent(); print (the) second;! [12: ~.~]
    ParaContent(); print "."; .L_Say968; .L_SayX941;rtrue;
];
Array TX_S_504 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_504;
[ R_TX_S_505 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes poner un objeto dentro de sí mismo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes poner un objeto dentro de sí mismo.~]
    say__p=1;! [2: ~No puedes poner un objeto dentro de sí mismo.~]
    ParaContent(); print "No puedes poner un objeto dentro de sí mismo."; .L_Say969; .L_SayX942;rtrue;
];
Array TX_S_505 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_505;
[ R_TX_S_506 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] está[n] cerrad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] está[n] cerrad[o].~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ está~]
    ParaContent(); print " está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ cerrad~]
    ParaContent(); print " cerrad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say970; .L_SayX943;rtrue;
];
Array TX_S_506 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_506;
[ R_TX_S_507 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No se pueden meter cosas dentro [del second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No se pueden meter cosas dentro [del second noun].~]
    say__p=1;! [2: ~No se pueden meter cosas dentro ~]
    ParaContent(); print "No se pueden meter cosas dentro ";! [3: del second noun]
    ParaContent(); print (del) second;! [4: ~.~]
    ParaContent(); print "."; .L_Say971; .L_SayX944;rtrue;
];
Array TX_S_507 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_507;
[ R_TX_S_508 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te [lo] quitas)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te [lo] quitas)[command clarification break]~]
    say__p=1;! [2: ~(primero te ~]
    ParaContent(); print "(primero te ";! [3: lo]
    ParaContent(); (PHR_820_r94 ());! [4: ~ quitas)~]
    ParaContent(); print " quitas)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say972; .L_SayX945;rtrue;
];
Array TX_S_508 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_508;
[ R_TX_S_509 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No queda sitio en [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No queda sitio en [the second noun].~]
    say__p=1;! [2: ~No queda sitio en ~]
    ParaContent(); print "No queda sitio en ";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~.~]
    ParaContent(); print "."; .L_Say973; .L_SayX946;rtrue;
];
Array TX_S_509 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_509;
[ R_TX_S_510 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Hecho.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Hecho.~]
    say__p=1;! [2: ~Hecho.~]
    ParaContent(); print "Hecho."; .L_Say974; .L_SayX947;rtrue;
];
Array TX_S_510 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_510;
[ R_TX_S_511 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Pones[otherwise][The actor] pone[end if] [the noun] dentro [del second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Pones[otherwise][The actor] pone[end if] [the noun] dentro [del second noun].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say975;! [3: ~Pones~]
    ParaContent(); print "Pones";! [4: otherwise]

    	jump L_SayX948; .L_Say975;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ pone~]
    ParaContent(); print " pone";! [7: end if]

    	.L_Say976; .L_SayX948;! [8: ~ ~]
    ParaContent(); print " ";! [9: the noun]
    ParaContent(); print (the) noun;! [10: ~ dentro ~]
    ParaContent(); print " dentro ";! [11: del second noun]
    ParaContent(); print (del) second;! [12: ~.~]
    ParaContent(); print "."; .L_Say977; .L_SayX949;rtrue;
];
Array TX_S_511 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_511;
[ R_TX_S_512 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso es simplemente incomestible.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso es simplemente incomestible.~]
    say__p=1;! [2: ~Eso es simplemente incomestible.~]
    ParaContent(); print "Eso es simplemente incomestible."; .L_Say978; .L_SayX950;rtrue;
];
Array TX_S_512 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_512;
[ R_TX_S_513 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te quitas [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te quitas [the noun])[command clarification break]~]
    say__p=1;! [2: ~(primero te quitas ~]
    ParaContent(); print "(primero te quitas ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say979; .L_SayX951;rtrue;
];
Array TX_S_513 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_513;
[ R_TX_S_514 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[Al owner] puede que no le guste.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al owner] puede que no le guste.~]
    say__p=1;! [2: al owner]
    ParaContent(); print (_Al) tmp_0;! [3: ~ puede que no le guste.~]
    ParaContent(); print " puede que no le guste."; .L_Say980; .L_SayX952;rtrue;
];
Array TX_S_514 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_514;
[ R_TX_S_515 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Te comes [the noun]. No está[n] mal.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Te comes [the noun]. No está[n] mal.~]
    say__p=1;! [2: ~Te comes ~]
    ParaContent(); print "Te comes ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~. No está~]
    ParaContent(); print ". No está";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ mal.~]
    ParaContent(); print " mal."; .L_Say981; .L_SayX953;rtrue;
];
Array TX_S_515 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_515;
[ R_TX_S_516 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] se come [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] se come [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ se come ~]
    ParaContent(); print " se come ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say982; .L_SayX954;rtrue;
];
Array TX_S_516 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_516;
[ R_TX_S_517 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(saliendo primero de [the chaise])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(saliendo primero de [the chaise])[command clarification break]~]
    say__p=1;! [2: ~(saliendo primero de ~]
    ParaContent(); print "(saliendo primero de ";! [3: the chaise]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say983; .L_SayX955;rtrue;
];
Array TX_S_517 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_517;
[ R_TX_S_518 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~Tienes que bajarte [del nonvehicle] primero.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Tienes que bajarte [del nonvehicle] primero.~]
    say__p=1;! [2: ~Tienes que bajarte ~]
    ParaContent(); print "Tienes que bajarte ";! [3: del nonvehicle]
    ParaContent(); print (del) tmp_0;! [4: ~ primero.~]
    ParaContent(); print " primero."; .L_Say984; .L_SayX956;rtrue;
];
Array TX_S_518 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_518;
[ R_TX_S_519 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~Tienes que salirte [del nonvehicle] primero.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Tienes que salirte [del nonvehicle] primero.~]
    say__p=1;! [2: ~Tienes que salirte ~]
    ParaContent(); print "Tienes que salirte ";! [3: del nonvehicle]
    ParaContent(); print (del) tmp_0;! [4: ~ primero.~]
    ParaContent(); print " primero."; .L_Say985; .L_SayX957;rtrue;
];
Array TX_S_519 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_519;
[ R_TX_S_520 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes ir por ahí.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes ir por ahí.~]
    say__p=1;! [2: ~No puedes ir por ahí.~]
    ParaContent(); print "No puedes ir por ahí."; .L_Say986; .L_SayX958;rtrue;
];
Array TX_S_520 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_520;
[ R_TX_S_521 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(abriendo primero [the door gone through])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(abriendo primero [the door gone through])[command clarification break]~]
    say__p=1;! [2: ~(abriendo primero ~]
    ParaContent(); print "(abriendo primero ";! [3: the door gone through]
    ParaContent(); print (the) (MStack-->MstVO(20007,2));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say987; .L_SayX959;rtrue;
];
Array TX_S_521 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_521;
[ R_TX_S_522 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes ir por ahí.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes ir por ahí.~]
    say__p=1;! [2: ~No puedes ir por ahí.~]
    ParaContent(); print "No puedes ir por ahí."; .L_Say988; .L_SayX960;rtrue;
];
Array TX_S_522 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_522;
[ R_TX_S_523 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes ir porque [the door gone through] no lleva a ningún sitio.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes ir porque [the door gone through] no lleva a ningún sitio.~]
    say__p=1;! [2: ~No puedes ir porque ~]
    ParaContent(); print "No puedes ir porque ";! [3: the door gone through]
    ParaContent(); print (the) (MStack-->MstVO(20007,2));! [4: ~ no lleva a ningún sitio.~]
    ParaContent(); print " no lleva a ningún sitio."; .L_Say989; .L_SayX961;rtrue;
];
Array TX_S_523 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_523;
[ R_TX_S_524 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] se va hacia arriba~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] se va hacia arriba~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ se va hacia arriba~]
    ParaContent(); print " se va hacia arriba"; .L_Say990; .L_SayX962;rtrue;
];
Array TX_S_524 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_524;
[ R_TX_S_525 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] se va hacia abajo~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] se va hacia abajo~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ se va hacia abajo~]
    ParaContent(); print " se va hacia abajo"; .L_Say991; .L_SayX963;rtrue;
];
Array TX_S_525 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_525;
[ R_TX_S_526 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] se va hacia [the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] se va hacia [the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ se va hacia ~]
    ParaContent(); print " se va hacia ";! [4: the noun]
    ParaContent(); print (the) noun; .L_Say992; .L_SayX964;rtrue;
];
Array TX_S_526 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_526;
[ R_TX_S_527 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega desde arriba~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega desde arriba~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega desde arriba~]
    ParaContent(); print " llega desde arriba"; .L_Say993; .L_SayX965;rtrue;
];
Array TX_S_527 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_527;
[ R_TX_S_528 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega desde abajo~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega desde abajo~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega desde abajo~]
    ParaContent(); print " llega desde abajo"; .L_Say994; .L_SayX966;rtrue;
];
Array TX_S_528 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_528;
[ R_TX_S_529 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega desde [the opposite of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega desde [the opposite of the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega desde ~]
    ParaContent(); print " llega desde ";! [4: the opposite of the noun]
    ParaContent(); @push self; print (the) GProperty(OBJECT_TY, self=noun,p10_opposite);@pull self;  .L_Say995; .L_SayX967;rtrue;
];
Array TX_S_529 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_529;
[ R_TX_S_530 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega~]
    ParaContent(); print " llega"; .L_Say996; .L_SayX968;rtrue;
];
Array TX_S_530 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_530;
[ R_TX_S_531 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega a [the room gone to] desde arriba~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega a [the room gone to] desde arriba~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega a ~]
    ParaContent(); print " llega a ";! [4: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [5: ~ desde arriba~]
    ParaContent(); print " desde arriba"; .L_Say997; .L_SayX969;rtrue;
];
Array TX_S_531 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_531;
[ R_TX_S_532 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega a [the room gone to] desde abajo~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega a [the room gone to] desde abajo~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega a ~]
    ParaContent(); print " llega a ";! [4: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [5: ~ desde abajo~]
    ParaContent(); print " desde abajo"; .L_Say998; .L_SayX970;rtrue;
];
Array TX_S_532 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_532;
[ R_TX_S_533 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega a [the room gone to] desde [the opposite of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega a [the room gone to] desde [the opposite of the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega a ~]
    ParaContent(); print " llega a ";! [4: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [5: ~ desde ~]
    ParaContent(); print " desde ";! [6: the opposite of the noun]
    ParaContent(); @push self; print (the) GProperty(OBJECT_TY, self=noun,p10_opposite);@pull self;  .L_Say999; .L_SayX971;rtrue;
];
Array TX_S_533 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_533;
[ R_TX_S_534 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor]  se va por [the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor]  se va por [the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~  se va por ~]
    ParaContent(); print "  se va por ";! [4: the noun]
    ParaContent(); print (the) noun; .L_Say1000; .L_SayX972;rtrue;
];
Array TX_S_534 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_534;
[ R_TX_S_535 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] llega desde [the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] llega desde [the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ llega desde ~]
    ParaContent(); print " llega desde ";! [4: the noun]
    ParaContent(); print (the) noun; .L_Say1001; .L_SayX973;rtrue;
];
Array TX_S_535 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_535;
[ R_TX_S_536 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~sobre [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~sobre [the vehicle gone by]~]
    say__p=1;! [2: ~sobre ~]
    ParaContent(); print "sobre ";! [3: the vehicle gone by]
    ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1002; .L_SayX974;rtrue;
];
Array TX_S_536 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_536;
[ R_TX_S_537 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~en [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~en [the vehicle gone by]~]
    say__p=1;! [2: ~en ~]
    ParaContent(); print "en ";! [3: the vehicle gone by]
    ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1003; .L_SayX975;rtrue;
];
Array TX_S_537 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_537;
[ R_TX_S_538 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, llevando [the thing gone with] en frente, y a ti también~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, llevando [the thing gone with] en frente, y a ti también~]
    say__p=1;! [2: ~, llevando ~]
    ParaContent(); print ", llevando ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ en frente, y a ti también~]
    ParaContent(); print " en frente, y a ti también"; .L_Say1004; .L_SayX976;rtrue;
];
Array TX_S_538 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_538;
[ R_TX_S_539 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, llevando [the thing gone with] en frente~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, llevando [the thing gone with] en frente~]
    say__p=1;! [2: ~, llevando ~]
    ParaContent(); print ", llevando ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ en frente~]
    ParaContent(); print " en frente"; .L_Say1005; .L_SayX977;rtrue;
];
Array TX_S_539 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_539;
[ R_TX_S_540 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, llevando [the thing gone with] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, llevando [the thing gone with] ~]
    say__p=1;! [2: ~, llevando ~]
    ParaContent(); print ", llevando ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ ~]
    ParaContent(); print " "; .L_Say1006; .L_SayX978;rtrue;
];
Array TX_S_540 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_540;
[ R_TX_S_541 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, llevando [the thing gone with] en~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, llevando [the thing gone with] en~]
    say__p=1;! [2: ~, llevando ~]
    ParaContent(); print ", llevando ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ en~]
    ParaContent(); print " en"; .L_Say1007; .L_SayX979;rtrue;
];
Array TX_S_541 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_541;
[ R_TX_S_542 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, llevándote a ti también~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, llevándote a ti también~]
    say__p=1;! [2: ~, llevándote a ti también~]
    ParaContent(); print ", llevándote a ti también"; .L_Say1008; .L_SayX980;rtrue;
];
Array TX_S_542 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_542;
[ R_TX_S_543 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pero si ya estás sobre [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Pero si ya estás sobre [the noun].~]
    say__p=1;! [2: ~Pero si ya estás sobre ~]
    ParaContent(); print "Pero si ya estás sobre ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1009; .L_SayX981;rtrue;
];
Array TX_S_543 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_543;
[ R_TX_S_544 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pero si ya estás en [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Pero si ya estás en [the noun].~]
    say__p=1;! [2: ~Pero si ya estás en ~]
    ParaContent(); print "Pero si ya estás en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1010; .L_SayX982;rtrue;
];
Array TX_S_544 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_544;
[ R_TX_S_545 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es algo donde puedas entrar.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es algo donde puedas entrar.~]
    say__p=1;! [2: ~No es algo donde puedas entrar.~]
    ParaContent(); print "No es algo donde puedas entrar."; .L_Say1011; .L_SayX983;rtrue;
];
Array TX_S_545 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_545;
[ R_TX_S_546 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes entrar en [the noun] porque está[n] cerrad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes entrar en [the noun] porque está[n] cerrad[o].~]
    say__p=1;! [2: ~No puedes entrar en ~]
    ParaContent(); print "No puedes entrar en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ porque está~]
    ParaContent(); print " porque está";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ cerrad~]
    ParaContent(); print " cerrad";! [7: o]
    ParaContent(); (PHR_818_r92 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1012; .L_SayX984;rtrue;
];
Array TX_S_546 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_546;
[ R_TX_S_547 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes entrar ahí mientras no lo sueltes.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes entrar ahí mientras no lo sueltes.~]
    say__p=1;! [2: ~No puedes entrar ahí mientras no lo sueltes.~]
    ParaContent(); print "No puedes entrar ahí mientras no lo sueltes."; .L_Say1013; .L_SayX985;rtrue;
];
Array TX_S_547 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_547;
[ R_TX_S_548 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(te bajas [del holder of the actor])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(te bajas [del holder of the actor])[command clarification break]~]
    say__p=1;! [2: ~(te bajas ~]
    ParaContent(); print "(te bajas ";! [3: del holder of the actor]
    ParaContent(); print (del) (HolderOf(actor));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1014; .L_SayX986;rtrue;
];
Array TX_S_548 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_548;
[ R_TX_S_549 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(sales [del holder of the actor])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(sales [del holder of the actor])[command clarification break]~]
    say__p=1;! [2: ~(sales ~]
    ParaContent(); print "(sales ";! [3: del holder of the actor]
    ParaContent(); print (del) (HolderOf(actor));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1015; .L_SayX987;rtrue;
];
Array TX_S_549 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_549;
[ R_TX_S_550 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(te subes [al target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(te subes [al target])[command clarification break]~]
    say__p=1;! [2: ~(te subes ~]
    ParaContent(); print "(te subes ";! [3: al target]
    ParaContent(); print (al) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1016; .L_SayX988;rtrue;
];
Array TX_S_550 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_550;
[ R_TX_S_551 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(te metes en [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(te metes en [the target])[command clarification break]~]
    say__p=1;! [2: ~(te metes en ~]
    ParaContent(); print "(te metes en ";! [3: the target]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1017; .L_SayX989;rtrue;
];
Array TX_S_551 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_551;
[ R_TX_S_552 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(entras en [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(entras en [the target])[command clarification break]~]
    say__p=1;! [2: ~(entras en ~]
    ParaContent(); print "(entras en ";! [3: the target]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1018; .L_SayX990;rtrue;
];
Array TX_S_552 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_552;
[ R_TX_S_553 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Te subes [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Te subes [al noun].~]
    say__p=1;! [2: ~Te subes ~]
    ParaContent(); print "Te subes ";! [3: al noun]
    ParaContent(); print (al) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1019; .L_SayX991;rtrue;
];
Array TX_S_553 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_553;
[ R_TX_S_554 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Entras en [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Entras en [the noun].~]
    say__p=1;! [2: ~Entras en ~]
    ParaContent(); print "Entras en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1020; .L_SayX992;rtrue;
];
Array TX_S_554 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_554;
[ R_TX_S_555 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Entras[otherwise][The actor] entra[end if] en [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Entras[otherwise][The actor] entra[end if] en [the noun].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say1021;! [3: ~Entras~]
    ParaContent(); print "Entras";! [4: otherwise]

    	jump L_SayX993; .L_Say1021;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ entra~]
    ParaContent(); print " entra";! [7: end if]

    	.L_Say1022; .L_SayX993;! [8: ~ en ~]
    ParaContent(); print " en ";! [9: the noun]
    ParaContent(); print (the) noun;! [10: ~.~]
    ParaContent(); print "."; .L_Say1023; .L_SayX994;rtrue;
];
Array TX_S_555 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_555;
[ R_TX_S_556 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Subes[otherwise][The actor] sube[end if] [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Subes[otherwise][The actor] sube[end if] [al noun].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say1024;! [3: ~Subes~]
    ParaContent(); print "Subes";! [4: otherwise]

    	jump L_SayX995; .L_Say1024;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ sube~]
    ParaContent(); print " sube";! [7: end if]

    	.L_Say1025; .L_SayX995;! [8: ~ ~]
    ParaContent(); print " ";! [9: al noun]
    ParaContent(); print (al) noun;! [10: ~.~]
    ParaContent(); print "."; .L_Say1026; .L_SayX996;rtrue;
];
Array TX_S_556 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_556;
[ R_TX_S_557 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No estás en ningún sitio del que debas salir.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No estás en ningún sitio del que debas salir.~]
    say__p=1;! [2: ~No estás en ningún sitio del que debas salir.~]
    ParaContent(); print "No estás en ningún sitio del que debas salir."; .L_Say1027; .L_SayX997;rtrue;
];
Array TX_S_557 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_557;
[ R_TX_S_558 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes salir [del cage] porque está cerrad[o cage].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes salir [del cage] porque está cerrad[o cage].~]
    say__p=1;! [2: ~No puedes salir ~]
    ParaContent(); print "No puedes salir ";! [3: del cage]
    ParaContent(); print (del) tmp_0;! [4: ~ porque está cerrad~]
    ParaContent(); print " porque está cerrad";! [5: o cage]
    ParaContent(); print (o) tmp_0;! [6: ~.~]
    ParaContent(); print "."; .L_Say1028; .L_SayX998;rtrue;
];
Array TX_S_558 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_558;
[ R_TX_S_559 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Bajas [del container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Bajas [del container exited from].~]
    say__p=1;! [2: ~Bajas ~]
    ParaContent(); print "Bajas ";! [3: del container exited from]
    ParaContent(); print (del) (MStack-->MstVO(20009,0));! [4: ~.~]
    ParaContent(); print "."; .L_Say1029; .L_SayX999;rtrue;
];
Array TX_S_559 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_559;
[ R_TX_S_560 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sales [del container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sales [del container exited from].~]
    say__p=1;! [2: ~Sales ~]
    ParaContent(); print "Sales ";! [3: del container exited from]
    ParaContent(); print (del) (MStack-->MstVO(20009,0));! [4: ~.~]
    ParaContent(); print "."; .L_Say1030; .L_SayX1000;rtrue;
];
Array TX_S_560 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_560;
[ R_TX_S_561 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Sales[otherwise][The actor] sale[end if] [del container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Sales[otherwise][The actor] sale[end if] [del container exited from].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say1031;! [3: ~Sales~]
    ParaContent(); print "Sales";! [4: otherwise]

    	jump L_SayX1001; .L_Say1031;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ sale~]
    ParaContent(); print " sale";! [7: end if]

    	.L_Say1032; .L_SayX1001;! [8: ~ ~]
    ParaContent(); print " ";! [9: del container exited from]
    ParaContent(); print (del) (MStack-->MstVO(20009,0));! [10: ~.~]
    ParaContent(); print "."; .L_Say1033; .L_SayX1002;rtrue;
];
Array TX_S_561 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_561;
[ R_TX_S_562 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pero si no estás en [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Pero si no estás en [the noun].~]
    say__p=1;! [2: ~Pero si no estás en ~]
    ParaContent(); print "Pero si no estás en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1034; .L_SayX1003;rtrue;
];
Array TX_S_562 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_562;
[ R_TX_S_563 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the actor is the player]Sales[otherwise][The actor] sale[end if] [del noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the actor is the player]Sales[otherwise][The actor] sale[end if] [del noun].~]
    say__p=1;! [2: if the actor is the player]

    	if (~~((((actor == player))))) jump L_Say1035;! [3: ~Sales~]
    ParaContent(); print "Sales";! [4: otherwise]

    	jump L_SayX1004; .L_Say1035;! [5: the actor]
    ParaContent(); print (The) actor;! [6: ~ sale~]
    ParaContent(); print " sale";! [7: end if]

    	.L_Say1036; .L_SayX1004;! [8: ~ ~]
    ParaContent(); print " ";! [9: del noun]
    ParaContent(); print (del) noun;! [10: ~.~]
    ParaContent(); print "."; .L_Say1037; .L_SayX1005;rtrue;
];
Array TX_S_563 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_563;
[ R_TX_S_564 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oscuridad~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oscuridad~]
    say__p=1;! [2: ~Oscuridad~]
    ParaContent(); print "Oscuridad"; .L_Say1038; .L_SayX1006;rtrue;
];
Array TX_S_564 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_564;
[ R_TX_S_565 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (sobre [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (sobre [the intermediate level])~]
    say__p=1;! [2: ~ (sobre ~]
    ParaContent(); print " (sobre ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1039; .L_SayX1007;rtrue;
];
Array TX_S_565 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_565;
[ R_TX_S_566 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (en [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (en [the intermediate level])~]
    say__p=1;! [2: ~ (en ~]
    ParaContent(); print " (en ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1040; .L_SayX1008;rtrue;
];
Array TX_S_566 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_566;
[ R_TX_S_567 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Está muy oscuro y no puedes ver nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Está muy oscuro y no puedes ver nada.~]
    say__p=1;! [2: ~Está muy oscuro y no puedes ver nada.~]
    ParaContent(); print "Está muy oscuro y no puedes ver nada."; .L_Say1041; .L_SayX1009;rtrue;
];
Array TX_S_567 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_567;
[ R_TX_S_568 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] mira alrededor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] mira alrededor.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ mira alrededor.~]
    ParaContent(); print " mira alrededor."; .L_Say1042; .L_SayX1010;rtrue;
];
Array TX_S_568 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_568;
[ R_TX_S_569 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No ves nada en especial al mirar en esa dirección.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No ves nada en especial al mirar en esa dirección.~]
    say__p=1;! [2: ~No ves nada en especial al mirar en esa dirección.~]
    ParaContent(); print "No ves nada en especial al mirar en esa dirección."; .L_Say1043; .L_SayX1011;rtrue;
];
Array TX_S_569 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_569;
[ R_TX_S_570 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~En [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En [the noun] ~]
    say__p=1;! [2: ~En ~]
    ParaContent(); print "En ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1044; .L_SayX1012;rtrue;
];
Array TX_S_570 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_570;
[ R_TX_S_571 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está[n] vací[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está[n] vací[o].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está~]
    ParaContent(); print " está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ vací~]
    ParaContent(); print " vací";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1045; .L_SayX1013;rtrue;
];
Array TX_S_571 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_571;
[ R_TX_S_572 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sobre [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sobre [the noun] ~]
    say__p=1;! [2: ~Sobre ~]
    ParaContent(); print "Sobre ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1046; .L_SayX1014;rtrue;
];
Array TX_S_572 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_572;
[ R_TX_S_573 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está[n] [if the noun is switched on]encendid[o][otherwise]apagad[o][end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está[n] [if the noun is switched on]encendid[o][otherwise]apagad[o][end if].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está~]
    ParaContent(); print " está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: if the noun is switched on]

    	if (~~(((((Adj_93_t1_v10(noun))))))) jump L_Say1047;! [7: ~encendid~]
    ParaContent(); print "encendid";! [8: o]
    ParaContent(); (PHR_818_r92 ());! [9: otherwise]

    	jump L_SayX1015; .L_Say1047;! [10: ~apagad~]
    ParaContent(); print "apagad";! [11: o]
    ParaContent(); (PHR_818_r92 ());! [12: end if]

    	.L_Say1048; .L_SayX1015;! [13: ~.~]
    ParaContent(); print "."; .L_Say1049; .L_SayX1016;rtrue;
];
Array TX_S_573 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_573;
[ R_TX_S_574 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No observas nada especial en [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No observas nada especial en [the noun].~]
    say__p=1;! [2: ~No observas nada especial en ~]
    ParaContent(); print "No observas nada especial en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1050; .L_SayX1017;rtrue;
];
Array TX_S_574 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_574;
[ R_TX_S_575 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] mira de cerca [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] mira de cerca [al noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ mira de cerca ~]
    ParaContent(); print " mira de cerca ";! [4: al noun]
    ParaContent(); print (al) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1051; .L_SayX1018;rtrue;
];
Array TX_S_575 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_575;
[ R_TX_S_576 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No ves nada interesante.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No ves nada interesante.~]
    say__p=1;! [2: ~No ves nada interesante.~]
    ParaContent(); print "No ves nada interesante."; .L_Say1052; .L_SayX1019;rtrue;
];
Array TX_S_576 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_576;
[ R_TX_S_577 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] mira debajo [del noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] mira debajo [del noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ mira debajo ~]
    ParaContent(); print " mira debajo ";! [4: del noun]
    ParaContent(); print (del) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1053; .L_SayX1020;rtrue;
];
Array TX_S_577 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_577;
[ R_TX_S_578 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No encuentras nada interesante.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No encuentras nada interesante.~]
    say__p=1;! [2: ~No encuentras nada interesante.~]
    ParaContent(); print "No encuentras nada interesante."; .L_Say1054; .L_SayX1021;rtrue;
];
Array TX_S_578 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_578;
[ R_TX_S_579 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes ver lo que hay dentro [del noun] porque está[n] cerrado[s noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes ver lo que hay dentro [del noun] porque está[n] cerrado[s noun].~]
    say__p=1;! [2: ~No puedes ver lo que hay dentro ~]
    ParaContent(); print "No puedes ver lo que hay dentro ";! [3: del noun]
    ParaContent(); print (del) noun;! [4: ~ porque está~]
    ParaContent(); print " porque está";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ cerrado~]
    ParaContent(); print " cerrado";! [7: s noun]
    ParaContent(); print (s) noun;! [8: ~.~]
    ParaContent(); print "."; .L_Say1055; .L_SayX1022;rtrue;
];
Array TX_S_579 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_579;
[ R_TX_S_580 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~En [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En [the noun] ~]
    say__p=1;! [2: ~En ~]
    ParaContent(); print "En ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1056; .L_SayX1023;rtrue;
];
Array TX_S_580 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_580;
[ R_TX_S_581 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está[n] vací[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está[n] vací[o].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está~]
    ParaContent(); print " está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ vací~]
    ParaContent(); print " vací";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1057; .L_SayX1024;rtrue;
];
Array TX_S_581 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_581;
[ R_TX_S_582 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sobre [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sobre [the noun] ~]
    say__p=1;! [2: ~Sobre ~]
    ParaContent(); print "Sobre ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1058; .L_SayX1025;rtrue;
];
Array TX_S_582 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_582;
[ R_TX_S_583 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay nada sobre [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay nada sobre [the noun].~]
    say__p=1;! [2: ~No hay nada sobre ~]
    ParaContent(); print "No hay nada sobre ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1059; .L_SayX1026;rtrue;
];
Array TX_S_583 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_583;
[ R_TX_S_584 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] busca [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] busca [al noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ busca ~]
    ParaContent(); print " busca ";! [4: al noun]
    ParaContent(); print (al) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1060; .L_SayX1027;rtrue;
];
Array TX_S_584 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_584;
[ R_TX_S_585 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No descubres nada interesante en [the noun] sobre este tema.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No descubres nada interesante en [the noun] sobre este tema.~]
    say__p=1;! [2: ~No descubres nada interesante en ~]
    ParaContent(); print "No descubres nada interesante en ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ sobre este tema.~]
    ParaContent(); print " sobre este tema."; .L_Say1061; .L_SayX1028;rtrue;
];
Array TX_S_585 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_585;
[ R_TX_S_586 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] consulta [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] consulta [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ consulta ~]
    ParaContent(); print " consulta ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1062; .L_SayX1029;rtrue;
];
Array TX_S_586 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_586;
[ R_TX_S_587 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]No parece[n] tener ningún tipo de cerrojo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]No parece[n] tener ningún tipo de cerrojo.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~No parece~]
    ParaContent(); print "No parece";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ tener ningún tipo de cerrojo.~]
    ParaContent(); print " tener ningún tipo de cerrojo."; .L_Say1063; .L_SayX1030;rtrue;
];
Array TX_S_587 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_587;
[ R_TX_S_588 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][The noun] ya estaba cerrad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][The noun] ya estaba cerrad[o].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: the noun]
    ParaContent(); print (The) noun;! [4: ~ ya estaba cerrad~]
    ParaContent(); print " ya estaba cerrad";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~.~]
    ParaContent(); print "."; .L_Say1064; .L_SayX1031;rtrue;
];
Array TX_S_588 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_588;
[ R_TX_S_589 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Primero [tu] tienes que cerrar [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Primero [tu] tienes que cerrar [the noun].~]
    say__p=1;! [2: ~Primero ~]
    ParaContent(); print "Primero ";! [3: tu]
    ParaContent(); (PHR_806_r80 ());! [4: ~ tienes que cerrar ~]
    ParaContent(); print " tienes que cerrar ";! [5: the noun]
    ParaContent(); print (the) noun;! [6: ~.~]
    ParaContent(); print "."; .L_Say1065; .L_SayX1032;rtrue;
];
Array TX_S_589 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_589;
[ R_TX_S_590 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun]No parece[n], encajar en la cerradura.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the second noun]No parece[n], encajar en la cerradura.~]
    say__p=1;! [2: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [3: ~No parece~]
    ParaContent(); print "No parece";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~, encajar en la cerradura.~]
    ParaContent(); print ", encajar en la cerradura."; .L_Say1066; .L_SayX1033;rtrue;
];
Array TX_S_590 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_590;
[ R_TX_S_591 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Cierras [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Cierras [the noun].~]
    say__p=1;! [2: ~Cierras ~]
    ParaContent(); print "Cierras ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1067; .L_SayX1034;rtrue;
];
Array TX_S_591 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_591;
[ R_TX_S_592 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] cierra [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] cierra [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ cierra ~]
    ParaContent(); print " cierra ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1068; .L_SayX1035;rtrue;
];
Array TX_S_592 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_592;
[ R_TX_S_593 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No [regarding the noun]parece[n] tener ningún tipo de cerrojo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No [regarding the noun]parece[n] tener ningún tipo de cerrojo.~]
    say__p=1;! [2: ~No ~]
    ParaContent(); print "No ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~parece~]
    ParaContent(); print "parece";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ tener ningún tipo de cerrojo.~]
    ParaContent(); print " tener ningún tipo de cerrojo."; .L_Say1069; .L_SayX1036;rtrue;
];
Array TX_S_593 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_593;
[ R_TX_S_594 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] ya tenía abierto el cerrojo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] ya tenía abierto el cerrojo.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ ya tenía abierto el cerrojo.~]
    ParaContent(); print " ya tenía abierto el cerrojo."; .L_Say1070; .L_SayX1037;rtrue;
];
Array TX_S_594 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_594;
[ R_TX_S_595 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No [regarding the second noun]parece[n] encajar en la cerradura.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No [regarding the second noun]parece[n] encajar en la cerradura.~]
    say__p=1;! [2: ~No ~]
    ParaContent(); print "No ";! [3: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [4: ~parece~]
    ParaContent(); print "parece";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ encajar en la cerradura.~]
    ParaContent(); print " encajar en la cerradura."; .L_Say1071; .L_SayX1038;rtrue;
];
Array TX_S_595 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_595;
[ R_TX_S_596 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Tu] quitas el cerrojo [al noun].[plm]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Tu] quitas el cerrojo [al noun].[plm]~]
    say__p=1;! [2: tu]
    ParaContent(); (PHR_807_r81 ());! [3: ~ quitas el cerrojo ~]
    ParaContent(); print " quitas el cerrojo ";! [4: al noun]
    ParaContent(); print (al) noun;! [5: ~.~]
    ParaContent(); print ".";! [6: plm]
    ParaContent(); (PHR_805_r79 ()); .L_Say1072; .L_SayX1039;rtrue;
];
Array TX_S_596 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_596;
[ R_TX_S_597 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] quita el cerrojo [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] quita el cerrojo [al noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ quita el cerrojo ~]
    ParaContent(); print " quita el cerrojo ";! [4: al noun]
    ParaContent(); print (al) noun;! [5: ~.~]
    ParaContent(); print "."; .L_Say1073; .L_SayX1040;rtrue;
];
Array TX_S_597 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_597;
[ R_TX_S_598 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es algo que pueda encenderse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es algo que pueda encenderse.~]
    say__p=1;! [2: ~No es algo que pueda encenderse.~]
    ParaContent(); print "No es algo que pueda encenderse."; .L_Say1074; .L_SayX1041;rtrue;
];
Array TX_S_598 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_598;
[ R_TX_S_599 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya [regarding the noun]estaba[n] encendid[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya [regarding the noun]estaba[n] encendid[o].~]
    say__p=1;! [2: ~Ya ~]
    ParaContent(); print "Ya ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~estaba~]
    ParaContent(); print "estaba";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ encendid~]
    ParaContent(); print " encendid";! [7: o]
    ParaContent(); (PHR_818_r92 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1075; .L_SayX1042;rtrue;
];
Array TX_S_599 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_599;
[ R_TX_S_600 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] enciendes [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] enciendes [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ enciendes ~]
    ParaContent(); print " enciendes ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1076; .L_SayX1043;rtrue;
];
Array TX_S_600 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_600;
[ R_TX_S_601 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es algo pueda apagarse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es algo pueda apagarse.~]
    say__p=1;! [2: ~No es algo pueda apagarse.~]
    ParaContent(); print "No es algo pueda apagarse."; .L_Say1077; .L_SayX1044;rtrue;
];
Array TX_S_601 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_601;
[ R_TX_S_602 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya [regarding the noun] estaba apagad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya [regarding the noun] estaba apagad[o].~]
    say__p=1;! [2: ~Ya ~]
    ParaContent(); print "Ya ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~ estaba apagad~]
    ParaContent(); print " estaba apagad";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~.~]
    ParaContent(); print "."; .L_Say1078; .L_SayX1045;rtrue;
];
Array TX_S_602 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_602;
[ R_TX_S_603 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] apaga [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] apaga [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ apaga ~]
    ParaContent(); print " apaga ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1079; .L_SayX1046;rtrue;
];
Array TX_S_603 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_603;
[ R_TX_S_604 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es algo que pueda abrirse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es algo que pueda abrirse.~]
    say__p=1;! [2: ~No es algo que pueda abrirse.~]
    ParaContent(); print "No es algo que pueda abrirse."; .L_Say1080; .L_SayX1047;rtrue;
];
Array TX_S_604 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_604;
[ R_TX_S_605 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Está[n] cerrad[o] con llave.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Está[n] cerrad[o] con llave.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Está~]
    ParaContent(); print "Está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ cerrad~]
    ParaContent(); print " cerrad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~ con llave.~]
    ParaContent(); print " con llave."; .L_Say1081; .L_SayX1048;rtrue;
];
Array TX_S_605 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_605;
[ R_TX_S_606 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya [regarding the noun]esta[n] abiert[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya [regarding the noun]esta[n] abiert[o].~]
    say__p=1;! [2: ~Ya ~]
    ParaContent(); print "Ya ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~esta~]
    ParaContent(); print "esta";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ abiert~]
    ParaContent(); print " abiert";! [7: o]
    ParaContent(); (PHR_818_r92 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1082; .L_SayX1049;rtrue;
];
Array TX_S_606 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_606;
[ R_TX_S_607 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Abres [el noun], descubriendo ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Abres [el noun], descubriendo ~]
    say__p=1;! [2: ~Abres ~]
    ParaContent(); print "Abres ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~, descubriendo ~]
    ParaContent(); print ", descubriendo "; .L_Say1083; .L_SayX1050;rtrue;
];
Array TX_S_607 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_607;
[ R_TX_S_608 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Abres [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Abres [el noun].~]
    say__p=1;! [2: ~Abres ~]
    ParaContent(); print "Abres ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1084; .L_SayX1051;rtrue;
];
Array TX_S_608 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_608;
[ R_TX_S_609 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] abre [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] abre [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ abre ~]
    ParaContent(); print " abre ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1085; .L_SayX1052;rtrue;
];
Array TX_S_609 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_609;
[ R_TX_S_610 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] se abre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] se abre.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ se abre.~]
    ParaContent(); print " se abre."; .L_Say1086; .L_SayX1053;rtrue;
];
Array TX_S_610 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_610;
[ R_TX_S_611 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es algo que pueda cerrarse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es algo que pueda cerrarse.~]
    say__p=1;! [2: ~No es algo que pueda cerrarse.~]
    ParaContent(); print "No es algo que pueda cerrarse."; .L_Say1087; .L_SayX1054;rtrue;
];
Array TX_S_611 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_611;
[ R_TX_S_612 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ya [regarding the noun]esta[n] cerrad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ya [regarding the noun]esta[n] cerrad[o].~]
    say__p=1;! [2: ~Ya ~]
    ParaContent(); print "Ya ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~esta~]
    ParaContent(); print "esta";! [5: n]
    ParaContent(); (PHR_821_r95 ());! [6: ~ cerrad~]
    ParaContent(); print " cerrad";! [7: o]
    ParaContent(); (PHR_818_r92 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1088; .L_SayX1055;rtrue;
];
Array TX_S_612 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_612;
[ R_TX_S_613 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Cierras [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Cierras [el noun].~]
    say__p=1;! [2: ~Cierras ~]
    ParaContent(); print "Cierras ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1089; .L_SayX1056;rtrue;
];
Array TX_S_613 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_613;
[ R_TX_S_614 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] cierra [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] cierra [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ cierra ~]
    ParaContent(); print " cierra ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1090; .L_SayX1057;rtrue;
];
Array TX_S_614 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_614;
[ R_TX_S_615 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] se cierra.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] se cierra.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ se cierra.~]
    ParaContent(); print " se cierra."; .L_Say1091; .L_SayX1058;rtrue;
];
Array TX_S_615 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_615;
[ R_TX_S_616 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡No puedes ponerte eso!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡No puedes ponerte eso!~]
    say__p=1;! [2: ~¡No puedes ponerte eso!~]
    ParaContent(); print "¡No puedes ponerte eso!"; .L_Say1092; .L_SayX1059;rtrue;
];
Array TX_S_616 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_616;
[ R_TX_S_617 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡No [regarding the noun]l[o] tienes!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡No [regarding the noun]l[o] tienes!~]
    say__p=1;! [2: ~¡No ~]
    ParaContent(); print "¡No ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~l~]
    ParaContent(); print "l";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~ tienes!~]
    ParaContent(); print " tienes!"; .L_Say1093; .L_SayX1060;rtrue;
];
Array TX_S_617 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_617;
[ R_TX_S_618 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡Ya [regarding the noun]l[o] llevas puest[o]!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡Ya [regarding the noun]l[o] llevas puest[o]!~]
    say__p=1;! [2: ~¡Ya ~]
    ParaContent(); print "¡Ya ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~l~]
    ParaContent(); print "l";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~ llevas puest~]
    ParaContent(); print " llevas puest";! [7: o]
    ParaContent(); (PHR_818_r92 ());! [8: ~!~]
    ParaContent(); print "!"; .L_Say1094; .L_SayX1061;rtrue;
];
Array TX_S_618 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_618;
[ R_TX_S_619 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Te pones [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Te pones [el noun].~]
    say__p=1;! [2: ~Te pones ~]
    ParaContent(); print "Te pones ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1095; .L_SayX1062;rtrue;
];
Array TX_S_619 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_619;
[ R_TX_S_620 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] se pone [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] se pone [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ se pone ~]
    ParaContent(); print " se pone ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1096; .L_SayX1063;rtrue;
];
Array TX_S_620 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_620;
[ R_TX_S_621 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No llevas puesto eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No llevas puesto eso.~]
    say__p=1;! [2: ~No llevas puesto eso.~]
    ParaContent(); print "No llevas puesto eso."; .L_Say1097; .L_SayX1064;rtrue;
];
Array TX_S_621 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_621;
[ R_TX_S_622 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Llevas demasiadas cosas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Llevas demasiadas cosas.~]
    say__p=1;! [2: ~Llevas demasiadas cosas.~]
    ParaContent(); print "Llevas demasiadas cosas."; .L_Say1098; .L_SayX1065;rtrue;
];
Array TX_S_622 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_622;
[ R_TX_S_623 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Te quitas [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Te quitas [el noun].~]
    say__p=1;! [2: ~Te quitas ~]
    ParaContent(); print "Te quitas ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1099; .L_SayX1066;rtrue;
];
Array TX_S_623 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_623;
[ R_TX_S_624 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] se quita [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] se quita [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ se quita ~]
    ParaContent(); print " se quita ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~.~]
    ParaContent(); print "."; .L_Say1100; .L_SayX1067;rtrue;
];
Array TX_S_624 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_624;
[ R_TX_S_625 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No tienes [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No tienes [el noun].~]
    say__p=1;! [2: ~No tienes ~]
    ParaContent(); print "No tienes ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1101; .L_SayX1068;rtrue;
];
Array TX_S_625 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_625;
[ R_TX_S_626 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes darte [el noun] a tí mismo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes darte [el noun] a tí mismo.~]
    say__p=1;! [2: ~No puedes darte ~]
    ParaContent(); print "No puedes darte ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~ a tí mismo.~]
    ParaContent(); print " a tí mismo."; .L_Say1102; .L_SayX1069;rtrue;
];
Array TX_S_626 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_626;
[ R_TX_S_627 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El second noun] no puede recibir cosas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El second noun] no puede recibir cosas.~]
    say__p=1;! [2: el second noun]
    ParaContent(); (PHR_803_r77 (second));! [3: ~ no puede recibir cosas.~]
    ParaContent(); print " no puede recibir cosas."; .L_Say1103; .L_SayX1070;rtrue;
];
Array TX_S_627 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_627;
[ R_TX_S_628 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te quitas [el noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te quitas [el noun])[command clarification break]~]
    say__p=1;! [2: ~(primero te quitas ~]
    ParaContent(); print "(primero te quitas ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1104; .L_SayX1071;rtrue;
];
Array TX_S_628 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_628;
[ R_TX_S_629 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El second noun] no parece[n] interesad[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El second noun] no parece[n] interesad[o].~]
    say__p=1;! [2: el second noun]
    ParaContent(); (PHR_803_r77 (second));! [3: ~ no parece~]
    ParaContent(); print " no parece";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ interesad~]
    ParaContent(); print " interesad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1105; .L_SayX1072;rtrue;
];
Array TX_S_629 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_629;
[ R_TX_S_630 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El second noun] está[n] llevando demasiadas cosas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El second noun] está[n] llevando demasiadas cosas.~]
    say__p=1;! [2: el second noun]
    ParaContent(); (PHR_803_r77 (second));! [3: ~ está~]
    ParaContent(); print " está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ llevando demasiadas cosas.~]
    ParaContent(); print " llevando demasiadas cosas."; .L_Say1106; .L_SayX1073;rtrue;
];
Array TX_S_630 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_630;
[ R_TX_S_631 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Le das [el noun] [al second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Le das [el noun] [al second noun].~]
    say__p=1;! [2: ~Le das ~]
    ParaContent(); print "Le das ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~ ~]
    ParaContent(); print " ";! [5: al second noun]
    ParaContent(); print (al) second;! [6: ~.~]
    ParaContent(); print "."; .L_Say1107; .L_SayX1074;rtrue;
];
Array TX_S_631 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_631;
[ R_TX_S_632 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] te da [el second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] te da [el second noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ te da ~]
    ParaContent(); print " te da ";! [4: el second noun]
    ParaContent(); (PHR_801_r75 (second));! [5: ~.~]
    ParaContent(); print "."; .L_Say1108; .L_SayX1075;rtrue;
];
Array TX_S_632 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_632;
[ R_TX_S_633 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] da [el noun] [al second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] da [el noun] [al second noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ da ~]
    ParaContent(); print " da ";! [4: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [5: ~ ~]
    ParaContent(); print " ";! [6: al second noun]
    ParaContent(); print (al) second;! [7: ~.~]
    ParaContent(); print "."; .L_Say1109; .L_SayX1076;rtrue;
];
Array TX_S_633 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_633;
[ R_TX_S_634 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No tienes [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No tienes [el noun].~]
    say__p=1;! [2: ~No tienes ~]
    ParaContent(); print "No tienes ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1110; .L_SayX1077;rtrue;
];
Array TX_S_634 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_634;
[ R_TX_S_635 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El second noun] no muestra interés.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El second noun] no muestra interés.~]
    say__p=1;! [2: el second noun]
    ParaContent(); (PHR_803_r77 (second));! [3: ~ no muestra interés.~]
    ParaContent(); print " no muestra interés."; .L_Say1111; .L_SayX1078;rtrue;
];
Array TX_S_635 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_635;
[ R_TX_S_636 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso parece innecesario.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso parece innecesario.~]
    say__p=1;! [2: ~Eso parece innecesario.~]
    ParaContent(); print "Eso parece innecesario."; .L_Say1112; .L_SayX1079;rtrue;
];
Array TX_S_636 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_636;
[ R_TX_S_637 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero te quitas [el noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero te quitas [el noun])[command clarification break]~]
    say__p=1;! [2: ~(primero te quitas ~]
    ParaContent(); print "(primero te quitas ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1113; .L_SayX1080;rtrue;
];
Array TX_S_637 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_637;
[ R_TX_S_638 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No serviría de nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No serviría de nada.~]
    say__p=1;! [2: ~No serviría de nada.~]
    ParaContent(); print "No serviría de nada."; .L_Say1114; .L_SayX1081;rtrue;
];
Array TX_S_638 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_638;
[ R_TX_S_639 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~En el último momento te echas atrás.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En el último momento te echas atrás.~]
    say__p=1;! [2: ~En el último momento te echas atrás.~]
    ParaContent(); print "En el último momento te echas atrás."; .L_Say1115; .L_SayX1082;rtrue;
];
Array TX_S_639 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_639;
[ R_TX_S_640 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~La violencia no es la solución.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~La violencia no es la solución.~]
    say__p=1;! [2: ~La violencia no es la solución.~]
    ParaContent(); print "La violencia no es la solución."; .L_Say1116; .L_SayX1083;rtrue;
];
Array TX_S_640 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_640;
[ R_TX_S_641 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No conseguirás mucho con eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No conseguirás mucho con eso.~]
    say__p=1;! [2: ~No conseguirás mucho con eso.~]
    ParaContent(); print "No conseguirás mucho con eso."; .L_Say1117; .L_SayX1084;rtrue;
];
Array TX_S_641 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_641;
[ R_TX_S_642 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1118; .L_SayX1085;rtrue;
];
Array TX_S_642 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_642;
[ R_TX_S_643 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay respuesta.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay respuesta.~]
    say__p=1;! [2: ~No hay respuesta.~]
    ParaContent(); print "No hay respuesta."; .L_Say1119; .L_SayX1086;rtrue;
];
Array TX_S_643 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_643;
[ R_TX_S_644 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Hablas sol[o] durante un rato.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Hablas sol[o] durante un rato.~]
    say__p=1;! [2: ~Hablas sol~]
    ParaContent(); print "Hablas sol";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ durante un rato.~]
    ParaContent(); print " durante un rato."; .L_Say1120; .L_SayX1087;rtrue;
];
Array TX_S_644 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_644;
[ R_TX_S_645 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No has provocado ninguna reacción.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No has provocado ninguna reacción.~]
    say__p=1;! [2: ~No has provocado ninguna reacción.~]
    ParaContent(); print "No has provocado ninguna reacción."; .L_Say1121; .L_SayX1088;rtrue;
];
Array TX_S_645 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_645;
[ R_TX_S_646 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay respuesta.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay respuesta.~]
    say__p=1;! [2: ~No hay respuesta.~]
    ParaContent(); print "No hay respuesta."; .L_Say1122; .L_SayX1089;rtrue;
];
Array TX_S_646 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_646;
[ R_TX_S_647 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El tiempo pasa...~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El tiempo pasa...~]
    say__p=1;! [2: ~El tiempo pasa...~]
    ParaContent(); print "El tiempo pasa..."; .L_Say1123; .L_SayX1090;rtrue;
];
Array TX_S_647 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_647;
[ R_TX_S_648 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] deja pasar el tiempo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] deja pasar el tiempo.~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ deja pasar el tiempo.~]
    ParaContent(); print " deja pasar el tiempo."; .L_Say1124; .L_SayX1091;rtrue;
];
Array TX_S_648 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_648;
[ R_TX_S_649 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No logras nada con eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No logras nada con eso.~]
    say__p=1;! [2: ~No logras nada con eso.~]
    ParaContent(); print "No logras nada con eso."; .L_Say1125; .L_SayX1092;rtrue;
];
Array TX_S_649 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_649;
[ R_TX_S_650 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] se toca[n] a si mism[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] se toca[n] a si mism[o].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ se toca~]
    ParaContent(); print " se toca";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ a si mism~]
    ParaContent(); print " a si mism";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1126; .L_SayX1093;rtrue;
];
Array TX_S_650 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_650;
[ R_TX_S_651 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1127; .L_SayX1094;rtrue;
];
Array TX_S_651 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_651;
[ R_TX_S_652 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] te toca[n].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] te toca[n].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ te toca~]
    ParaContent(); print " te toca";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~.~]
    ParaContent(); print "."; .L_Say1128; .L_SayX1095;rtrue;
];
Array TX_S_652 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_652;
[ R_TX_S_653 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] toca[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] toca[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ toca~]
    ParaContent(); print " toca";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1129; .L_SayX1096;rtrue;
];
Array TX_S_653 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_653;
[ R_TX_S_654 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No notas nada extraño al tacto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No notas nada extraño al tacto.~]
    say__p=1;! [2: ~No notas nada extraño al tacto.~]
    ParaContent(); print "No notas nada extraño al tacto."; .L_Say1130; .L_SayX1097;rtrue;
];
Array TX_S_654 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_654;
[ R_TX_S_655 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] toca[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] toca[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ toca~]
    ParaContent(); print " toca";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1131; .L_SayX1098;rtrue;
];
Array TX_S_655 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_655;
[ R_TX_S_656 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pero no [regarding the noun]l[o] tienes.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Pero no [regarding the noun]l[o] tienes.~]
    say__p=1;! [2: ~Pero no ~]
    ParaContent(); print "Pero no ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: ~l~]
    ParaContent(); print "l";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: ~ tienes.~]
    ParaContent(); print " tienes."; .L_Say1132; .L_SayX1099;rtrue;
];
Array TX_S_656 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_656;
[ R_TX_S_657 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Agitas [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Agitas [el noun].~]
    say__p=1;! [2: ~Agitas ~]
    ParaContent(); print "Agitas ";! [3: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [4: ~.~]
    ParaContent(); print "."; .L_Say1133; .L_SayX1100;rtrue;
];
Array TX_S_657 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_657;
[ R_TX_S_658 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] agita[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] agita[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ agita~]
    ParaContent(); print " agita";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1134; .L_SayX1101;rtrue;
];
Array TX_S_658 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_658;
[ R_TX_S_659 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Está[n] firmemente sujet[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Está[n] firmemente sujet[o].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Está~]
    ParaContent(); print "Está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ firmemente sujet~]
    ParaContent(); print " firmemente sujet";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1135; .L_SayX1102;rtrue;
];
Array TX_S_659 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_659;
[ R_TX_S_660 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No eres capaz.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No eres capaz.~]
    say__p=1;! [2: ~No eres capaz.~]
    ParaContent(); print "No eres capaz."; .L_Say1136; .L_SayX1103;rtrue;
];
Array TX_S_660 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_660;
[ R_TX_S_661 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1137; .L_SayX1104;rtrue;
];
Array TX_S_661 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_661;
[ R_TX_S_662 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No ocurre nada, aparentemente.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No ocurre nada, aparentemente.~]
    say__p=1;! [2: ~No ocurre nada, aparentemente.~]
    ParaContent(); print "No ocurre nada, aparentemente."; .L_Say1138; .L_SayX1105;rtrue;
];
Array TX_S_662 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_662;
[ R_TX_S_663 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] tira[n] [del noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] tira[n] [del noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ tira~]
    ParaContent(); print " tira";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: del noun]
    ParaContent(); print (del) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1139; .L_SayX1106;rtrue;
];
Array TX_S_663 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_663;
[ R_TX_S_664 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Está[n] firmemente sujet[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Está[n] firmemente sujet[o].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Está~]
    ParaContent(); print "Está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ firmemente sujet~]
    ParaContent(); print " firmemente sujet";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1140; .L_SayX1107;rtrue;
];
Array TX_S_664 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_664;
[ R_TX_S_665 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No eres capaz.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No eres capaz.~]
    say__p=1;! [2: ~No eres capaz.~]
    ParaContent(); print "No eres capaz."; .L_Say1141; .L_SayX1108;rtrue;
];
Array TX_S_665 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_665;
[ R_TX_S_666 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1142; .L_SayX1109;rtrue;
];
Array TX_S_666 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_666;
[ R_TX_S_667 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No ocurre nada, aparentemente.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No ocurre nada, aparentemente.~]
    say__p=1;! [2: ~No ocurre nada, aparentemente.~]
    ParaContent(); print "No ocurre nada, aparentemente."; .L_Say1143; .L_SayX1110;rtrue;
];
Array TX_S_667 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_667;
[ R_TX_S_668 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] empuja[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] empuja[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ empuja~]
    ParaContent(); print " empuja";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1144; .L_SayX1111;rtrue;
];
Array TX_S_668 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_668;
[ R_TX_S_669 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Está[n] firmemente sujet[o].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Está[n] firmemente sujet[o].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Está~]
    ParaContent(); print "Está";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ firmemente sujet~]
    ParaContent(); print " firmemente sujet";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1145; .L_SayX1112;rtrue;
];
Array TX_S_669 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_669;
[ R_TX_S_670 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No eres capaz.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No eres capaz.~]
    say__p=1;! [2: ~No eres capaz.~]
    ParaContent(); print "No eres capaz."; .L_Say1146; .L_SayX1113;rtrue;
];
Array TX_S_670 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_670;
[ R_TX_S_671 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1147; .L_SayX1114;rtrue;
];
Array TX_S_671 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_671;
[ R_TX_S_672 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No ocurre nada, aparentemente.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No ocurre nada, aparentemente.~]
    say__p=1;! [2: ~No ocurre nada, aparentemente.~]
    ParaContent(); print "No ocurre nada, aparentemente."; .L_Say1148; .L_SayX1115;rtrue;
];
Array TX_S_672 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_672;
[ R_TX_S_673 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] gira[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] gira[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ gira~]
    ParaContent(); print " gira";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1149; .L_SayX1116;rtrue;
];
Array TX_S_673 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_673;
[ R_TX_S_674 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] no puede[n] ser empujad[o] de un lugar a otro.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] no puede[n] ser empujad[o] de un lugar a otro.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ no puede~]
    ParaContent(); print " no puede";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ser empujad~]
    ParaContent(); print " ser empujad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~ de un lugar a otro.~]
    ParaContent(); print " de un lugar a otro."; .L_Say1150; .L_SayX1117;rtrue;
];
Array TX_S_674 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_674;
[ R_TX_S_675 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso no es una dirección.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso no es una dirección.~]
    say__p=1;! [2: ~Eso no es una dirección.~]
    ParaContent(); print "Eso no es una dirección."; .L_Say1151; .L_SayX1118;rtrue;
];
Array TX_S_675 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_675;
[ R_TX_S_676 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] no puede[n] ser empujad[o] hacia arriba o hacia abajo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] no puede[n] ser empujad[o] hacia arriba o hacia abajo.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ no puede~]
    ParaContent(); print " no puede";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ser empujad~]
    ParaContent(); print " ser empujad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~ hacia arriba o hacia abajo.~]
    ParaContent(); print " hacia arriba o hacia abajo."; .L_Say1152; .L_SayX1119;rtrue;
];
Array TX_S_676 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_676;
[ R_TX_S_677 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] no puede ser empujado desde aquí.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] no puede ser empujado desde aquí.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ no puede ser empujado desde aquí.~]
    ParaContent(); print " no puede ser empujado desde aquí."; .L_Say1153; .L_SayX1120;rtrue;
];
Array TX_S_677 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_677;
[ R_TX_S_678 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El noun] no puede[n] ser empujad[o] de un lugar a otro.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El noun] no puede[n] ser empujad[o] de un lugar a otro.~]
    say__p=1;! [2: el noun]
    ParaContent(); (PHR_803_r77 (noun));! [3: ~ no puede~]
    ParaContent(); print " no puede";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ser empujad~]
    ParaContent(); print " ser empujad";! [6: o]
    ParaContent(); (PHR_818_r92 ());! [7: ~ de un lugar a otro.~]
    ParaContent(); print " de un lugar a otro."; .L_Say1154; .L_SayX1121;rtrue;
];
Array TX_S_678 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_678;
[ R_TX_S_679 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría no gustarle~]
    ParaContent(); print " podría no gustarle";! [4: s]
    ParaContent(); (PHR_822_r96 ());! [5: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1155; .L_SayX1122;rtrue;
];
Array TX_S_679 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_679;
[ R_TX_S_680 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No logras nada con eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No logras nada con eso.~]
    say__p=1;! [2: ~No logras nada con eso.~]
    ParaContent(); print "No logras nada con eso."; .L_Say1156; .L_SayX1123;rtrue;
];
Array TX_S_680 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_680;
[ R_TX_S_681 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] retuerce[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] retuerce[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ retuerce~]
    ParaContent(); print " retuerce";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1157; .L_SayX1124;rtrue;
];
Array TX_S_681 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_681;
[ R_TX_S_682 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sólo era una pregunta retórica.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sólo era una pregunta retórica.~]
    say__p=1;! [2: ~Sólo era una pregunta retórica.~]
    ParaContent(); print "Sólo era una pregunta retórica."; .L_Say1158; .L_SayX1125;rtrue;
];
Array TX_S_682 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_682;
[ R_TX_S_683 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sólo era una pregunta retórica.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sólo era una pregunta retórica.~]
    say__p=1;! [2: ~Sólo era una pregunta retórica.~]
    ParaContent(); print "Sólo era una pregunta retórica."; .L_Say1159; .L_SayX1126;rtrue;
];
Array TX_S_683 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_683;
[ R_TX_S_684 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Con esa peligrosa acción no lograrías nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Con esa peligrosa acción no lograrías nada.~]
    say__p=1;! [2: ~Con esa peligrosa acción no lograrías nada.~]
    ParaContent(); print "Con esa peligrosa acción no lograrías nada."; .L_Say1160; .L_SayX1127;rtrue;
];
Array TX_S_684 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_684;
[ R_TX_S_685 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~La cruda realidad es que esto no es un sueño.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~La cruda realidad es que esto no es un sueño.~]
    say__p=1;! [2: ~La cruda realidad es que esto no es un sueño.~]
    ParaContent(); print "La cruda realidad es que esto no es un sueño."; .L_Say1161; .L_SayX1128;rtrue;
];
Array TX_S_685 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_685;
[ R_TX_S_686 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Vaya. Qué buena idea.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Vaya. Qué buena idea.~]
    say__p=1;! [2: ~Vaya. Qué buena idea.~]
    ParaContent(); print "Vaya. Qué buena idea."; .L_Say1162; .L_SayX1129;rtrue;
];
Array TX_S_686 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_686;
[ R_TX_S_687 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hueles nada extraño.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hueles nada extraño.~]
    say__p=1;! [2: ~No hueles nada extraño.~]
    ParaContent(); print "No hueles nada extraño."; .L_Say1163; .L_SayX1130;rtrue;
];
Array TX_S_687 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_687;
[ R_TX_S_688 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] huele el ambiente.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] huele el ambiente.~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ huele el ambiente.~]
    ParaContent(); print " huele el ambiente."; .L_Say1164; .L_SayX1131;rtrue;
];
Array TX_S_688 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_688;
[ R_TX_S_689 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No escuchas nada fuera de lo común.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No escuchas nada fuera de lo común.~]
    say__p=1;! [2: ~No escuchas nada fuera de lo común.~]
    ParaContent(); print "No escuchas nada fuera de lo común."; .L_Say1165; .L_SayX1132;rtrue;
];
Array TX_S_689 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_689;
[ R_TX_S_690 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] presta[n] atención a lo que escucha[n].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] presta[n] atención a lo que escucha[n].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ presta~]
    ParaContent(); print " presta";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ atención a lo que escucha~]
    ParaContent(); print " atención a lo que escucha";! [6: n]
    ParaContent(); (PHR_821_r95 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1166; .L_SayX1133;rtrue;
];
Array TX_S_690 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_690;
[ R_TX_S_691 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No saboreas nada raro.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No saboreas nada raro.~]
    say__p=1;! [2: ~No saboreas nada raro.~]
    ParaContent(); print "No saboreas nada raro."; .L_Say1167; .L_SayX1134;rtrue;
];
Array TX_S_691 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_691;
[ R_TX_S_692 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] saborea[n] [el noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] saborea[n] [el noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ saborea~]
    ParaContent(); print " saborea";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: el noun]
    ParaContent(); (PHR_801_r75 (noun));! [7: ~.~]
    ParaContent(); print "."; .L_Say1168; .L_SayX1135;rtrue;
];
Array TX_S_692 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_692;
[ R_TX_S_693 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]Cortándol[o] no lograrás gran cosa.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]Cortándol[o] no lograrás gran cosa.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~Cortándol~]
    ParaContent(); print "Cortándol";! [4: o]
    ParaContent(); (PHR_818_r92 ());! [5: ~ no lograrás gran cosa.~]
    ParaContent(); print " no lograrás gran cosa."; .L_Say1169; .L_SayX1136;rtrue;
];
Array TX_S_693 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_693;
[ R_TX_S_694 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Saltas en el sitio.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Saltas en el sitio.~]
    say__p=1;! [2: ~Saltas en el sitio.~]
    ParaContent(); print "Saltas en el sitio."; .L_Say1170; .L_SayX1137;rtrue;
];
Array TX_S_694 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_694;
[ R_TX_S_695 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] salta[n] en el sitio~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] salta[n] en el sitio~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ salta~]
    ParaContent(); print " salta";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ en el sitio~]
    ParaContent(); print " en el sitio"; .L_Say1171; .L_SayX1138;rtrue;
];
Array TX_S_695 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_695;
[ R_TX_S_696 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No lograrás nada con eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No lograrás nada con eso.~]
    say__p=1;! [2: ~No lograrás nada con eso.~]
    ParaContent(); print "No lograrás nada con eso."; .L_Say1172; .L_SayX1139;rtrue;
];
Array TX_S_696 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_696;
[ R_TX_S_697 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso no parece potable.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso no parece potable.~]
    say__p=1;! [2: ~Eso no parece potable.~]
    ParaContent(); print "Eso no parece potable."; .L_Say1173; .L_SayX1140;rtrue;
];
Array TX_S_697 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_697;
[ R_TX_S_698 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oh, no es necesario que te disculpes.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oh, no es necesario que te disculpes.~]
    say__p=1;! [2: ~Oh, no es necesario que te disculpes.~]
    ParaContent(); print "Oh, no es necesario que te disculpes."; .L_Say1174; .L_SayX1141;rtrue;
];
Array TX_S_698 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_698;
[ R_TX_S_699 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No [if noun is plural-named]son[otherwise]es[end if] [regarding the noun]adecuad[o] para columpiarse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No [if noun is plural-named]son[otherwise]es[end if] [regarding the noun]adecuad[o] para columpiarse.~]
    say__p=1;! [2: ~No ~]
    ParaContent(); print "No ";! [3: if noun is plural-named]

    	if (~~(((((Adj_53_t1_v10(noun))))))) jump L_Say1175;! [4: ~son~]
    ParaContent(); print "son";! [5: otherwise]

    	jump L_SayX1142; .L_Say1175;! [6: ~es~]
    ParaContent(); print "es";! [7: end if]

    	.L_Say1176; .L_SayX1142;! [8: ~ ~]
    ParaContent(); print " ";! [9: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [10: ~adecuad~]
    ParaContent(); print "adecuad";! [11: o]
    ParaContent(); (PHR_818_r92 ());! [12: ~ para columpiarse.~]
    ParaContent(); print " para columpiarse."; .L_Say1177; .L_SayX1143;rtrue;
];
Array TX_S_699 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_699;
[ R_TX_S_700 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Al noun] podría[n] no gustarle[s] eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Al noun] podría[n] no gustarle[s] eso.~]
    say__p=1;! [2: al noun]
    ParaContent(); print (_Al) noun;! [3: ~ podría~]
    ParaContent(); print " podría";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ no gustarle~]
    ParaContent(); print " no gustarle";! [6: s]
    ParaContent(); (PHR_822_r96 ());! [7: ~ eso.~]
    ParaContent(); print " eso."; .L_Say1178; .L_SayX1144;rtrue;
];
Array TX_S_700 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_700;
[ R_TX_S_701 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the noun is the actor]Te frotas[otherwise]Frotas[end if] [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the noun is the actor]Te frotas[otherwise]Frotas[end if] [al noun].~]
    say__p=1;! [2: if the noun is the actor]

    	if (~~((((noun == actor))))) jump L_Say1179;! [3: ~Te frotas~]
    ParaContent(); print "Te frotas";! [4: otherwise]

    	jump L_SayX1145; .L_Say1179;! [5: ~Frotas~]
    ParaContent(); print "Frotas";! [6: end if]

    	.L_Say1180; .L_SayX1145;! [7: ~ ~]
    ParaContent(); print " ";! [8: al noun]
    ParaContent(); print (al) noun;! [9: ~.~]
    ParaContent(); print "."; .L_Say1181; .L_SayX1146;rtrue;
];
Array TX_S_701 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_701;
[ R_TX_S_702 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] frota[n] [al noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] frota[n] [al noun].~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ frota~]
    ParaContent(); print " frota";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: al noun]
    ParaContent(); print (al) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1182; .L_SayX1147;rtrue;
];
Array TX_S_702 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_702;
[ R_TX_S_703 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso no puede setearse a ningún valor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso no puede setearse a ningún valor.~]
    say__p=1;! [2: ~Eso no puede setearse a ningún valor.~]
    ParaContent(); print "Eso no puede setearse a ningún valor."; .L_Say1183; .L_SayX1148;rtrue;
];
Array TX_S_703 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_703;
[ R_TX_S_704 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ondeas las manos.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ondeas las manos.~]
    say__p=1;! [2: ~Ondeas las manos.~]
    ParaContent(); print "Ondeas las manos."; .L_Say1184; .L_SayX1149;rtrue;
];
Array TX_S_704 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_704;
[ R_TX_S_705 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[El actor] ondea[n] las manos.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[El actor] ondea[n] las manos.~]
    say__p=1;! [2: el actor]
    ParaContent(); (PHR_803_r77 (actor));! [3: ~ ondea~]
    ParaContent(); print " ondea";! [4: n]
    ParaContent(); (PHR_821_r95 ());! [5: ~ las manos.~]
    ParaContent(); print " las manos."; .L_Say1185; .L_SayX1150;rtrue;
];
Array TX_S_705 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_705;
[ R_TX_S_706 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay nada en venta.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay nada en venta.~]
    say__p=1;! [2: ~No hay nada en venta.~]
    ParaContent(); print "No hay nada en venta."; .L_Say1186; .L_SayX1151;rtrue;
];
Array TX_S_706 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_706;
[ R_TX_S_707 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No creo que vayas a lograr nada así.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No creo que vayas a lograr nada así.~]
    say__p=1;! [2: ~No creo que vayas a lograr nada así.~]
    ParaContent(); print "No creo que vayas a lograr nada así."; .L_Say1187; .L_SayX1152;rtrue;
];
Array TX_S_707 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_707;
[ R_TX_S_708 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No estás especialmente somnolient[o_jugador].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No estás especialmente somnolient[o_jugador].~]
    say__p=1;! [2: ~No estás especialmente somnolient~]
    ParaContent(); print "No estás especialmente somnolient";! [3: o_jugador]
    ParaContent(); (PHR_819_r93 ());! [4: ~.~]
    ParaContent(); print "."; .L_Say1188; .L_SayX1153;rtrue;
];
Array TX_S_708 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_708;
[ R_TX_S_709 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[paragraph break]Presiona ESPACIO para continuar.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[paragraph break]Presiona ESPACIO para continuar.~]
    say__p=1;! [2: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [3: ~Presiona ESPACIO para continuar.~]
    ParaContent(); print "Presiona ESPACIO para continuar."; .L_Say1189; .L_SayX1154;rtrue;
];
Array TX_S_709 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_709;
[ R_TX_S_710 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡Está muy oscuro aquí!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡Está muy oscuro aquí!~]
    say__p=1;! [2: ~¡Está muy oscuro aquí!~]
    ParaContent(); print "¡Está muy oscuro aquí!"; .L_Say1190; .L_SayX1155;rtrue;
];
Array TX_S_710 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_710;
[ R_TX_S_711 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(solo considero los primeros dieciséis objetos)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(solo considero los primeros dieciséis objetos)[command clarification break]~]
    say__p=1;! [2: ~(solo considero los primeros dieciséis objetos)~]
    ParaContent(); print "(solo considero los primeros dieciséis objetos)";! [3: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1191; .L_SayX1156;rtrue;
];
Array TX_S_711 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_711;
[ R_TX_S_712 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡Nada para hacer!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡Nada para hacer!~]
    say__p=1;! [2: ~¡Nada para hacer!~]
    ParaContent(); print "¡Nada para hacer!"; .L_Say1192; .L_SayX1157;rtrue;
];
Array TX_S_712 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_712;
[ R_TX_S_713 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes decir algo más... concreto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes decir algo más... concreto.~]
    say__p=1;! [2: ~Debes decir algo más... concreto.~]
    ParaContent(); print "Debes decir algo más... concreto."; .L_Say1193; .L_SayX1158;rtrue;
];
Array TX_S_713 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_713;
[ R_TX_S_714 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Está demasiado oscuro, no puedes ver nada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Está demasiado oscuro, no puedes ver nada.~]
    say__p=1;! [2: ~Está demasiado oscuro, no puedes ver nada.~]
    ParaContent(); print "Está demasiado oscuro, no puedes ver nada."; .L_Say1194; .L_SayX1159;rtrue;
];
Array TX_S_714 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_714;
[ R_TX_S_715 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] tiene mejores cosas que hacer.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] tiene mejores cosas que hacer.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ tiene mejores cosas que hacer.~]
    ParaContent(); print " tiene mejores cosas que hacer."; .L_Say1195; .L_SayX1160;rtrue;
];
Array TX_S_715 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_715;
[ R_TX_S_716 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] no puede hace eso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] no puede hace eso.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ no puede hace eso.~]
    ParaContent(); print " no puede hace eso."; .L_Say1196; .L_SayX1161;rtrue;
];
Array TX_S_716 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_716;
[ R_TX_S_717 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] no está abierto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] no está abierto.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ no está abierto.~]
    ParaContent(); print " no está abierto."; .L_Say1197; .L_SayX1162;rtrue;
];
Array TX_S_717 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_717;
[ R_TX_S_718 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No llegas a [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No llegas a [the noun].~]
    say__p=1;! [2: ~No llegas a ~]
    ParaContent(); print "No llegas a ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1198; .L_SayX1163;rtrue;
];
Array TX_S_718 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_718;
[ R_TX_S_719 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] no está abierto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] no está abierto.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ no está abierto.~]
    ParaContent(); print " no está abierto."; .L_Say1199; .L_SayX1164;rtrue;
];
Array TX_S_719 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_719;
[ R_TX_S_720 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ (~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (~]
    say__p=1;! [2: ~ (~]
    ParaContent(); print " ("; .L_Say1200; .L_SayX1165;rtrue;
];
Array TX_S_720 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_720;
[ R_TX_S_721 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~)~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~)~]
    say__p=1;! [2: ~)~]
    ParaContent(); print ")"; .L_Say1201; .L_SayX1166;rtrue;
];
Array TX_S_721 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_721;
[ R_TX_S_722 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ y ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ y ~]
    say__p=1;! [2: ~ y ~]
    ParaContent(); print " y "; .L_Say1202; .L_SayX1167;rtrue;
];
Array TX_S_722 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_722;
[ R_TX_S_723 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~alumbrando~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~alumbrando~]
    say__p=1;! [2: ~alumbrando~]
    ParaContent(); print "alumbrando"; .L_Say1203; .L_SayX1168;rtrue;
];
Array TX_S_723 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_723;
[ R_TX_S_724 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o]~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1204; .L_SayX1169;rtrue;
];
Array TX_S_724 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_724;
[ R_TX_S_725 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun]vací[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun]vací[o]~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: ~vací~]
    ParaContent(); print "vací";! [4: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1205; .L_SayX1170;rtrue;
];
Array TX_S_725 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_725;
[ R_TX_S_726 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o] y vací[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o] y vací[o]~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ y vací~]
    ParaContent(); print " y vací";! [5: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1206; .L_SayX1171;rtrue;
];
Array TX_S_726 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_726;
[ R_TX_S_727 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o] y alumbrando~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o] y alumbrando~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ y alumbrando~]
    ParaContent(); print " y alumbrando"; .L_Say1207; .L_SayX1172;rtrue;
];
Array TX_S_727 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_727;
[ R_TX_S_728 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~vací[o] y alumbrando~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~vací[o] y alumbrando~]
    say__p=1;! [2: ~vací~]
    ParaContent(); print "vací";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ y alumbrando~]
    ParaContent(); print " y alumbrando"; .L_Say1208; .L_SayX1173;rtrue;
];
Array TX_S_728 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_728;
[ R_TX_S_729 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o], vací[o][if serial comma option is active],[end if] y alumbrando~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o], vací[o][if serial comma option is active],[end if] y alumbrando~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~, vací~]
    ParaContent(); print ", vací";! [5: o]
    ParaContent(); (PHR_818_r92 ());! [6: if serial comma option is active]

    	if (~~(((((Adj_25_t1_v16(6))))))) jump L_Say1209;! [7: ~,~]
    ParaContent(); print ",";! [8: end if]

    	.L_Say1209; .L_SayX1174;! [9: ~ y alumbrando~]
    ParaContent(); print " y alumbrando"; .L_Say1210; .L_SayX1175;rtrue;
];
Array TX_S_729 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_729;
[ R_TX_S_730 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(alumbrando y que llevas puest[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(alumbrando y que llevas puest[o]~]
    say__p=1;! [2: ~(alumbrando y que llevas puest~]
    ParaContent(); print "(alumbrando y que llevas puest";! [3: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1211; .L_SayX1176;rtrue;
];
Array TX_S_730 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_730;
[ R_TX_S_731 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~que llevas puest[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~que llevas puest[o]~]
    say__p=1;! [2: ~que llevas puest~]
    ParaContent(); print "que llevas puest";! [3: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1212; .L_SayX1177;rtrue;
];
Array TX_S_731 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_731;
[ R_TX_S_732 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~abiert[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~abiert[o]~]
    say__p=1;! [2: ~abiert~]
    ParaContent(); print "abiert";! [3: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1213; .L_SayX1178;rtrue;
];
Array TX_S_732 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_732;
[ R_TX_S_733 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~abiert[o] y vací[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~abiert[o] y vací[o]~]
    say__p=1;! [2: ~abiert~]
    ParaContent(); print "abiert";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ y vací~]
    ParaContent(); print " y vací";! [5: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1214; .L_SayX1179;rtrue;
];
Array TX_S_733 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_733;
[ R_TX_S_734 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o]~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ()); .L_Say1215; .L_SayX1180;rtrue;
];
Array TX_S_734 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_734;
[ R_TX_S_735 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~cerrad[o] con llave~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~cerrad[o] con llave~]
    say__p=1;! [2: ~cerrad~]
    ParaContent(); print "cerrad";! [3: o]
    ParaContent(); (PHR_818_r92 ());! [4: ~ con llave~]
    ParaContent(); print " con llave"; .L_Say1216; .L_SayX1181;rtrue;
];
Array TX_S_735 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_735;
[ R_TX_S_736 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~que contiene~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~que contiene~]
    say__p=1;! [2: ~que contiene~]
    ParaContent(); print "que contiene"; .L_Say1217; .L_SayX1182;rtrue;
];
Array TX_S_736 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_736;
[ R_TX_S_737 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the noun is a person]encima [del_ noun][otherwise]sobre[end if] [el_ noun]cual[s noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the noun is a person]encima [del_ noun][otherwise]sobre[end if] [el_ noun]cual[s noun] ~]
    say__p=1;! [2: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1218;! [3: ~encima ~]
    ParaContent(); print "encima ";! [4: del_ noun]
    ParaContent(); print (del_) noun;! [5: otherwise]

    	jump L_SayX1183; .L_Say1218;! [6: ~sobre~]
    ParaContent(); print "sobre";! [7: end if]

    	.L_Say1219; .L_SayX1183;! [8: ~ ~]
    ParaContent(); print " ";! [9: el_ noun]
    ParaContent(); print (el_) noun;! [10: ~cual~]
    ParaContent(); print "cual";! [11: s noun]
    ParaContent(); print (s) noun;! [12: ~ ~]
    ParaContent(); print " "; .L_Say1220; .L_SayX1184;rtrue;
];
Array TX_S_737 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_737;
[ R_TX_S_738 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, [if the noun is a person]encima[otherwise]sobre[end if] [el_ noun]cual ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, [if the noun is a person]encima[otherwise]sobre[end if] [el_ noun]cual ~]
    say__p=1;! [2: ~, ~]
    ParaContent(); print ", ";! [3: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1221;! [4: ~encima~]
    ParaContent(); print "encima";! [5: otherwise]

    	jump L_SayX1185; .L_Say1221;! [6: ~sobre~]
    ParaContent(); print "sobre";! [7: end if]

    	.L_Say1222; .L_SayX1185;! [8: ~ ~]
    ParaContent(); print " ";! [9: el_ noun]
    ParaContent(); print (el_) noun;! [10: ~cual ~]
    ParaContent(); print "cual "; .L_Say1223; .L_SayX1186;rtrue;
];
Array TX_S_738 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_738;
[ R_TX_S_739 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the noun is a person]encima[otherwise]en[end if] [el_ noun]cual ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the noun is a person]encima[otherwise]en[end if] [el_ noun]cual ~]
    say__p=1;! [2: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1224;! [3: ~encima~]
    ParaContent(); print "encima";! [4: otherwise]

    	jump L_SayX1187; .L_Say1224;! [5: ~en~]
    ParaContent(); print "en";! [6: end if]

    	.L_Say1225; .L_SayX1187;! [7: ~ ~]
    ParaContent(); print " ";! [8: el_ noun]
    ParaContent(); print (el_) noun;! [9: ~cual ~]
    ParaContent(); print "cual "; .L_Say1226; .L_SayX1188;rtrue;
];
Array TX_S_739 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_739;
[ R_TX_S_740 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, dentro ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, dentro ~]
    say__p=1;! [2: ~, dentro ~]
    ParaContent(); print ", dentro "; .L_Say1227; .L_SayX1189;rtrue;
];
Array TX_S_740 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_740;
[ R_TX_S_741 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[es-ves]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[es-ves]~]
    say__p=1;! [2: es-ves]
    ParaContent(); (PHR_827_r97 ()); .L_Say1228; .L_SayX1190;rtrue;
];
Array TX_S_741 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_741;
[ R_TX_S_742 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~es nada~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~es nada~]
    say__p=1;! [2: ~es nada~]
    ParaContent(); print "es nada"; .L_Say1229; .L_SayX1191;rtrue;
];
Array TX_S_742 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_742;
[ R_TX_S_743 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nada~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nada~]
    say__p=1;! [2: ~Nada~]
    ParaContent(); print "Nada"; .L_Say1230; .L_SayX1192;rtrue;
];
Array TX_S_743 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_743;
[ R_TX_S_744 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~nada~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~nada~]
    say__p=1;! [2: ~nada~]
    ParaContent(); print "nada"; .L_Say1231; .L_SayX1193;rtrue;
];
Array TX_S_744 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_744;
[ R_TX_S_745 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Esa orden se aplica fuera del juego, por lo que solo tiene sentido para el parser, no para [the noun].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Esa orden se aplica fuera del juego, por lo que solo tiene sentido para el parser, no para [the noun].[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Esa orden se aplica fuera del juego, por lo que solo tiene sentido para el parser, no para ~]
    ParaContent(); print "Esa orden se aplica fuera del juego, por lo que solo tiene sentido para el parser, no para ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~.~]
    ParaContent(); print ".";! [6: close bracket]
    ParaContent(); print "]"; .L_Say1232; .L_SayX1194;rtrue;
];
Array TX_S_745 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_745;
[ R_TX_S_746 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes mencionar un objeto en concreto~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes mencionar un objeto en concreto~]
    say__p=1;! [2: ~Debes mencionar un objeto en concreto~]
    ParaContent(); print "Debes mencionar un objeto en concreto"; .L_Say1233; .L_SayX1195;rtrue;
];
Array TX_S_746 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_746;
[ R_TX_S_747 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es necesario mencionar un objeto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es necesario mencionar un objeto.~]
    say__p=1;! [2: ~No es necesario mencionar un objeto.~]
    ParaContent(); print "No es necesario mencionar un objeto."; .L_Say1234; .L_SayX1196;rtrue;
];
Array TX_S_747 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_747;
[ R_TX_S_748 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes mencionar un objeto en concreto~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes mencionar un objeto en concreto~]
    say__p=1;! [2: ~Debes mencionar un objeto en concreto~]
    ParaContent(); print "Debes mencionar un objeto en concreto"; .L_Say1235; .L_SayX1197;rtrue;
];
Array TX_S_748 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_748;
[ R_TX_S_749 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No es necesario mencionar un objeto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No es necesario mencionar un objeto.~]
    say__p=1;! [2: ~No es necesario mencionar un objeto.~]
    ParaContent(); print "No es necesario mencionar un objeto."; .L_Say1236; .L_SayX1198;rtrue;
];
Array TX_S_749 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_749;
[ R_TX_S_750 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes mencionar el segundo objeto en concreto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes mencionar el segundo objeto en concreto.~]
    say__p=1;! [2: ~Debes mencionar el segundo objeto en concreto.~]
    ParaContent(); print "Debes mencionar el segundo objeto en concreto."; .L_Say1237; .L_SayX1199;rtrue;
];
Array TX_S_750 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_750;
[ R_TX_S_751 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Puedes no mencionar el segundo objeto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Puedes no mencionar el segundo objeto.~]
    say__p=1;! [2: ~Puedes no mencionar el segundo objeto.~]
    ParaContent(); print "Puedes no mencionar el segundo objeto."; .L_Say1238; .L_SayX1200;rtrue;
];
Array TX_S_751 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_751;
[ R_TX_S_752 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debes mencionar el segundo objeto en concreto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debes mencionar el segundo objeto en concreto.~]
    say__p=1;! [2: ~Debes mencionar el segundo objeto en concreto.~]
    ParaContent(); print "Debes mencionar el segundo objeto en concreto."; .L_Say1239; .L_SayX1201;rtrue;
];
Array TX_S_752 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_752;
[ R_TX_S_753 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Puedes no mencionar el segundo objeto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Puedes no mencionar el segundo objeto.~]
    say__p=1;! [2: ~Puedes no mencionar el segundo objeto.~]
    ParaContent(); print "Puedes no mencionar el segundo objeto."; .L_Say1240; .L_SayX1202;rtrue;
];
Array TX_S_753 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_753;
[ R_TX_S_754 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(Ya que ha ocurrido algo dramático, se ha recortado la lista de objetos sobre los que actuabas)~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(Ya que ha ocurrido algo dramático, se ha recortado la lista de objetos sobre los que actuabas)~]
    say__p=1;! [2: ~(Ya que ha ocurrido algo dramático, se ha recortado la lista de objetos sobre los que actuabas)~]
    ParaContent(); print "(Ya que ha ocurrido algo dramático, se ha recortado la lista de objetos sobre los que actuabas)"; .L_Say1241; .L_SayX1203;rtrue;
];
Array TX_S_754 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_754;
[ R_TX_S_755 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Instrucción no comprendida.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Instrucción no comprendida.~]
    say__p=1;! [2: ~Instrucción no comprendida.~]
    ParaContent(); print "Instrucción no comprendida."; .L_Say1242; .L_SayX1204;rtrue;
];
Array TX_S_755 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_755;
[ R_TX_S_756 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No entendí esa frase.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No entendí esa frase.~]
    say__p=1;! [2: ~No entendí esa frase.~]
    ParaContent(); print "No entendí esa frase."; .L_Say1243; .L_SayX1205;rtrue;
];
Array TX_S_756 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_756;
[ R_TX_S_757 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Intenta de nuevo, porque sólo te pude entender: ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Intenta de nuevo, porque sólo te pude entender: ~]
    say__p=1;! [2: ~Intenta de nuevo, porque sólo te pude entender: ~]
    ParaContent(); print "Intenta de nuevo, porque sólo te pude entender: "; .L_Say1244; .L_SayX1206;rtrue;
];
Array TX_S_757 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_757;
[ R_TX_S_758 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Intenta de nuevo, porque sólo te pude entender: (IR) ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Intenta de nuevo, porque sólo te pude entender: (IR) ~]
    say__p=1;! [2: ~Intenta de nuevo, porque sólo te pude entender: (IR) ~]
    ParaContent(); print "Intenta de nuevo, porque sólo te pude entender: (IR) "; .L_Say1245; .L_SayX1207;rtrue;
];
Array TX_S_758 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_758;
[ R_TX_S_759 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No comprendí ese número.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No comprendí ese número.~]
    say__p=1;! [2: ~No comprendí ese número.~]
    ParaContent(); print "No comprendí ese número."; .L_Say1246; .L_SayX1208;rtrue;
];
Array TX_S_759 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_759;
[ R_TX_S_760 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No veo eso que dices.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No veo eso que dices.~]
    say__p=1;! [2: ~No veo eso que dices.~]
    ParaContent(); print "No veo eso que dices."; .L_Say1247; .L_SayX1209;rtrue;
];
Array TX_S_760 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_760;
[ R_TX_S_761 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡Pareces haber dicho muy poca cosa!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡Pareces haber dicho muy poca cosa!~]
    say__p=1;! [2: ~¡Pareces haber dicho muy poca cosa!~]
    ParaContent(); print "¡Pareces haber dicho muy poca cosa!"; .L_Say1248; .L_SayX1210;rtrue;
];
Array TX_S_761 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_761;
[ R_TX_S_762 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡No tienes eso!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡No tienes eso!~]
    say__p=1;! [2: ~¡No tienes eso!~]
    ParaContent(); print "¡No tienes eso!"; .L_Say1249; .L_SayX1211;rtrue;
];
Array TX_S_762 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_762;
[ R_TX_S_763 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes especificar objetos múltiples con ese verbo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes especificar objetos múltiples con ese verbo.~]
    say__p=1;! [2: ~No puedes especificar objetos múltiples con ese verbo.~]
    ParaContent(); print "No puedes especificar objetos múltiples con ese verbo."; .L_Say1250; .L_SayX1212;rtrue;
];
Array TX_S_763 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_763;
[ R_TX_S_764 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sólo puedes especificar objetos múltiples una vez en cada línea.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sólo puedes especificar objetos múltiples una vez en cada línea.~]
    say__p=1;! [2: ~Sólo puedes especificar objetos múltiples una vez en cada línea.~]
    ParaContent(); print "Sólo puedes especificar objetos múltiples una vez en cada línea."; .L_Say1251; .L_SayX1213;rtrue;
];
Array TX_S_764 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_764;
[ R_TX_S_765 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No estoy seguro de a qué se refiere ['][pronoun i6 dictionary word]['].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No estoy seguro de a qué se refiere ['][pronoun i6 dictionary word]['].~]
    say__p=1;! [2: ~No estoy seguro de a qué se refiere ~]
    ParaContent(); print "No estoy seguro de a qué se refiere ";! [3: ']
    ParaContent(); print "'";! [4: pronoun i6 dictionary word]
    ParaContent(); print (address) pronoun_word;! [5: ']
    ParaContent(); print "'";! [6: ~.~]
    ParaContent(); print "."; .L_Say1252; .L_SayX1214;rtrue;
];
Array TX_S_765 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_765;
[ R_TX_S_766 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ahora mismo no puedes ver lo que representa el pronombre ['][pronoun i6 dictionary word]['] ([the noun]).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ahora mismo no puedes ver lo que representa el pronombre ['][pronoun i6 dictionary word]['] ([the noun]).~]
    say__p=1;! [2: ~Ahora mismo no puedes ver lo que representa el pronombre ~]
    ParaContent(); print "Ahora mismo no puedes ver lo que representa el pronombre ";! [3: ']
    ParaContent(); print "'";! [4: pronoun i6 dictionary word]
    ParaContent(); print (address) pronoun_word;! [5: ']
    ParaContent(); print "'";! [6: ~ (~]
    ParaContent(); print " (";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~).~]
    ParaContent(); print ")."; .L_Say1253; .L_SayX1215;rtrue;
];
Array TX_S_766 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_766;
[ R_TX_S_767 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Has exceptuado algo que no estaba incluido.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Has exceptuado algo que no estaba incluido.~]
    say__p=1;! [2: ~Has exceptuado algo que no estaba incluido.~]
    ParaContent(); print "Has exceptuado algo que no estaba incluido."; .L_Say1254; .L_SayX1216;rtrue;
];
Array TX_S_767 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_767;
[ R_TX_S_768 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sólo puedes hacer eso con seres animados.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sólo puedes hacer eso con seres animados.~]
    say__p=1;! [2: ~Sólo puedes hacer eso con seres animados.~]
    ParaContent(); print "Sólo puedes hacer eso con seres animados."; .L_Say1255; .L_SayX1217;rtrue;
];
Array TX_S_768 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_768;
[ R_TX_S_769 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No conozco ese verbo.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No conozco ese verbo.~]
    say__p=1;! [2: ~No conozco ese verbo.~]
    ParaContent(); print "No conozco ese verbo."; .L_Say1256; .L_SayX1218;rtrue;
];
Array TX_S_769 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_769;
[ R_TX_S_770 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso no es importante.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso no es importante.~]
    say__p=1;! [2: ~Eso no es importante.~]
    ParaContent(); print "Eso no es importante."; .L_Say1257; .L_SayX1219;rtrue;
];
Array TX_S_770 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_770;
[ R_TX_S_771 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No entendí la última parte de la orden.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No entendí la última parte de la orden.~]
    say__p=1;! [2: ~No entendí la última parte de la orden.~]
    ParaContent(); print "No entendí la última parte de la orden."; .L_Say1258; .L_SayX1220;rtrue;
];
Array TX_S_771 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_771;
[ R_TX_S_772 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if number understood is 0]No hay suficientes [otherwise]Aquí sólo hay [number understood in words] [end if]disponibles.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if number understood is 0]No hay suficientes [otherwise]Aquí sólo hay [number understood in words] [end if]disponibles.~]
    say__p=1;! [2: if number understood is 0]

    	if (~~((((parsed_number == 0))))) jump L_Say1259;! [3: ~No hay suficientes ~]
    ParaContent(); print "No hay suficientes ";! [4: otherwise]

    	jump L_SayX1221; .L_Say1259;! [5: ~Aquí sólo hay ~]
    ParaContent(); print "Aquí sólo hay ";! [6: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [7: ~ ~]
    ParaContent(); print " ";! [8: end if]

    	.L_Say1260; .L_SayX1221;! [9: ~disponibles.~]
    ParaContent(); print "disponibles."; .L_Say1261; .L_SayX1222;rtrue;
];
Array TX_S_772 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_772;
[ R_TX_S_773 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ese objeto no tiene sentido en este contexto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ese objeto no tiene sentido en este contexto.~]
    say__p=1;! [2: ~Ese objeto no tiene sentido en este contexto.~]
    ParaContent(); print "Ese objeto no tiene sentido en este contexto."; .L_Say1262; .L_SayX1223;rtrue;
];
Array TX_S_773 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_773;
[ R_TX_S_774 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Para repetir un comando como 'rana, salta', escribe 'repite', en lugar de 'rana, repite'.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Para repetir un comando como 'rana, salta', escribe 'repite', en lugar de 'rana, repite'.~]
    say__p=1;! [2: ~Para repetir un comando como 'rana, salta', escribe 'repite', en lugar de 'rana, repite'.~]
    ParaContent(); print "Para repetir un comando como ~rana, salta~, escribe ~repite~, en lugar de ~rana, repite~."; .L_Say1263; .L_SayX1224;rtrue;
];
Array TX_S_774 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_774;
[ R_TX_S_775 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes empezar la frase con una coma.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes empezar la frase con una coma.~]
    say__p=1;! [2: ~No puedes empezar la frase con una coma.~]
    ParaContent(); print "No puedes empezar la frase con una coma."; .L_Say1264; .L_SayX1225;rtrue;
];
Array TX_S_775 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_775;
[ R_TX_S_776 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Parece que quieres hablar con alguien, pero no veo con quién.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Parece que quieres hablar con alguien, pero no veo con quién.~]
    say__p=1;! [2: ~Parece que quieres hablar con alguien, pero no veo con quién.~]
    ParaContent(); print "Parece que quieres hablar con alguien, pero no veo con quién."; .L_Say1265; .L_SayX1226;rtrue;
];
Array TX_S_776 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_776;
[ R_TX_S_777 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes hablar con [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes hablar con [the noun].~]
    say__p=1;! [2: ~No puedes hablar con ~]
    ParaContent(); print "No puedes hablar con ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1266; .L_SayX1227;rtrue;
];
Array TX_S_777 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_777;
[ R_TX_S_778 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Para hablar con alguien intenta 'alguien, hola' o algo así.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Para hablar con alguien intenta 'alguien, hola' o algo así.~]
    say__p=1;! [2: ~Para hablar con alguien intenta 'alguien, hola' o algo así.~]
    ParaContent(); print "Para hablar con alguien intenta ~alguien, hola~ o algo así."; .L_Say1267; .L_SayX1228;rtrue;
];
Array TX_S_778 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_778;
[ R_TX_S_779 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Perdón?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Perdón?~]
    say__p=1;! [2: ~¿Perdón?~]
    ParaContent(); print "¿Perdón?"; .L_Say1268; .L_SayX1229;rtrue;
];
Array TX_S_779 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_779;
[ R_TX_S_780 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¡No encuentro nada para hacer eso!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¡No encuentro nada para hacer eso!~]
    say__p=1;! [2: ~¡No encuentro nada para hacer eso!~]
    ParaContent(); print "¡No encuentro nada para hacer eso!"; .L_Say1269; .L_SayX1230;rtrue;
];
Array TX_S_780 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_780;
[ R_TX_S_781 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay ninguno disponible.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay ninguno disponible.~]
    say__p=1;! [2: ~No hay ninguno disponible.~]
    ParaContent(); print "No hay ninguno disponible."; .L_Say1270; .L_SayX1231;rtrue;
];
Array TX_S_781 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_781;
[ R_TX_S_782 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso parece partenecer a [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso parece partenecer a [the noun].~]
    say__p=1;! [2: ~Eso parece partenecer a ~]
    ParaContent(); print "Eso parece partenecer a ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1271; .L_SayX1232;rtrue;
];
Array TX_S_782 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_782;
[ R_TX_S_783 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Eso no puede contener cosas.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Eso no puede contener cosas.~]
    say__p=1;! [2: ~Eso no puede contener cosas.~]
    ParaContent(); print "Eso no puede contener cosas."; .L_Say1272; .L_SayX1233;rtrue;
];
Array TX_S_783 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_783;
[ R_TX_S_784 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está cerrado.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está cerrado.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está cerrado.~]
    ParaContent(); print " está cerrado."; .L_Say1273; .L_SayX1234;rtrue;
];
Array TX_S_784 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_784;
[ R_TX_S_785 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] está vacío.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] está vacío.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ está vacío.~]
    ParaContent(); print " está vacío."; .L_Say1274; .L_SayX1235;rtrue;
];
Array TX_S_785 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_785;
[ R_TX_S_786 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oscuridad~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oscuridad~]
    say__p=1;! [2: ~Oscuridad~]
    ParaContent(); print "Oscuridad"; .L_Say1275; .L_SayX1236;rtrue;
];
Array TX_S_786 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_786;
[ R_TX_S_787 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Lo siento, eso no puede corregirse.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Lo siento, eso no puede corregirse.~]
    say__p=1;! [2: ~Lo siento, eso no puede corregirse.~]
    ParaContent(); print "Lo siento, eso no puede corregirse."; .L_Say1276; .L_SayX1237;rtrue;
];
Array TX_S_787 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_787;
[ R_TX_S_788 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No te preocupes.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No te preocupes.~]
    say__p=1;! [2: ~No te preocupes.~]
    ParaContent(); print "No te preocupes."; .L_Say1277; .L_SayX1238;rtrue;
];
Array TX_S_788 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_788;
[ R_TX_S_789 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'eepa' sólo puede corregir una palabra.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'eepa' sólo puede corregir una palabra.~]
    say__p=1;! [2: ~'eepa' sólo puede corregir una palabra.~]
    ParaContent(); print "~eepa~ sólo puede corregir una palabra."; .L_Say1278; .L_SayX1239;rtrue;
];
Array TX_S_789 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_789;
[ R_TX_S_790 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay commando que repetir.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay commando que repetir.~]
    say__p=1;! [2: ~No hay commando que repetir.~]
    ParaContent(); print "No hay commando que repetir."; .L_Say1279; .L_SayX1240;rtrue;
];
Array TX_S_790 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_790;
[ R_TX_S_791 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Quién concretamente [set pregunta exacta]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Quién concretamente [set pregunta exacta]~]
    say__p=1;! [2: ~¿Quién concretamente ~]
    ParaContent(); print "¿Quién concretamente ";! [3: set pregunta exacta]
    ParaContent(); PreguntaCualExactamente=1; .L_Say1280; .L_SayX1241;rtrue;
];
Array TX_S_791 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_791;
[ R_TX_S_792 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Cuál concretamente, [set pregunta exacta]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Cuál concretamente, [set pregunta exacta]~]
    say__p=1;! [2: ~¿Cuál concretamente, ~]
    ParaContent(); print "¿Cuál concretamente, ";! [3: set pregunta exacta]
    ParaContent(); PreguntaCualExactamente=1; .L_Say1281; .L_SayX1242;rtrue;
];
Array TX_S_792 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_792;
[ R_TX_S_793 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Lo siento, sólo puedes referirte a un objeto aquí. ¿Cuál exactamente?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Lo siento, sólo puedes referirte a un objeto aquí. ¿Cuál exactamente?~]
    say__p=1;! [2: ~Lo siento, sólo puedes referirte a un objeto aquí. ¿Cuál exactamente?~]
    ParaContent(); print "Lo siento, sólo puedes referirte a un objeto aquí. ¿Cuál exactamente?"; .L_Say1282; .L_SayX1243;rtrue;
];
Array TX_S_793 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_793;
[ R_TX_S_794 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if no se inicia pregunta con preprosicion]¿Qué[end if] [if the noun is not the player][the noun] tiene que[otherwise]quieres[end if] [parser command so far]?[set pregunta exacta]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if no se inicia pregunta con preprosicion]¿Qué[end if] [if the noun is not the player][the noun] tiene que[otherwise]quieres[end if] [parser command so far]?[set pregunta exacta]~]
    say__p=1;! [2: if no se inicia pregunta con preprosicion]

    	if (~~(((IniciarPregunta()==0)))) jump L_Say1283;! [3: ~¿Qué~]
    ParaContent(); print "¿Qué";! [4: end if]

    	.L_Say1283; .L_SayX1244;! [5: ~ ~]
    ParaContent(); print " ";! [6: if the noun is not the player]

    	if (~~((((~~((noun == player))))))) jump L_Say1284;! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~ tiene que~]
    ParaContent(); print " tiene que";! [9: otherwise]

    	jump L_SayX1245; .L_Say1284;! [10: ~quieres~]
    ParaContent(); print "quieres";! [11: end if]

    	.L_Say1285; .L_SayX1245;! [12: ~ ~]
    ParaContent(); print " ";! [13: parser command so far]
    ParaContent(); PrintCommand();! [14: ~?~]
    ParaContent(); print "?";! [15: set pregunta exacta]
    ParaContent(); PreguntaCualExactamente=1; .L_Say1286; .L_SayX1246;rtrue;
];
Array TX_S_794 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_794;
[ R_TX_S_795 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Qué [if the noun is not the player][the noun] tiene que[otherwise]quieres[end if] [parser command so far]?[set pregunta exacta]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Qué [if the noun is not the player][the noun] tiene que[otherwise]quieres[end if] [parser command so far]?[set pregunta exacta]~]
    say__p=1;! [2: ~¿Qué ~]
    ParaContent(); print "¿Qué ";! [3: if the noun is not the player]

    	if (~~((((~~((noun == player))))))) jump L_Say1287;! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~ tiene que~]
    ParaContent(); print " tiene que";! [6: otherwise]

    	jump L_SayX1247; .L_Say1287;! [7: ~quieres~]
    ParaContent(); print "quieres";! [8: end if]

    	.L_Say1288; .L_SayX1247;! [9: ~ ~]
    ParaContent(); print " ";! [10: parser command so far]
    ParaContent(); PrintCommand();! [11: ~?~]
    ParaContent(); print "?";! [12: set pregunta exacta]
    ParaContent(); PreguntaCualExactamente=1; .L_Say1289; .L_SayX1248;rtrue;
];
Array TX_S_795 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_795;
[ R_TX_S_796 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~esas cosas~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~esas cosas~]
    say__p=1;! [2: ~esas cosas~]
    ParaContent(); print "esas cosas"; .L_Say1290; .L_SayX1249;rtrue;
];
Array TX_S_796 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_796;
[ R_TX_S_797 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~eso~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~eso~]
    say__p=1;! [2: ~eso~]
    ParaContent(); print "eso"; .L_Say1291; .L_SayX1250;rtrue;
];
Array TX_S_797 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_797;
[ R_TX_S_798 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ o ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ o ~]
    say__p=1;! [2: ~ o ~]
    ParaContent(); print " o "; .L_Say1292; .L_SayX1251;rtrue;
];
Array TX_S_798 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_798;
[ R_TX_S_799 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Por favor responde sí o no.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Por favor responde sí o no.~]
    say__p=1;! [2: ~Por favor responde sí o no.~]
    ParaContent(); print "Por favor responde sí o no."; .L_Say1293; .L_SayX1252;rtrue;
];
Array TX_S_799 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_799;
[ R_TX_S_800 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_768_r44 ()); .L_Say1294; .L_SayX1253;rtrue;
];
Array TX_S_800 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_800;
[ R_TX_S_801 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[ourselves]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[ourselves]~]
    say__p=1;! [2: ourselves]
    ParaContent(); (PHR_815_r89 ()); .L_Say1295; .L_SayX1254;rtrue;
];
Array TX_S_801 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_801;
[ R_TX_S_802 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] anterior tú~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] anterior tú~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_767_r43 ());! [3: ~ anterior tú~]
    ParaContent(); print " anterior tú"; .L_Say1296; .L_SayX1255;rtrue;
];
Array TX_S_802 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_802;
[ R_TX_S_803 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(primero coges [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(primero coges [the noun])[command clarification break]~]
    say__p=1;! [2: ~(primero coges ~]
    ParaContent(); print "(primero coges ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1297; .L_SayX1256;rtrue;
];
Array TX_S_803 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_803;
[ R_TX_S_804 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~([the second noun] primero coge [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~([the second noun] primero coge [the noun])[command clarification break]~]
    say__p=1;! [2: ~(~]
    ParaContent(); print "(";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~ primero coge ~]
    ParaContent(); print " primero coge ";! [5: the noun]
    ParaContent(); print (the) noun;! [6: ~)~]
    ParaContent(); print ")";! [7: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1298; .L_SayX1257;rtrue;
];
Array TX_S_804 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_804;
[ R_TX_S_805 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ Has muerto ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ Has muerto ~]
    say__p=1;! [2: ~ Has muerto ~]
    ParaContent(); print " Has muerto "; .L_Say1299; .L_SayX1258;rtrue;
];
Array TX_S_805 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_805;
[ R_TX_S_806 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ Has ganado ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ Has ganado ~]
    say__p=1;! [2: ~ Has ganado ~]
    ParaContent(); print " Has ganado "; .L_Say1300; .L_SayX1259;rtrue;
];
Array TX_S_806 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_806;
[ R_TX_S_807 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ Fin ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ Fin ~]
    say__p=1;! [2: ~ Fin ~]
    ParaContent(); print " Fin "; .L_Say1301; .L_SayX1260;rtrue;
];
Array TX_S_807 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_807;
[ R_TX_S_808 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El uso de 'deshacer' no está permitido en esta historia.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El uso de 'deshacer' no está permitido en esta historia.~]
    say__p=1;! [2: ~El uso de 'deshacer' no está permitido en esta historia.~]
    ParaContent(); print "El uso de ~deshacer~ no está permitido en esta historia."; .L_Say1302; .L_SayX1261;rtrue;
];
Array TX_S_808 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_808;
[ R_TX_S_809 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes 'deshacer' lo que no has hecho.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes 'deshacer' lo que no has hecho.~]
    say__p=1;! [2: ~No puedes 'deshacer' lo que no has hecho.~]
    ParaContent(); print "No puedes ~deshacer~ lo que no has hecho."; .L_Say1303; .L_SayX1262;rtrue;
];
Array TX_S_809 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_809;
[ R_TX_S_810 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Tu intérprete no puede 'deshacer' acciones, ¡lo siento!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Tu intérprete no puede 'deshacer' acciones, ¡lo siento!~]
    say__p=1;! [2: ~Tu intérprete no puede 'deshacer' acciones, ¡lo siento!~]
    ParaContent(); print "Tu intérprete no puede ~deshacer~ acciones, ¡lo siento!"; .L_Say1304; .L_SayX1263;rtrue;
];
Array TX_S_810 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_810;
[ R_TX_S_811 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No puedes 'deshacer' más.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No puedes 'deshacer' más.~]
    say__p=1;! [2: ~No puedes 'deshacer' más.~]
    ParaContent(); print "No puedes ~deshacer~ más."; .L_Say1305; .L_SayX1264;rtrue;
];
Array TX_S_811 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_811;
[ R_TX_S_812 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Retrocediendo al turno anterior.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Retrocediendo al turno anterior.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Retrocediendo al turno anterior.~]
    ParaContent(); print "Retrocediendo al turno anterior.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say1306; .L_SayX1265;rtrue;
];
Array TX_S_812 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_812;
[ R_TX_S_813 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Deshacer' agotado. Lo siento.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Deshacer' agotado. Lo siento.~]
    say__p=1;! [2: ~'Deshacer' agotado. Lo siento.~]
    ParaContent(); print "~Deshacer~ agotado. Lo siento."; .L_Say1307; .L_SayX1266;rtrue;
];
Array TX_S_813 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_813;
[ R_TX_S_814 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Seguro que quieres abandonar el juego? ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Seguro que quieres abandonar el juego? ~]
    say__p=1;! [2: ~¿Seguro que quieres abandonar el juego? ~]
    ParaContent(); print "¿Seguro que quieres abandonar el juego? "; .L_Say1308; .L_SayX1267;rtrue;
];
Array TX_S_814 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_814;
[ R_TX_S_815 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Error. No se pudo guardar.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Error. No se pudo guardar.~]
    say__p=1;! [2: ~Error. No se pudo guardar.~]
    ParaContent(); print "Error. No se pudo guardar."; .L_Say1309; .L_SayX1268;rtrue;
];
Array TX_S_815 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_815;
[ R_TX_S_816 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ok.~]
    say__p=1;! [2: ~Ok.~]
    ParaContent(); print "Ok."; .L_Say1310; .L_SayX1269;rtrue;
];
Array TX_S_816 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_816;
[ R_TX_S_817 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Error. No se pudo recuperar la partida.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Error. No se pudo recuperar la partida.~]
    say__p=1;! [2: ~Error. No se pudo recuperar la partida.~]
    ParaContent(); print "Error. No se pudo recuperar la partida."; .L_Say1311; .L_SayX1270;rtrue;
];
Array TX_S_817 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_817;
[ R_TX_S_818 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ok.~]
    say__p=1;! [2: ~Ok.~]
    ParaContent(); print "Ok."; .L_Say1312; .L_SayX1271;rtrue;
];
Array TX_S_818 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_818;
[ R_TX_S_819 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~¿Seguro que quieres reiniciar el juego? ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~¿Seguro que quieres reiniciar el juego? ~]
    say__p=1;! [2: ~¿Seguro que quieres reiniciar el juego? ~]
    ParaContent(); print "¿Seguro que quieres reiniciar el juego? "; .L_Say1313; .L_SayX1272;rtrue;
];
Array TX_S_819 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_819;
[ R_TX_S_820 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Error.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Error.~]
    say__p=1;! [2: ~Error.~]
    ParaContent(); print "Error."; .L_Say1314; .L_SayX1273;rtrue;
];
Array TX_S_820 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_820;
[ R_TX_S_821 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Fichero de juego verificado e intacto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Fichero de juego verificado e intacto.~]
    say__p=1;! [2: ~Fichero de juego verificado e intacto.~]
    ParaContent(); print "Fichero de juego verificado e intacto."; .L_Say1315; .L_SayX1274;rtrue;
];
Array TX_S_821 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_821;
[ R_TX_S_822 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~El fichero de juego no parece intacto, puede estar corrompido (a menos que estés jugando con un intérprete muy primitivo que no sea capaz de realizar la comprobación).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~El fichero de juego no parece intacto, puede estar corrompido (a menos que estés jugando con un intérprete muy primitivo que no sea capaz de realizar la comprobación).~]
    say__p=1;! [2: ~El fichero de juego no parece intacto, puede estar corrompido (a menos que estés jugando con un intérprete muy primitivo que no sea capaz de realizar la comprobación).~]
    ParaContent(); print "El fichero de juego no parece intacto, puede estar corrompido (a menos que estés jugando con un intérprete muy primitivo que no sea capaz de realizar la comprobación)."; .L_Say1316; .L_SayX1275;rtrue;
];
Array TX_S_822 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_822;
[ R_TX_S_823 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~La transcripción ya estaba desactivada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~La transcripción ya estaba desactivada.~]
    say__p=1;! [2: ~La transcripción ya estaba desactivada.~]
    ParaContent(); print "La transcripción ya estaba desactivada."; .L_Say1317; .L_SayX1276;rtrue;
];
Array TX_S_823 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_823;
[ R_TX_S_824 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]Fin de la transcripción.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break]Fin de la transcripción.~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: ~Fin de la transcripción.~]
    ParaContent(); print "Fin de la transcripción."; .L_Say1318; .L_SayX1277;rtrue;
];
Array TX_S_824 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_824;
[ R_TX_S_825 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Intento fallido de finalización de transcripción.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Intento fallido de finalización de transcripción.~]
    say__p=1;! [2: ~Intento fallido de finalización de transcripción.~]
    ParaContent(); print "Intento fallido de finalización de transcripción."; .L_Say1319; .L_SayX1278;rtrue;
];
Array TX_S_825 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_825;
[ R_TX_S_826 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the story has ended]En este relato, tu puntuación ha sido[otherwise]Hasta el momento tu puntuación es[end if] [score] de un total de [maximum score], en [turn count] turno[s]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the story has ended]En este relato, tu puntuación ha sido[otherwise]Hasta el momento tu puntuación es[end if] [score] de un total de [maximum score], en [turn count] turno[s]~]
    say__p=1;! [2: if the story has ended]

    	if (~~((((deadflag~=0))))) jump L_Say1320;! [3: ~En este relato, tu puntuación ha sido~]
    ParaContent(); print "En este relato, tu puntuación ha sido";! [4: otherwise]

    	jump L_SayX1279; .L_Say1320;! [5: ~Hasta el momento tu puntuación es~]
    ParaContent(); print "Hasta el momento tu puntuación es";! [6: end if]

    	.L_Say1321; .L_SayX1279;! [7: ~ ~]
    ParaContent(); print " ";! [8: score]
    ParaContent(); print (say__n=score);! [9: ~ de un total de ~]
    ParaContent(); print " de un total de ";! [10: maximum score]
    ParaContent(); print (say__n=MAX_SCORE);! [11: ~, en ~]
    ParaContent(); print ", en ";! [12: turn count]
    ParaContent(); print (say__n=turns);! [13: ~ turno~]
    ParaContent(); print " turno";! [14: s]
    ParaContent(); (PHR_822_r96 ()); .L_Say1322; .L_SayX1280;rtrue;
];
Array TX_S_826 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_826;
[ R_TX_S_827 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, logrando el rango de ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, logrando el rango de ~]
    say__p=1;! [2: ~, logrando el rango de ~]
    ParaContent(); print ", logrando el rango de "; .L_Say1323; .L_SayX1281;rtrue;
];
Array TX_S_827 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_827;
[ R_TX_S_828 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~No hay puntuación en esta historia.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~No hay puntuación en esta historia.~]
    say__p=1;! [2: ~No hay puntuación en esta historia.~]
    ParaContent(); print "No hay puntuación en esta historia."; .L_Say1324; .L_SayX1282;rtrue;
];
Array TX_S_828 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_828;
[ R_TX_S_829 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[italic type]Has ganado [number understood in words] punto de destino.[roman type]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[italic type]Has ganado [number understood in words] punto de destino.[roman type]~]
    say__p=1;! [2: italic type]
    ParaContent(); style underline;! [3: ~Has ganado ~]
    ParaContent(); print "Has ganado ";! [4: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [5: ~ punto de destino.~]
    ParaContent(); print " punto de destino.";! [6: roman type]
    ParaContent(); style roman; .L_Say1325; .L_SayX1283;rtrue;
];
Array TX_S_829 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_829;
[ R_TX_S_830 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Tu puntuación ha disminuido en [number understood in words] punto[s].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Tu puntuación ha disminuido en [number understood in words] punto[s].[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Tu puntuación ha disminuido en ~]
    ParaContent(); print "Tu puntuación ha disminuido en ";! [4: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [5: ~ punto~]
    ParaContent(); print " punto";! [6: s]
    ParaContent(); (PHR_822_r96 ());! [7: ~.~]
    ParaContent(); print ".";! [8: close bracket]
    ParaContent(); print "]"; .L_Say1326; .L_SayX1284;rtrue;
];
Array TX_S_830 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_830;
[ R_TX_S_831 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ está ahora en su modo 'superbreve', que siempre da descripciones cortas de los lugares (incluso si nunca habías estado antes).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ está ahora en su modo 'superbreve', que siempre da descripciones cortas de los lugares (incluso si nunca habías estado antes).~]
    say__p=1;! [2: ~ está ahora en su modo 'superbreve', que siempre da descripciones cortas de los lugares (incluso si nunca habías estado antes).~]
    ParaContent(); print " está ahora en su modo ~superbreve~, que siempre da descripciones cortas de los lugares (incluso si nunca habías estado antes)."; .L_Say1327; .L_SayX1285;rtrue;
];
Array TX_S_831 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_831;
[ R_TX_S_832 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ está ahora en su modo 'largo', que siempre da descripciones largas de los lugares (incluso si ya habías estado antes).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ está ahora en su modo 'largo', que siempre da descripciones largas de los lugares (incluso si ya habías estado antes).~]
    say__p=1;! [2: ~ está ahora en su modo 'largo', que siempre da descripciones largas de los lugares (incluso si ya habías estado antes).~]
    ParaContent(); print " está ahora en su modo ~largo~, que siempre da descripciones largas de los lugares (incluso si ya habías estado antes)."; .L_Say1328; .L_SayX1286;rtrue;
];
Array TX_S_832 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_832;
[ R_TX_S_833 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ está ahora en su modo normal 'breve', que da sólo descripciones largas de los lugares la primera vez que son visitados, y descripciones cortas en otro caso.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ está ahora en su modo normal 'breve', que da sólo descripciones largas de los lugares la primera vez que son visitados, y descripciones cortas en otro caso.~]
    say__p=1;! [2: ~ está ahora en su modo normal 'breve', que da sólo descripciones largas de los lugares la primera vez que son visitados, y descripciones cortas en otro caso.~]
    ParaContent(); print " está ahora en su modo normal ~breve~, que da sólo descripciones largas de los lugares la primera vez que son visitados, y descripciones cortas en otro caso."; .L_Say1329; .L_SayX1287;rtrue;
];
Array TX_S_833 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_833;
[ R_TX_S_834 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Notificación de puntuación activada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Notificación de puntuación activada.~]
    say__p=1;! [2: ~Notificación de puntuación activada.~]
    ParaContent(); print "Notificación de puntuación activada."; .L_Say1330; .L_SayX1288;rtrue;
];
Array TX_S_834 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_834;
[ R_TX_S_835 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Notificación de puntuación desactivada.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Notificación de puntuación desactivada.~]
    say__p=1;! [2: ~Notificación de puntuación desactivada.~]
    ParaContent(); print "Notificación de puntuación desactivada."; .L_Say1331; .L_SayX1289;rtrue;
];
Array TX_S_835 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_835;
[ R_TX_S_836 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~En este momento, ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~En este momento, ~]
    say__p=1;! [2: ~En este momento, ~]
    ParaContent(); print "En este momento, "; .L_Say1332; .L_SayX1290;rtrue;
];
Array TX_S_836 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_836;
[ R_TX_S_837 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~es ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~es ~]
    say__p=1;! [2: ~es ~]
    ParaContent(); print "es "; .L_Say1333; .L_SayX1291;rtrue;
];
Array TX_S_837 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_837;
[ R_TX_S_838 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~no está definido~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~no está definido~]
    say__p=1;! [2: ~no está definido~]
    ParaContent(); print "no está definido"; .L_Say1334; .L_SayX1292;rtrue;
];
Array TX_S_838 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_838;
[ R_TX_S_839 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~esta historia no conoce ningún pronombre.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~esta historia no conoce ningún pronombre.~]
    say__p=1;! [2: ~esta historia no conoce ningún pronombre.~]
    ParaContent(); print "esta historia no conoce ningún pronombre."; .L_Say1335; .L_SayX1293;rtrue;
];
Array TX_S_839 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_839;



Array Rel_Record_0 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "equality relation"
     RELS_TEST
     0 KD2_relation_of_values Rel_Handler_0 "is";
[ Rel_Handler_0 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == Y) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_0);
    }
    rfalse;
];
Array Rel_Record_1 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "provision relation"
     RELS_TEST
     0 KD3_relation_of_objects Rel_Handler_1 "provides";
[ Rel_Handler_1 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (false) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_1);
    }
    rfalse;
];
Array Rel_Record_3 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "universal relation"
     RELS_TEST
     0 KD3_relation_of_objects Rel_Handler_3 "relates";
[ Rel_Handler_3 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (((RlnGetF(X, RR_HANDLER))(X, RELS_TEST, Y))) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_3);
    }
    rfalse;
];
Array Rel_Record_5 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "meaning relation"
     RELS_TEST
     0 KD3_relation_of_objects Rel_Handler_5 "means";
[ Rel_Handler_5 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((BlkValueCompare(X(CV_MEANING), Y)==0)) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_5);
    }
    rfalse;
];
Array Rel_Record_15 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "containment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD3_relation_of_objects Rel_Handler_15 "contains";
[ Rel_Handler_15 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == ContainerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_17 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "support relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD4_relation_of_supporters_to_ Rel_Handler_17 "supports";
[ Rel_Handler_17 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == SupporterOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_19 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "incorporation relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD5_relation_of_things Rel_Handler_19 "incorporates";
[ Rel_Handler_19 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (Y.component_parent)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MakePart(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_21 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "carrying relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_21 "carries";
[ Rel_Handler_21 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == CarrierOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_23 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "holding relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_23 "holds";
[ Rel_Handler_23 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == HolderOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_25 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "wearing relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD6_relation_of_people_to_thin Rel_Handler_25 "wears";
[ Rel_Handler_25 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == WearerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: WearObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_27 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "possession relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD3_relation_of_objects Rel_Handler_27 "has";
[ Rel_Handler_27 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == OwnerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            rfalse;
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            rfalse;
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_31 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "visibility relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_31 "can-see";
[ Rel_Handler_31 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestVisibility(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_33 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "touchability relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_33 "can-touch";
[ Rel_Handler_33 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestTouchability(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_35 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "concealment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD5_relation_of_things Rel_Handler_35 "conceals";
[ Rel_Handler_35 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestConcealment(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_37 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "enclosure relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD3_relation_of_objects Rel_Handler_37 "encloses";
[ Rel_Handler_37 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (IndirectlyContains(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_67 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "leading-through relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     door_to KD7_relation_of_rooms_to_doors Rel_Handler_67 "Leading-through relates one room ( called the other side ) to various doors";
[ Rel_Handler_67 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_0(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=nothing: false: ) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=nothing: false: ) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_0(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_0(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "lock-fitting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     with_key KD5_relation_of_things Rel_Handler_69 "Lock-fitting relates one thing ( called the matching key ) to various things";
[ Rel_Handler_69 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_1(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_1(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_1(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
[ CreateDynamicRelations 
    i ! loop counter
    rel ! new relation
    ;
    ];
[ RProperty obj cl pr; if (obj ofclass cl) return obj.pr; return nothing; ];
! Routines guarding leading-through(L, R)
[ RGuard_f0_0 
    X ! which is related to at most one object
    ;
    if (X ofclass K4_door) return (X.door_to);
    return nothing;
];
[ RGuard_f1_0 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_0 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        R.door_to = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
[ RGuard_MF_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        Relation_NowN1toV(R,door_to,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
! Routines guarding lock-fitting(L, R)
[ RGuard_f0_1 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.with_key);
    return nothing;
];
[ RGuard_f1_1 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_1 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        R.with_key = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];
[ RGuard_MF_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,with_key,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];






[ Noun_Filter_0 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_1 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_2 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_3 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_4 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_5 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_6 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_7 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_8 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_9 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_10 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K13_device));
];
[ Noun_Filter_11 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_12 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_13 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_14 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_15 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_16 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];
[ Noun_Filter_17 
    v ! value parsed
    n ! saved value of noun
    ;
    v = DECIMAL_TOKEN();
    if (v == GPR_NUMBER) {
        n = noun; noun = parsed_number;
        if (~~(((true) && (true)))) v = GPR_FAIL;
        noun = n;
    }
    return v;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Chronology
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Present and Past
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Chronology Point
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Update Chronological Records Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Test Single Past State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PAPR_0 ;
    if ((((action ==##Take or ##Examine) &&  (actor==player) && ((noun == I276_piedra) && (true))))) rtrue;
    rfalse;
];
Array PastActionsI6Routines --> PAPR_0 0 0;

Constant NO_PAST_TENSE_CONDS 0;
Constant NO_PAST_TENSE_ACTIONS 1;

[ TestSinglePastState 
    past_flag ! Implied call parameter
    pt ! Implied call parameter
    turn_end ! Implied call parameter
    wanted ! Implied call parameter
    old ! internal use only
    new ! internal use only
    trips ! internal use only
    consecutives ! internal use only
    ;
    if (past_flag) {
        new = (past_chronological_record-->pt) & 1;
        trips = ((past_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
    } else {
        old = (present_chronological_record-->pt) & 1;
        trips = ((present_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
        switch(pt) {
            default: print "*** No such past tense condition ***^"; new = false;
        }
        if (new) {
            if (old == false) { trips++; if (trips > 127) trips = 127; }
            if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
        } else {
            consecutives = 0;
        }
        present_chronological_record-->pt = new + 2*trips + 256*consecutives;
    }
    switch(wanted) {
        0: if (new) return new;
        1: if (new) return trips;
        2: if (new) return consecutives+1; ! Plus one because we count the current turn
        4: return new;
        5: return trips;
        6: return consecutives;
    }
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme II
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Past Action Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Track Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TrackActions readjust oow i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ Parse_Name_GV1 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_353_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'sube') jump group_353_1_2;
                jump group_353_1_end;
                .group_353_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'techo') jump group_353_1_3;
                jump group_353_1_end;
                .group_353_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'lado') jump group_353_1_4;
                jump group_353_1_end;
                .group_353_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'cielo') jump group_353_1_5;
                jump group_353_1_end;
                .group_353_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'asciende') jump Fail_1;
                .group_353_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_354_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'b//') jump group_354_1_2;
                jump group_354_1_end;
                .group_354_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'baja') jump group_354_1_3;
                jump group_354_1_end;
                .group_354_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'suelo') jump group_354_1_4;
                jump group_354_1_end;
                .group_354_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'desciende') jump Fail_1;
                .group_354_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV13 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_12() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'your') jump Fail_1;
                if (NextWordStopped() ~= 'former') jump Fail_1;
                if (NextWordStopped() ~= 'self') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_13() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'my') jump Fail_2;
                if (NextWordStopped() ~= 'former') jump Fail_2;
                if (NextWordStopped() ~= 'self') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (Cond_Token_16() == GPR_FAIL) jump Fail_3;
                if (NextWordStopped() ~= 'tu') jump Fail_3;
                if (NextWordStopped() ~= 'antiguo') jump Fail_3;
                if (NextWordStopped() ~= 'yo') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (Cond_Token_17() == GPR_FAIL) jump Fail_4;
                if (NextWordStopped() ~= 'mi') jump Fail_4;
                if (NextWordStopped() ~= 'antiguo') jump Fail_4;
                if (NextWordStopped() ~= 'yo') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
                if (Cond_Token_14() == GPR_FAIL) jump Fail_5;
                if (NextWordStopped() ~= 'former') jump Fail_5;
                if (NextWordStopped() ~= 'self') jump Fail_5;
                try_from_wn = wn; f = true; continue;
                .Fail_5; wn = try_from_wn;
                if (Cond_Token_18() == GPR_FAIL) jump Fail_6;
                if (NextWordStopped() ~= 'antiguo') jump Fail_6;
                if (NextWordStopped() ~= 'yo') jump Fail_6;
                try_from_wn = wn; f = true; continue;
                .Fail_6; wn = try_from_wn;
                if (Cond_Token_15() == GPR_FAIL) jump Fail_7;
                if (NextWordStopped() ~= 'former') jump Fail_7;
                try_from_wn = wn; f = true; continue;
                .Fail_7; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV239 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV240 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV241 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV242 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV243 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'motivos') jump Fail_1;
                if (NextWordStopped() ~= 'femeninos') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV244 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV245 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV246 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV247 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV248 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV249 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV250 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV251 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV252 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV253 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV254 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV255 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV256 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'motivos') jump Fail_1;
                if (NextWordStopped() ~= 'femeninos') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV257 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV258 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV259 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV260 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV261 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV262 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV263 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV264 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV265 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV266 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV267 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_364_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'fuego') jump group_364_1_2;
                jump group_364_1_end;
                .group_364_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'lena') jump group_364_1_3;
                jump group_364_1_end;
                .group_364_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'leña') jump group_364_1_4;
                jump group_364_1_end;
                .group_364_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'antorcha') jump Fail_1;
                .group_364_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV268 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV269 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV270 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_271 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'reiniciar') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_272 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'recuperar') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_273 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'curiosidades') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_274 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'terminar') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_275 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_276 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'stand') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_277 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_278 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'lie') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_279 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_373_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'palabras') jump group_373_1_2;
        jump group_373_1_end;
        .group_373_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'tonterias') jump group_373_1_3;
        jump group_373_1_end;
        .group_373_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'poema') jump group_373_1_4;
        jump group_373_1_end;
        .group_373_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'relato') jump group_373_1_5;
        jump group_373_1_end;
        .group_373_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'cuento') jump group_373_1_6;
        jump group_373_1_end;
        .group_373_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'versos') jump group_373_1_7;
        jump group_373_1_end;
        .group_373_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'amado') jump group_373_1_8;
        jump group_373_1_end;
        .group_373_1_8; wn = group_wn;
        if (NextWordStopped() ~= 'follar') jump Fail_1;
        .group_373_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_280 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_374_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'ayuda') jump group_374_1_2;
        jump group_374_1_end;
        .group_374_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'auxilio') jump group_374_1_3;
        jump group_374_1_end;
        .group_374_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'socorro') jump Fail_1;
        .group_374_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_281 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'en') jump Fail_1;
        if (NextWordStopped() ~= 'libro') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_282 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_376_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'libro') jump group_376_1_2;
        jump group_376_1_end;
        .group_376_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'texto') jump group_376_1_3;
        jump group_376_1_end;
        .group_376_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'verso') jump group_376_1_4;
        jump group_376_1_end;
        .group_376_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'algo') jump Fail_1;
        .group_376_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_283 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_377_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'muerte') jump group_377_1_2;
        jump group_377_1_end;
        .group_377_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'sacrificio') jump group_377_1_3;
        jump group_377_1_end;
        .group_377_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'honor') jump group_377_1_4;
        jump group_377_1_end;
        .group_377_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'soldado') jump group_377_1_5;
        jump group_377_1_end;
        .group_377_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'guerra') jump group_377_1_6;
        jump group_377_1_end;
        .group_377_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'mercader') jump group_377_1_7;
        jump group_377_1_end;
        .group_377_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'castigo') jump Fail_1;
        .group_377_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_284 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_378_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'insulto') jump group_378_1_2;
        jump group_378_1_end;
        .group_378_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'palabrota') jump group_378_1_3;
        jump group_378_1_end;
        .group_378_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'palabrotas') jump group_378_1_4;
        jump group_378_1_end;
        .group_378_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'puta') jump group_378_1_5;
        jump group_378_1_end;
        .group_378_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'zorra') jump group_378_1_6;
        jump group_378_1_end;
        .group_378_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'cerda') jump group_378_1_7;
        jump group_378_1_end;
        .group_378_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'guarra') jump Fail_1;
        .group_378_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_285 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_379_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'vida') jump group_379_1_2;
        jump group_379_1_end;
        .group_379_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'ternura') jump group_379_1_3;
        jump group_379_1_end;
        .group_379_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'amor') jump group_379_1_4;
        jump group_379_1_end;
        .group_379_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'desamor') jump group_379_1_5;
        jump group_379_1_end;
        .group_379_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'belleza') jump group_379_1_6;
        jump group_379_1_end;
        .group_379_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'abismo') jump group_379_1_7;
        jump group_379_1_end;
        .group_379_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'penitencia') jump Fail_1;
        .group_379_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_286 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_380_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'hermano') jump group_380_1_2;
        jump group_380_1_end;
        .group_380_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'abel') jump group_380_1_3;
        jump group_380_1_end;
        .group_380_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'eva') jump group_380_1_4;
        jump group_380_1_end;
        .group_380_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'adan') jump group_380_1_5;
        jump group_380_1_end;
        .group_380_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'dios') jump Fail_1;
        .group_380_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_287 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_381_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'sucesos') jump group_381_1_2;
        jump group_381_1_end;
        .group_381_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'actos') jump group_381_1_3;
        jump group_381_1_end;
        .group_381_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'ovejas') jump group_381_1_4;
        jump group_381_1_end;
        .group_381_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'castillo') jump group_381_1_5;
        jump group_381_1_end;
        .group_381_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'comida') jump Fail_1;
        .group_381_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_288 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_382_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'musa') jump group_382_1_2;
        jump group_382_1_end;
        .group_382_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'lilith') jump Fail_1;
        .group_382_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_289 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_383_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'espada') jump group_383_1_2;
        jump group_383_1_end;
        .group_383_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'doncella') jump group_383_1_3;
        jump group_383_1_end;
        .group_383_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'violacion') jump group_383_1_4;
        jump group_383_1_end;
        .group_383_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'banquete') jump group_383_1_5;
        jump group_383_1_end;
        .group_383_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'diamante') jump Fail_1;
        .group_383_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_290 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_384_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'ternero') jump group_384_1_2;
        jump group_384_1_end;
        .group_384_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'asesinato') jump group_384_1_3;
        jump group_384_1_end;
        .group_384_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'venganza') jump group_384_1_4;
        jump group_384_1_end;
        .group_384_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'piedra') jump group_384_1_5;
        jump group_384_1_end;
        .group_384_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'canticos') jump group_384_1_6;
        jump group_384_1_end;
        .group_384_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'sangre') jump group_384_1_7;
        jump group_384_1_end;
        .group_384_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'visceras') jump Fail_1;
        .group_384_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_291 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_385_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'pecado') jump group_385_1_2;
        jump group_385_1_end;
        .group_385_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'avaricia') jump group_385_1_3;
        jump group_385_1_end;
        .group_385_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'envidia') jump group_385_1_4;
        jump group_385_1_end;
        .group_385_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'gula') jump group_385_1_5;
        jump group_385_1_end;
        .group_385_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'mentir') jump group_385_1_6;
        jump group_385_1_end;
        .group_385_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'pecar') jump group_385_1_7;
        jump group_385_1_end;
        .group_385_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'matar') jump Fail_1;
        .group_385_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_292 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_386_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'ira') jump group_386_1_2;
        jump group_386_1_end;
        .group_386_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'lujuria') jump group_386_1_3;
        jump group_386_1_end;
        .group_386_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'pereza') jump group_386_1_4;
        jump group_386_1_end;
        .group_386_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'soberbia') jump group_386_1_5;
        jump group_386_1_end;
        .group_386_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'pecados') jump group_386_1_6;
        jump group_386_1_end;
        .group_386_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'violar') jump group_386_1_7;
        jump group_386_1_end;
        .group_386_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'asesinar') jump Fail_1;
        .group_386_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_293 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_387_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'genocidio') jump group_387_1_2;
        jump group_387_1_end;
        .group_387_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'masacre') jump group_387_1_3;
        jump group_387_1_end;
        .group_387_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'sacrificio') jump group_387_1_4;
        jump group_387_1_end;
        .group_387_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'crimen') jump group_387_1_5;
        jump group_387_1_end;
        .group_387_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'martirio') jump group_387_1_6;
        jump group_387_1_end;
        .group_387_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'ruina') jump group_387_1_7;
        jump group_387_1_end;
        .group_387_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'caida') jump Fail_1;
        .group_387_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_294 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'cain') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_295 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_389_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'rencor') jump group_389_1_2;
        jump group_389_1_end;
        .group_389_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'rencores') jump group_389_1_3;
        jump group_389_1_end;
        .group_389_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'pecados') jump group_389_1_4;
        jump group_389_1_end;
        .group_389_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'guerras') jump group_389_1_5;
        jump group_389_1_end;
        .group_389_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'temor') jump group_389_1_6;
        jump group_389_1_end;
        .group_389_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'temores') jump Fail_1;
        .group_389_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_296 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_390_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'muerte') jump group_390_1_2;
        jump group_390_1_end;
        .group_390_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'la') jump Fail_1;
        .group_390_1_end;
        if (NextWordStopped() ~= 'muerte') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_297 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_391_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'guerras') jump group_391_1_2;
        jump group_391_1_end;
        .group_391_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'la') jump Fail_1;
        .group_391_1_end;
        group_wn = wn;
        .group_391_2_1; wn = group_wn;
        if (NextWordStopped() ~= 'guerra') jump group_391_2_2;
        jump group_391_2_end;
        .group_391_2_2; wn = group_wn;
        if (NextWordStopped() ~= 'destruccion') jump group_391_2_3;
        jump group_391_2_end;
        .group_391_2_3; wn = group_wn;
        if (NextWordStopped() ~= 'la') jump Fail_1;
        .group_391_2_end;
        if (NextWordStopped() ~= 'destruccion') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_298 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_392_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'apocalipsis') jump group_392_1_2;
        jump group_392_1_end;
        .group_392_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'matanza') jump group_392_1_3;
        jump group_392_1_end;
        .group_392_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'el') jump Fail_1;
        .group_392_1_end;
        if (NextWordStopped() ~= 'apocalipsis') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_299 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_393_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'holocausto') jump group_393_1_2;
        jump group_393_1_end;
        .group_393_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'sacrificio') jump group_393_1_3;
        jump group_393_1_end;
        .group_393_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'hecatombe') jump group_393_1_4;
        jump group_393_1_end;
        .group_393_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'ofrenda') jump group_393_1_5;
        jump group_393_1_end;
        .group_393_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'el') jump Fail_1;
        .group_393_1_end;
        if (NextWordStopped() ~= 'holocausto') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_300 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_394_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'gehena') jump group_394_1_2;
        jump group_394_1_end;
        .group_394_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'la') jump Fail_1;
        .group_394_1_end;
        group_wn = wn;
        .group_394_2_1; wn = group_wn;
        if (NextWordStopped() ~= 'gehena') jump group_394_2_2;
        jump group_394_2_end;
        .group_394_2_2; wn = group_wn;
        if (NextWordStopped() ~= 'expiacion') jump Fail_1;
        .group_394_2_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_301 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_395_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'gehenna') jump group_395_1_2;
        jump group_395_1_end;
        .group_395_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'la') jump Fail_1;
        .group_395_1_end;
        if (NextWordStopped() ~= 'gehenna') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_302 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_396_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'perdon') jump group_396_1_2;
        jump group_396_1_end;
        .group_396_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'misericordia') jump group_396_1_3;
        jump group_396_1_end;
        .group_396_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'perdoname') jump Fail_1;
        .group_396_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_303 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_397_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'arrepentimiento') jump group_397_1_2;
        jump group_397_1_end;
        .group_397_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'clemencia') jump group_397_1_3;
        jump group_397_1_end;
        .group_397_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'compasion') jump group_397_1_4;
        jump group_397_1_end;
        .group_397_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'indulgencia') jump Fail_1;
        .group_397_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ SlashGPR_0 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_397_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'con') jump group_397_1_2;
    jump group_397_1_end;
    .group_397_1_2;
    wn = group_wn;
    .group_397_1_end;
    return GPR_PREPOSITION;
];
Verb 'sorry' 'perdon' 'perdona' 'siento' 'lamento' 'disculpa'
    *  -> Sorry
;
Verb 'wait' 'z//'
    *  -> Wait
;
Verb 'answer' 'say' 'shout' 'speak'
    * Cond_Token_440 DECIMAL_TOKEN  -> A82_responding_with
    * Cond_Token_448 DECIMAL_TOKEN  -> A84_qbc_responding_with
;
Verb 'wake' 'awake' 'awaken'
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script' 'transcripcion'
    *  -> ScriptOn
    * 'on' / 'si'  -> ScriptOn
    * 'off' / 'no'  -> ScriptOff
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'normal'
    *  -> LMode1
;
Verb 'notify' 'notificar' 'notificacion'
    *  -> NotifyOn
    * 'on' / 'si'  -> NotifyOn
    * 'off' / 'no'  -> NotifyOff
;
Verb 'toma' 'coge' 'recoge'
    * multi  -> Take
    * 'a//' creature  -> Take
    * multiinside 'de' noun  -> Remove
;
Verb 'saca'
    * multiinside 'de' noun  -> Remove
    * 'a//' creature 'de' noun  -> Remove
;
Verb 'quita' 'quitale'
    * multiinside 'de' noun  -> Remove
    * multiinside 'a//' noun  -> Remove
    * 'a//' creature 'de' noun  -> Remove
    * 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun 'con' held  -> Unlock
    * 'el' 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun 'con' held  -> Unlock
;
Verb 'sacate' 'quitate' 'sacarse' 'quitarse' 'quitarte' 'sacarte' 'sacarme' 'quitarme' 'quitame' 'sacame'
    * held  -> Disrobe
;
Verb 'ponte' 'viste' 'vistete' 'ponerse' 'vestirse' 'ponerte' 'vestirte' 'ponerme' 'vestirme' 'ponme' 'visteme'
    * held  -> Wear
    * 'con' held  -> Wear
;
Verb 'pon' 'echa' 'inserta' 'coloca'
    * multiexcept 'en' noun=Noun_Filter_2  -> Insert
    * multiexcept 'en' / 'sobre' noun  -> PutOn
    * 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun  -> Lock
    * multiexcept 'dentro' 'de' noun  -> Insert
    * multiexcept 'encima' 'de' noun  -> PutOn
    * 'a//' creature 'en' noun=Noun_Filter_3  -> Insert
    * 'el' 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun  -> Lock
    * 'a//' creature 'en' noun  -> PutOn
    * 'a//' creature 'sobre' noun  -> PutOn
    * 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun 'con' held  -> Lock
    * 'a//' creature 'dentro' 'de' noun  -> Insert
    * 'a//' creature 'encima' 'de' noun  -> PutOn
    * 'el' 'cerrojo' / 'pestillo' / 'cierre' 'a//' noun 'con' held  -> Lock
    * noun 'a//' topic  -> SetTo
;
Verb 'deja' 'suelta'
    * multiheld  -> Drop
    * 'a//' creature  -> Drop
    * multiexcept 'en' noun=Noun_Filter_4  -> Insert
    * multiexcept 'en' / 'sobre' noun  -> PutOn
    * multiexcept 'dentro' 'de' noun  -> Insert
    * multiexcept 'encima' 'de' noun  -> PutOn
;
Verb 'tira'
    * multiheld  -> Drop
    * 'a//' multiheld  -> Drop
    * 'de' noun  -> Pull
    * held 'a//' / 'contra' noun  -> ThrowAt
    * multiexcept 'en' noun=Noun_Filter_5  -> Insert
    * multiheld 'por' noun  -> Insert
    * multiexcept 'en' / 'sobre' noun  -> PutOn
    * multiexcept 'dentro' 'de' noun  -> Insert
    * multiexcept 'encima' 'de' noun  -> PutOn
;
Verb 'mete'
    * multiexcept 'en' noun  -> Insert
    * multiheld 'por' noun  -> Insert
    * multiexcept 'dentro' 'de' noun  -> Insert
    * 'a//' creature 'en' noun  -> Insert
    * 'a//' creature 'dentro' 'de' noun  -> Insert
;
Verb 'lanza' 'arroja'
    * held 'a//' / 'por' / 'contra' noun  -> ThrowAt
    * 'a//' creature 'por' / 'contra' noun  -> ThrowAt
;
Verb 'da' 'regala' 'dale' 'dase' 'ofrece' 'darse'
    * creature held  -> Give reverse
    * held 'a//' creature  -> Give
    * 'a//' creature held  -> Give reverse
    * 'una' 'patada' 'a//' noun  -> Attack
    * 'un' 'punetazo' 'a//' noun  -> Attack
    * 'un' 'golpe' 'a//' noun  -> Attack
;
Verb 'muestra' 'ensena'
    * creature held  -> Show reverse
    * held 'a//' creature  -> Show
    * 'a//' creature held  -> Show reverse
;
Verb 'vete' 've' 'camina' 'anda' 'corre' 'vuelve' 'ir'
    *  -> Go
    * noun=Noun_Filter_6  -> Go
    * noun  -> Enter
    * 'a//' / 'hacia' noun=Noun_Filter_7  -> Go
    * 'a//' / 'hacia' / 'por' noun  -> Enter
;
Verb 'pasa'
    * 'por' noun  -> Enter
;
Verb 'inventario' 'inv' 'i//'
    *  -> Inv
;
Verb 'mira' 'm//' 'l//' 'look' 'ver'
    *  -> Look
    * noun  -> Examine
    * 'a//' creature  -> Examine
    * 'a//' / 'hacia' noun  -> Examine
    * 'en' / 'sobre' / 'por' noun  -> Search
    * 'bajo' noun  -> LookUnder
    * 'dentro' 'de' noun  -> Search
    * 'debajo' 'de' noun  -> LookUnder
    * 'a//' 'traves' 'de' noun  -> Search
;
Verb 'consulta'
    * 'a//' creature 'sobre' topic  -> Ask
    * noun 'acerca' 'de' topic  -> Consult
    * creature 'sobre' topic  -> Ask
    * noun 'sobre' topic  -> Consult
    * 'sobre' topic 'a//' creature  -> Ask reverse
    * topic 'en' noun  -> Consult reverse
;
Verb 'abre'
    * noun  -> Open
    * 'a//' creature  -> Open
    * noun 'con' held  -> Unlock
;
Verb 'cierra'
    * noun  -> Close
    * noun 'con' held  -> Lock
    * noun 'con' 'pestillo'  -> Lock
;
Verb 'destapa' 'descubre'
    * noun  -> Open
;
Verb 'tapa' 'cubre'
    * noun  -> Close
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'a//' creature  -> A91_fucking
    * 'a//' noun  -> A92_faping
;
Verb 'entra' 'cruza'
    *  -> A77_entering_to_room
    * noun  -> Enter
    * 'en' / 'por' / 'a//' noun  -> Enter
    * 'dentro' 'de' noun  -> Enter
;
Verb 'metete' 'meterse' 'meterte' 'meterme' 'meteme'
    * 'en' / 'por' noun  -> Enter
;
Verb 'atraviesa'
    * noun  -> Enter
;
Verb 'sienta' 'echate' 'sientate' 'echarse' 'sentarse' 'echarte' 'sentarte'
    * 'en' noun  -> Enter
;
Verb 'sal' 'fuera' 'afuera' 'salte' 'bajate' 'levantate' 'bajarse' 'levantarse' 'salirse' 'bajarte' 'levantarte' 'salirte'
    *  -> Exit
    * 'fuera' / 'afuera'  -> Exit
    * 'de' noun  -> GetOff
;
Verb 'examina' 'describe' 'inspecciona' 'observa' 'ex' 'x//'
    * noun  -> Examine
    * 'a//' noun  -> Examine
    * 'a//' creature  -> Examine
;
Verb 'lee'
    * noun  -> Examine
    * noun  -> Examine
    * 'sobre' topic 'en' noun  -> Consult reverse
    * topic 'en' noun  -> Consult reverse
;
Verb 'si'
    *  -> Yes
;
Verb 'sí'
    *  -> Yes
;
Verb 'nx'
    *  -> No
;
Verb 'lo'
    * 'siento' / 'lamento'  -> Sorry
    * 'siento' / 'lamento' 'mucho'  -> Sorry
;
Verb 'busca'
    * 'en' noun  -> Search
    * 'en' noun 'acerca' 'de' topic  -> Consult
    * 'en' noun 'sobre' topic  -> Consult
    * 'en' noun topic  -> Consult
    * topic 'en' noun  -> Consult reverse
;
Verb 'registra' 'rebusca'
    * noun  -> Search
    * 'a//' creature  -> Search
    * 'en' noun  -> Search
;
Verb 'ondea' 'sacude' 'agita'
    * creature  -> Attack
    * noun  -> Wave
    * 'la' 'mano'  -> WaveHands
    * 'las' 'manos'  -> WaveHands
    * 'a//' creature  -> Attack
;
Verb 'gesticula'
    *  -> WaveHands
;
Verb 'saluda'
    *  -> WaveHands
    * 'con' 'la' 'mano'  -> WaveHands
;
Verb 'ajusta' 'fija' 'set'
    * noun 'en' / 'a//' topic  -> SetTo
;
Verb 'pulsa'
    * noun  -> Push
;
Verb 'empuja' 'mueve' 'desplaza' 'menea'
    * noun  -> Push
    * noun noun=Noun_Filter_9  -> PushDir
    * 'a//' creature  -> Push
    * noun 'hacia' noun=Noun_Filter_8  -> PushDir
;
Verb 'gira' 'atornilla' 'desatornilla'
    * noun  -> Turn
;
Verb 'conecta'
    * noun  -> SwitchOn
    * noun 'a//' / 'con' noun  -> Tie
;
Verb 'enciende' 'prende'
    * noun=Noun_Filter_10  -> SwitchOn
    * noun  -> Burn
;
Verb 'desconecta' 'apaga'
    * noun  -> SwitchOff
    * 'a//' creature  -> SwitchOff
;
Verb 'rompe' 'aplasta' 'golpea' 'destruye' 'patea' 'pisotea'
    * noun  -> Attack
    * 'a//' creature  -> Attack
;
Verb 'ataca' 'mata' 'asesina' 'tortura' 'noquea'
    * noun  -> Attack
    * 'a//' creature  -> Attack
;
Verb 'lucha'
    * creature  -> Attack
    * 'con' creature  -> Attack
;
Verb 'espera'
    *  -> Wait
;
Verb 'responde' 'di' 'grita' 'dile'
    *  -> A93_singing
    * Cond_Token_443 DECIMAL_TOKEN  -> A82_responding_with
    * Cond_Token_453 DECIMAL_TOKEN  -> A84_qbc_responding_with
    * 'a//' creature topic  -> Answer
    * creature topic  -> Answer
    * topic 'a//' creature  -> Answer reverse
;
Verb 'cuenta' 'narra' 'explica' 'habla'
    * SlashGPR_0 noun  -> A83_talking_to
    * 'a//' creature 'de' / 'sobre' topic  -> Tell
    * 'con' creature 'sobre' / 'de' topic  -> Tell
    * 'con' creature 'acerca' 'de' topic  -> Tell
    * creature 'de' / 'sobre' topic  -> Tell
    * 'acerca' 'de' topic 'con' creature  -> Tell reverse
    * 'a//' creature topic  -> Tell
    * 'de' topic 'con' / 'a//' creature  -> Tell reverse
    * 'sobre' topic 'con' creature  -> Tell reverse
    * creature topic  -> Tell
    * topic 'a//' creature  -> Tell reverse
;
Verb 'pregunta' 'interroga'
    * 'a//' creature 'sobre' / 'por' topic  -> Ask
    * 'a//' creature 'acerca' 'de' topic  -> Ask
    * creature 'sobre' / 'por' topic  -> Ask
    * 'sobre' / 'por' topic 'a//' creature  -> Ask reverse
    * topic 'a//' creature  -> Ask reverse
;
Verb 'pide' 'pidele'
    * 'a//' creature noun  -> AskFor
    * noun 'a//' creature  -> AskFor reverse
;
Verb 'come' 'comete' 'traga' 'ingiere' 'mastica' 'comerse' 'comerte'
    * held  -> Eat
;
Verb 'duerme'
    *  -> Sleep
;
Verb 'ronca'
    *  -> Sleep
;
Verb 'descansa'
    *  -> Sleep
;
Verb 'escala' 'trepa'
    * noun  -> Climb
    * 'a//' noun  -> Climb
    * 'por' noun  -> Climb
;
Verb 'baja'
    *  -> A78_bajando
    * noun  -> GetOff
    * 'de' noun  -> GetOff
    * 'a//' / 'en' / 'por' noun  -> Enter
;
Verb 'subete' 'subirse' 'subirte'
    * 'a//' / 'en' noun  -> Enter
;
Verb 'sube'
    *  -> A79_subiendo
    * 'arriba'  -> A79_subiendo
    * noun  -> Enter
    * 'a//' / 'en' / 'por' noun  -> Enter
;
Verb 'compra'
    * noun  -> Buy
;
Verb 'adquiere'
    * noun  -> Buy
;
Verb 'retuerce' 'aprieta' 'estruja' 'tuerce'
    * noun  -> Squeeze
    * 'a//' creature  -> Squeeze
;
Verb 'balanceate' 'columpiate' 'meneate' 'balancearse' 'columpiarse' 'menearse' 'balancearte' 'columpiarte' 'menearte'
    * 'en' noun  -> Swing
;
Verb 'despierta' 'espabila'
    *  -> Wake
    * creature  -> WakeOther
    * 'a//' creature  -> WakeOther
;
Verb 'espabilate'
    *  -> Wake
;
Verb 'espabilarse'
    *  -> Wake
;
Verb 'espabilarte'
    *  -> Wake
;
Verb 'besa' 'abraza'
    * creature  -> Kiss
    * 'a//' creature  -> Kiss
;
Verb 'piensa'
    *  -> Think
;
Verb 'huele' 'olfatea'
    *  -> Smell
    * noun  -> Smell
    * 'a//' noun  -> Smell
;
Verb 'escucha' 'oye'
    *  -> Listen
    * noun  -> Listen
    * 'a//' noun  -> Listen
;
Verb 'saborea' 'paladea' 'prueba' 'lame'
    * noun  -> Taste
    * 'a//' noun  -> Taste
;
Verb 'toca' 'palpa'
    * noun  -> Touch
    * 'a//' creature  -> Touch
;
Verb 'lava' 'limpia' 'pule' 'abrillanta' 'friega' 'frota'
    * noun  -> Rub
    * 'a//' creature  -> Rub
;
Verb 'ata' 'enlaza' 'enchufa' 'une'
    * noun  -> Tie
    * 'a//' creature  -> Tie
    * noun 'a//' noun  -> Tie
    * 'a//' creature 'a//' noun  -> Tie
;
Verb 'quema'
    * noun  -> Burn
    * 'a//' creature  -> Burn
;
Verb 'bebe'
    * noun  -> Drink
;
Verb 'corta' 'rasga'
    * noun  -> Cut
;
Verb 'salta' 'brinca'
    *  -> Jump
    * 'a//' noun  -> Enter
;
Verb 'puntos'
    *  -> Score
;
Verb 'puntuacion'
    *  -> Score
;
Verb 'terminar'
    *  -> Quit
;
Verb 'fin'
    *  -> Quit
;
Verb 'acabar'
    *  -> Quit
;
Verb 'abandonar'
    *  -> Quit
;
Verb 'guardar'
    *  -> Save
;
Verb 'salvar'
    *  -> Save
;
Verb 'reiniciar'
    *  -> Restart
;
Verb 'recuperar'
    *  -> Restore
;
Verb 'cargar'
    *  -> Restore
;
Verb 'load'
    *  -> Restore
;
Verb 'restaurar'
    *  -> Restore
;
Verb 'verificar'
    *  -> Verify
;
Verb 'noscript'
    *  -> ScriptOff
;
Verb 'unscript'
    *  -> ScriptOff
;
Verb 'notranscripcion'
    *  -> ScriptOff
;
Verb 'superbreve'
    *  -> LMode3
;
Verb 'corto'
    *  -> LMode3
;
Verb 'largo'
    *  -> LMode2
;
Verb 'breve'
    *  -> LMode1
;
Verb 'pronombres'
    *  -> Pronouns
;
Verb 'p//'
    *  -> Pronouns
;
Verb 'help'
    *  -> A80_asking_for_help
;
Verb 'hint'
    *  -> A80_asking_for_help
;
Verb 'hints'
    *  -> A80_asking_for_help
;
Verb 'about'
    *  -> A80_asking_for_help
;
Verb 'info'
    *  -> A80_asking_for_help
;
Verb 'ayuda'
    *  -> A80_asking_for_help
;
Verb 'pistas'
    *  -> A80_asking_for_help
;
Verb 'autor'
    *  -> A80_asking_for_help
;
Verb 'repeat'
    * Cond_Token_437  -> A81_requesting_a_recap
    * Cond_Token_449  -> A85_qbc_recap
;
Verb 'recap'
    * Cond_Token_438  -> A81_requesting_a_recap
    * Cond_Token_450  -> A85_qbc_recap
;
Verb 'no.verb'
    * Cond_Token_439 DECIMAL_TOKEN  -> A82_responding_with
    * Cond_Token_447 DECIMAL_TOKEN  -> A84_qbc_responding_with
;
Verb 'mostrar'
    * Cond_Token_441  -> A81_requesting_a_recap
    * Cond_Token_454  -> A85_qbc_recap
;
Verb 'recapitular'
    * Cond_Token_442  -> A81_requesting_a_recap
    * Cond_Token_455  -> A85_qbc_recap
;
Verb 'elige'
    * Cond_Token_444 DECIMAL_TOKEN  -> A82_responding_with
    * Cond_Token_452 DECIMAL_TOKEN  -> A84_qbc_responding_with
;
Verb 'elegir'
    * Cond_Token_445 DECIMAL_TOKEN  -> A82_responding_with
;
Verb 'talk'
    * 'to' noun  -> A83_talking_to
;
Verb 'escribe'
    *  -> A87_writenothing
    * noun  -> A88_writenoun
    * 'sobre' topic  -> A86_writing_it_in
    * topic 'en' noun  -> A86_writing_it_in
    * topic  -> A86_writing_it_in
;
Verb 'escribi'
    *  -> A87_writenothing
    * noun  -> A88_writenoun
    * topic 'en' noun  -> A86_writing_it_in
    * topic  -> A86_writing_it_in
;
Verb 'escribir'
    * 'sobre' topic  -> A86_writing_it_in
;
Verb 'reza'
    *  -> A89_rezaring
;
Verb 'ora'
    *  -> A89_rezaring
;
Verb 'suplica'
    *  -> A89_rezaring
;
Verb 'recuerda'
    *  -> A90_remembering
;
Verb 'recorda'
    *  -> A90_remembering
;
Verb 'fornica'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'con' creature  -> A91_fucking
    * 'con' noun  -> A92_faping
;
Verb 'folla'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'con' creature  -> A91_fucking
    * 'con' noun  -> A92_faping
;
Verb 'ama'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'a//' creature  -> A91_fucking
    * 'a//' noun  -> A92_faping
;
Verb 'penetra'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'a//' creature  -> A91_fucking
;
Verb 'haz'
    * 'el' 'amor' 'con' creature  -> A91_fucking
    * 'el' 'amor' 'con' noun  -> A92_faping
;
Verb 'hazle'
    * 'el' 'amor' 'a//' creature  -> A91_fucking
    * 'el' 'amor' 'a//' noun  -> A92_faping
;
Verb 'hacer'
    * 'el' 'amor' 'con' creature  -> A91_fucking
    * 'el' 'amor' 'a//' creature  -> A91_fucking
    * 'el' 'amor' 'con' noun  -> A92_faping
    * 'el' 'amor' 'a//' noun  -> A92_faping
;
Verb 'monta'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'a//' creature  -> A91_fucking
    * 'a//' noun  -> A92_faping
;
Verb 'masturba'
    * creature  -> A91_fucking
    * noun  -> A92_faping
    * 'a//' creature  -> A91_fucking
    * 'a//' noun  -> A92_faping
;
Verb 'masturbate'
    * 'con' creature  -> A91_fucking
    * 'con' noun  -> A92_faping
;
Verb 'canta'
    *  -> A93_singing
;
Verb 'recita'
    *  -> A93_singing
;
Verb 'canto'
    *  -> A93_singing
;
Verb 'llora'
    *  -> A93_singing
;
Verb 'matar'
    * noun  -> Attack
    * 'a//' noun  -> Attack
;
Verb 'ahoga'
    * noun  -> Attack
;
Verb 'degolla'
    * noun  -> Attack
;
Verb 'destripa'
    * noun  -> Attack
;
Verb 'roba'
    * noun  -> Take
;





#IFTRUE (1 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


! Esto era parte de SpanishG.h (Gramatica.h) GRAMATICA: Gramática española

#Stub PreguntarPreposicion 0;

#ifdef DEBUG;
  [ ActivarAcentosSub;
    quitacentos = 0;
    "Los acentos no serán eliminados del comando recibido.";
  ];

  [ DesactivarAcentosSub;
    quitacentos = 1;
    "Los acentos serán eliminados del comando recibido, pero sólo en
      las palabras que de otro modo no serían comprendidas.";
  ];
#endif; ! DEBUG

! Elección del dialecto (afecta a la interpretación del
! verbo COGER únicamente)

[ DialectoSub;
  print "Actualmente estás jugando en el dialecto ";
  if (dialecto_sudamericano)
    print "sudamericano";
  else
    print "castellano";
  ". Puedes elegir dialecto usando el comando DIALECTO SUDAMERICANO \
    o bien DIALECTO CASTELLANO.";
];

[ DialectoSudSub;
  dialecto_sudamericano = 2; ! git
  "Elegido dialecto SUDAMERICANO.";
];    

[ DialectoCastSub;
  dialecto_sudamericano = 0;
  "Elegido dialecto CASTELLANO.";
];


[ QuitarSub;
    if (second) <<Remove noun second>>;
    if (noun in player) <<Disrobe noun>>;
    <<Take noun>>;
];

! Algunas lineas de gramatica no incluidas en las SR (lineas que son propias de InformATE)
! [TODO]: a la espera de ser 'transferidas' a SL (Spanish Localization I7 Extension)
! Actualizacion, ahora si andan las Extend, porque se cambio de lugar la inclusion de SpanishG
!   en el codigo de auto.inf (usando Foreign Language en SL y main.i6)

Verb meta 'dialecto'
  *                                   -> Dialecto
  * 'sudamericano'               -> DialectoSud
  * 'castellano'                    -> DialectoCast;

! GotoRoomSub: algunos momios de informATE estaban acotumbrados a hacer >xir 'nombre_habitacion'
! pero, despues de la Build 4S08 no fue posible sino la forma oficial
! >xir 'numero_habitacion' . Ese numero_habitacion se ve haciendo >tree
! Aqui agregamos una variante para poder seguir usando nuestro >xir 'nombre_habitacion'
! (de puro caprichosos que somos) 

#ifdef DEBUG;

[ GotoRoomSub x;  ! para funciones de debug
    x = noun;
    while (parent(x) ~= 0) x = parent(x);
!    print "   Moviendo a ",(the) x,"^";!infsp debug
    PlayerTo(x);
];   
  
 Verb meta 'acentos'
    *                                 -> ActivarAcentos
    * 'on'/'si'                          -> ActivarAcentos
    * 'off'/'no'                      -> DesactivarAcentos;

  Verb 'traza' = 'trace';

  Verb 'acciones' = 'actions';

  Verb 'aleatorio' 'predecible' = 'random' ;

  Verb 'xroba' = 'purloin';

  Verb meta 'xmueve'
	* scope=testcommandnoun 'a//' scope=testcommandnoun -> XAbstract;

  Verb 'arboljuego' 'xarbol' = 'tree';

  Verb meta 'xir'
    * scope=testcommandnoun  -> GotoRoom;

  Verb 'irdonde' = 'gonear';

  Verb 'alcance' = 'scope' ;

  Verb 'xverbo' = 'showverb';

  Verb 'xobjeto' =  'showme';

  Verb 'relaciones'= 'relations';
  
  Verb 'reglas' = 'rules';
  
  Verb 'escenas' =  'scenes';
  
#endif;  ! DEBUG


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Deferred Propositions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====







! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Miscellaneous Loose Ends
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Constant TX_PS_168 = " ";
Constant TX_PS_242 = " A = Anterior";
Array TX_L_242 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_242;
Constant TX_PS_166 = " N = Next";
Constant TX_PS_167 = " P = Previous";
Constant TX_PS_241 = " S = Siguiente";
Array TX_L_241 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_241;
Constant TX_PS_46 = "#000000";
Constant TX_PS_163 = "#FFFFF0";
Constant TX_PS_246 = "#FFFFFF";
Array TX_L_246 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_246;
Constant TX_PS_152 = ">";
Constant TX_PS_116 = "A lo lejos puedes ver de nuevo al pastor.";
Constant TX_PS_34 = "Abajo";
Constant TX_PS_177 = "Acerca de Ficción Interactiva";
Constant TX_PS_201 = "Al articular palabra, la doncella se estremece, una lágrima cae de su rostro. No implora ayuda, ni clemencia... está indefensa ante ti.";
Constant TX_PS_43 = "All-buffer-windows";
Constant TX_PS_44 = "All-grid-windows";
Constant TX_PS_42 = "All-windows";
Constant TX_PS_102 = "Apenas se puede ver la cama con tantos cojines y almohadas como hay sobre ella.";
Constant TX_PS_96 = "Apenas visible en el otro extremo de la sala está la cama, donde acabaréis esta noche.";
Constant TX_PS_32 = "Arriba";
Constant TX_PS_233 = "Aún así piensas que puedes librarte de ella. Tal vez hay una manera...";
Constant TX_PS_68 = "Bandejas repletas de comida... asado, frutas y todo tipo de delicias.";
Constant TX_PS_212 = "Buenas noches, muchacha";
Constant TX_PS_178 = "Comenzando a Jugar";
Constant TX_PS_188 = "Comparte";
Constant TX_PS_174 = "Contactar con el autor";
Constant TX_PS_147 = "Contemplas las sanguinolentas entrañas del animal.";
Constant TX_PS_191 = "Contenedores";
Constant TX_PS_181 = "Controlando el juego";
Constant TX_PS_183 = "Cuando te atascas";
Constant TX_PS_90 = "Cuarto acto";
Constant TX_PS_182 = "Cómo el Mundo es construido";
Constant TX_PS_222 = "Debes escribir una palabra relacionada con tus actos y con los pecados cometidos. Es una de las dos maneras posibles de terminar con tu agonía.";
Constant TX_PS_36 = "Dentro";
Constant TX_PS_72 = "Desde aquí puedes divisar toda la sierra. En el cielo, los cuervos dan vueltas. Uno de ellos se acerca sobrevolando el torreón. Sus graznidos hacen enloquecer al hombre encadenado.";
Constant TX_PS_223 = "Después de escribir en el libro, la musa espera que la mires. Solo así conseguirás la inspiración.";
Constant TX_PS_243 = "ENTER = Selec.";
Array TX_L_243 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_243;
Constant TX_PS_169 = "ENTER = Select";
Constant TX_PS_130 = "El cabello de la doncella, largo y rizado, presenta algunos enredos.";
Constant TX_PS_113 = "El cielo está nublado, amenaza tormenta.";
Constant TX_PS_149 = "El corazón del ternero palpita débilmente. Está fresco aún. Es el momento.";
Constant TX_PS_74 = "El cuervo espera impaciente a que el prisionero acabe con su agonía...";
Constant TX_PS_76 = "El hombre está encadenado con fuertes cadenas. Dos verdugos a cada lado vigilan que no pueda moverse.";
Constant TX_PS_198 = "El pastor parece que no puede oírte.";
Constant TX_PS_154 = "El pecado acecha a la puerta; y aunque viene por ti, tú puedes dominarlo. Confusa, que sólo tú eres mi musa. ¿Serás capaz de obtener suficiente inspiración de tu musa como para resultar vencedor de la aventura?";
Constant TX_PS_215 = "El ternero no se ha escapado, hermano...";
Constant TX_PS_227 = "En el cuarto acto debemos hacer algo pecaminoso que es la razón por la cual este juego no es apto para menores.";
Constant TX_PS_224 = "En el primer acto nos sentimos algo cansados. ¿Qué haces cuando estás cansado?";
Constant TX_PS_228 = "En el quinto acto hay algo que queremos y haremos lo necesario para conseguirlo.";
Constant TX_PS_225 = "En el segundo acto tenemos mucha comida disponible. ¿Qué haces cuando tienes hambre?";
Constant TX_PS_229 = "En el sexto acto debemos subir al altar y terminar con el ritual, pero también conseguir algo para el último acto.";
Constant TX_PS_230 = "En el séptimo y último acto terminaremos drásticamente lo que en el primero nos dio pereza hacer.";
Constant TX_PS_226 = "En el tercer acto podemos matar a un soldado con su propia arma.";
Constant TX_PS_49 = "En la oscuridad";
Constant TX_PS_244 = "Es el cepillo con el que la doncella suele sacudirse el cabello.";
Array TX_L_244 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_244;
Constant TX_PS_80 = "Es un banquete compuesto de un asado especiado, frutas y demás delicias para el paladar.";
Constant TX_PS_56 = "Es un libro cuyas páginas están salpicadas de rencores, pecados, desamores, guerras y temores, reunidos en forma de poemas de ininteligible lectura.";
Constant TX_PS_115 = "Es un pastor orgulloso, el favorito de su padre.";
Constant TX_PS_89 = "Es un soldado vencido en la batalla, tiene horribles heridas y le falta media mano derecha, su espada está tirada a un lado... junto al resto de su mano.";
Constant TX_PS_245 = "Es una piedra ensangrentada, con la que cometiste tu primer asesinato.";
Array TX_L_245 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_245;
Constant TX_PS_209 = "Esas heridas tienen que doler, déjame ponerle fin a tu sufrimiento...";
Constant TX_PS_235 = "Escribe sobre tus actos.";
Constant TX_PS_238 = "Esos actos son los pecados originales.";
Constant TX_PS_237 = "Esos actos son malvados.";
Constant TX_PS_236 = "Esos actos son ruines.";
Constant TX_PS_190 = "Espacio";
Constant TX_PS_208 = "Esta parece una buena espada...";
Constant TX_PS_184 = "Este juego es un trabajo de ficción interactiva (IF) o aventura conversacional.  En un juego conversacional tu desempeñas el papel del protagonista de la historia.  Mediante escribir comandos con el teclado puedes decidir la acción de los personajes y el flujo general de la historia.  Algunos juegos IF incluyen gráficos, aunque no tendrían porqué: las imágenes son provistas por tu propia imaginación (mejor que cualquier tarjeta gráfica).  Por otro lado, existe un amplio número de acciones disponibles en el juego: mientras que en otros tipos de juegos la interacción se limita a disparar, moverse en un mapa o buscar cosas (a veces usando el mouse), en los juegos Ifs dispones de muchos verbos con que probar.";
Constant TX_PS_61 = "Estás demasiado cansado para eso, te apetece dormir...";
Constant TX_PS_185 = "Explora";
Constant TX_PS_85 = "Fieros guerreros que te son leales. Esperan a que termines con la vida del último de los enemigos.";
Constant TX_PS_38 = "Fuera";
Constant TX_PS_214 = "Ha sido mi ofrenda.";
Constant TX_PS_179 = "Habitaciones y Movimientos en el Mapa";
Constant TX_PS_124 = "Horribles heridas, pero que quizás con el debido tratamiento podrían sanar. No va a ser el caso.";
Constant TX_PS_3 = "Inspiración, pecado y romanticismo";
Constant TX_PS_171 = "Instrucciones para Jugar";
Constant TX_PS_240 = "Instrucciones";
Array TX_L_240 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_240;
Constant TX_PS_155 = "Instructions";
Constant TX_PS_189 = "Juega con otra persona. Dos cabezas piensan más que una. Si eso no funciona, prueba contactando al autor o (mejor aun) deja un mensaje pidiendo ayuda en el foro de CAAD (caad.es/foro), sección Jugadores. Un consejo: primero busca algún hilo que ya esté relacionado con el juego. Si no existe, crea un hilo nuevo y pon el nombre del juego como título del hilo. Utiliza la herramienta de ~spoiler~ del editor del foro para escribir tu duda. Sé lo más claro posible.  Alguien que ya lo jugó (o el autor mismo) te dará una mano.";
Constant TX_PS_200 = "La chica se queda inmóvil frente al espejo.";
Constant TX_PS_196 = "La mayoría de las acciones que puedes hacer en el mundo IF son breves y específicas. Un buen ejemplo son >IR AL OESTE o >ABRE PUERTA. Un mal ejemplo son >TOMA UN VIAJE o >CONSTRUYE UNA MESA. Cosas como >VE AL HOTEL están en el límite: algunos juegos lo permiten, pero la mayoría no. En general, los comportamientos complejos o abstractos necesitan desdoblarse en acciones más sencillas para ser entendidas. ";
Constant TX_PS_194 = "La mayoría de los juegos IF se basan en un modelo de mundo construído con habitaciones (o localidades) como los menores elementos del mapa. Es posible el movimiento entre ellas y muy raro el movimiento dentro de alguna de ellas. >CAMINA SOBRE EL ESCRITORIO no es un comando muy útil. Por otro lado si algo se describe como muy alto para acceder, entonces sí sería interesante pararse sobre un objeto para incrementar nuestra altura. Este tipo de cosas solo tienen sentido si es mencionado antes por el juego.";
Constant TX_PS_2 = "La musa";
Array TX_L_2 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_2;
Constant TX_PS_232 = "La primera pista es que no vas a acabar con la musa.";
Constant TX_PS_151 = "La sangre salpica en las piedras del altar. Su aroma te estimula a continuar con el ritual.";
Constant TX_PS_87 = "Las armas de tus guerreros repiquetean en sus escudos. Todos esperan el inevitable desenlace.";
Constant TX_PS_157 = "Las opciones disponibles son:";
Constant TX_PS_63 = "Las ovejas campan a sus anchas, el rebaño se ha escapado del control del pastor, que te parece ver a lo lejos, intentando reunir de nuevo a sus animales.";
Constant TX_PS_186 = "Lee cuidadosamente";
Constant TX_PS_107 = "Los fieles recitan cánticos prohibidos. La muchedumbre espera la culminación del ritual.";
Constant TX_PS_197 = "Los personajes no jugador en los juegos IF son más bien limitados. Sin embargo, existen algunos juegos en donde la interacción con otros personajes es lo principal.  Y puedes percibirlo muy pronto: si los personajes responden muchas preguntas, recuerdan, se mueven por su cuenta, entonces son importantes. Si, por el contrario, tienen respuestas ~estandares~ y no parece que ocuparon un lugar importante en el diseño; entonces solo están para dar un toque local al juego o proveer una ayuda puntual en algun puzzle. Los personajes en juegos orientados a puzzles deben ser sobornados, amenazados, o lisonjeados para lograr algo que el jugador no puede, como dar cierta información u objeto, llegar a zonas inaccesibles, etc.";
Constant TX_PS_40 = "No importa tu aspecto, eres lo que dicte tu inspiración en cada momento.";
Constant TX_PS_65 = "No lo puedes ver muy bien, además estás demasiado cansado para acercarte a mirar.";
Constant TX_PS_118 = "No puedes verla, pero sientes la presencia acechante de tu musa.";
Constant TX_PS_156 = "No se me ocurre nada que decir sobre ese tema.";
Constant TX_PS_180 = "Objetos";
Constant TX_PS_173 = "Opciones";
Constant TX_PS_193 = "Otros Personajes";
Constant TX_PS_216 = "Parece que se avecina tormenta...";
Constant TX_PS_207 = "Pareces hambriento...";
Constant TX_PS_101 = "Pinturas obscenas rodean la estancia, propias de un alma corrupta y decadente. En el centro de la sala está la cama donde reposa el mercader.";
Constant TX_PS_172 = "Pistas";
Constant TX_PS_175 = "Poema de Roberto Menéndez";
Constant TX_PS_59 = "Primer acto";
Constant TX_PS_99 = "Quinto acto";
Constant TX_PS_159 = "RECUPERAR un juego guardado";
Constant TX_PS_158 = "REINICIAR";
Constant TX_PS_153 = "Romance";
Array TX_L_153 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_153;
Constant TX_PS_170 = "Sample Hint";
Constant TX_PS_187 = "Se creativo";
Constant TX_PS_66 = "Segundo acto";
Constant TX_PS_50 = "Sentado en algún punto de apoyo invisible en una oscuridad infinita, tu mirada se clava en el libro de páginas eternas que escribes con la ayuda de tu musa, acompañante fiel en tu pena y en tu pesar.";
Constant TX_PS_105 = "Sexto acto";
Constant TX_PS_141 = "Sin duda sus ropas están tejidas con las telas más finas.";
Constant TX_PS_53 = "Sobre el libro está tu pluma.";
Constant TX_PS_52 = "Solo es una pluma de la que constantemente gotea sangre.";
Constant TX_PS_132 = "Su cabello es ondulado y del color del oro.";
Constant TX_PS_134 = "Sus ojos son grandes y hermosos.";
Constant TX_PS_111 = "Séptimo acto";
Constant TX_PS_161 = "TERMINAR";
Constant TX_PS_83 = "Tercer acto";
Constant TX_PS_192 = "Tipos de Acciones";
Constant TX_PS_234 = "Tras cada inspiración recuerdas más cosas de tus actos del pasado.";
Constant TX_PS_213 = "Tu cabello es hermoso";
Constant TX_PS_78 = "Tus verdugos están aquí para acatar tus órdenes.";
Constant TX_PS_70 = "Un alto torreón desde donde se divisa toda la sierra.";
Constant TX_PS_94 = "Un gran espejo ovalado donde se refleja la gran belleza de esta muchacha.";
Constant TX_PS_136 = "Un lujoso cepillo con el que se sacude los enredos de su cabello.";
Constant TX_PS_195 = "Una de las cosas que la ficción interactiva considera y modela es el tema de los contenedores y soportes. ¿El objeto está ~en~ o ~sobre~ algo? El juego toma nota de esto, y en muchos puzzles interviene la ubicación de las cosas (en poder del jugador, sobre el piso, sobe una mesa, en una caja, etc).";
Constant TX_PS_127 = "Una ensangrentada espada.";
Constant TX_PS_109 = "Una hoguera crepita en la noche. Ilumina débilmente el altar.";
Constant TX_PS_92 = "Una lujosa habitación débilmente iluminada para la ocasión, donde puedes ver una butaca sobre la que se peina una doncella desnuda frente a un espejo.";
Constant TX_PS_144 = "Una piedra maldita.";
Constant TX_PS_199 = "Uno de tus verdugos acata la orden y le propina severos latigazos al ajusticiado, que se retuerce de dolor.";
Constant TX_PS_82 = "Viste túnicas extranjeras rotas y roídas, tiene la mirada fiera y desafiante, a pesar de su estado esquelético y su condición de reo ajusticiado. Está encadenado a un poste y dos verdugos lo custodian.";
Constant TX_PS_4 = "Xavier Carrascosa";
Constant TX_PS_41 = "Yourself";
Constant TX_PS_33 = "abajo";
Constant TX_PS_58 = "abismo";
Constant TX_PS_81 = "ajusticiado";
Constant TX_PS_139 = "almohada";
Constant TX_PS_137 = "almohadas";
Constant TX_PS_110 = "altar";
Constant TX_PS_9 = "animals";
Constant TX_PS_86 = "armas";
Constant TX_PS_31 = "arriba";
Constant TX_PS_121 = "asado";
Constant TX_PS_67 = "bandejas";
Constant TX_PS_79 = "banquete";
Constant TX_PS_165 = "bar";
Constant TX_PS_13 = "bolsas";
Constant TX_PS_97 = "butaca";
Constant TX_PS_131 = "cabello";
Constant TX_PS_75 = "cadenas";
Constant TX_PS_95 = "cama";
Constant TX_PS_135 = "cepillo";
Constant TX_PS_138 = "cojines";
Constant TX_PS_119 = "comida";
Constant TX_PS_11 = "contenedores";
Constant TX_PS_148 = "corazón";
Constant TX_PS_73 = "cuervo";
Constant TX_PS_18 = "decorados";
Constant TX_PS_122 = "delicias";
Constant TX_PS_35 = "dentro";
Constant TX_PS_103 = "diamante";
Constant TX_PS_21 = "direcciones";
Constant TX_PS_19 = "dispositivos";
Constant TX_PS_98 = "doncella";
Constant TX_PS_129 = "enredos";
Constant TX_PS_126 = "espada";
Constant TX_PS_93 = "espejo";
Constant TX_PS_29 = "este";
Constant TX_PS_106 = "fieles";
Constant TX_PS_164 = "foo";
Constant TX_PS_120 = "frutas";
Constant TX_PS_37 = "fuera";
Constant TX_PS_14 = "g-windows";
Constant TX_PS_15 = "graphics g-windows";
Constant TX_PS_84 = "guerreros";
Constant TX_PS_91 = "habitación";
Constant TX_PS_162 = "hacer UNDO del último comando";
Constant TX_PS_123 = "heridas";
Constant TX_PS_114 = "hermano";
Constant TX_PS_108 = "hoguera";
Constant TX_PS_7 = "hombres";
Constant TX_PS_55 = "libro";
Constant TX_PS_45 = "main window";
Constant TX_PS_125 = "mano";
Constant TX_PS_104 = "mercader";
Constant TX_PS_133 = "mirada";
Constant TX_PS_8 = "mujeres";
Constant TX_PS_54 = "musa";
Constant TX_PS_24 = "noreste";
Constant TX_PS_25 = "noroeste";
Constant TX_PS_22 = "norte";
Constant TX_PS_30 = "oeste";
Constant TX_PS_57 = "ojos";
Constant TX_PS_62 = "ovejas";
Constant TX_PS_60 = "paisaje";
Constant TX_PS_64 = "pastor";
Constant TX_PS_6 = "personas";
Constant TX_PS_143 = "piedra";
Constant TX_PS_142 = "piedras";
Constant TX_PS_100 = "pinturas";
Constant TX_PS_51 = "pluma";
Constant TX_PS_117 = "presencia";
Constant TX_PS_10 = "puertas";
Constant TX_PS_48 = "quote window";
Constant TX_PS_20 = "regiones";
Constant TX_PS_150 = "sangre";
Constant TX_PS_71 = "sierra";
Constant TX_PS_88 = "soldado";
Constant TX_PS_5 = "soportes";
Constant TX_PS_47 = "status window";
Constant TX_PS_26 = "sur";
Constant TX_PS_27 = "sureste";
Constant TX_PS_28 = "suroeste";
Constant TX_PS_140 = "telas";
Constant TX_PS_145 = "ternero";
Constant TX_PS_16 = "text buffer g-windows";
Constant TX_PS_17 = "text grid g-windows";
Constant TX_PS_23 = "the";
Constant TX_PS_112 = "tormenta";
Constant TX_PS_69 = "torreón";
Constant TX_PS_12 = "vehículos";
Constant TX_PS_160 = "ver algunas CURIOSIDADES";
Constant TX_PS_77 = "verdugos";
Constant TX_PS_146 = "vísceras";
Constant TX_PS_39 = "yourself";
Array TX_L_39 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_39;
Constant TX_PS_206 = "¡Azotadle!";
Constant TX_PS_211 = "¡Deja ya de cepillarte el pelo!";
Constant TX_PS_204 = "¡Hola!";
Constant TX_PS_205 = "¿Cuál es tu crimen, hombre infeliz?";
Constant TX_PS_219 = "¿Cómo puedo acabar con la musa?";
Constant TX_PS_218 = "¿Cómo puedo resolver los actos?";
Constant TX_PS_220 = "¿Has cogido la pluma ya? Sin la pluma no podrás escribir...";
Constant TX_PS_231 = "¿Has vuelto a empezar? ¡Claro! En eso consiste el tormento, así es la eternidad.";
Constant TX_PS_203 = "¿Necesita ayuda?";
Constant TX_PS_221 = "¿No se te ocurre sobre qué escribir? Es raro, la musa siempre te ofrece una nueva inspiración a cada acto.";
Constant TX_PS_202 = "¿Puede oírme?";
Constant TX_PS_210 = "¿Quieres decir tus últimas palabras?";
Constant TX_PS_128 = "¿Qué me importa la decoración de la sala?";
Constant TX_PS_239 = "¿Qué podemos hacer para que Él nos perdone?";
Constant TX_PS_217 = "¿Qué tengo que escribir en el libro?";
Constant TX_PS_176 = "¿Te has atascado? Puedes contactar conmigo escribiéndome un mensaje a mi cuenta de Twitter o Instagram: @@64XCarrascosa. Puedes pedir ayuda en los foros del CAAD (www.caad.es). También me puedes dejar un mensaje a través del formulario de contacto de mi web: www.xaviercarrascosa.com";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p10_opposite; Constant p10_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p14_adaptive_text_viewpoint; Constant p14_adaptive_text_viewpoint = 0; #endif;
#ifndef p15_default_ask_quip; Constant p15_default_ask_quip = 0; #endif;
#ifndef p16_default_tell_quip; Constant p16_default_tell_quip = 0; #endif;
#ifndef p17_greeting; Constant p17_greeting = 0; #endif;
#ifndef p18_litany; Constant p18_litany = 0; #endif;
#ifndef p19_type; Constant p19_type = 0; #endif;
#ifndef p20_position; Constant p20_position = 0; #endif;
#ifndef p21_scale_method; Constant p21_scale_method = 0; #endif;
#ifndef p22_measurement; Constant p22_measurement = 0; #endif;
#ifndef p23_minimum_size; Constant p23_minimum_size = 0; #endif;
#ifndef p24_rock_number; Constant p24_rock_number = 0; #endif;
#ifndef p25_ref_number; Constant p25_ref_number = 0; #endif;
#ifndef p26_border_hint; Constant p26_border_hint = 0; #endif;
#ifndef p27_background_color; Constant p27_background_color = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef ambigpluralname; Constant ambigpluralname = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p70_recurring; Constant p70_recurring = 0; #endif;
#ifndef p72_grammatical_gender; Constant p72_grammatical_gender = 0; #endif;
#ifndef p73_quiptext; Constant p73_quiptext = 0; #endif;
#ifndef p74_g_required; Constant p74_g_required = 0; #endif;
#ifndef p76_g_present; Constant p76_g_present = 0; #endif;
#ifndef p78_currently_being_processe; Constant p78_currently_being_processe = 0; #endif;
#ifndef p79_complacida; Constant p79_complacida = 0; #endif;
#ifndef p81_vivo; Constant p81_vivo = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK1_Count; Constant IK1_Count = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK2_Count; Constant IK2_Count = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK3_Count; Constant IK3_Count = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK4_Count; Constant IK4_Count = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK5_Count; Constant IK5_Count = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK6_Count; Constant IK6_Count = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK8_Count; Constant IK8_Count = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef IK10_Link; Constant IK10_Link = 0; #endif;
#ifndef IK11_Count; Constant IK11_Count = 0; #endif;
#ifndef IK11_Link; Constant IK11_Link = 0; #endif;
#ifndef IK12_Count; Constant IK12_Count = 0; #endif;
#ifndef IK12_Link; Constant IK12_Link = 0; #endif;
#ifndef IK13_Count; Constant IK13_Count = 0; #endif;
#ifndef IK13_Link; Constant IK13_Link = 0; #endif;
#ifndef IK14_Count; Constant IK14_Count = 0; #endif;
#ifndef IK14_Link; Constant IK14_Link = 0; #endif;
#ifndef IK15_Count; Constant IK15_Count = 0; #endif;
#ifndef IK15_Link; Constant IK15_Link = 0; #endif;
#ifndef IK16_Count; Constant IK16_Count = 0; #endif;
#ifndef IK16_Link; Constant IK16_Link = 0; #endif;
#ifndef IK17_Count; Constant IK17_Count = 0; #endif;
#ifndef IK17_Link; Constant IK17_Link = 0; #endif;
#ifndef IK18_Count; Constant IK18_Count = 0; #endif;
#ifndef IK18_Link; Constant IK18_Link = 0; #endif;
#ifndef IK19_Count; Constant IK19_Count = 0; #endif;
#ifndef IK19_Link; Constant IK19_Link = 0; #endif;
#ifndef KD_Count; Constant KD_Count = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;

Array Runtime_Quotations_Displayed --> 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Block Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 8192;
#ifnot;
Constant MEMORY_HEAP_SIZE = 32768;
#endif;

Array Closure_0 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Abs ! routine to call
    "abs function" ! name
;
Array Closure_1 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Root ! routine to call
    "root function" ! name
;
Array Closure_2 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    PHR_424_r33  ! routine to call
    "rsqr function" ! name
;
Array Closure_3 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Ceiling ! routine to call
    "ceiling function" ! name
;
Array Closure_4 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Floor ! routine to call
    "floor function" ! name
;
Array Closure_5 -->
    KD9_phrase_real_number_to_numb ! phrase real number -> number
    REAL_NUMBER_TY_to_NUMBER_TY ! routine to call
    "int function" ! name
;
Array Closure_6 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Log ! routine to call
    "log function" ! name
;
Array Closure_7 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Exp ! routine to call
    "exp function" ! name
;
Array Closure_8 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Sin ! routine to call
    "sin function" ! name
;
Array Closure_9 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Cos ! routine to call
    "cos function" ! name
;
Array Closure_10 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Tan ! routine to call
    "tan function" ! name
;
Array Closure_11 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arcsin ! routine to call
    "arcsin function" ! name
;
Array Closure_12 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arccos ! routine to call
    "arccos function" ! name
;
Array Closure_13 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Arctan ! routine to call
    "arctan function" ! name
;
Array Closure_14 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Sinh ! routine to call
    "sinh function" ! name
;
Array Closure_15 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Cosh ! routine to call
    "cosh function" ! name
;
Array Closure_16 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    REAL_NUMBER_TY_Tanh ! routine to call
    "tanh function" ! name
;
Array Closure_17 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    PHR_442_r34  ! routine to call
    "arcsinh function" ! name
;
Array Closure_18 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    PHR_443_r35  ! routine to call
    "arccosh function" ! name
;
Array Closure_19 -->
    KD8_phrase_real_number_to_real ! phrase real number -> real number
    PHR_444_r36  ! routine to call
    "arctanh function" ! name
;
Array Closure_20 -->
    KD10_phrase_nothing_to_number ! phrase nothing -> number
    PHR_1009_r118  ! routine to call
    "the handle glk event rule" ! name
;
Array Closure_21 -->
    KD11_phrase_number_number_numb ! phrase (number, number, number, number, number) -> number
    PHR_1071_r0  ! routine to call
    "handling an unscheduled construction" ! name
;
Array Closure_22 -->
    KD12_phrase_number_to_nothing ! phrase number -> nothing
    PHR_1072_r1  ! routine to call
    "handling an unscheduled deconstruction" ! name
;

Array KD0_rule --> ! rule
    RULE_TY 2 ACTION_NAME_TY NIL_TY;
Array KD1_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD2_relation_of_values --> ! relation of values
    RELATION_TY 2 VALUE_TY VALUE_TY;
Array KD3_relation_of_objects --> ! relation of objects
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD4_relation_of_supporters_to_ --> ! relation of supporters to things
    RELATION_TY 2 10 10;
Array KD5_relation_of_things --> ! relation of things
    RELATION_TY 2 10 10;
Array KD6_relation_of_people_to_thin --> ! relation of people to things
    RELATION_TY 2 10 10;
Array KD7_relation_of_rooms_to_doors --> ! relation of rooms to doors
    RELATION_TY 2 10 10;
Array KD8_phrase_real_number_to_real --> ! phrase real number -> real number
    PHRASE_TY 2    REAL_NUMBER_TY;
Array KD9_phrase_real_number_to_numb --> ! phrase real number -> number
    PHRASE_TY 2    NUMBER_TY;
Array KD10_phrase_nothing_to_number --> ! phrase nothing -> number
    PHRASE_TY 1    NUMBER_TY;
Array KD11_phrase_number_number_numb --> ! phrase (number, number, number, number, number) -> number
    PHRASE_TY 6    NUMBER_TY;
Array KD12_phrase_number_to_nothing --> ! phrase number -> nothing
    PHRASE_TY 2    NIL_TY;
[ DefaultValueFinder 
    K ! Implied call parameter
    ;
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_FLAG_TRUNCMULT = $$00010000;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;

Constant BLK_DATA_OFFSET = 3*WORDSIZE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Multiple Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_DATA_MULTI_OFFSET = BLK_DATA_OFFSET + 2*WORDSIZE;
Constant BLK_NEXT 3;
Constant BLK_PREV 4;

! Constant BLKVALUE_TRACE = 1; ! Uncomment this for debugging purposes


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: The Heap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Flex_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Initialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapInitialise n bsize blk2;
	blk2 = Flex_Heap + 16;
	Flex_Heap->BLK_HEADER_N = 4;
	Flex_Heap-->BLK_HEADER_KOV = 0;
	Flex_Heap-->BLK_HEADER_RCOUNT = MAX_POSITIVE_NUMBER;
	Flex_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Flex_Heap-->BLK_NEXT = blk2;
	Flex_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2-->BLK_HEADER_RCOUNT = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Flex_Heap;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Net Free Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Make Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock-->BLK_HEADER_RCOUNT = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Flex_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Flex_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Flex_Heap;
		.Linked; ;
		#ifdef BLKVALUE_TRACE;
		print "Increasing heap to free space map: "; FlexDebugDecomposition(Flex_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ HeapDebug full;
	if (full) {
		print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
		print HeapNetFreeSpace(false), " bytes currently free.^";
		print "Free space decomposition: "; FlexDebugDecomposition(Flex_Heap);
		print "Free space map: "; FlexDebug(Flex_Heap);
	} else {
		print HeapNetFreeSpace(false), " of ", MEMORY_HEAP_SIZE+16, " bytes free.^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) FlexError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	! Calculate the data size
	n=0; for (dsize=1: ((dsize < hsize+size) || (n<3+(WORDSIZE/2))): dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Flex_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = FlexAllocate(dsize-hsize, kov, flags);
		if (head == 0) FlexError("for head block not available");
		tail = FlexAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) FlexError("for tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		! print "Halving size to ", dsize, "^";
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf-->BLK_HEADER_RCOUNT = 0;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block-->BLK_HEADER_RCOUNT = 1;
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Merging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexMergeInternal block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+FlexSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + FlexSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Flex_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef BLKVALUE_TRACE;
	print "Merging: "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (FlexRecutInternal(first, last)) {
		#ifdef BLKVALUE_TRACE;
		print " --> "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Recutting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + FlexSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == FlexSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend-->BLK_HEADER_RCOUNT = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Deallocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	if ((block->BLK_HEADER_N) & $80) return; ! not a flexible block at all
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; FlexFreeSingleBlockInternal(block); block = ptxb;
		}
	}
	FlexFreeSingleBlockInternal(block);
];

[ FlexFreeSingleBlockInternal block free nx;
	block-->BLK_HEADER_KOV = 0;
	block-->BLK_HEADER_RCOUNT = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Flex_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			FlexMergeInternal(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			FlexMergeInternal(block);
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Resizing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) FlexError("failed resizing null block");
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("failed resizing inextensible block");
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = FlexAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			return;
		}
		if (block-->BLK_NEXT ~= NULL) {
			FlexFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Size
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ FlexTotalSize txb size_in_bytes; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return FlexSize(txb) - BLK_DATA_OFFSET;
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		size_in_bytes = size_in_bytes + FlexSize(txb) - BLK_DATA_MULTI_OFFSET;
	}
	return size_in_bytes;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Debugging Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ FlexDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print FlexSize(txb);
		pf = true;
	}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Overview
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RC_INFINITY = MAX_POSITIVE_NUMBER;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_BVBITMAP           = $ff;

Constant BLK_BVBITMAP_LONGBLOCK = $10; ! Word 1 of SB is pointer to LB
Constant BLK_BVBITMAP_TEXT      = $20; ! BV holds a TEXT_TY value
Constant BLK_BVBITMAP_CONSTANT  = $40; ! BV holds a TEXT_TY value

#IFTRUE WORDSIZE == 4;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ffffff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ffffff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ffffff40;
#IFNOT;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ff40;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetLongBlock bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv + WORDSIZE;
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_LONGBLOCK) return bv-->1;
			return 0;
		}
		return o;
	}
	return bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Weak Kind
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueWeakKind bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv-->(BLK_HEADER_KOV+1);
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_TEXT) return TEXT_TY;
			o = bv-->1;
		}
		return o-->BLK_HEADER_KOV;
	}
	return NIL_TY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Reference counting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetRefCountPrimitive bv long_block;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) return long_block-->BLK_HEADER_RCOUNT;
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Changing Reference Counts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueIncRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) long_block-->BLK_HEADER_RCOUNT = refc + 1;
	}
];

[ BlkValueDecRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) {
			refc--;
			if (refc < 0) BlkValueError("reference count negative");
			long_block-->BLK_HEADER_RCOUNT = refc;
		}
		return refc;
	}
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Capacity
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueLBCapacity bv  long_block array_size_in_bytes entry_size_in_bytes flags;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) return 0;

	array_size_in_bytes = FlexTotalSize(long_block);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	return array_size_in_bytes / entry_size_in_bytes;
];

[ BlkValueSetLBCapacity bv new_capacity  long_block flags entry_size_in_bytes;
	if (bv == 0) rfalse;
	BlkMakeMutable(bv);
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) rfalse;

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	FlexResize(long_block, new_capacity*entry_size_in_bytes);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Array Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRead from pos do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (from == 0) rfalse;
	if (do_not_indirect)
		long_block = from;
	else
		long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: return long_block->0;
				2:	#Iftrue (WORDSIZE == 2); return long_block-->0;
					#ifnot; return (long_block->0)*256 + (long_block->1);
					#endif;
				4: return long_block-->0;
			}
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueRead: reading from index out of range: ", pos, " in ", from, " ***";
];

[ BlkValueWrite to pos val do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (to == 0) rfalse;
	if (do_not_indirect)
		long_block = to;
	else {
		BlkMakeMutable(to);
		long_block = BlkValueGetLongBlock(to);
	}

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (:long_block~=NULL:long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: long_block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); long_block-->0 = val;
					#ifnot; long_block->0 = (val/256)%256; long_block->1 = val%256;
					#endif;
				4: long_block-->0 = val;
			}
			return;
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueWrite: writing to index out of range: ", pos, " in ", to, " ***";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: First Zero Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSeekZeroEntry from
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes
	byte_position addr from_addr to_addr;
	if (from == 0) return -1;
	long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	byte_position = 0;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		from_addr = long_block + header_size_in_bytes;
		to_addr = from_addr + chunk_size_in_bytes;
		switch(entry_size_in_bytes) {
			1:
				for (addr = from_addr: addr < to_addr: addr++)
					if (addr->0 == 0)
						return byte_position + addr - from_addr;
			2:
				#iftrue (WORDSIZE == 2);
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/2;
				#ifnot;
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if ((addr->0 == 0) && (addr->1 == 0))
						return (byte_position + addr - from_addr)/2;
				#endif;
			4:
				for (addr = from_addr: addr < to_addr: addr=addr+4)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/4;
		}
		byte_position = byte_position + chunk_size_in_bytes;
	}
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy Entries
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy
	from_long_block from_addr from_bytes_left from_header_size_in_bytes
	to_long_block to_addr to_bytes_left to_header_size_in_bytes
	bytes_to_copy flags entry_size_in_bytes min;

	BlkMakeMutable(to_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = from_long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else from_header_size_in_bytes = BLK_DATA_OFFSET;
	flags = to_long_block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE) to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else to_header_size_in_bytes = BLK_DATA_OFFSET;

	from_addr = from_long_block + from_header_size_in_bytes;
	from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
	to_addr = to_long_block + to_header_size_in_bytes;
	to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;

	bytes_to_copy = entry_size_in_bytes*no_entries_to_copy;
	while (true) {
		if (from_bytes_left == 0) {
			from_long_block = from_long_block-->BLK_NEXT;
			if (from_long_block == 0) BlkValueError("copy destination exhausted");
			from_addr = from_long_block + from_header_size_in_bytes;
			from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
		} else if (to_bytes_left == 0) {
			to_long_block = to_long_block-->BLK_NEXT;
			if (to_long_block == 0) BlkValueError("copy source exhausted");
			to_addr = to_long_block + to_header_size_in_bytes;
			to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;
		} else {
			min = from_bytes_left; if (to_bytes_left < min) min = to_bytes_left;
			if (bytes_to_copy <= min) {
				Memcpy(to_addr, from_addr, bytes_to_copy);
				return;
			}
			Memcpy(to_addr, from_addr, min);
			bytes_to_copy = bytes_to_copy - min;
			from_addr = from_addr + min;
			from_bytes_left = from_bytes_left - min;
			to_addr = to_addr + min;
			to_bytes_left = to_bytes_left - min;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy From Array
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy
	to_long_block to_addr to_entries_left to_header_size to_entry_size
	flags;

	BlkMakeMutable(to_bv);

	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = to_long_block->BLK_HEADER_FLAGS;
	to_entry_size = 1;
	if (flags & BLK_FLAG_16_BIT) to_entry_size = 2;
	else if (flags & BLK_FLAG_WORD) to_entry_size = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) to_header_size = BLK_DATA_MULTI_OFFSET;
	else to_header_size = BLK_DATA_OFFSET;

	to_addr = to_long_block + to_header_size;
	to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;

	while (no_entries_to_copy > to_entries_left) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
		no_entries_to_copy = no_entries_to_copy - to_entries_left;
		from_array = from_array + to_entries_left*from_entry_size;
		to_long_block = to_long_block-->BLK_NEXT;
		if (to_long_block == 0) BlkValueError("copy source exhausted");
		to_addr = to_long_block + to_header_size;
		to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;
	}
	if (no_entries_to_copy > 0) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: KOVS Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CREATE_KOVS      = 1;
Constant CAST_KOVS        = 2;
Constant DESTROY_KOVS     = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS    = 5;
Constant EXTENT_KOVS      = 6;
Constant COPYQUICK_KOVS   = 7;
Constant COPYSB_KOVS      = 8;
Constant KINDDATA_KOVS    = 9;
Constant COPY_KOVS        = 10;
Constant COMPARE_KOVS     = 11;
Constant READ_FILE_KOVS   = 12;
Constant WRITE_FILE_KOVS  = 13;
Constant HASH_KOVS        = 14;
Constant DEBUG_KOVS       = 15;

! Constant BLKVALUE_TRACE; ! Uncomment this to expose masses of tracery


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreate strong_kind short_block  kovs;

	kovs = KOVSupportFunction(strong_kind, "impossible allocation");
	short_block = kovs(CREATE_KOVS, strong_kind, short_block);

	#ifdef BLKVALUE_TRACE; print "Created: ", (BlkValueDebug) short_block, "^"; #endif;

	! The new value is represented in I6 as the pointer to its short block:
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueError reason;
	print "*** Value handling failed: ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreateSB1 short_block val;
	if (short_block == 0)
		short_block = FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val;
	return short_block;
];

[ BlkValueCreateSB2 short_block val1 val2;
	if (short_block == 0)
		short_block = FlexAllocate(2*WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val1; short_block-->1 = val2;
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Block Values On Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ StackFramingInitialise;
	I7SFRAME = blockv_stack + WORDSIZE*BLOCKV_STACK_SIZE;
];

[ StackFrameCreate size new;
	new = I7SFRAME - WORDSIZE*size;
	if (new < blockv_stack) { RunTimeProblem(RTP_HEAPERROR); @quit; }
	I7SFRAME = new;
];

[ BlkValueCreateOnStack offset strong_kind;
	BlkValueCreate(strong_kind, I7SFRAME + WORDSIZE*offset);
];

[ BlkValueFreeOnStack offset;
    BlkValueFree(I7SFRAME + WORDSIZE*offset);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Freeing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueFree bv kovs d;
	if (bv == 0) return;

	! Dispose of any data in the long block
	kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation");
	BlkValueDestroyPrimitive(bv, kovs);

	! Free any heap memory occupied by the short block
	d = bv - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16))
		FlexFree(bv - BLK_DATA_OFFSET);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Quick Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
	BlkValueDestroyPrimitive(to_bv, kovs);
	kovs(COPYSB_KOVS, to_bv, from_bv);
	BlkValueIncRefCountPrimitive(from_bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopySB1 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	if (to_bv-->0 == 0) to_bv-->0 = from_bv + WORDSIZE;
];

[ BlkValueCopySB2 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	to_bv-->1 = from_bv-->1;
	if (to_bv-->1 == 0) to_bv-->1 = from_bv + 2*WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Slow Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling
	k from_long_block no_entries_to_copy;
	k = kovs(KINDDATA_KOVS, to_bv, from_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	if (from_long_block) {
		if (recycling) BlkValueRecyclePrimitive(to_bv, kovs);
		no_entries_to_copy = kovs(EXTENT_KOVS, from_bv);
		if (no_entries_to_copy == -1) no_entries_to_copy = BlkValueLBCapacity(from_bv);
		BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
!print "So to: "; BlkValueDebug(to_bv); print "^";

	}

	kovs(COPY_KOVS, to_bv, from_bv, k);
!print "Whence to: "; BlkValueDebug(to_bv); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopy to_bv from_bv  to_kind from_kind kovs;
	if (to_bv == 0) BlkValueError("copy to null value");
	if (from_bv == 0) BlkValueError("copy from null value");
	if (to_bv == from_bv) return;

	#ifdef BLKVALUE_TRACE;
	print "Copy: ", (BlkValueDebug) to_bv, " to equal ", (BlkValueDebug) from_bv, "^";
	#endif;

	to_kind = BlkValueWeakKind(to_bv);
	from_kind = BlkValueWeakKind(from_bv);
	if (to_kind ~= from_kind) BlkValueError("copy incompatible kinds");

	kovs = KOVSupportFunction(to_kind, "impossible copy");
	
	if (kovs(COPYQUICK_KOVS, to_bv, from_bv))
		BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
	else
		BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, true);

	return to_bv;
];

[ BlkValueCopyAZ to_bv from_bv;
	if (from_bv) return BlkValueCopy(to_bv, from_bv);
	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDestroyPrimitive bv kovs long_block;
	#ifdef BLKVALUE_TRACE; print "Destroying ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) FlexFree(long_block);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Recycling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRecyclePrimitive bv kovs;
	#ifdef BLKVALUE_TRACE; print "Recycling ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		BlkValueIncRefCountPrimitive(bv);
	} else {
		BlkValueCreate(BlkValueWeakKind(bv), bv);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkMakeMutable bv block bv_kind kovs sb_size;
	if (bv == 0) BlkValueError("tried to make null block mutable");

	if (BlkValueGetRefCountPrimitive(bv) > 1) {
		#ifdef BLKVALUE_TRACE; print "Make mutable: ", (BlkValueDebug) bv, "^"; #endif;

		BlkValueDecRefCountPrimitive(bv);

		bv_kind = BlkValueWeakKind(bv);
		kovs = KOVSupportFunction(bv_kind, "impossible mutability");

		sb_size = kovs(MAKEMUTABLE_KOVS, bv);
		if (sb_size > 0) {
			@push I7SFRAME;
			StackFrameCreate(sb_size);
			BlkValueCreateOnStack(0, bv_kind);
			kovs(COPYKIND_KOVS, I7SFRAME, bv);
			BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, false);
			kovs(COPYSB_KOVS, bv, I7SFRAME);
			@pull I7SFRAME;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCast to_bv original_kind original_value  kovs;
	kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast");
	kovs(CAST_KOVS, to_bv, original_kind, original_value);
	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCompare bv_left bv_right  kind_left kind_right kovs;
	if ((bv_left == 0) && (bv_right == 0)) return 0;
	if (bv_left == 0) return 1;
	if (bv_right == 0) return -1;

	kind_left = BlkValueWeakKind(bv_left);
	kind_right = BlkValueWeakKind(bv_right);
	if (kind_left ~= kind_right) return kind_left - kind_right;

	kovs = KOVSupportFunction(kind_left, "impossible comparison");
	return kovs(COMPARE_KOVS, bv_left, bv_right);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetHashValue kind value;
	if (KOVIsBlockValue(kind)) return BlkValueHash(value);
	return value;
];

[ BlkValueHash bv  bv_kind kovs;
	if (bv == 0) return 0;
	bv_kind = BlkValueWeakKind(bv);
	kovs = KOVSupportFunction(bv_kind, "impossible hashing");
	return kovs(HASH_KOVS, bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueReadFromFile bv auxf ch bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(READ_FILE_KOVS, bv, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile bv bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(WRITE_FILE_KOVS, bv);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDebug bv flag refc long_block kovs;
	print "(BV";
	if (bv) {
		BlkDebugAddress(bv, flag);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) {
			if (bv-->0 == 0) print "..."; else print "-->";
			print "L"; BlkDebugAddress(long_block, flag);
			print " 2**", long_block->BLK_HEADER_N;
			refc = BlkValueGetRefCountPrimitive(bv);
			if (refc == RC_INFINITY) print " resident";
			else { print " ", refc, " ref"; if (refc ~= 1) print "s"; }
		}
		kovs = KOVSupportFunction(BlkValueWeakKind(bv));
		if (kovs) kovs(DEBUG_KOVS, bv);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Printing Memory Addresses
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkDebugAddress addr flag d;
	if (flag) { print "###"; return; }

	d = addr - blockv_stack;
	if ((d >= 0) && (d <= WORDSIZE*BLOCKV_STACK_SIZE)) {
		print "s+", (BlkPrintHexadecimal) d;
		d = addr - I7SFRAME;
		print "=f"; if (d >= 0) print "+"; print d;
		return;
	}
	
	d = addr - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16)) {
		print "h+", (BlkPrintHexadecimal) d;
		return;
	}

	print (BlkPrintHexadecimal) addr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hexadecimal Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkPrintHexadecimal v;
	#iftrue WORDSIZE == 4;
	if (v & $ffff0000) {
		if (v & $ff000000) {
			BlkPrintHexDigit(v / $10000000);
			BlkPrintHexDigit(v / $1000000);
		}
		BlkPrintHexDigit(v / $100000);
		BlkPrintHexDigit(v / $10000);
	}
	#endif;
	BlkPrintHexDigit(v / $1000);
	BlkPrintHexDigit(v / $100);
	BlkPrintHexDigit(v / $10);
	BlkPrintHexDigit(v);
];

[ BlkPrintHexDigit v;
	v = v & $F;
	if (v < 10) print v; else print (char) 'A' + v - 10;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CONSTANT_PACKED_TEXT_STORAGE     = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 2;
Constant PACKED_TEXT_STORAGE              = BLK_BVBITMAP_TEXT + 3;
Constant UNPACKED_TEXT_STORAGE            = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK + 4;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Extent Of Long Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Extent arg1 x;
	x = BlkValueSeekZeroEntry(arg1);
	if (x < 0) return -1; ! should not happen, of course
	return x+1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Source
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: ZSCII Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Small Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Large Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char Is Of Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char To Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Reversing Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Testing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return TEXT_TY_Create(arg2);
		CAST_KOVS:        TEXT_TY_Cast(arg1, arg2, arg3);
		MAKEMUTABLE_KOVS: return TEXT_TY_Mutable(arg1);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  TEXT_TY_CopySB(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return TEXT_TY_Extent(arg1);
		COMPARE_KOVS:     return TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:   if (arg3 == -1) rtrue;
			              return TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS:  return TEXT_TY_WriteFile(arg1);
		HASH_KOVS:        return TEXT_TY_Hash(arg1);
		DEBUG_KOVS:       TEXT_TY_Debug(arg1);
	}
	! We choose not to respond to: DESTROY_KOVS, COPYKIND_KOVS, COPY_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Debug txt;
	switch (txt-->0) {
		CONSTANT_PACKED_TEXT_STORAGE:     print " = cp~", (PrintI6Text) txt-->1, "~";
		CONSTANT_PERISHABLE_TEXT_STORAGE: print " = cp~", (PrintI6Text) txt-->1, "~";
		PACKED_TEXT_STORAGE:              print " = p~", (PrintI6Text) txt-->1, "~";
		UNPACKED_TEXT_STORAGE:            print " = ~", (TEXT_TY_Say) txt, "~";
		default:                          print " broken?";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Create short_block x;
	return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Copy Short Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CopySB to_bv from_bv;
	BlkValueCopySB2(to_bv, from_bv);
	if (to_bv-->0 & BLK_BVBITMAP_CONSTANTMASK) to_bv-->0 = PACKED_TEXT_STORAGE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Transmutation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Transmute txt;
	TEXT_TY_Temporarily_Transmute(txt);
];

[ TEXT_TY_Temporarily_Transmute txt  x;
	if ((txt) && (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0)) {
		x = txt-->1; ! The old value was a packed string
		
		txt-->0 = UNPACKED_TEXT_STORAGE;
		txt-->1 = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags);
		if (x ~= EMPTY_TEXT_PACKED) TEXT_TY_CastPrimitive(txt, false, x);
		
		return x;
	}
	return 0;
];

[ TEXT_TY_Untransmute txt pk cp x;
	if ((pk) && (txt-->0 == UNPACKED_TEXT_STORAGE)) {
		x = txt-->1; ! The old value was an unpacked string
		FlexFree(x);
		txt-->0 = cp;
		txt-->1 = pk; ! The value earlier returned by TEXT_TY_Temporarily_Transmute
	}
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Mutable txt;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		TEXT_TY_Transmute(txt);
		return 0;
	}
	return 2; ! Tell BlockValue there's a long block pointer
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Cast to_txt from_kind from_value;
	if (from_kind == TEXT_TY) {
		BlkValueCopy(to_txt, from_value);
	} else if (from_kind == SNIPPET_TY) {
		TEXT_TY_Transmute(to_txt);
		TEXT_TY_CastPrimitive(to_txt, true, from_value);
	} else BlkValueError("impossible cast to text");
];

[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
	return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Data Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef TEXT_TY_BufferSize;
Constant TEXT_TY_BufferSize = 512;
#endif;
Constant TEXT_TY_NoBuffers = 2;

#ifdef TARGET_ZCODE;
Array TEXT_TY_Buffers -> TEXT_TY_BufferSize*TEXT_TY_NoBuffers; ! Where characters are bytes
#ifnot;
Array TEXT_TY_Buffers --> (TEXT_TY_BufferSize+2)*TEXT_TY_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;

Global TEXT_TY_CastPrimitiveNesting = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Z Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value  len news buffer;
	if (to_txt == 0) BlkValueError("no destination for cast");
	SuspendRTP();
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*TEXT_TY_BufferSize;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)
		FlexError("ran out with too many simultaneous text conversions");

	@push say__p; @push say__pc;
	ClearParagraphing(6);
	@output_stream 3 buffer;
	if (from_value) {
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
	}
	@output_stream -3;
	@pull say__pc; @pull say__p;
	ResumeRTP();

	len = buffer-->0;
	if (len > RawBufferSize-1) len = RawBufferSize-1;
	buffer->(len+2) = 0;

	TEXT_TY_CastPrimitiveNesting--;
	BlkValueMassCopyFromArray(to_txt, buffer+2, 1, len+1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Glulx Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifnot; ! TARGET_ZCODE
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value
	len i stream saved_stream news buffer buffer_size memory_to_free results;

	if (to_txt == 0) BlkValueError("no destination for cast");

	buffer_size = (TEXT_TY_BufferSize + 2)*WORDSIZE;
	
	RawBufferSize = TEXT_TY_BufferSize;
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*buffer_size;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers) {
		buffer = VM_AllocateMemory(buffer_size); memory_to_free = buffer;
		if (buffer == 0)
			FlexError("ran out with too many simultaneous text conversions");
	}

	if (unicode_gestalt_ok) {
		SuspendRTP();
		.RetryWithLargerBuffer;
		saved_stream = glk_stream_get_current();
		stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(stream);

		@push say__p; @push say__pc;
		ClearParagraphing(7);
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
		@pull say__pc; @pull say__p;

		results = buffer + buffer_size - 2*WORDSIZE;
		glk_stream_close(stream, results);
		if (saved_stream) glk_stream_set_current(saved_stream);
		ResumeRTP();

		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			i = VM_AllocateMemory(news*WORDSIZE);
			if (i ~= 0) {
				if (memory_to_free) VM_FreeMemory(memory_to_free);
				memory_to_free = i;
				buffer = i;
				RawBufferSize = news;
				buffer_size = (RawBufferSize + 2)*WORDSIZE;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		buffer-->(len) = 0;

		TEXT_TY_CastPrimitiveNesting--;
		BlkValueMassCopyFromArray(to_txt, buffer, 4, len+1);
	} else {
		RunTimeProblem(RTP_NOGLULXUNICODE);
	}
	if (memory_to_free) VM_FreeMemory(memory_to_free);
];
#endif; 


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Compare left_txt right_txt rv;
	@push say__comp;
	say__comp = true;
	rv = TEXT_TY_Compare_Inner(left_txt, right_txt);
	@pull say__comp;
	return rv;
];

[ TEXT_TY_Compare_Inner left_txt right_txt
	pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
	if (left_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fl = true;
	if (right_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fr = true;

	if (fl && fr) {
		if ((left_txt-->1 ofclass String) && (right_txt-->1 ofclass String))
			return left_txt-->1 - right_txt-->1;
		if ((left_txt-->1 ofclass Routine) && (right_txt-->1 ofclass Routine))
			return left_txt-->1 - right_txt-->1;
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);		
	} else if (fl) {
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
	} else if (fr) {
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);
	}
	if ((cl) || (cr)) {
		pos = TEXT_TY_Compare(left_txt, right_txt);
		TEXT_TY_Untransmute(left_txt, cl, cpl);
		TEXT_TY_Untransmute(right_txt, cr, cpr);
		return pos;
	}
	capacity_left = BlkValueLBCapacity(left_txt);
	capacity_right = BlkValueLBCapacity(right_txt);
	for (pos=0:(pos<capacity_left) && (pos<capacity_right):pos++) {
		ch1 = BlkValueRead(left_txt, pos);
		ch2 = BlkValueRead(right_txt, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == capacity_left) return -1;
	return 1;
];

[ TEXT_TY_Distinguish left_txt right_txt;
	if (TEXT_TY_Compare(left_txt, right_txt) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Hash txt  rv len i p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	rv = 0;
	len = BlkValueLBCapacity(txt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(txt, i);
	TEXT_TY_Untransmute(txt, p, cp);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say txt  ch i dsize;
	if (txt==0) rfalse;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) return PrintI6Text(txt-->1);
	dsize = BlkValueLBCapacity(txt);
	for (i=0: i<dsize: i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		@streamunichar ch;
		#endif;
	}
	if (i == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Capitalised printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say_Capitalised txt mod rc;
	mod = BlkValueCreate(TEXT_TY);
	TEXT_TY_SubstitutedForm(mod, txt);
	if (TEXT_TY_CharacterLength(mod) > 0) {
		BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
		TEXT_TY_Say(mod);
		rc = true;
		say__p = 1;
	}
	BlkValueFree(mod);
	return rc;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_WriteFile txt len pos ch p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = BlkValueLBCapacity(txt);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
	TEXT_TY_Untransmute(txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Unserialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
	TEXT_TY_Transmute(txt);
	tsize = BlkValueLBCapacity(txt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetLBCapacity(txt, 2*pos) == false) break;
				tsize = BlkValueLBCapacity(txt);
			}
			BlkValueWrite(txt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(txt, pos, 0);
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Substitution
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_SubstitutedForm to txt;
	if (txt) {
		BlkValueCopy(to, txt);
		TEXT_TY_Transmute(to);
	}
	return to;
];

[ TEXT_TY_IsSubstituted txt;
	if ((txt) &&
		(txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) &&
		(txt-->1 ofclass Routine)) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Perishability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ExpandIfPerishable to from;
	if ((from) && (from-->0 == CONSTANT_PERISHABLE_TEXT_STORAGE))
		return TEXT_TY_SubstitutedForm(to, from);
	return from;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Recognition-only-GPR
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ROGPR txt p cp r;
	if (txt == 0) return GPR_FAIL;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	r = TEXT_TY_ROGPRI(txt);
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];
[ TEXT_TY_ROGPRI txt
	pos len wa wl wpos bdm ch own;
	bdm = true; own = wn;
	len = BlkValueLBCapacity(txt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or TEXT_TY_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blobs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blob Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt
	p1 p2 cp1 cp2 r;
	if (txt==0) return 0;
	if (blobtype == CHR_BLOB) return TEXT_TY_CharacterLength(txt);
	cp1 = txt-->0; p1 = TEXT_TY_Temporarily_Transmute(txt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	TEXT_TY_Transmute(ctxt);
	r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt);
	TEXT_TY_Untransmute(txt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	dsize = BlkValueLBCapacity(txt);
	if (ctxt) csize = BlkValueLBCapacity(ctxt);
	else if (rtxt) "*** rtxt without ctxt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(txt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(txt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((ctxt) && (blobcount == wanted)) {
				if (rtxt) {
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			} else {
				if (rtxt) {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			}
		} else {
			if ((rtxt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
	}
	if (ctxt) BlkValueWrite(ctxt, cl++, 0);
	return blobcount;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
	if (txt==0) return;
	if (blobtype == CHR_BLOB) return TEXT_TY_GetCharacter(ctxt, txt, wanted);
	TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
	TEXT_TY_Transmute(txt);
	cp = rtxt-->0; p = TEXT_TY_Temporarily_Transmute(rtxt);
	if (blobtype == CHR_BLOB) {
		ilen = TEXT_TY_CharacterLength(txt);
		rlen = TEXT_TY_CharacterLength(rtxt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
			} else {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				if (BlkValueSetLBCapacity(ctxt, ilen+rlen+1)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(ctxt, wanted+i, BlkValueRead(rtxt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(ctxt, rlen+i-1, BlkValueRead(txt, i));
					BlkValueWrite(ctxt, rlen+ilen, 0);
					BlkValueCopy(txt, ctxt);
				}
				BlkValueFree(ctxt);
			}
		}
	} else {
		ctxt = BlkValueCreate(TEXT_TY);
		TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
		BlkValueCopy(txt, ctxt);
		BlkValueFree(ctxt);
	}
	TEXT_TY_Untransmute(rtxt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt
	r p1 p2 cp1 cp2;
	TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];

[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt
	ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
	
	ilen = TEXT_TY_CharacterLength(txt);
	flen = TEXT_TY_CharacterLength(ftxt);
	ctxt = BlkValueCreate(TEXT_TY);
	TEXT_TY_Transmute(ctxt);
	csize = BlkValueLBCapacity(ctxt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(txt, i);
		.MoreMatching;
		chm = BlkValueRead(ftxt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(txt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
			csize = BlkValueLBCapacity(ctxt);
		}
		BlkValueWrite(ctxt, cl++, ch);
	}
	BlkValueCopy(txt, ctxt);	
	BlkValueFree(ctxt);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	dsize = BlkValueLBCapacity(txt); r = dsize;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) { r = i; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Empty txt;
	if (txt==0) rtrue;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		if (txt-->1 == EMPTY_TEXT_PACKED) rtrue;
		rfalse;
	}
	if (TEXT_TY_CharacterLength(txt) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	if ((i<=0) || (i>TEXT_TY_CharacterLength(txt))) ch = 0;
	else ch = BlkValueRead(txt, i-1);
	BlkValueWrite(ctxt, 0, ch);
	BlkValueWrite(ctxt, 1, 0);
	TEXT_TY_Untransmute(txt, p, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = TEXT_TY_CharacterLength(txt);
	r = true;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) { r = false; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Change Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
	if (txt==0) return 0;
	cp = txt-->0; pk = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	len = TEXT_TY_CharacterLength(txt);
	if (BlkValueSetLBCapacity(ctxt, len+1)) {
		bnd = 1;
		for (i=0:i<len:i++) {
			ch = BlkValueRead(txt, i);
			if (case < 2) {
				BlkValueWrite(ctxt, i, CharToCase(ch, case));
			} else {
				BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
				if (case == 2) {
					bnd = 0;
					if (ch == 0 or 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
				}
				if (case == 3) {
					if (ch ~= 0 or 10 or 13 or 32 or 9) {
						if (bnd == 1) bnd = 0;
						else {
							if (ch == '.' or '!' or '?') bnd = 1;
						}
					}
				}
			}
		}
		BlkValueWrite(ctxt, len, 0);
	}
	TEXT_TY_Untransmute(txt, pk, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt
	p cp r;
	if (to_txt==0) rfalse;
	if (from_txt==0) return to_txt;
	TEXT_TY_Transmute(to_txt);
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt);
	TEXT_TY_Untransmute(from_txt, p, cp);
	return r;
];

[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt
	pos len ch i tosize x y case;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = TEXT_TY_CharacterLength(to_txt);
			len = TEXT_TY_CharacterLength(from_txt);
			if (BlkValueSetLBCapacity(to_txt, pos+len+1) == false) return to_txt;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(from_txt, i);
				BlkValueWrite(to_txt, i+pos, ch);
			}
			BlkValueWrite(to_txt, len+pos, 0);
			return to_txt;
		REGEXP_BLOB:
			return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
	}
	print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Setting the Player's Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetPlayersCommand from_txt i len at p cp;
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	len = TEXT_TY_CharacterLength(from_txt);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(from_txt, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable "player's command"
	TEXT_TY_Untransmute(from_txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ TEXT_TY_RE_SetTrace F; TEXT_TY_RE_Trace = F; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Algorithm
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Class Codes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Packets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Nodes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ TEXT_TY_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Match Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ TEXT_TY_RE_DebugMatchVars txt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(txt, i);
		print "^";
	}
];

[ TEXT_TY_RE_CreateMatchVars txt
	offset n i ch ctxt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n) BlkValueFree(Allocated_Match_Vars-->n);
		Allocated_Match_Vars-->n = BlkValueCreate(TEXT_TY);
		TEXT_TY_Transmute(Allocated_Match_Vars-->n);
		ctxt = Allocated_Match_Vars-->n;
		csize = BlkValueLBCapacity(ctxt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(txt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
				csize = BlkValueLBCapacity(ctxt);
			}
			BlkValueWrite(ctxt, cl++, ch);
		}
		BlkValueWrite(ctxt, cl, 0);
	}
];

[ TEXT_TY_RE_EmptyMatchVars txt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ TEXT_TY_RE_GetMatchVar vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) return EMPTY_TEXT_VALUE;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) return EMPTY_TEXT_VALUE;
	if (offset-->RE_DATA1 < 0) return EMPTY_TEXT_VALUE;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		return EMPTY_TEXT_VALUE;
	}
	return Allocated_Match_Vars-->vn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Markers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ TEXT_TY_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_DebugTree ftxt detail;
	print "Pattern: ", (TEXT_TY_Say) ftxt, "^";
	TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];

[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		TEXT_TY_RE_DebugNode(offset, ftxt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			TEXT_TY_RE_DebugSubtree(ftxt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ TEXT_TY_RE_DebugNode offset ftxt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Substring Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CHR_CompileTree ftxt exactly
	root literal fto no_packets token attach_to;

	fto = TEXT_TY_CharacterLength(ftxt);

	root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Regexp Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Subexp_Posns --> 20;
[ TEXT_TY_RE_CompileTree ftxt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = TEXT_TY_CharacterLength(ftxt);
	if (fto == 0) {
		TEXT_TY_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(ftxt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(ftxt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(ftxt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(ftxt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(ftxt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(ftxt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(ftxt, ffrom++)) {
							'#': while (BlkValueRead(ftxt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(ftxt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(ftxt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(ftxt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(ftxt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(ftxt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							TEXT_TY_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(ftxt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(ftxt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(ftxt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(ftxt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(ftxt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(ftxt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(ftxt, par1) == ':') &&
						(BlkValueRead(ftxt, par2-1) == ':') &&
						(BlkValueRead(ftxt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(ftxt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (TEXT_TY_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (TEXT_TY_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			TEXT_TY_RE_DebugNode(attach_to, ftxt);
			TEXT_TY_RE_DebugTree(ftxt);
		}

		token = TEXT_TY_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (TEXT_TY_RE_Trace == 2) {
			print "Result:^";
			TEXT_TY_RE_DebugTree(ftxt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (TEXT_TY_RE_Trace) {
		print "Compiled pattern:^";
		TEXT_TY_RE_DebugTree(ftxt);
	}
	
	bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
			if (chm > BlkValueRead(ftxt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ TEXT_TY_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = TEXT_TY_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!TEXT_TY_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = TEXT_TY_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = TEXT_TY_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ TEXT_TY_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = TEXT_TY_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = TEXT_TY_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ TEXT_TY_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = TEXT_TY_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= TEXT_TY_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = TEXT_TY_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = TEXT_TY_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = TEXT_TY_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_RewindCount;
[ TEXT_TY_RE_PrintNoRewinds; print TEXT_TY_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ TEXT_TY_RE_Parse ftxt txt ipos insens
	ilen rv root i initial_mode;

	ilen = TEXT_TY_CharacterLength(txt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) TEXT_TY_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		TEXT_TY_RE_RewindCount = 0;
		rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parse At Position
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (TEXT_TY_RE_Trace) {
			print "Matching at ", ipos, ": ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}

		if (ipos<ito) ch = BlkValueRead(txt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(txt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (TEXT_TY_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (TEXT_TY_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (TEXT_TY_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (TEXT_TY_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						TEXT_TY_RE_DebugNode(ch, ftxt, true);
					}
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (TEXT_TY_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							TEXT_TY_RE_DebugNode(ch, ftxt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							TEXT_TY_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (TEXT_TY_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) TEXT_TY_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (TEXT_TY_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (TEXT_TY_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if (TEXT_TY_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (TEXT_TY_RE_Range(ch, ftxt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
					ftxt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
						txt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (TEXT_TY_RE_RewindCount++ >= 10000) {
				if (TEXT_TY_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (TEXT_TY_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) TEXT_TY_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (TEXT_TY_RE_SeekBacktrack(token, ftxt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						TEXT_TY_RE_DebugTree(ftxt, true);
					if (TEXT_TY_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (TEXT_TY_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Backtracking
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((TEXT_TY_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((TEXT_TY_RE_Trace) && (report_only == false)) print "Descend^";
			if (TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((TEXT_TY_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (TEXT_TY_RE_Trace) {
				print "Grounds for rewind at: ";
				TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			TEXT_TY_RE_EraseConstraints(token-->RE_NEXT);
			TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Fail Subexpressions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Erasing Constraints
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Literal Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mtxt, i);
			if (BlkValueRead(txt, ipos++) ~= ch or TEXT_TY_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(txt, ipos++) ~= BlkValueRead(mtxt, i))
				return -1;
	return mto-mfrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Character Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Range ch ftxt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		} else {
			if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
				upper = BlkValueRead(ftxt, i+2);
				if ((ch >= chm) && (ch <= upper)) rtrue;
				if (insens) {
					crev = TEXT_TY_RevCase(ch);
					if ((crev >= chm) && (crev <= upper)) rtrue;
				}
				i=i+2;
			} else {
				if (chm == ch) rtrue;
				if ((insens) && (chm == TEXT_TY_RevCase(ch))) rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Search And Replace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly
	r p p1 p2 cp cp1 cp2;
	!print "Find: "; BlkValueDebug(ftxt); print "^";
	!print "Rep: "; BlkValueDebug(rtxt); print "^";
	!print "In: "; BlkValueDebug(txt); print "^";
	if (rtxt == 0 or 1) { cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt); }
	else TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	if (rtxt == 0 or 1) TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly
	ctxt csize ilen i cl mpos cpos ch chm;

	ilen = TEXT_TY_CharacterLength(txt);

	TEXT_TY_RE_Err = 0;
	switch (ftxtype) {
		REGEXP_BLOB: i = TEXT_TY_RE_CompileTree(ftxt, exactly);
		CHR_BLOB: i = TEXT_TY_CHR_CompileTree(ftxt, exactly);
		default: "*** bad ftxtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		TEXT_TY_RE_Err = i;
		print "*** Regular expression error: ", (string) TEXT_TY_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (TEXT_TY_RE_Trace) {
		TEXT_TY_RE_DebugTree(ftxt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (ftxtype == REGEXP_BLOB) TEXT_TY_RE_EmptyMatchVars();
	mpos = 0; chm = 0; cpos = 0;
	while (TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0) {
		chm++;
		
		if (TEXT_TY_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(txt, i);
			}
			print " ***^";
		}
		
		if (rtxt == 0) break; ! Accept only one match, replace nothing
		
		if (rtxt ~= 0 or 1) {
			if (chm == 1) {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				csize = BlkValueLBCapacity(ctxt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
			BlkValueWrite(ctxt, cl, 0);
	
			TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
			csize = BlkValueLBCapacity(ctxt);
			cl = TEXT_TY_CharacterLength(ctxt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (TEXT_TY_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rtxt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
		
		if (ftxtype == REGEXP_BLOB) {
			TEXT_TY_RE_CreateMatchVars(txt);
			if (TEXT_TY_RE_Trace)
				TEXT_TY_RE_DebugMatchVars(txt);
		}

		if (rtxt ~= 0 or 1) {
			BlkValueWrite(ctxt, cl, 0);
			BlkValueCopy(txt, ctxt);	
			BlkValueFree(ctxt);
		}
	}
	return chm;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref
	pos len ch i tosize x y case;
	if ((txt_to==0) || (BlkValueWeakKind(txt_to) ~= TEXT_TY)) rfalse;
	if ((txt_from==0) || (BlkValueWeakKind(txt_from) ~= TEXT_TY)) return txt_to;
	pos = TEXT_TY_CharacterLength(txt_to);
	tosize = BlkValueLBCapacity(txt_to);
	len = TEXT_TY_CharacterLength(txt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(txt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(txt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(txt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
								tosize = BlkValueLBCapacity(txt_to);
							}
							if (case >= 0)
								BlkValueWrite(txt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(txt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
			tosize = BlkValueLBCapacity(txt_to);
		}
		BlkValueWrite(txt_to, pos++, ch);
	}
	BlkValueWrite(txt_to, pos, 0);
	return txt_to;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return STORED_ACTION_TY_Create(arg2);
		DESTROY_KOVS:     STORED_ACTION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return 6;
		COPY_KOVS:        STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return STORED_ACTION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return STORED_ACTION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (STORED_ACTION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Create sb stora;
	stora = FlexAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, STORA_ACTION_F, ##Wait, true); ! action
	BlkValueWrite(stora, STORA_NOUN_F, 0, true); ! noun
	BlkValueWrite(stora, STORA_SECOND_F, 0, true); ! second
	BlkValueWrite(stora, STORA_ACTOR_F, player, true); ! actor
	BlkValueWrite(stora, STORA_REQUEST_F, false, true); ! whether a request
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, true); ! text of command if necessary, 0 if not
	return BlkValueCreateSB1(sb, stora);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Setting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = BlkValueCreate(STORED_ACTION_TY);
	BlkValueWrite(stora, STORA_ACTION_F, a);
	BlkValueWrite(stora, STORA_NOUN_F, n);
	BlkValueWrite(stora, STORA_SECOND_F, s);
	BlkValueWrite(stora, STORA_ACTOR_F, ac);
	BlkValueWrite(stora, STORA_REQUEST_F, req);
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (toc) BlkValueFree(toc);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F);
	if (tocfrom == 0) return;
	tocto = BlkValueCreate(TEXT_TY);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F);
	itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F);
	if ((itleft ~= 0) && (itright ~= 0))
		return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, STORA_ACTION_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_NOUN_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_SECOND_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_ACTOR_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_REQUEST_F);
	it = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (it ~= 0)
		rv = rv * 33 + TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, STORA_ACTION_F);
	cf = consult_from; cw = consult_words;
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
			consult_from = parsed_number/100; consult_words = parsed_number%100;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
			consult_from = parsed_number/100; consult_words = parsed_number%100;
		}
	}	
	DB_Action(
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F), true);
	parsed_number = saved_pn; action = saved_action;
	consult_from = cf; consult_words = cw;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Involvement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_NOUN_F) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_SECOND_F) == item)) rtrue;
	}
	if (BlkValueRead(stora, STORA_ACTOR_F) == item) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Nouns
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == STORA_NOUN_F or STORA_SECOND_F) {
		if (ind == STORA_NOUN_F) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Pattern Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, STORA_ACTION_F);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		noun = BlkValueRead(stora, STORA_NOUN_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		noun = nothing;
	}
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		second = BlkValueRead(stora, STORA_SECOND_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		second = nothing;
	}
	actor = BlkValueRead(stora, STORA_ACTOR_F);
	if (BlkValueRead(stora, STORA_REQUEST_F)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Current Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, STORA_ACTION_F, action);
	at = FindAction(-1);

	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_NOUN_F, noun);
	else
		BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_SECOND_F, second);
	else
		BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
	BlkValueWrite(stora, STORA_ACTOR_F, actor);
	if (act_requester) BlkValueWrite(stora, STORA_REQUEST_F, true);
	else BlkValueWrite(stora, STORA_REQUEST_F, false);

	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
		if (text_of_command == 0) {
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
		}
		BlkValueCast(text_of_command, SNIPPET_TY, players_command);
	} else BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);

	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Trying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant LIST_ITEM_KOV_F = 0; ! The kind of the items
Constant LIST_LENGTH_F = 1;   ! The number of items
Constant LIST_ITEM_BASE = 2;  ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return LIST_OF_TY_Create(arg1, arg2);
		DESTROY_KOVS:     LIST_OF_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return LIST_OF_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   return LIST_OF_TY_QuickCopy(arg1, arg2);
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return LIST_OF_TY_KindData(arg1, arg2);
		EXTENT_KOVS:      return BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE;
		COPY_KOVS:        LIST_OF_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return LIST_OF_TY_Compare(arg1, arg2);
		HASH_KOVS:        return LIST_OF_TY_Hash(arg1);
		DEBUG_KOVS:       print " = {", (LIST_OF_TY_Say) arg1, "} of kind ",
                              BlkValueRead(arg1, LIST_ITEM_KOV_F);
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Create skov sb list;
	skov = KindBaseTerm(skov, 0);
	list = FlexAllocate(27*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov, true);
	BlkValueWrite(list, LIST_LENGTH_F, 0, true);
	sb = BlkValueCreateSB1(sb, list);
	return sb;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Destroy list no_items i k;
	k = BlkValueRead(list, LIST_ITEM_KOV_F);
	if (KOVIsBlockValue(k)) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0: i<no_items: i++) BlkValueFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_CopyKind to from;
	BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_QuickCopy to from;
	if (BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))
		rfalse;
	rtrue;
];

[ LIST_OF_TY_KindData list;
	return BlkValueRead(list, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom  precopied_list_kov no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or UNKNOWN_TY)
		BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if (KOVIsBlockValue(bk)) {
		for (i=0: i<no_items: i++) {
			val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
			if (precopied_list_kov ~= 0 or UNKNOWN_TY)
				nv = BlkValueCreate(precopied_list_kov);
			else
				nv = BlkValueCreate(bk);
			BlkValueCopy(nv, val);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	if (no_items == 0) return 0;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0: i<no_items: i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + GetHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print no_items, " of kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				LIST_WRITER_INTERNAL_RM('C');
			}
		}
	}
	if (format == 1) print "}";
	prior_named_list = no_items; prior_named_list_gender = -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: List From Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueLBCapacity(list);
	len = desc(-3);
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Find Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0: i<no_items: i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Insert Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueLBCapacity(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetLBCapacity(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(contents_kind)) {
		nv = BlkValueCreate(contents_kind);
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Append List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkValueWeakKind(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueLBCapacity(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	for (i=0: i<no_items: i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkValueFree(delendum);
			for (j=i+1: j<no_items: j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Item Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0: i<d: i++)
			BlkValueFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkValueFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Set Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueLBCapacity(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetLBCapacity(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Write Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Put Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Reversing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0:i*2<no_items:i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Rotation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Sorting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) LIST_OF_TY_Sort_cf = BlkValueCompare;
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0) {
		if (i > j) return 1;
		if (i < j) return -1;
		return 0;
	} else
		return cf(i, j);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant COMBINATION_KIND_F = 0;    ! Strong kind ID
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return COMBINATION_TY_Create(arg1, arg2);
		DESTROY_KOVS:     COMBINATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return COMBINATION_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return COMBINATION_TY_KindData(arg1);
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        COMBINATION_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return COMBINATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return COMBINATION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (COMBINATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Create kind sb long_block N i bk v;
	N = KindBaseArity(kind);
	long_block = FlexAllocate(
		(COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(long_block, COMBINATION_KIND_F, kind, true);
	for (i=0: i<N: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk);
		else v = DefaultValueOfKOV(bk);
		BlkValueWrite(long_block, COMBINATION_ITEM_BASE+i, v, true);
	}
	return BlkValueCreateSB1(sb, long_block);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkValueFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_CopyKind to from;
	BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];

[ COMBINATION_TY_CopySB to from;
	BlkValueCopySB1(to, from);
];

[ COMBINATION_TY_KindData comb;
	return BlkValueRead(comb, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov  no_items i nv kind bk;
	! kind = BlkValueRead(to_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(precopied_comb_kov);
	BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(from_comb, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(to_comb, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
	kind = BlkValueRead(left_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE),
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish left_comb right_comb;
	if (COMBINATION_TY_Compare(left_comb, right_comb) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + GetHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkValueWeakKind(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0: i<no_items: i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRV_NAME     		RR_NAME-5;        ! Packed string, e.g. "containment relation"
Constant RRV_PERMISSIONS	RR_PERMISSIONS-5; ! A bitmap of what operations this supports
Constant RRV_STORAGE		RR_STORAGE-5;     ! Data location, depending on format
Constant RRV_KIND			RR_KIND-5;        ! Strong kind ID of the relation
Constant RRV_HANDLER		RR_HANDLER-5;     ! Routine to perform operations on this
Constant RRV_DESCRIPTION	RR_DESCRIPTION-5; ! Packed string, e.g. "contains"
Constant RRV_USED			6;
Constant RRV_FILLED			7;
Constant RRV_DATA_BASE		8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return RELATION_TY_Create(arg1, 0, arg2);
		DESTROY_KOVS:     RELATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return RELATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return arg1;
		DEBUG_KOVS:       print " = ", (RELATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Other Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED		$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE		$0004;	! entry's Y is a value, not a list
Constant RRF_HASX		$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY		$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
!Constant RELS_LOOKUP_ANY $0008;
!Constant RELS_LOOKUP_ALL_X $0004;
!Constant RELS_LOOKUP_ALL_Y $0002;
!Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Tunable Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Abstract Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RelationTest relation task X Y  handler rv;
	handler = RlnGetF(relation, RR_HANDLER);
	return handler(relation, task, X, Y);
];

[ RlnGetF rel fld i;
	rel = BlkValueGetLongBlock(rel);
	return rel-->fld;
];

[ RlnSetF rel fld v;
	rel = BlkValueGetLongBlock(rel);
	rel-->fld = v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Create kov from sb rel i skov handler;
	rel = FlexAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i), true);
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, true));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
			BlkValueWrite(rel, RRV_HANDLER, handler, true);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
			BlkValueWrite(rel, RRV_USED, 0, true);
			BlkValueWrite(rel, RRV_FILLED, 0, true);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
		BlkValueWrite(rel, RRV_KIND, kov, true);
		BlkValueWrite(rel, RRV_HANDLER, handler, true);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
		BlkValueWrite(rel, RRV_USED, 0, true);
		BlkValueWrite(rel, RRV_FILLED, 0, true);
	}

	return BlkValueCreateSB1(sb, rel);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2) return ind1 - ind2;
	if (IsMutableRelationHandler(ind1) == false) return 0;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) RlnGetF(rel, RR_NAME);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Naming
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Choose Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];

[ IsMutableRelationHandler h;
	if (h == SymHashListRelationHandler or HashListRelationHandler or
		SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Valency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:			RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Double Hash Set Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				
				Y = BlkValueCreate(kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = GetHashValue(kx, x) + GetHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash List Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Reversed Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReversedHashTableRelationHandler rel task X Y  kov kx ky swap;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
			swap=X; X=Y; Y=swap;
			swap=kx; kx=ky; ky=swap;
 		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Symmetric Relation Handlers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Core Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = BlkValueCreate(LIST_OF_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkValueFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkValueFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Equivalence Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Two-In-One Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (4*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1, true);
			X = BlkValueRead(temp, 4*i + 2, true);
			Y = BlkValueRead(temp, 4*i + 3, true);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Empty rel set  handler;
	handler = RlnGetF(rel, RR_HANDLER);
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1 3 4 5 6 7 8 9 10 11 12 13 14  0;

Array ResourceIDsOfSounds --> 0 15 16 17  0;



Array BC_0 --> PACKED_TEXT_STORAGE TX_PS_2;
Array BC_1 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_2 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_3 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_4 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_5 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_6 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_7 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_8 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_9 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_10 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_11 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_12 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_13 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_14 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_15 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_16 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_17 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_18 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_19 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_20 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_21 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_22 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_23 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_24 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_25 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_26 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_27 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_28 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_29 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_30 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_31 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_32 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_33 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_34 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_35 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_36 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_37 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_38 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_39 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_40 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_41 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_42 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_43 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_44 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_45 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_46 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_47 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_48 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_49 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_50 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_51 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_52 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_53 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_54 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_55 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_56 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_57 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_58 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_59 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_60 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_61 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_62 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_63 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_64 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_65 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_66 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_67 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_68 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_69 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_70 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_71 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_72 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_73 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_74 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_75 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_76 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_77 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_78 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_79 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_80 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_81 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_82 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_83 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_84 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_85 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_86 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_87 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_88 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_89 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_90 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_91 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_92 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_93 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_94 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_95 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_96 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_97 --> PACKED_TEXT_STORAGE TX_PS_15;
Array BC_98 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_99 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_102 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_103 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_104 --> PACKED_TEXT_STORAGE TX_PS_16;
Array BC_105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_106 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_107 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_108 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_110 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_111 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_116 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_117 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_118 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_119 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_120 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_124 --> PACKED_TEXT_STORAGE TX_PS_19;
Array BC_125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_126 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_127 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_130 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_132 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_133 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_134 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_135 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_136 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_138 --> PACKED_TEXT_STORAGE TX_PS_22;
Array BC_139 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_141 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_142 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_143 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_144 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_145 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_146 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_147 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_148 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_149 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_150 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_151 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_153 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_154 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_155 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_156 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_157 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_158 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_159 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_161 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_162 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_163 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_164 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_165 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_166 --> PACKED_TEXT_STORAGE TX_PS_30;
Array BC_167 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_168 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_169 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_170 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_171 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_172 --> PACKED_TEXT_STORAGE TX_PS_32;
Array BC_173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_174 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_175 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_176 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_177 --> PACKED_TEXT_STORAGE TX_PS_34;
Array BC_178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_179 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_180 --> PACKED_TEXT_STORAGE TX_PS_35;
Array BC_181 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_182 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_183 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_184 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_185 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_186 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_187 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_188 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_189 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_190 --> PACKED_TEXT_STORAGE TX_PS_39;
Array BC_191 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_192 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_194 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_195 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_196 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_197 --> PACKED_TEXT_STORAGE TX_PS_42;
Array BC_198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_199 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_200 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_201 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_202 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_203 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_204 --> PACKED_TEXT_STORAGE TX_PS_43;
Array BC_205 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_206 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_207 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_208 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_209 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_210 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_211 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_212 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_214 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_215 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_216 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_217 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_218 --> PACKED_TEXT_STORAGE TX_PS_45;
Array BC_219 --> PACKED_TEXT_STORAGE TX_PS_46;
Array BC_220 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_221 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_222 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_223 --> PACKED_TEXT_STORAGE TX_PS_16;
Array BC_224 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_225 --> PACKED_TEXT_STORAGE TX_PS_47;
Array BC_226 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_227 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_229 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_230 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_231 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_232 --> PACKED_TEXT_STORAGE TX_PS_48;
Array BC_233 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_234 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_235 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_236 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_237 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_238 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_239 --> PACKED_TEXT_STORAGE TX_PS_49;
Array BC_240 --> PACKED_TEXT_STORAGE TX_PS_50;
Array BC_241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_242 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_244 --> PACKED_TEXT_STORAGE TX_PS_51;
Array BC_245 --> PACKED_TEXT_STORAGE TX_PS_52;
Array BC_246 --> PACKED_TEXT_STORAGE TX_PS_53;
Array BC_247 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_248 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_249 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_250 --> PACKED_TEXT_STORAGE TX_PS_54;
Array BC_251 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_134;
Array BC_252 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_135;
Array BC_253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_254 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_255 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_256 --> PACKED_TEXT_STORAGE TX_PS_55;
Array BC_257 --> PACKED_TEXT_STORAGE TX_PS_56;
Array BC_258 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_259 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_260 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_262 --> PACKED_TEXT_STORAGE TX_PS_57;
Array BC_263 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_264 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_265 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_266 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_267 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_268 --> PACKED_TEXT_STORAGE TX_PS_58;
Array BC_269 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_270 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_271 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_272 --> PACKED_TEXT_STORAGE TX_PS_59;
Array BC_273 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_136;
Array BC_274 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_277 --> PACKED_TEXT_STORAGE TX_PS_60;
Array BC_278 --> PACKED_TEXT_STORAGE TX_PS_61;
Array BC_279 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_280 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_281 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_282 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_283 --> PACKED_TEXT_STORAGE TX_PS_62;
Array BC_284 --> PACKED_TEXT_STORAGE TX_PS_63;
Array BC_285 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_286 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_287 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_288 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_289 --> PACKED_TEXT_STORAGE TX_PS_64;
Array BC_290 --> PACKED_TEXT_STORAGE TX_PS_65;
Array BC_291 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_292 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_293 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_294 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_295 --> PACKED_TEXT_STORAGE TX_PS_66;
Array BC_296 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_137;
Array BC_297 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_299 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_300 --> PACKED_TEXT_STORAGE TX_PS_67;
Array BC_301 --> PACKED_TEXT_STORAGE TX_PS_68;
Array BC_302 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_303 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_304 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_305 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_306 --> PACKED_TEXT_STORAGE TX_PS_69;
Array BC_307 --> PACKED_TEXT_STORAGE TX_PS_70;
Array BC_308 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_309 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_310 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_312 --> PACKED_TEXT_STORAGE TX_PS_71;
Array BC_313 --> PACKED_TEXT_STORAGE TX_PS_72;
Array BC_314 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_316 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_318 --> PACKED_TEXT_STORAGE TX_PS_73;
Array BC_319 --> PACKED_TEXT_STORAGE TX_PS_74;
Array BC_320 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_321 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_322 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_323 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_324 --> PACKED_TEXT_STORAGE TX_PS_75;
Array BC_325 --> PACKED_TEXT_STORAGE TX_PS_76;
Array BC_326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_327 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_329 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_330 --> PACKED_TEXT_STORAGE TX_PS_77;
Array BC_331 --> PACKED_TEXT_STORAGE TX_PS_78;
Array BC_332 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_333 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_334 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_336 --> PACKED_TEXT_STORAGE TX_PS_79;
Array BC_337 --> PACKED_TEXT_STORAGE TX_PS_80;
Array BC_338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_339 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_340 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_342 --> PACKED_TEXT_STORAGE TX_PS_81;
Array BC_343 --> PACKED_TEXT_STORAGE TX_PS_82;
Array BC_344 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_345 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_346 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_347 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_348 --> PACKED_TEXT_STORAGE TX_PS_83;
Array BC_349 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_138;
Array BC_350 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_352 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_353 --> PACKED_TEXT_STORAGE TX_PS_84;
Array BC_354 --> PACKED_TEXT_STORAGE TX_PS_85;
Array BC_355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_357 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_359 --> PACKED_TEXT_STORAGE TX_PS_86;
Array BC_360 --> PACKED_TEXT_STORAGE TX_PS_87;
Array BC_361 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_362 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_363 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_364 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_365 --> PACKED_TEXT_STORAGE TX_PS_88;
Array BC_366 --> PACKED_TEXT_STORAGE TX_PS_89;
Array BC_367 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_369 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_370 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_371 --> PACKED_TEXT_STORAGE TX_PS_90;
Array BC_372 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_139;
Array BC_373 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_374 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_375 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_376 --> PACKED_TEXT_STORAGE TX_PS_91;
Array BC_377 --> PACKED_TEXT_STORAGE TX_PS_92;
Array BC_378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_379 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_380 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_381 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_382 --> PACKED_TEXT_STORAGE TX_PS_93;
Array BC_383 --> PACKED_TEXT_STORAGE TX_PS_94;
Array BC_384 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_385 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_386 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_387 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_388 --> PACKED_TEXT_STORAGE TX_PS_95;
Array BC_389 --> PACKED_TEXT_STORAGE TX_PS_96;
Array BC_390 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_391 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_392 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_394 --> PACKED_TEXT_STORAGE TX_PS_97;
Array BC_395 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_140;
Array BC_396 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_397 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_398 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_399 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_400 --> PACKED_TEXT_STORAGE TX_PS_98;
Array BC_401 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_141;
Array BC_402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_403 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_404 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_405 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_406 --> PACKED_TEXT_STORAGE TX_PS_99;
Array BC_407 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_142;
Array BC_408 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_409 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_411 --> PACKED_TEXT_STORAGE TX_PS_100;
Array BC_412 --> PACKED_TEXT_STORAGE TX_PS_101;
Array BC_413 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_414 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_415 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_417 --> PACKED_TEXT_STORAGE TX_PS_95;
Array BC_418 --> PACKED_TEXT_STORAGE TX_PS_102;
Array BC_419 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_420 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_421 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_422 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_423 --> PACKED_TEXT_STORAGE TX_PS_103;
Array BC_424 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_143;
Array BC_425 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_426 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_427 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_428 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_429 --> PACKED_TEXT_STORAGE TX_PS_104;
Array BC_430 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_144;
Array BC_431 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_433 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_434 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_435 --> PACKED_TEXT_STORAGE TX_PS_105;
Array BC_436 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_145;
Array BC_437 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_438 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_439 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_440 --> PACKED_TEXT_STORAGE TX_PS_106;
Array BC_441 --> PACKED_TEXT_STORAGE TX_PS_107;
Array BC_442 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_443 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_444 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_445 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_446 --> PACKED_TEXT_STORAGE TX_PS_108;
Array BC_447 --> PACKED_TEXT_STORAGE TX_PS_109;
Array BC_448 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_449 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_450 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_451 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_452 --> PACKED_TEXT_STORAGE TX_PS_110;
Array BC_453 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_146;
Array BC_454 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_147;
Array BC_455 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_456 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_457 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_458 --> PACKED_TEXT_STORAGE TX_PS_111;
Array BC_459 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_148;
Array BC_460 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_461 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_462 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_463 --> PACKED_TEXT_STORAGE TX_PS_112;
Array BC_464 --> PACKED_TEXT_STORAGE TX_PS_113;
Array BC_465 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_466 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_468 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_469 --> PACKED_TEXT_STORAGE TX_PS_114;
Array BC_470 --> PACKED_TEXT_STORAGE TX_PS_115;
Array BC_471 --> PACKED_TEXT_STORAGE TX_PS_116;
Array BC_472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_473 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_474 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_475 --> PACKED_TEXT_STORAGE TX_PS_117;
Array BC_476 --> PACKED_TEXT_STORAGE TX_PS_118;
Array BC_477 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_478 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_479 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_481 --> PACKED_TEXT_STORAGE TX_PS_119;
Array BC_482 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_483 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_484 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_485 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_487 --> PACKED_TEXT_STORAGE TX_PS_120;
Array BC_488 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_489 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_490 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_491 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_493 --> PACKED_TEXT_STORAGE TX_PS_121;
Array BC_494 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_495 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_497 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_498 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_499 --> PACKED_TEXT_STORAGE TX_PS_122;
Array BC_500 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_502 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_503 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_504 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_505 --> PACKED_TEXT_STORAGE TX_PS_123;
Array BC_506 --> PACKED_TEXT_STORAGE TX_PS_124;
Array BC_507 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_508 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_509 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_510 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_511 --> PACKED_TEXT_STORAGE TX_PS_125;
Array BC_512 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_149;
Array BC_513 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_514 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_515 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_517 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_518 --> PACKED_TEXT_STORAGE TX_PS_127;
Array BC_519 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_520 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_521 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_522 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_523 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_525 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_526 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_527 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_528 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_529 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_530 --> PACKED_TEXT_STORAGE TX_PS_128;
Array BC_531 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_532 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_533 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_534 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_535 --> PACKED_TEXT_STORAGE TX_PS_129;
Array BC_536 --> PACKED_TEXT_STORAGE TX_PS_130;
Array BC_537 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_538 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_539 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_540 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_541 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_542 --> PACKED_TEXT_STORAGE TX_PS_132;
Array BC_543 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_544 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_545 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_546 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_547 --> PACKED_TEXT_STORAGE TX_PS_133;
Array BC_548 --> PACKED_TEXT_STORAGE TX_PS_134;
Array BC_549 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_550 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_551 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_553 --> PACKED_TEXT_STORAGE TX_PS_135;
Array BC_554 --> PACKED_TEXT_STORAGE TX_PS_136;
Array BC_555 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_556 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_557 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_558 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_559 --> PACKED_TEXT_STORAGE TX_PS_137;
Array BC_560 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_150;
Array BC_561 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_562 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_563 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_564 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_565 --> PACKED_TEXT_STORAGE TX_PS_138;
Array BC_566 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_151;
Array BC_567 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_568 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_569 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_570 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_571 --> PACKED_TEXT_STORAGE TX_PS_139;
Array BC_572 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_152;
Array BC_573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_574 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_575 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_576 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_577 --> PACKED_TEXT_STORAGE TX_PS_140;
Array BC_578 --> PACKED_TEXT_STORAGE TX_PS_141;
Array BC_579 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_582 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_583 --> PACKED_TEXT_STORAGE TX_PS_142;
Array BC_584 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_585 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_587 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_588 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_589 --> PACKED_TEXT_STORAGE TX_PS_143;
Array BC_590 --> PACKED_TEXT_STORAGE TX_PS_144;
Array BC_591 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_592 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_594 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_595 --> PACKED_TEXT_STORAGE TX_PS_145;
Array BC_596 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_153;
Array BC_597 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_598 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_599 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_601 --> PACKED_TEXT_STORAGE TX_PS_146;
Array BC_602 --> PACKED_TEXT_STORAGE TX_PS_147;
Array BC_603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_604 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_605 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_606 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_607 --> PACKED_TEXT_STORAGE TX_PS_148;
Array BC_608 --> PACKED_TEXT_STORAGE TX_PS_149;
Array BC_609 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_610 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_611 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_612 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_613 --> PACKED_TEXT_STORAGE TX_PS_150;
Array BC_614 --> PACKED_TEXT_STORAGE TX_PS_151;
Array BC_615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_616 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_617 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_618 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_619 --> PACKED_TEXT_STORAGE TX_PS_152;
Array BC_620 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_621 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_622 --> PACKED_TEXT_STORAGE TX_PS_153;
Array BC_623 --> PACKED_TEXT_STORAGE TX_PS_154;
Array BC_624 --> PACKED_TEXT_STORAGE TX_PS_155;
Array BC_625 --> PACKED_TEXT_STORAGE TX_PS_156;
Array BC_626 --> PACKED_TEXT_STORAGE TX_PS_156;
Array BC_627 --> PACKED_TEXT_STORAGE TX_PS_157;
Array BC_628 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_154;
Array BC_629 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_155;
Array BC_630 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_156;
Array BC_631 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_157;
Array BC_632 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_633 --> PACKED_TEXT_STORAGE TX_PS_46;
Array BC_634 --> PACKED_TEXT_STORAGE TX_PS_158;
Array BC_635 --> PACKED_TEXT_STORAGE TX_PS_159;
Array BC_636 --> PACKED_TEXT_STORAGE TX_PS_160;
Array BC_637 --> PACKED_TEXT_STORAGE TX_PS_161;
Array BC_638 --> PACKED_TEXT_STORAGE TX_PS_162;
Array BC_639 --> PACKED_TEXT_STORAGE TX_PS_163;
Array BC_640 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_158;
Array BC_641 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_642 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_159;
Array BC_643 --> PACKED_TEXT_STORAGE TX_PS_164;
Array BC_644 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_646 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_160;
Array BC_647 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_648 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_649 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_650 --> PACKED_TEXT_STORAGE TX_PS_166;
Array BC_651 --> PACKED_TEXT_STORAGE TX_PS_167;
Array BC_652 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_161;
Array BC_653 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_654 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_656 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_657 --> PACKED_TEXT_STORAGE TX_PS_168;
Array BC_658 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_162;
Array BC_659 --> PACKED_TEXT_STORAGE TX_PS_169;
Array BC_660 --> PACKED_TEXT_STORAGE TX_PS_170;
Array BC_661 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_163;
Array BC_662 --> PACKED_TEXT_STORAGE TX_PS_171;
Array BC_663 --> PACKED_TEXT_STORAGE TX_PS_172;
Array BC_664 --> PACKED_TEXT_STORAGE TX_PS_173;
Array BC_665 --> PACKED_TEXT_STORAGE TX_PS_174;
Array BC_666 --> PACKED_TEXT_STORAGE TX_PS_175;
Array BC_667 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_164;
Array BC_668 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_165;
Array BC_669 --> PACKED_TEXT_STORAGE TX_PS_176;
Array BC_670 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_166;
Array BC_671 --> PACKED_TEXT_STORAGE TX_PS_177;
Array BC_672 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_167;
Array BC_673 --> PACKED_TEXT_STORAGE TX_PS_178;
Array BC_674 --> PACKED_TEXT_STORAGE TX_PS_179;
Array BC_675 --> PACKED_TEXT_STORAGE TX_PS_180;
Array BC_676 --> PACKED_TEXT_STORAGE TX_PS_181;
Array BC_677 --> PACKED_TEXT_STORAGE TX_PS_182;
Array BC_678 --> PACKED_TEXT_STORAGE TX_PS_183;
Array BC_679 --> PACKED_TEXT_STORAGE TX_PS_184;
Array BC_680 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_168;
Array BC_681 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_169;
Array BC_682 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_170;
Array BC_683 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_171;
Array BC_684 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_172;
Array BC_685 --> PACKED_TEXT_STORAGE TX_PS_185;
Array BC_686 --> PACKED_TEXT_STORAGE TX_PS_186;
Array BC_687 --> PACKED_TEXT_STORAGE TX_PS_187;
Array BC_688 --> PACKED_TEXT_STORAGE TX_PS_188;
Array BC_689 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_173;
Array BC_690 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_174;
Array BC_691 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_175;
Array BC_692 --> PACKED_TEXT_STORAGE TX_PS_189;
Array BC_693 --> PACKED_TEXT_STORAGE TX_PS_190;
Array BC_694 --> PACKED_TEXT_STORAGE TX_PS_191;
Array BC_695 --> PACKED_TEXT_STORAGE TX_PS_192;
Array BC_696 --> PACKED_TEXT_STORAGE TX_PS_193;
Array BC_697 --> PACKED_TEXT_STORAGE TX_PS_194;
Array BC_698 --> PACKED_TEXT_STORAGE TX_PS_195;
Array BC_699 --> PACKED_TEXT_STORAGE TX_PS_196;
Array BC_700 --> PACKED_TEXT_STORAGE TX_PS_197;
Array BC_701 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_176;
Array BC_702 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_177;
Array BC_703 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_178;
Array BC_704 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_179;
Array BC_705 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_180;
Array BC_706 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_181;
Array BC_707 --> PACKED_TEXT_STORAGE TX_PS_198;
Array BC_708 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_182;
Array BC_709 --> PACKED_TEXT_STORAGE TX_PS_199;
Array BC_710 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_183;
Array BC_711 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_184;
Array BC_712 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_185;
Array BC_713 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_186;
Array BC_714 --> PACKED_TEXT_STORAGE TX_PS_200;
Array BC_715 --> PACKED_TEXT_STORAGE TX_PS_201;
Array BC_716 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_187;
Array BC_717 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_188;
Array BC_718 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_189;
Array BC_719 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_190;
Array BC_720 --> PACKED_TEXT_STORAGE TX_PS_202;
Array BC_721 --> PACKED_TEXT_STORAGE TX_PS_203;
Array BC_722 --> PACKED_TEXT_STORAGE TX_PS_204;
Array BC_723 --> PACKED_TEXT_STORAGE TX_PS_205;
Array BC_724 --> PACKED_TEXT_STORAGE TX_PS_206;
Array BC_725 --> PACKED_TEXT_STORAGE TX_PS_207;
Array BC_726 --> PACKED_TEXT_STORAGE TX_PS_208;
Array BC_727 --> PACKED_TEXT_STORAGE TX_PS_209;
Array BC_728 --> PACKED_TEXT_STORAGE TX_PS_210;
Array BC_729 --> PACKED_TEXT_STORAGE TX_PS_211;
Array BC_730 --> PACKED_TEXT_STORAGE TX_PS_212;
Array BC_731 --> PACKED_TEXT_STORAGE TX_PS_213;
Array BC_732 --> PACKED_TEXT_STORAGE TX_PS_214;
Array BC_733 --> PACKED_TEXT_STORAGE TX_PS_215;
Array BC_734 --> PACKED_TEXT_STORAGE TX_PS_216;
Array BC_735 --> PACKED_TEXT_STORAGE TX_PS_217;
Array BC_736 --> PACKED_TEXT_STORAGE TX_PS_218;
Array BC_737 --> PACKED_TEXT_STORAGE TX_PS_219;
Array BC_738 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_741 --> PACKED_TEXT_STORAGE TX_PS_220;
Array BC_742 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_191;
Array BC_743 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_192;
Array BC_744 --> PACKED_TEXT_STORAGE TX_PS_221;
Array BC_745 --> PACKED_TEXT_STORAGE TX_PS_222;
Array BC_746 --> PACKED_TEXT_STORAGE TX_PS_223;
Array BC_747 --> PACKED_TEXT_STORAGE TX_PS_224;
Array BC_748 --> PACKED_TEXT_STORAGE TX_PS_225;
Array BC_749 --> PACKED_TEXT_STORAGE TX_PS_226;
Array BC_750 --> PACKED_TEXT_STORAGE TX_PS_227;
Array BC_751 --> PACKED_TEXT_STORAGE TX_PS_228;
Array BC_752 --> PACKED_TEXT_STORAGE TX_PS_229;
Array BC_753 --> PACKED_TEXT_STORAGE TX_PS_230;
Array BC_754 --> PACKED_TEXT_STORAGE TX_PS_231;
Array BC_755 --> PACKED_TEXT_STORAGE TX_PS_232;
Array BC_756 --> PACKED_TEXT_STORAGE TX_PS_233;
Array BC_757 --> PACKED_TEXT_STORAGE TX_PS_234;
Array BC_758 --> PACKED_TEXT_STORAGE TX_PS_235;
Array BC_759 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_760 --> PACKED_TEXT_STORAGE TX_PS_237;
Array BC_761 --> PACKED_TEXT_STORAGE TX_PS_238;
Array BC_762 --> PACKED_TEXT_STORAGE TX_PS_239;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Signing off
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! End of automatically generated I6 source
! --------------------------------------------------------------------------
